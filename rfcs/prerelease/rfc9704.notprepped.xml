<?xml version='1.0' encoding='UTF-8'?>

<!DOCTYPE rfc [
 <!ENTITY nbsp    "&#160;">
 <!ENTITY zwsp   "&#8203;">
 <!ENTITY nbhy   "&#8209;">
 <!ENTITY wj     "&#8288;">
]> 

<rfc xmlns:xi="http://www.w3.org/2001/XInclude" category="std" docName="draft-ietf-add-split-horizon-authority-14" number="9704" updates="" obsoletes="" ipr="trust200902" submissionType="IETF" xml:lang="en" tocInclude="true" tocDepth="4" symRefs="true" sortRefs="true" version="3" consensus="true">
  <front>
    <title abbrev="Establishing Local DNS Authority">Establishing Local DNS
    Authority in Validated Split-Horizon Environments</title>
    <seriesInfo name="RFC" value="9704"/>
    <author fullname="Tirumaleswar Reddy.K" initials="T." surname="Reddy.K">
      <organization>Nokia</organization>
      <address>
        <postal>
          <country>India</country>
        </postal>
        <email>kondtir@gmail.com</email>
      </address>
    </author>
    <author fullname="Dan Wing" initials="D." surname="Wing">
      <organization abbrev="Citrix">Citrix Systems, Inc.</organization>
      <address>
        <postal>
          <country>United States of America</country>
        </postal>
        <email>danwing@gmail.com</email>
      </address>
    </author>
    <author fullname="Kevin Smith" initials="K." surname="Smith">
      <organization abbrev="Vodafone">Vodafone Group</organization>
      <address>
        <postal>
          <street>One Kingdom Street</street>
          <city>London</city>
          <country>United Kingdom</country>
        </postal>
        <email>kevin.smith@vodafone.com</email>
      </address>
    </author>
    <author fullname="Benjamin Schwartz" initials="B." surname="Schwartz">
      <organization abbrev="Meta">Meta Platforms, Inc.</organization>
      <address>
        <email>ietf@bemasc.net</email>
      </address>
    </author>
    <date month="January" year="2025"/>
    <area>INT</area>
    <workgroup>add</workgroup>
    <abstract>
      <t>When split-horizon DNS is deployed by a network, certain domain names can
      be resolved authoritatively by a network-provided DNS resolver. DNS clients
      that are not configured to use this resolver by default can use it for
      these specific domains only. This specification defines a mechanism for domain owners
      to inform DNS clients about local resolvers that are authorized to answer
      authoritatively for certain subdomains.</t>
    </abstract>
    </front>
  <middle>
    <section anchor="intro">
      <name>Introduction</name>
      <t>To resolve a DNS query, there are three main behaviors that an
      implementation can apply: (1) answer from a local database, (2) query
      the relevant authorities and their parents, or (3) ask a server to query
      those authorities and return the final answer. Implementations that use
      these behaviors are called "authoritative nameservers", "full/recursive
      resolvers", and "forwarders" (or "stub resolvers"), respectively. However, an
      implementation can also implement a mixture of these behaviors,
      depending on local policy, for each query. Such an implementation
      is termed a "hybrid resolver".</t>
      <t>Most DNS resolvers are hybrids of some kind. For example, stub
      resolvers support a local "hosts file" that preempts query
      forwarding, and most DNS forwarders and full resolvers can also serve
      responses from a local zone file. Other standardized hybrid resolution
      behaviors include <xref target="RFC8806">using a local root</xref>, <xref
      target="RFC6762">Multicast DNS (mDNS)</xref>, and <xref target="RFC7686">NXDOMAIN
      synthesis for .onion</xref>.</t>
      <t>Networks usually offer clients a DNS resolver using means such as
      DHCP offers or IPv6 Router Advertisements (RAs). Although this resolver is
      formally specified as a recursive resolver (e.g., see <xref section="5.1"
      target="RFC8106"/>), some networks provide a hybrid resolver
      instead. If this resolver acts as an authoritative server for some names
      and -- depending on the source of the query -- provides different answers for those domains, the network is said to be using "split-horizon DNS", because those
      names resolve in this way only from inside the network.</t>
      <t>DNS clients that use pure stub resolution, sending all queries to
      the network-provided resolver, will always receive the split-horizon
      results. Conversely, clients that send all queries to a different
      resolver or implement pure full resolution locally will never receive
      them. Clients that strictly implement either of these resolution behaviors are out of scope for
      this specification. Instead, this specification enables hybrid clients
      to access split-horizon results from a network-provided hybrid resolver,
      while using a different resolution method for some or all other
      names.</t>
      <t>There are several existing mechanisms for a network to provide
      clients with "local domain hints", listing domain names that are given
      special treatment in this network (e.g., <xref target="RFC6731">
      "Recursive DNS Server (RDNSS) selection"</xref>, <xref target="RFC5986">
      "access network domain name"</xref>, and "Client Fully Qualified Domain Name
 (FQDN)" <xref
      target="RFC4702"/> <xref target="RFC4704"/> in DHCP; "dnsZones" in
      Provisioning Domains (PvDs) <xref target="RFC8801"/>; and <xref
      target="RFC8598">"INTERNAL_DNS_DOMAIN"</xref> in Internet Key Exchange Protocol Version 2 (IKEv2)).
      However, none of the local domain hint mechanisms enable clients to
      determine whether this special treatment is authorized by the domain
      owner. Instead, these specifications require clients to make their own
      determinations about whether to trust and rely on these hints.</t>
      <t>This document describes a mechanism between domain names, networks,
      and clients that allows the network to establish its authority over a
      domain to a client (<xref target="establishing"/>). Clients can
      use this protocol to confirm that a local domain hint was authorized by
      the domain owner (<xref target="validating"/>), which might influence
      its processing of that hint.  This process requires cooperation between
      the local DNS zone and the public zone.</t>
      <t>In this specification, network operators securely identify the local DNS
      servers, and clients check each local domain hint against a globally
      valid parent zone.</t>
    </section>
    <section anchor="notation">
      <name>Terminology</name>
       <t>The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>",
       "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>",
       "<bcp14>SHALL NOT</bcp14>", "<bcp14>SHOULD</bcp14>",
       "<bcp14>SHOULD NOT</bcp14>",
       "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
       "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document
       are to be interpreted as described in BCP&nbsp;14
       <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only
       when, they appear in all capitals, as shown here.</t>
      <t>This document makes use of the terms defined in <xref
      target="RFC9499"/>, e.g., "global DNS".  The following additional terms are
      used throughout this document:</t>
      <dl>
        <dt>Encrypted DNS:</dt><dd>A DNS protocol that provides an
        encrypted channel between a DNS client and server (e.g., DNS
        over TLS (DoT) <xref
      target="RFC7858"/>, DNS (queries) over HTTPS (DoH) <xref
      target="RFC8484"/>, DNS over QUIC (DoQ) <xref
      target="RFC9250"/>).</dd>
        <dt>Encrypted DNS Resolver:</dt><dd>Refers to a DNS resolver
        that supports any encrypted DNS scheme.</dd>
          <dt>Split-Horizon DNS:</dt><dd>The DNS service provided by a resolver
          that also acts as an authoritative server for some names, providing
          resolution results that are meaningfully different from those in the
          global DNS. (See the definition of "split DNS" in <xref section="6"
          target="RFC9499"/>.)</dd>
        <dt>Validated Split Horizon:</dt><dd>A split-horizon configuration that
        is authorized by the parents of the affected names and confirmed by the 
        client. Such authorization generally extends to the
          entire subtree of names below the authorization point.</dd>
      </dl>
      <t>In this document, the terms "owner" and "operator" are used interchangeably
      and refer to the individual or entity responsible for the management and
      maintenance of domains.</t>
    </section>
    <section>
      <name>Scope</name>
      <t>The protocol described in this document is designed to support the ability of
      a domain owner to create or authorize a split-horizon view of their
      domain. The protocol does not support split-horizon views created by
      any other entity. Thus, DNS filtering is not enabled by this protocol.</t>
      <t>The protocol is applicable to any type of network offering
      split-horizon DNS configuration. The endpoint does not need any prior
      configuration to confirm that a local domain hint was indeed authorized
      by the domain.</t>
      <t>All of the Special-Use Domain Names registered with IANA <xref target="RFC6761"/>,
      most notably "home.arpa.", "resolver.arpa.", "ipv4only.arpa.", and "local.", are never
      unique to a specific DNS server's authority. All Special-Use Domain Names are outside the
      scope of this document and <bcp14>MUST NOT</bcp14> be validated using the mechanism described in this document. </t>
      <t>The use of this specification is limited to DNS servers that support authenticated encryption and
      split-horizon DNS names that are rooted in the global DNS.</t>
    </section>
    <section>
      <name>Requirements</name>
      <t>This solution seeks to fulfill the following requirements:</t>
<dl newline="false" spacing="normal">
        <dt>No loss of security:</dt><dd>No unauthorized party can impersonate
          a zone unless they could already do so without the use of this
          specification.</dd>
        <dt>Least privilege:</dt><dd>Local resolvers do not hold any
          secrets that could weaken the security of the public zone if
          compromised.</dd>
        <dt>Local zone confidentiality:</dt><dd>The specification does not leak
          local network subdomains to anyone outside of the network.</dd>
        <dt>Flexibility:</dt><dd>The specification can represent and authorize
          a split DNS zone structure.</dd>
        <dt>DNSSEC compatibility:</dt><dd>The specification supports DNSSEC-based
          object security for local zone contents per <xref target="RFC9364"/>.</dd>
      </dl>
    </section>
    <section anchor="establishing">
      <name>Establishing Local DNS Authority</name>
      <t>A participating network <bcp14>MUST</bcp14> offer one or more
      encrypted resolvers via DHCP and Router Advertisement options for the
      Discovery of Network-designated Resolvers (DNR) <xref target="RFC9463"/>,
      Discovery of Designated Resolvers (DDR) <xref target="RFC9462"/>, or an
      equivalent mechanism (see <xref target="vpn"/>).</t>
      <t>To establish local authority, the network <bcp14>MUST</bcp14> convey one or more
      "authorization claims" to the client.  An authorization claim is an
      abstract structure comprising:</t>
      <ul>
        <li>An Authentication Domain Name (ADN) of a local encrypted resolver.</li>
        <li>The DNS name of the authorizing parent zone.</li>
        <li>A set of subdomains of this parent zone that are claimed by
            the named local resolver (potentially including the entire parent
            zone). To claim the entire parent zone, the claimed subdomain
            will be represented as an asterisk symbol ("*").</li>
        <li>A ZONEMD Hash Algorithm (<xref section="5.3" target="RFC8976"/>).
           For interoperability purposes, implementations <bcp14>MUST</bcp14> support the
           "mandatory to implement" hash algorithms defined in
           <xref section="2.2.3" target="RFC8976"/>. </li>
        <li>A high-entropy salt, up to 255 octets.</li>
      </ul>
      <t>If the local encrypted resolver is identified by name (e.g., using DNR), that
      identifying name <bcp14>MUST</bcp14> be the name used in any corresponding authorization
      claim.  Otherwise (e.g., DDR using IP addresses), the resolver <bcp14>MUST</bcp14>
      present a validatable certificate containing a subjectAltName that
      matches the authorization claim using the validation techniques for
      matching as described in <xref target="RFC9525"/>.</t>
      <t>The network then provides each authorization claim to the parent zone operator.
      If the contents are approved, the parent zone operator computes a "Verification Token"
      according to the following procedure:</t>
      <ol>
        <li>Convert all subdomains into canonical form and sort them in canonical
            order (<xref section="6" target="RFC4034"/>).</li>
        <li>Replace the suffix corresponding to the parent zone with a zero
            octet.</li>
        <li>Let $X be the concatenation of the resulting pseudo-FQDNs.</li>
        <li>Let len($SALT) be the number of octets of salt, as a single octet.</li>
        <li>Let $TOKEN = hash(len($SALT) || $SALT || $X), where "||" denotes concatenation and hash is the ZONEMD Hash Algorithm.</li>
      </ol>
      <t>The zone operator then publishes a "Verification Record" with the
      following structure, following the best practices outlined in
      Sections&nbsp;<xref target="I-D.ietf-dnsop-domain-verification-techniques" sectionFormat="bare" section="5.2"/> and <xref target="I-D.ietf-dnsop-domain-verification-techniques"      
sectionFormat="bare" section="5.3"/> of <xref target="I-D.ietf-dnsop-domain-verification-techniques"/>:</t>
<ul>
        <li>Type = TXT</li>
        <li>Owner Name = Concatenation of the ADN, "_splitdns-challenge", and
            the parent zone name</li>
        <li>Contents = "key/value" pairs, e.g., "token=base64url($TOKEN)" (without padding)</li>
      </ul>
      <t>By publishing this record, the parent zone authorizes the local
      encrypted resolver to serve these subdomains authoritatively.</t>
      <section>
        <name>Example</name>
        <t>Consider the following authorization claim:</t>
        <ul>
          <li>ADN = "resolver17.parent.example"</li>
          <li>Parent = "parent.example"</li>
          <li>Subdomains = "payroll.parent.example",
              "secret.project.parent.example"</li>
          <li>Hash Algorithm = SHA-384 <xref target="RFC6234"/></li>
          <li>Salt = "example salt octets (should be random)"</li>
        </ul>
        <t>To approve this claim, the zone operator would publish the following record:</t>
        <sourcecode type="dns-rr">
NOTE: '\' line wrapping per RFC 8792

  resolver17.parent.example._splitdns-challenge.parent.example. \
  IN TXT "token=z1qyK7QWwQPkT-ZmVW-tAQbsNyYenTNBPp5ogYB8S1wesVCR\
  -KJDv2eFwfJcWQM"
</sourcecode>
      </section>
      <section>
        <name>Conveying Authorization Claims</name>
        <t>
          The authorization claim is an abstract structure that must be encoded in
          some concrete syntax in order to convey it from the network to the client.
          This section defines some encodings of the authorization claims.
        </t>
        <section>
          <name>Using DHCP</name>
          <t>

            In DHCP, each authorization claim is encoded as a DHCP Authentication
            option (<xref target="RFC3118"/> and <xref section="21.11" target="RFC8415"/>),
            using the Protocol value 4, "Split-horizon DNS". In DHCPv4 <xref target="RFC2131"/>, the mechanism for splitting long options as
            described in <xref section="8" target="RFC3396"/> <bcp14>MUST</bcp14> be used if the
            Authentication option exceeds the maximum DHCPv4 option size of 255 octets. The Algorithm field
            provides the ZONEMD Hash Algorithm, represented by its registered Value.
            The Replay Detection Method value <bcp14>MUST</bcp14> be 0x00. The Authentication Information
            <bcp14>MUST</bcp14> contain the following information, concatenated:</t>
          <ol>
            <li>The ADN in canonical form.</li>
            <li>The parent name in canonical form.</li>
            <li>A one-octet "salt length" field.</li>
            <li>The salt value.</li>
            <li>The $X value as defined in <xref target="establishing"/>.</li>
          </ol>
        </section>
        <section anchor="splitclaims">
          <name>Using Provisioning Domains</name>
          <t>When using <xref target="RFC8801">PvDs</xref>, the
          authorization claims are represented by the PvD Additional
          Information key "splitDnsClaims", whose value is a
          JSON array.  Each entry in the array <bcp14>MUST</bcp14> be a JSON object
          with the following structure:</t>
<dl newline="false" spacing="normal">
            <dt>"resolver":</dt><dd>The ADN as a dot-separated name.</dd>
            <dt>"parent":</dt><dd>The parent zone name as a dot-separated name.</dd>
            <dt>"subdomains":</dt><dd>An array containing the claimed subdomains, as
                dot-separated names with the parent suffix already removed, in
                canonical order. To claim the entire parent zone, the claimed subdomain
                will be represented as an asterisk symbol ("*").</dd>
            <dt>"algorithm":</dt><dd>The hash algorithm, represented by its "Mnemonic"
                string from the "ZONEMD Hash Algorithms" registry (<xref target="RFC8976"
                section="5.3" sectionFormat="of"/>).</dd>
            <dt>"salt":</dt><dd>The salt, encoded in base64url <xref target="RFC4648"/>.</dd>
          </dl>

        <t>Future specifications aiming to define new keys will need to add them to the
        IANA registry defined in <xref target="new-split-claims-registry"/>. DNS client implementations
        will ignore any keys they don't recognize but may also report
        unknown keys.</t>
        </section>
      </section>
    </section>
    <section anchor="validating">
      <name>Validating Authority over Local Domain Hints</name>
      <t>To validate an authorization claim provided by the network, DNS clients
      <bcp14>MUST</bcp14> resolve the Verification Record for that name.
      If the resolution produces an RRset containing the expected token for this
      claim, the client <bcp14>SHALL</bcp14> regard the named resolver as
      authoritative for the claimed subdomains. Clients <bcp14>MUST</bcp14> ignore
      any unrecognized keys in the Verification Record.</t>
      <t>Each validation of authority applies only to a specific ADN.
      If a network offers multiple encrypted resolvers, each claimed
      subdomain may be authorized for a distinct subset of the network-provided
      resolvers.</t>
      <t>A zone is termed a "Validated Split-Horizon zone" after successful
      validation using a "tamperproof" DNS resolution method, i.e., a method
      that is not subject to interference by the local network operator. Two
      possible tamperproof resolution methods are presented below.</t>
      <section anchor="validating-external">
        <name>Using a Preconfigured External Resolver</name>
        <t>This method applies only if the client is already configured with
        a default resolution strategy that sends queries to a resolver outside
        of the network over an encrypted transport.  That resolution strategy is
        considered tamperproof because any actor who could modify the
        response could already modify all of the user's other DNS responses.
        If the client cannot obtain a response from the external resolver within a
        reasonable timeframe, it <bcp14>MUST</bcp14> consider the verification process
        to have failed.</t>
        <t>To ensure that this assumption holds, clients <bcp14>MUST NOT</bcp14>
        relax the acceptance rules they would otherwise apply when using this
        resolver. For example, if the client would check the Authenticated Data (AD)
        bit or validate RRSIGs locally when using this resolver, it must also do so
        when resolving TXT records for this purpose. The client <bcp14>MAY</bcp14>
        perform DNSSEC validation for the verification query
        even if it has disabled DNSSEC validation for other DNS queries.</t>
      </section>

      <section anchor="validating-dnssec">
        <name>Using DNSSEC</name>
        <t>The client resolves the Verification Record using any resolution method of
        its choice (e.g., querying one of the network-provided resolvers,
        performing iterative resolution locally) and performs full DNSSEC
        validation locally <xref target="RFC6698"/>. The result is
        processed based on its DNSSEC validation state (<xref section="4.3"
        target="RFC4035" sectionFormat="of"/>): </t>

<dl newline="false" spacing="normal">	
          <dt><strong>Secure</strong>:</dt><dd>The response is used for validation.</dd>
          <dt><strong>Bogus</strong> or <strong>Indeterminate</strong>:</dt><dd>The response is rejected, and
            validation is considered to have failed.</dd>
          <dt><strong>Insecure</strong>:</dt><dd>The client <bcp14>SHOULD</bcp14> retry the validation
            process using a different method, such as the method described in <xref
            target="validating-external"/>, to ensure compatibility with
            unsigned names. If the client chooses not to retry (e.g., no configured policy to validate
            the authorization claim using an external resolver), it <bcp14>MUST</bcp14> consider
            validation to have failed.</dd>
        </dl>
      </section>
    </section>

    <section>
      <name>Delegating DNSSEC Across Split DNS Boundaries</name>
      <t>When the local zone can be signed with globally trusted keys for the parent
      zone, support for DNSSEC can be accomplished by simply placing a zone cut at
      the parent zone and including a suitable DS record for the local resolver's
      DNSKEY.  Zones in this configuration appear the same to validating stubs whether
      or not they implement this specification.</t>
      <t>To enable DNSSEC validation of local DNS names without requiring
      the local resolver to hold DNSSEC private keys that are valid for the parent
      zone, parent zones <bcp14>MAY</bcp14> add a "ds=..." key to the Verification
      Record whose value is the RDATA of a single DS record, encoded in base64url. This
      DS record authorizes a DNSKEY whose owner name is "resolver.arpa."</t>
      <t>To validate DNSSEC, the client first fetches and validates the Verification
      Record.  If it is valid and contains a "ds" key, the client <bcp14>MAY</bcp14>
      send a DNSKEY query for "resolver.arpa." to the local encrypted resolver.
      At least one resulting DNSKEY Resource Record (RR) <bcp14>MUST</bcp14> match the DS RDATA from
      the "ds" key in the Verification Record. All local resolution results for
      subdomains in this claim <bcp14>MUST</bcp14> offer RRSIGs that chain to a
      DNSKEY whose RDATA is identical to one of these approved DNSKEYs.</t>
      <t>The "ds" key <bcp14>MAY</bcp14> appear multiple
      times in a single Verification Record, in order to authorize multiple DNSKEYs
      for this local encrypted resolver.</t>
      <t>Note that when the local resolver does not have a globally trusted DNSKEY, any claimed subdomains <bcp14>MUST</bcp14> be marked as
      unsigned in the public DNS.  Otherwise, local resolution results would be rejected
      by validating stubs that do not implement this specification.</t>
      <figure>
        <name>Example Use of "ds=..."</name>
        <sourcecode type="dns-rr">
NOTE: '\' line wrapping per RFC 8792

;; Parent zone.
$ORIGIN parent.example.

; Parent zone's public Key Signing Key (KSK)
; and Zone Signing Key (ZSK).
@ IN DNSKEY 257 3 5 ABCD...=
@ IN DNSKEY 256 3 5 DCBA...=

; Verification Record containing DS RDATA for the local
; resolver's KSK.  This is an ordinary public TXT record,
; secured by RRSIGs from the public ZSK.
resolver.example._splitdns-challenge IN TXT "token=abc...,ds=QWE..."

; NSEC record indicating that unsigned delegations are permitted at
; this subdomain.  This is required for compatibility with 
; non-split-aware validating stub resolvers.  If the claimed label is 
; confidential, the parent zone can conceal it using NSEC3 (with or
; without "opt-out").
@ IN NSEC subdomain.parent.example. NS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Local zone, claiming "subdomain.parent.example".

; The local resolver's KSK, validated by the Verification Record.
; It may not have a corresponding RRSIG.
resolver.arpa. IN DNSKEY 257 3 5 ASDF...=

; Each claimed subdomain duplicates the local resolver's KSK at its
; zone apex and uses it to sign the ZSK.
subdomain.parent.example.        IN DNSKEY 257 3 5 ASDF...=
subdomain.parent.example.        IN DNSKEY 256 3 5 FDSA...=
subdomain.parent.example         IN RRSIG DNSKEY 5 3 ...  \
        (KSK key tag) subdomain.parent.example. ...
subdomain.parent.example.        IN AAAA 2001:db8::17
subdomain.parent.example         IN RRSIG AAAA 5 3 ...    \
        (ZSK key tag) subdomain.parent.example. ...
deeper.subdomain.parent.example. IN AAAA 2001:db8::18
deeper.subdomain.parent.example  IN RRSIG AAAA 5 3 ...    \
        (ZSK key tag) subdomain.parent.example. ...
</sourcecode></figure>
    </section>

    <section>
      <name>Example Split-Horizon DNS Configuration</name>
        <t>Consider an organization that operates "example.com" and runs a
        different version of its global domain on its internal network.</t>
        <t>First, the host and network both need to support one of the discovery
        mechanisms described in <xref target="establishing"/>. <xref target="fig-learn"/>
        shows discovery using information from the DNR and the PvD.</t>
        <t>Validation is then performed using either <xref
        target="example-verify-external">an external resolver</xref> or <xref
        target="example-verify-dnssec">DNSSEC</xref>.</t>

<dl newline="false" spacing="normal">	
          <dt><strong>Steps 1-2</strong>:</dt><dd>The client determines the network's DNS
            server (<tt>dns.example.net</tt>) and PvD ID (<tt>pvd.example.com</tt>)
            using DNR and a PvD, along with one of the following: DNR Router Solicitation,
            DHCPv4, or DHCPv6.</dd>
          <dt><strong>Steps 3-5</strong>:</dt><dd>The client connects to <tt>dns.example.net</tt>
            using an encrypted transport as indicated in <xref
            target="RFC9463">DNR</xref>, authenticating the server to
            its name using TLS (<xref target="RFC8310" section="8"
            sectionFormat="of"/>), and
            sends it a query for the address of <tt>pvd.example.com</tt>.</dd>
          <dt><strong>Steps 6-7</strong>:</dt><dd><t>The client connects to the PvD server,
            validates its certificate, and retrieves the PvD Additional Information
            indicated by the associated PvD. The JSON object contains:</t>
            <sourcecode type="json">{
  "identifier": "pvd.example.com",
  "expires": "2025-05-23T06:00:00Z",
  "prefixes": ["2001:db8:1::/48", "2001:db8:4::/48"],
  "splitDnsClaims": [{
    "resolver": "dns.example.net",
    "parent": "example.com",
    "subdomains": ["*"],
    "algorithm": "SHA384",
    "salt": "abc...123"
  }]
}</sourcecode>
            <t>The JSON keys "identifier", "expires", and "prefixes"
            are defined in <xref target="RFC8801"/>.</t></dd>
        </dl>
        <figure anchor="fig-learn">
          <name>An Example of Learning Local Claims of DNS Authority</name>
          <artwork><![CDATA[
+---------+         +--------------------+  +------------+ +--------+
| Client  |         | Network's          |  | Network    | | Router |
|         |         | Encrypted Resolver |  | PvD Server | |        |
+---------+         +--------------------+  +------------+ +--------+
   |                                     |         |            |
   | Router Solicitation or              |         |            |
   | DHCPv4/DHCPv6 (1)                   |         |            |
   |----------------------------------------------------------->|
   |                                     |         |            |
   |  Response with DNR ADN &            |         |            |
   |  PvD FQDN (2)                       |         |            |
   |<-----------------------------------------------------------|
   | ----------------------------\       |         |            |
   |-| now knows DNR ADN &       |       |         |            |
   | | PvD FQDN                  |       |         |            |
   | |---------------------------/       |         |            |
   |                                     |         |            |
   | TLS connection to dns.example.net (3)         |            |
   |------------------------------------>|         |            |
   | ---------------------------\        |         |            |
   |-| validate TLS certificate |        |         |            |
   | |--------------------------/        |         |            |
   |                                     |         |            |
   | resolve pvd.example.com (4)         |         |            |
   |------------------------------------>|         |            |
   |                                     |         |            |
   |            A or AAAA records (5)    |         |            |
   |<------------------------------------|         |            |
   |                                     |         |            |
   | https://pvd.example.com/.well-known/pvd (6)   |            |
   |---------------------------------------------->|            |
   |                                     |         |            |
   |  200 OK (JSON Additional Information) (7)     |            |
   |<----------------------------------------------|            |
   | ----------------------------------\ |         |            |
   |-| {..., "splitDnsClaims": [...] } | |         |            |
   | |---------------------------------/ |         |            |
]]></artwork>
        </figure>
        <section anchor="example-verify-external">
          <name>Verification Using an External Resolver</name>
          <t><xref target="fig-learn2"/> shows the steps performed to verify the local
          claims of DNS authority using an external resolver.</t>

<dl newline="false" spacing="normal">	  
            <dt><strong>Steps 1-2</strong>:</dt><dd>The client uses an encrypted DNS
              connection to an external resolver to issue TXT
              queries for the Verification Records. The TXT lookup returns
              a token that matches the claim.</dd>
            <dt><strong>Step 3</strong>:</dt><dd>The client has validated that
              <tt>example.com</tt> has authorized <tt>dns.example.net</tt>
              to serve <tt>example.com</tt>. When the client connects using an
              encrypted transport as indicated in <xref
              target="RFC9463">DNR</xref>, it will authenticate
              the server to its name using TLS (<xref target="RFC8310"
              section="8" sectionFormat="of"/>) and send queries to resolve
              any names that fall within the claimed zones.</dd>
          </dl>
          <figure anchor="fig-learn2">
            <name>Verifying Claims Using an External Resolver</name>
            <artwork><![CDATA[
+---------+                  +--------------------+  +----------+
| Client  |                  | Network's          |  | External |
|         |                  | Encrypted Resolver |  | Resolver |
+---------+                  +--------------------+  +----------+
     |                                          |         |
     | TLS connection                           |         |
     |--------------------------------------------------->|
     | ---------------------------\             |         |
     |-| validate TLS certificate |             |         |
     | |--------------------------|             |         |
     |                                          |         |
     | TXT? dns.example.net.\                   |         |
     |   _splitdns-challenge.example.com (1)    |         |
     |--------------------------------------------------->|
     |                                          |         |
     |  TXT "token=ABC..." (2)                  |         |
     |<---------------------------------------------------|
     | --------------------------------\        |         |
     |-| dns.example.net is authorized |        |         |
     | ----------------------\---------|        |         |
     |-| finished validation |                  |         |
     | |---------------------|                  |         |
     |                                          |         |
     |  use dns.example.net when                |         |
     |  resolving example.com (3)               |         |
     |----------------------------------------->|         |
     |                                          |         |
]]></artwork>
          </figure>
        </section>
        <section anchor="example-verify-dnssec">
          <name>Verification Using DNSSEC</name>
          <t><xref target="fig-learn3"/> shows the steps performed to verify the local
          claims of DNS authority using DNSSEC.</t>

<dl newline="false" spacing="normal">	  
            <dt><strong>Steps 1-2</strong>:</dt><dd>The DNSSEC-validating client queries
              the network's encrypted resolver to issue TXT queries for the
              Verification Records. The TXT lookup will return
              a signed response containing the expected token. The client then
              performs full DNSSEC validation locally.</dd>
            <dt><strong>Step 3</strong>:</dt><dd>If the DNSSEC validation is successful and
              the token matches, then this authorization claim is validated.
              Once the client connects using an encrypted transport as indicated
              in <xref target="RFC9463">DNR</xref>, it will authenticate
              the server to its name using TLS (<xref target="RFC8310"
              section="8" sectionFormat="of"/>) and send queries to resolve
              any names that fall within the claimed zones.</dd>
          </dl>
          <figure anchor="fig-learn3">
            <name>An Example of Verifying Claims Using DNSSEC</name>
            <artwork><![CDATA[
+---------+                                    +--------------------+
| Client  |                                    | Network's          |
|         |                                    | Encrypted Resolver |
+---------+                                    +--------------------+
  |                                                               |
  | DNSSEC OK (DO), TXT? dns.example.net.\                        |
  |   _splitdns-challenge.example.com (1)                         |
  |-------------------------------------------------------------->|
  |                                                               |
  | TXT token=DEF..., Signed Answer (RRSIG) (2)                   |
  |<--------------------------------------------------------------|
  | -------------------------------------\                        |
  |-| DNSKEY+TXT matches RRSIG, use TXT  |                        |
  | |------------------------------------|                        |
  | --------------------------------\                             |
  |-| dns.example.net is authorized |                             |
  | |-------------------------------|                             |
  | ----------------------\                                       |
  |-| finished validation |                                       |
  | |---------------------|                                       |
  |                                                               |
  | use encrypted network-designated resolver for example.com (3) |
  |-------------------------------------------------------------->|
  |                                                               |
]]></artwork>
          </figure>
        </section>
    </section>
    <section anchor="operational">
      <name>Operational Efficiency in Split-Horizon Deployments</name>
        <t>In many split-horizon deployments, all non-public domain names are
        placed in a separate child zone (e.g., <tt>internal.example.com</tt>).
        In this configuration, the message flow is similar to the flow described in <xref
        target="example-verify-external"/>, except that queries for hosts not within the
        subdomain (e.g., <tt>www.example.com</tt>) are sent to the
        external resolver rather than the resolver for <tt>internal.example.com</tt>.</t>
        <t>As specified in <xref target="example-verify-external"/>, the internal DNS
        server will need a certificate signed by a Certification Authority (CA) trusted by the
        client.</t>
        <t>Although placing internal domains inside a child domain is not necessary to prevent leakage,
        such placement reduces the frequency of changes to the Verification Record. This document
        recommends that the internal domains be kept in a child zone of the local domain hints
        advertised by the network. For example, if the PvD "dnsZones" entry is
        "internal.example.com" and the network-provided DNS resolver is "ns1.internal.example.com",
        the network operator can structure the internal domain names as
        "private1.internal.example.com", "private2.internal.example.com",
        etc. The network-designated resolver will be used to resolve the subdomains of
        the local domain hint "*.internal.example.com".</t>
    </section>
    <section anchor="vpn">
      <name>Validation with IKEv2</name>
      <t>When the endpoint is using a VPN tunnel and the tunnel is IPsec, the encrypted DNS resolver hosted by
      the VPN service provider can be securely discovered by the endpoint
      using the ENCDNS_IP* IKEv2 Configuration Payload Attribute Types
      defined in <xref target="RFC9464"/>. The VPN client
      can use the mechanism defined in <xref target="validating"/> to validate that the discovered
      encrypted DNS resolver is authorized to answer for the claimed subdomains.</t>
      <t>Other VPN tunnel types have similar configuration capabilities. Note that those
      capabilities are not discussed in this document.</t>
    </section>
    <section anchor="aclaim">
      <name>Authorization Claim Update</name>
      <t>A Verification Record is only valid until it expires. Expiry occurs when the Time To Live (TTL)
      or DNSSEC signature validity period ends. Shortly before Verification Record expiry, clients <bcp14>MUST</bcp14>
      fetch the Verification Records again and repeat the verification procedure. This ensures the
      availability of updated and valid Verification Records.</t>
      <t>A new Verification Record must be added to the RRset before the corresponding authorization
      claim is updated.  After the claim is updated, the following procedures can be used:</t>
      <ol>
        <li>DHCP reconfiguration can be initiated by a DHCP server that has previously communicated with a DHCP client and
   negotiated for the DHCP client to listen for Reconfigure messages, to prompt the DHCP client to
        dynamically request the updated authorization claim. This process avoids the need for
        the client to wait for its current lease to complete and request a new one, enabling the lease
        renewal to be driven by the DHCP server.</li>
        <li>The sequence number in the RA PvD Option
        can be incremented, requiring clients to fetch PvD Additional Information from the HTTPS
        server due to the updated sequence number in the new RA (<xref target="RFC8801" section="4.1"
        sectionFormat="of"/>).</li>
        <li>The old Verification Record needs to be maintained until the DHCP lease or PvD Additional Information expires.</li>
      </ol>
    </section>
    <section anchor="Security">
      <name>Security Considerations</name>
      <t>The ADNs of authorized local encrypted resolvers are
      revealed in the owner names of Verification Records.  This makes it easier for
      domain owners to understand which resolvers they are currently authorizing to
      implement split DNS. However, this could create a confidentiality issue if the
      local encrypted resolver's name contains sensitive information or is part of a
      secret subdomain. To mitigate the impact of such leakage, local resolvers should
      be given names that do not reveal any sensitive information.</t>
      <t> The security properties of hashing algorithms are not fixed. Algorithm agility
      (see <xref target="RFC7696"/>) is achieved by providing implementations with
      the flexibility to choose hashing algorithms from the "ZONEMD Hash Algorithms" registry
      (<xref target="RFC8976" section="5.3" sectionFormat="of"/>).</t>
      <t>The entropy of a salt depends on a high-quality pseudorandom number generator.
      For further discussion on random number generation, see <xref target="RFC4086"/>.
      The salt <bcp14>MUST</bcp14> be regenerated whenever the authorization claim is updated.</t>
    </section>
    <section anchor="IANA">
      <name>IANA Considerations</name>
      <section>
        <name>New DHCP Authentication Algorithm for Split DNS</name>
        <t>IANA has added the following entry to the "Protocol Name Space
        Values" registry in the "Dynamic Host Configuration Protocol (DHCP)
        Authentication Option Name Spaces" registry group:</t>

	<dl newline="false" spacing="normal">
	  <dt>Value:</dt><dd>4</dd>
	  <dt>Description:</dt><dd>Split-horizon DNS</dd>
	  <dt>Reference:</dt><dd>RFC 9704</dd>
	</dl>
      </section>
      <section>
        <name>New PvD Additional Information Type for Split DNS</name>
        <t>IANA has added the following entry to the "Additional
        Information PvD Keys" registry in the "Provisioning Domains (PvDs)" registry group:</t>

<dl newline="false" spacing="normal">
          <dt>JSON key:</dt><dd>splitDnsClaims</dd>
          <dt>Description:</dt><dd>Verifiable locally served domains</dd>
          <dt>Type:</dt><dd>Array of Objects</dd>
          <dt>Example:</dt><dd><sourcecode type="json">[{
  "resolver": "dns.example.net",
  "parent": "example.com",
  "subdomains": ["sub"],
  "algorithm": "SHA384",
  "salt": "abc...123"
}]</sourcecode></dd>
          <dt>Reference:</dt><dd>RFC 9704</dd>
        </dl>
      </section>
      <section anchor="new-split-claims-registry">
        <name>New PvD Split DNS Claims Registry</name>
        <t>IANA has created a new registry called "PvD Split DNS Claims"
        within the "Provisioning Domains (PvDs)" registry group.  This new registry
        reserves JSON keys for use in sub-dictionaries under the splitDnsClaims JSON key.
        The initial contents of this registry, as discussed in <xref target="splitclaims"/>,
        are listed below and have been added to the registry:</t>

<table anchor="split-claims">
  <name>Split DNS Claims</name>
  <thead>
    <tr>
      <th>JSON key</th>    
      <th>Description</th>
      <th>Type</th>
      <th>Example</th>
      <th>Reference</th>
    </tr>
  </thead>
  <tbody> 
    <tr>
      <td>resolver</td>
      <td>The Authentication Domain Name</td>
      <td>String</td>
      <td>"dns.example.net"</td>
      <td>RFC 9704</td>
    </tr>
    <tr>
      <td>parent</td>
      <td>The parent zone name</td>
      <td>String</td>
      <td>"example.com"</td>
      <td>RFC 9704</td>
    </tr>
    <tr>
      <td>subdomains</td>
      <td>An array containing the claimed subdomains</td>
      <td>Array of Strings</td>
      <td>["sub"]</td>
      <td>RFC 9704</td>
    </tr>
    <tr>
      <td>algorithm</td>
      <td>The hash algorithm</td>
      <td>String</td>
      <td>"SHA384"</td>
      <td>RFC 9704</td>
    </tr>
    <tr>
      <td>salt</td>
      <td>The salt (base64url)</td>
      <td>String</td>
      <td>"abc...123"</td>
      <td>RFC 9704</td>
    </tr>
  </tbody>
</table>

        <t>The keys defined in this document are mandatory. Any new assignments of keys will be considered
        as optional for the purpose of the mechanism described in this document.</t>
        <t>New assignments in the "PvD Split DNS Claims" registry will be
        administered by IANA through Expert Review <xref target="RFC8126"/>. Experts are
        requested to ensure that defined keys do not overlap in names or semantics.</t>
        <section>
          <name>Guidelines for the Designated Experts</name>
          <t>It is suggested that multiple designated experts be appointed for
          registry change requests.</t>

          <t>Criteria that should be applied by the designated experts include
          determining whether the proposed registration duplicates existing
          entries and whether the registration description is clear and fits
          the purpose of this registry.</t>

          <t>Registration requests are evaluated within a three-week review period
          on the advice of one or more designated experts. Within the review
          period, the designated experts will either approve or deny the
          registration request, communicating this decision to IANA. Denials
          should include an explanation and, if applicable, suggestions as to
          how to make the request successful.</t>

        </section>
      </section>
      <section>
        <name>DNS Underscore Name</name>
        <t>IANA has added the following entry to the "Underscored and
        Globally Scoped DNS Node Names" registry in the "Domain Name System (DNS)
        Parameters" registry group:</t>
<dl newline="false" spacing="normal">
          <dt>RR Type:</dt><dd>TXT</dd>
          <dt>_NODE NAME:</dt><dd>_splitdns-challenge</dd>
          <dt>Reference:</dt><dd>RFC 9704</dd>
        </dl>
      </section>
    </section>
  </middle>


  <back>
    <displayreference target="I-D.ietf-dnsop-domain-verification-techniques" to="DOMAIN-VERIFICATION-TECHNIQUES"/>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.3118.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2131.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4034.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8801.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6698.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4035.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8976.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8415.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.3396.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6761.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8126.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9525.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4086.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4648.xml"/>
      </references>
      <references>
        <name>Informative References</name>

        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9499.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8598.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7686.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8806.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8106.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4702.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4704.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6731.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.5986.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8310.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7696.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7858.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8484.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9250.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9364.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6234.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6762.xml"/>
	<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8792.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9463.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9464.xml"/>
	<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9462.xml"/>

<!-- draft-ietf-dnsop-domain-verification-techniques (I-D Exists)
     "Long way" to fix first author's initials -->

<reference anchor="I-D.ietf-dnsop-domain-verification-techniques">
   <front>
      <title>Domain Control Validation using DNS</title>
      <author initials="S." surname="Sahib" fullname="Shivan Kaul Sahib">
         <organization>Brave Software</organization>
      </author>
      <author initials="S." surname="Huque" fullname="Shumon Huque">
         <organization>Salesforce</organization>
      </author>
      <author initials="P." surname="Wouters" fullname="Paul Wouters">
         <organization>Aiven</organization>
      </author>
      <author initials="E." surname="Nygren" fullname="Erik Nygren">
         <organization>Akamai Technologies</organization>
      </author>
      <date month="October" day="21" year="2024" />
   </front>
   <seriesInfo name="Internet-Draft" value="draft-ietf-dnsop-domain-verification-techniques-06" />
</reference>
    </references>
    </references>

    <section numbered="false">
      <name>Acknowledgements</name>
      <t>Thanks to <contact fullname="Mohamed Boucadair"/>, <contact
      fullname="Jim Reid"/>, <contact fullname="Tommy Pauly"/>, <contact
      fullname="Paul Vixie"/>, <contact fullname="Michael Richardson"/>,
      <contact fullname="Bernie Volz"/>, <contact fullname="ric Vyncke"/>, and
      <contact fullname="Vinny Parla"/> for the discussion and comments.</t>

      <t>Thanks to <contact fullname="Tianran Zhou"/> for the opsdir review,
      <contact fullname="Anthony Somerset"/> for the dnsdir review, <contact
      fullname="Watson Ladd"/> for the secdir review, <contact fullname="Bob
      Halley"/> for the intdir review, and <contact fullname="Mallory Knodel"/>
      for the genart review.</t>

      <t>Thanks to <contact fullname="Mohamed Boucadair"/> for the Shepherd review.</t>

    </section>
  </back>
</rfc>
