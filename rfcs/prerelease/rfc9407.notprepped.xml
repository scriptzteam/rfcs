<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>

<rfc xmlns:xi="http://www.w3.org/2001/XInclude" submissionType="IRTF" category="exp" consensus="true" docName="draft-irtf-nwcrg-tetrys-04" number="9407" ipr="trust200902" obsoletes="" updates="" xml:lang="en" tocInclude="true" tocDepth="3" symRefs="true" sortRefs="true" version="3">

   <front>
    <title abbrev="Tetrys Network Coding Protocol">Tetrys: An On-the-Fly Network Coding Protocol</title>
    <seriesInfo name="RFC" value="9407"/>
    <author fullname="Jonathan Detchart" initials="J." surname="Detchart">
      <organization>ISAE-SUPAERO</organization>
      <address>
        <postal>
          <street>10, avenue Edouard Belin</street>
          <extaddr>BP 54032</extaddr>
          <city>Toulouse CEDEX 4</city>
          <code>31055</code>
          <country>France</country>
        </postal>
        <email>jonathan.detchart@isae-supaero.fr</email>
      </address>
    </author>
    <author fullname="Emmanuel Lochin" initials="E." surname="Lochin">
      <organization>ENAC</organization>
      <address>
        <postal>
          <street>7, avenue Edouard Belin</street>
          <city>Toulouse</city>
          <code>31400</code>
          <country>France</country>
        </postal>
        <email>emmanuel.lochin@enac.fr</email>
      </address>
    </author>
    <author fullname="Jerome Lacan" initials="J." surname="Lacan">
      <organization>ISAE-SUPAERO</organization>
      <address>
        <postal>
          <street>10, avenue Edouard Belin</street>
          <extaddr>BP 54032</extaddr>
          <city>Toulouse CEDEX 4</city>
          <code>31055</code>
          <country>France</country>
        </postal>
        <email>jerome.lacan@isae-supaero.fr</email>
      </address>
    </author>
    <author fullname="Vincent Roca" initials="V." surname="Roca">
      <organization>INRIA</organization>
      <address>
        <postal>
          <street>655, avenue de l'Europe</street>
          <extaddr>Inovallee; Montbonnot</extaddr>
          <city>St Ismier CEDEX</city>
          <code>38334</code>
          <country>France</country>
        </postal>
        <email>vincent.roca@inria.fr</email>
      </address>
    </author>
    <date year="2023" month="June" />
    <workgroup>Coding for Efficient NetWork Communications</workgroup>
    <keyword>Network Coding</keyword>
    <abstract>
      <t>This document describes Tetrys, which is an on-the-fly network coding protocol that can be used to transport delay-sensitive and loss-sensitive data over a lossy network. Tetrys may recover from erasures within an RTT-independent delay thanks to the transmission of coded packets.
This document is a record of the experience gained by the authors while developing and testing the Tetrys protocol in real conditions.</t>
      <t>
            This document is a product of the Coding for Efficient NetWork Communications Research Group (NWCRG). 
It conforms to the NWCRG taxonomy described in RFC 8406.
      </t>
    </abstract>
  </front>
  <middle>
    <section anchor="intro" numbered="true" toc="default">
      <name>Introduction</name>
         <t>This document is a product of and represents the collaborative work
	   and consensus of the Coding for Efficient NetWork Communications
	   Research Group (NWCRG). It is not an IETF product or an IETF standard.</t>
      <t>This document describes Tetrys, which is an on-the-fly network coding
            protocol that can be used to transport delay-sensitive and 
            loss-sensitive data over a lossy network. 
            Network codes were introduced in the early 2000s <xref
            target="AHL-00" format="default"/> to address the limitations of
            transmission over the Internet (delay, capacity, and packet
            loss). While network codes have seen some deployment fairly
            recently in the Internet community, the use of application-layer
            erasure codes in the IETF has already been standardized in the RMT
            <xref target="RFC5052" format="default"/> <xref target="RFC5445" format="default"/>
            and FECFRAME
            <xref target="RFC8680" format="default"/>
            Working Groups. The protocol presented here may be seen as a network-coding extension to standard unicast transport protocols (or even multicast or anycast with a few modifications).  The current proposal may be considered a combination of network erasure coding and feedback mechanisms
            <xref target="Tetrys" format="default"/> <xref target="Tetrys-RT" format="default"/>.
      </t>
      <t>The main innovation of the Tetrys protocol is in the generation of coded packets from an elastic encoding window. This window is filled by any source packets coming from an input flow and is periodically updated with the receiver feedback. 
These feedback messages provide to the sender information about the
highest sequence number received or rebuilt, which can enable the flushing the
corresponding source packets stored in the encoding window. The size of this
window may be fixed or dynamically updated. If the window is full, incoming
source packets replace older source packets that are dropped. As a matter of
fact, its limit should be correctly sized.

Finally, Tetrys allows dealing with losses on both the forward and return paths and is particularly resilient to acknowledgment losses. All these operations are further detailed in <xref target="tetrys_basic_functions" format="default"/>.</t>
      <t>With Tetrys, a coded packet is a linear combination over a finite field of the data source packets belonging to the coding window. 

The choice of coefficients, as finite fields elements, is a trade-off between the best erasure recovery performance (finite fields of 256 elements) and the system constraints (finite fields of 16 elements are preferred) and is driven by the application.</t>
      <t>Thanks to the elastic encoding window, the coded packets are built on-the-fly by using a predefined method to choose the coefficients. The redundancy ratio may be dynamically adjusted and the coefficients may be generated in different ways during the transmission. Compared to Forward Error Correction (FEC) block codes, this reduces the bandwidth use and the decoding delay.</t>
      <t>The design description of the Tetrys protocol in this document is complemented by a record of the experience gained by the authors while developing and testing the Tetrys protocol in realistic conditions. In particular, several research issues are discussed in <xref target="research" format="default"/> following our own experience and observations.</t>
      <section numbered="true" toc="default">
        <name>Requirements Notation</name>
        <t>
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL
    NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as
    described in BCP&nbsp;14 <xref target="RFC2119"/> <xref target="RFC8174"/> 
    when, and only when, they appear in all capitals, as shown here.
        </t>
      </section>
    </section>
    <section anchor="terminology" numbered="true" toc="default">
      <name>Definitions, Notations, and Abbreviations</name>
                <t>
                  The notation used in this document is based on the NWCRG taxonomy
                  <xref target="RFC8406" format="default"/>.
      </t>
<dl spacing="normal" newline="false">
        <dt>Source Symbol:</dt><dd>A symbol that is transmitted between the ingress and egress of the network.</dd>
        <dt>Coded Symbol:</dt><dd>A linear combination over a finite field of a set of source symbols.</dd>
        <dt>Source Symbol ID:</dt><dd>A sequence number to identify the source symbols.</dd>
        <dt>Coded Symbol ID:</dt><dd>A sequence number to identify the coded symbols.</dd>
        <dt>Encoding Coefficients:</dt><dd>Elements of the finite field characterizing the linear combination used to generate coded symbols.</dd>
        <dt>Encoding Vector:</dt><dd>A set of the coding coefficients and input source symbol IDs.</dd>
        <dt>Source Packet:</dt><dd>A source packet contains a source symbol with its associated IDs.</dd>
        <dt>Coded Packet:</dt><dd>A coded packet contains a coded symbol, the coded symbol's ID, and encoding vector.</dd>
        <dt>Input Symbol:</dt><dd>A symbol at the input of the Tetrys encoder.</dd>
        <dt>Output Symbol:</dt><dd>A symbol generated by the Tetrys encoder. For a non-systematic mode, all output symbols are coded symbols. For a systematic mode, output symbols <bcp14>MAY</bcp14> be the input symbols and a number of coded symbols that are linear combinations of the input symbols plus the encoding vectors.</dd>
        <dt>Feedback Packet:</dt><dd>A feedback packet is a packet containing information about the decoded or received source symbols. It <bcp14>MAY</bcp14> also contain additional information about the Packet Error Rate or the number of various packets in the receiver decoding window.</dd>
        <dt>Elastic Encoding Window:</dt><dd>An encoder-side buffer that stores all the unacknowledged source packets of the input flow involved in the coding process.</dd>
<dt>Coding Coefficient Generator Identifier (CCGI):</dt><dd>A unique identifier that
defines a function or an algorithm allowing the generation of the encoding
vector.</dd>
        <dt>Code Rate:</dt><dd>Defines the rate between the number of input symbols and the number of output symbols.</dd>
      </dl>
    </section>
    <section anchor="tetrys_architecture" numbered="true" toc="default">
      <name>Architecture</name>
         <section anchor="use_cases" numbered="true" toc="default">
        <name>Use Cases</name>
            <t>Tetrys is well suited, but not limited, to the use case where
            there is a single flow originated by a single source with intra-stream 
            coding at a single encoding node. Note that the input
            stream <bcp14>MAY</bcp14> be a multiplex of several upper-layer
            streams.  Transmission <bcp14>MAY</bcp14> be over a single path or
            multiple paths.  
This is the simplest use case that is quite
            aligned with currently proposed scenarios for end-to-end
            streaming.</t>
      </section>
      <section anchor="protocol_overview" numbered="true" toc="default">
        <name>Overview</name>
            <figure anchor="fig-archi-tetrys">
          <name>Tetrys Architecture</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
   +----------+                +----------+
   |          |                |          |
   |    App   |                |    App   |
   |          |                |          |
   +----------+                +----------+
        |                           ^
        |  Source           Source  |
        |  Symbols          Symbols |
        |                           |
        v                           |
   +----------+                +----------+
   |          | Output Packets |          |
   |  Tetrys  |--------------->|  Tetrys  |
   |  Encoder |Feedback Packets|  Decoder |
   |          |<---------------|          |
   +----------+                +----------+
]]></artwork>
        </figure>
        <t>
               The Tetrys protocol features several key functionalities. The mandatory features include:
        </t>
        <ul spacing="normal">
          <li>on-the-fly encoding;</li>
          <li>decoding;</li>
          <li>signaling, to carry in particular the symbol IDs in the encoding window and the associated coding coefficients when meaningful;</li>
          <li>feedback management;</li>
          <li>elastic window management; and</li>
          <li>Tetrys packet header creation and processing.</li>
        </ul>
        <t>The optional features include:
        </t>
        <ul spacing="normal">
          <li>channel estimation;</li>
          <li>dynamic adjustment of the code rate and flow control; and</li>
          <li>
                     congestion control management (if appropriate). See <xref
                     target="transport-issue" format="default"/> for further
                     details.
                  </li>
        </ul>
        <t>
               Several building blocks provide the following functionalities:
        </t>
        <dl spacing="normal">
          <dt>The Tetrys Building Block:</dt><dd>This building block embeds
          both the Tetrys decoder and Tetrys encoder; thus, it is used during
          encoding and decoding processes. It must be noted that Tetrys does
          not mandate a specific building block.  Instead, any building block
          compatible with the elastic encoding window feature of Tetrys may be
          used.</dd>
          <dt>The Window Management Building Block:</dt><dd>This building block
                     is in charge of managing the encoding window at a Tetrys
                     sender.
                  </dd>
        </dl>
        <t>
               To ease the addition of future components and services, Tetrys adds a header extension mechanism that is compatible with that of Layered Coding Transport (LCT) 
               <xref target="RFC5651" format="default"/>, NACK-Oriented Reliable Multicast (NORM) 
               <xref target="RFC5740" format="default"/>, and FEC Framework (FECFRAME)
               <xref target="RFC8680" format="default"/>.
        </t>
         </section>
    </section>
    <section anchor="tetrys_basic_functions" numbered="true" toc="default">
      <name>Tetrys Basic Functions</name>
         <section anchor="encoding" numbered="true" toc="default">
        <name>Encoding</name>
            <t>At the beginning of a transmission, a Tetrys encoder <bcp14>MUST</bcp14> choose an initial code rate that adds redundancy as it doesn't know the packet loss rate of the channel. 
In the steady state, the Tetrys encoder <bcp14>MAY</bcp14> generate coded symbols when it receives a source symbol from the application or some feedback from the decoding blocks depending on the code rate.</t>
        <t>When a Tetrys encoder needs to generate a coded symbol, it considers the set of source symbols stored in the elastic encoding window and generates an encoding vector with the coded symbol. These source symbols are the set of source symbols that are not yet acknowledged by the receiver. For each source symbol, a finite field coefficient is determined using a Coding Coefficient Generator. 
This generator <bcp14>MAY</bcp14> take the source symbol IDs and the coded symbol ID as an input and <bcp14>MAY</bcp14> determine a coefficient in a deterministic way as presented in <xref target="coded-packet" format="default"/>. Finally, the coded symbol is the sum of the source symbols multiplied by their corresponding coefficients.</t>
        <t>A Tetrys encoder <bcp14>MUST</bcp14> set a limit to the elastic encoding window maximum size. This controls the algorithmic complexity at the encoder and decoder by limiting the size of linear combinations. It is also needed in situations where all window update packets are lost or absent.</t>
      </section>
      <section anchor="windowing" numbered="true" toc="default">
        <name>The Elastic Encoding Window</name>
            <t>When an input source symbol is passed to a Tetrys encoder, it is added to the elastic encoding window. This window <bcp14>MUST</bcp14> have a limit set by the encoding building block. 
If the elastic encoding window has reached its limit, the window slides over the symbols. The first (oldest) symbol is removed, and the newest symbol is added. As an element of the coding window, this symbol is included in the next linear combinations created to generate the coded symbols.</t>
        <t>As explained below, the Tetrys decoder sends periodic feedback indicating the received or decoded source symbols. When the sender receives the information that a source symbol was received or decoded by the receiver, it removes this symbol from the coding window.</t>
      </section>
      <section anchor="decoding" numbered="true" toc="default">
        <name>Decoding</name>
            <t>A standard Gaussian elimination is sufficient to recover the erased source symbols when the matrix rank enables it.</t>
      </section>
    </section>
    <section anchor="encapsulation-format" numbered="true" toc="default">
      <name>Packet Format</name>
         <section anchor="common-packet-header-format" numbered="true" toc="default">
        <name>Common Header Format</name>
            <t>
               All types of Tetrys packets share the same common header format (see <xref target="fig-common-header-format" format="default"/>).
        </t>
        <figure anchor="fig-common-header-format">
          <name>Common Header Format</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   V   | C |S|     Reserved    |   HDR_LEN     |    PKT_TYPE   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Congestion Control Information (CCI, length = 32*C bits)    |
|                          ...                                  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Transport Session Identifier (TSI, length = 32*S bits)     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                Header Extensions (if applicable)              |
|                          ...                                  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
        </figure>
        <t>As noted above, this format is inspired by, and inherits from, the LCT header format <xref target="RFC5651" format="default"/> with slight modifications.</t>
        <dl spacing="normal">
          <dt>Tetrys version number (V):</dt><dd>4 bits.
			      Indicates the Tetrys version number.  The Tetrys version number for this specification is 1.</dd>
          <dt>Congestion control flag (C):</dt><dd>2 bits.  C set to 0b00
                     indicates the Congestion Control Information (CCI) field
                     is 0 bits in length.  C set to 0b01 indicates the CCI field is 32
                     bits in length. C set to 0b10 indicates the CCI field is 64 bits in
                     length.  C set to 0b11 indicates the CCI field is 96 bits in
                     length.
                  </dd>
          <dt>Transport Session Identifier flag (S):</dt><dd>1 bit.
      			 This is the number of full 32-bit words in the TSI field.  The TSI field is 32*S bits in length; i.e., the length is either 0 bits or 32 bits.</dd>
          <dt>Reserved (Resv):</dt><dd>9 bits. These bits are reserved.  In this version of the specification, they <bcp14>MUST</bcp14> be set to zero by senders and <bcp14>MUST</bcp14> be ignored by receivers.</dd>
          <dt>Header length (HDR_LEN):</dt><dd>8 bits.  The total length of
          the Tetrys header in units of 32-bit words. The length of the Tetrys
          header <bcp14>MUST</bcp14> be a multiple of 32 bits.  This field may
          be used to directly access the portion of the packet beyond the
          Tetrys header, i.e., to the first next header if it exists, to the
          packet payload if it exists and there is no other header, or to the
          end of the packet if there are no other headers or packet
          payload.</dd>
<dt>Tetrys packet type (PKT_TYPE):</dt><dd>8 bits.
				There are three types of packets: the PKT_TYPE_SOURCE (0b00) defined in <xref target="source-packet" format="default"/>, the PKT_TYPE_CODED (0b01) defined in <xref target="coded-packet" format="default"/> and the PKT_TYPE_WND_UPT (0b11) for window update packets defined in <xref target="ack-packet" format="default"/>.</dd>
          <dt>Congestion Control Information (CCI):</dt><dd>0, 32, 64, or 96 bits.
			      Used to carry congestion control information.  For example, the
			      congestion control information could include layer numbers,
			      logical channel numbers, and sequence numbers.  This field is
			      opaque for this specification.
			      This field <bcp14>MUST</bcp14> be 0 bits (absent) if C is set to 0b00.
			      This field <bcp14>MUST</bcp14> be 32 bits if C is set to 0b01.
			      This field <bcp14>MUST</bcp14> be 64 bits if C is set to 0b10.
			      This field <bcp14>MUST</bcp14> be 96 bits if C is set to 0b11.</dd>

          <dt>Transport Session Identifier (TSI):</dt><dd>0 or 32 bits.
			      The TSI uniquely identifies a session among all sessions from a
			      particular Tetrys encoder. The TSI is scoped by the IP address of the
			      sender; thus, the IP address of the sender and the TSI together
			      uniquely identify the session.  
Although a TSI always uniquely identifies a session conjointly with
			      the IP address of the sender, whether the TSI is included in the Tetrys header depends on
			      what is used as the TSI value.  If the underlying transport is
			      UDP, then the 16-bit UDP source port number <bcp14>MAY</bcp14> serve as the TSI
			      for the session.
                     If there is
			      no underlying TSI provided by the network, transport, or any other
			      layer, then the TSI <bcp14>MUST</bcp14> be included in the Tetrys header.
                  </dd>
        </dl>
        <section anchor="header-extension-format" numbered="true" toc="default">
          <name>Header Extensions</name>
               <t>Header extensions are used in Tetrys to accommodate optional header fields that are not always used or have variable sizes.
				The presence of header extensions <bcp14>MAY</bcp14> be inferred by the Tetrys header length (HDR_LEN).
				If HDR_LEN is larger than the length of the standard header, then the remaining header space is taken by header extensions.</t>
          <t>If present, header extensions <bcp14>MUST</bcp14> be processed to ensure that they are recognized before performing any congestion control procedure or otherwise accepting a packet.
				The default action for unrecognized header extensions is to ignore them.
				This allows for the future introduction of backward-compatible enhancements to Tetrys without changing the Tetrys version number.
				Header extensions that are not backward-compatible <bcp14>MUST NOT</bcp14> be introduced without changing the Tetrys version number.</t>
          <t>
                  There are two formats for header extensions as depicted in <xref target="fig_header_extension" format="default"/>:
          </t>
          <ul spacing="normal">
            <li>The first format is used for variable-length extensions with header extension type (HET) values between 0 and 127.</li>
            <li>The second format is used for fixed-length (one 32-bit word) extensions using HET values from 128 to 255.</li>
          </ul>
          <figure anchor="fig_header_extension">
            <name>Header Extension Format</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  HET (<=127)  |       HEL     |                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
.                                                               .
.              Header Extension Content (HEC)                   .
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  HET (>=128)  |       Header Extension Content (HEC)          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
          </figure>
<dl spacing="normal">
            <dt>Header Extension Type (HET):</dt><dd>8 bits. The type of the header extension. This document defines several possible types.
				Additional types may be defined in future versions of this specification.
				HET values from 0 to 127 are used for variable-length header extensions.
				HET values from 128 to 255 are used for fixed-length, 32-bit header extensions.</dd>            
              <dt>Header Extension Length (HEL):</dt><dd>8 bits. The length of the whole header extension field expressed in multiples of 32-bit words.
				This field <bcp14>MUST</bcp14> be present for variable-length extensions (HETs between 0 and 127) and <bcp14>MUST NOT</bcp14> be present for fixed-length extensions (HETs between 128 and 255).</dd>            
              <dt>Header Extension Content (HEC):</dt><dd>Length of the variable. The content of the header extension.
				The format of this subfield depends on the header extension type.
				For fixed-length header extensions, the HEC is 24 bits.
				For variable-length header extensions, the HEC field has a variable size as specified by the HEL field.
				Note that the length of each header extension <bcp14>MUST</bcp14> be a multiple of 32 bits.
				Additionally, the total size of the Tetrys header, including all header extensions and optional header fields, cannot exceed 255 32-bit words.</dd>
</dl>
        </section>
      </section>
      <section anchor="source-packet" numbered="true" toc="default">
        <name>Source Packet Format</name>
            <t>A source packet is a common packet header encapsulation, a source symbol ID, and a source symbol (payload). The source symbols <bcp14>MAY</bcp14> have variable sizes.</t>
        <figure anchor="fig-src-pkt">
          <name>Source Packet Format</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
/                      Common Packet Header                     /
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Source Symbol ID                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
/                            Payload                            /
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
        </figure>
<dl spacing="normal">
        <dt>Common Packet Header:</dt><dd>A common packet header (as common header format) where packet type is set to 0b00.</dd>
        <dt>Source Symbol ID:</dt><dd>The sequence number to identify a source symbol.</dd>
        <dt>Payload:</dt><dd>The payload (source symbol).</dd>
</dl>
      </section>
      <section anchor="coded-packet" numbered="true" toc="default">
        <name>Coded Packet Format</name>
            <t>
               A coded packet is the encapsulation of a common packet header, a coded symbol ID, the associated encoding vector, and a coded symbol (payload). 
               As the source symbols <bcp14>MAY</bcp14> have variable sizes, all the source symbol sizes need to be encoded. To generate this encoded payload size as a 16-bit unsigned value, the linear combination uses the same coefficients as the coded payload. The result <bcp14>MUST</bcp14> be stored in the coded packet as the encoded payload size (16 bits). As it is an optional field, the encoding vector <bcp14>MUST</bcp14> signal the use of variable source symbol sizes with the field V (see <xref target="unified-encoding-vector-format" format="default"/>).
        </t>
        <figure anchor="fig-rpr-pkt">
          <name>Coded Packet Format</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
/                      Common Packet Header                     /
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Coded Symbol ID                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
/                         Encoding Vector                       /
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Encoded Payload Size      |                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
|                                                               |
/                            Payload                            /
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
        </figure>
<dl spacing="normal">
        <dt>Common Packet Header:</dt><dd>A common packet header (as common header format) where packet type is set to 0b01.</dd>
        <dt>Coded Symbol ID:</dt><dd>The sequence number to identify a coded symbol.</dd>
        <dt>Encoding Vector:</dt><dd>An encoding vector to define the linear combination used (coefficients and source symbols).</dd>
        <dt>Encoded Payload Size:</dt><dd>The coded payload size used if the source symbols have a variable size (optional, <xref target="unified-encoding-vector-format" format="default"/>).</dd>
        <dt>Payload:</dt><dd>The coded symbol.</dd>
</dl>
        <section anchor="unified-encoding-vector-format" numbered="true" toc="default">
          <name>The Encoding Vector</name>
          <t>An encoding vector contains all the information about the linear combination used to generate a coded symbol. The information includes the source identifiers and the coefficients used for each source symbol. It <bcp14>MAY</bcp14> be stored in different ways depending on the situation.</t>
          <figure anchor="fig-unif-enc-vec">
            <name>Encoding Vector Format</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     EV_LEN    |  CCGI | I |C|V|    NB_IDS     |   NB_COEFS    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        FIRST_SOURCE_ID                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     b_id      |                                               |
+-+-+-+-+-+-+-+-+            id_bit_vector        +-+-+-+-+-+-+-+
|                                                 |   Padding   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                          coef_bit_vector        +-+-+-+-+-+-+-+
|                                                 |   Padding   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
          </figure>
<dl>
            <dt>Encoding Vector Length (EV_LEN):</dt><dd>8 bits. The size in
            units of 32-bit words.</dd>
              <dt>Coding Coefficient Generator Identifier (CCGI):</dt><dd><t>4-bit ID to identify the algorithm or function used to generate the coefficients. As a CCGI is included in each encoded vector, it <bcp14>MAY</bcp14> dynamically change between the generation of two coded symbols.
                     The CCGI builds the coding coefficients used to generate the coded symbols. They <bcp14>MUST</bcp14> be known by all the Tetrys encoders or decoders.
                     The two RLC FEC schemes specified in this document reuse the finite fields defined in <xref target="RFC5510" sectionFormat="comma" section="8.1"/>.  
More specifically, the elements of the field GF(2<sup>(m)</sup>) are represented by polynomials with binary coefficients (i.e., over GF(2)) and with degree lower or equal to m-1. The addition between two elements is defined as the addition of binary polynomials in GF(2), which is equivalent to a bitwise XOR operation on the binary representation of these elements.
                     With GF(2<sup>(8)</sup>), multiplication between two elements is the multiplication modulo a given irreducible polynomial of degree 8. The following irreducible polynomial is used for GF(2<sup>(8)</sup>):</t> 
                     
     <t indent="3">x<sup>(8)</sup> + x<sup>(4)</sup> + x<sup>(3)</sup> + x<sup>(2)</sup> + 1</t>

                    <t>With GF(2<sup>(4)</sup>), multiplication between two elements is the multiplication modulo a given irreducible polynomial of degree 4. The following irreducible polynomial is used for GF(2<sup>(4)</sup>):</t> 
                     
      <t indent="3">x<sup>(4)</sup> + x + 1
              </t>
              <ul spacing="normal">
                <li>0b00: Vandermonde-based coefficients over the finite field GF(2<sup>(4)</sup>) as defined below. Each coefficient is built as alpha<sup>( (source_symbol_id*coded-symbol_id) % 16)</sup>, with alpha the root of the primitive polynomial.</li>
                <li>0b01: Vandermonde-based coefficients over the finite field GF(2<sup>(8)</sup>) as defined below. Each coefficient is built as alpha<sup>( (source_symbol_id*coded-symbol_id) % 256)</sup>, with alpha the root of the primitive polynomial.</li>
                <li>Suppose we want to generate the coded symbol 2 as a linear combination of the source symbols 1, 2, and 4 using CCGI set to 0b01. The coefficients will be alpha<sup>( (1 * 1) % 256)</sup>, alpha<sup>(&nbsp;(1 * 2) % 256)</sup>, and alpha<sup>( (1 * 4) % 256)</sup>.</li>
              </ul></dd>
              <dt>
                        Store the Source Symbol ID Format (I) (2 bits):
              </dt><dd>
              <ul spacing="normal">
                <li>0b00 means there is no source symbol ID information.</li>
                <li>0b01 means the encoding vector contains the edge blocks of the source symbol IDs without compression.</li>
                <li>0b10 means the encoding vector contains the compressed list of the source symbol IDs.</li>
                <li>0b11 means the encoding vector contains the compressed edge blocks of the source symbol IDs.</li>
              </ul>
            </dd>
            <dt>Store the Encoding Coefficients (C):</dt><dd>1 bit to indicate if an encoding vector contains information about the coefficients used.</dd>
            <dt>Having Source Symbols with Variable Size Encoding (V):</dt><dd>Set V to 0b01 if the combination that refers to the encoding vector is a combination of source symbols with variable sizes. In this case, the coded packets <bcp14>MUST</bcp14> have the 'Encoded Payload Size' field.</dd>
            <dt>NB_IDS:</dt><dd>The number of source IDs stored in the encoding vector (depending on I).</dd>
            <dt>Number of Coefficients (NB_COEFS):</dt><dd>The number of the coefficients used to generate the associated coded symbol.</dd>
            <dt>The First Source Identifier (FIRST_SOURCE_ID):</dt><dd>The first source symbol ID used in the combination.</dd>
            <dt>
                        Number of Bits for Each Edge Block (b_id):</dt><dd>The number of bits needed to store the edge.
                     </dd>
            <dt>Information about the Source Symbol IDs (id_bit_vector):</dt><dd>If I is set to 0b01, store the edge blocks as b_id * (NB_IDS * 2 - 1). 
If I is set to 0b10, store the edge blocks in a compressed way.</dd>
            <dt>The Coefficients (coef_bit_vector):</dt><dd>The coefficients stored depending on the CCGI (4 or 8 bits for each coefficient).</dd>
            <dt>Padding:</dt><dd>Padding to have an encoding vector size that is a multiple of 32 bits (for the ID and coefficient part).</dd>
          </dl>
               <t>The source symbol IDs are organized as a sorted list of 32-bit unsigned integers. Depending on the feedback, the source symbol IDs in the list <bcp14>MAY</bcp14> be successive or not. If they are successive, the boundaries are stored in the encoding vector; it just needs 2*32 bits of information. If not, the full list or the edge blocks <bcp14>MAY</bcp14> be stored and a differential transform to reduce the number of bits needed to represent an identifier <bcp14>MAY</bcp14> be used.</t>
<t>For the following subsections, let's take as an example the generation of an encoding vector for a coded symbol that is a linear combination of the source symbols with IDs 1, 2, 3, 5, 6, 8, 9, and 10 (or as edge blocks: [1..3], [5..6], [8..10]).</t>
          <t>There are several ways to store the source symbol IDs into the encoding vector:
          </t>
          <ul spacing="normal">
            <li>If no information about the source symbol IDs is needed, the field I  <bcp14>MUST</bcp14> be set to 0b00: no b_id and no id_bit_vector field.</li>
            <li>If the edge blocks are stored without compression, the field I <bcp14>MUST</bcp14> be set to 0b01. 
In this case, set b_id to 32 (as a Symbol ID is 32 bits), and store the list of 32-bit unsigned integers (1, 3, 4, 5, 6, 10) into id_bit_vectors.</li>
            <li>If the source symbol IDs are stored as a list with compression, the field I <bcp14>MUST</bcp14> be set to 0b10. In this case, see <xref target="compressing-encoding-vector" format="default"/>, but rather than compressing the edge blocks, we compress the full list of the source symbol IDs.</li>
            <li>If the edge blocks are stored with compression, the field I <bcp14>MUST</bcp14> be set to 0b11. In this case, see <xref target="compressing-encoding-vector" format="default"/>.</li>
          </ul>
          <section anchor="compressing-encoding-vector" numbered="true" toc="default">
            <name>Compressed List of Source Symbol IDs</name>
                  <t>Let's continue with our coded symbol defined in the previous section. The source symbol IDs used in the linear combination are: [1..3], [5..6], [8..10].</t>
            <t> If we want to compress and store this list into the encoding vector, we <bcp14>MUST</bcp14> follow this procedure:
            </t>
            <ol spacing="normal" type="1"><li>Keep the first element in the packet as the first_source_id: 1.</li>
              <li>Apply a differential transform to the other elements
              ([3, 5, 6, 8, 10]) that removes the element i-1 to the element i,
              starting with the first_source_id as i0, and get the list L =
              [2, 2, 1, 2, 2].</li> <li>Compute b, the number of bits needed to
              store all the elements, which is ceil(log2(max(L))), where
              max(L) represents the maximum of the elements of the list L;
              here, it is 2 bits.</li>
              <li>Write b in the corresponding field, and write all the b * [(2 * NB blocks) - 1] elements in a bit vector here: 10, 10, 01, 10, 10.</li>
            </ol>
          </section>
          <section anchor="decompressing-encoding-vector" numbered="true" toc="default">
            <name>Decompressing the Source Symbol IDs</name>
                  <t>When a Tetrys decoding block wants to reverse the operations, this algorithm is used:</t>
            <ol spacing="normal" type="1"><li>Rebuild the list of the transmitted elements by reading the bit vector and b: [10, 10, 01, 10, 10] =&gt; [2, 2, 1, 2, 2].</li>
              <li>Apply the reverse transform by adding successively the elements, starting with first_source_id: [1, 1 + 2, (1 + 2) + 2, (1 + 2 + 2) + 1, ...] =&gt; [1, 3, 5, 6, 8, 10].</li>
              <li>Rebuild the blocks using the list and first_source_id: [1..3], [5..6], [8..10].</li>
            </ol>
          </section>
        </section>
      </section>
      <section anchor="ack-packet" numbered="true" toc="default">
        <name>Window Update Packet Format</name>
              <t>A Tetrys decoder <bcp14>MAY</bcp14> send window update packets back to another building block. They contain information about what the packets received, decoded, or dropped, and other information such as a packet loss rate or the size of the decoding buffers. They are used to optimize the content of the encoding window. The window update packets are <bcp14>OPTIONAL</bcp14>; hence, they could be omitted or lost in transmission without impacting the protocol behavior.</t>
        <figure anchor="fig-ack-pkt">
          <name>Window Update Packet Format</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
/                      Common Packet Header                     /
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        nb_missing_src                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                   nb_not_used_coded_symb                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         first_src_id                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      plr      |   sack_size   |                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
|                                                               |
/                          SACK Vector                          /
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
        </figure>
<dl spacing="normal">
        <dt>Common Packet Header:</dt><dd>A common packet header (as common header format) where packet type is set to 0b10.</dd>
        <dt>nb_missing_src:</dt><dd>The number of missing source symbols in the receiver since the beginning of the session.</dd>
            <dt>nb_not_used_coded_symb:</dt><dd>The number of coded symbols at the receiver that have not already been used for decoding (e.g., the linear combinations contain at least two unknown source symbols).</dd>
<dt>first_src_id:</dt><dd>ID of the first source symbol to consider in the selective acknowledgment (SACK) vector.</dd>
<dt>plr:</dt><dd>Packet loss ratio expressed as a percentage normalized to an 8-bit unsigned integer. For example, 2.5% will be stored as floor(2.5 * 256/100) = 6. Conversely, if 6 is the stored value, the corresponding packet loss ratio expressed as a percentage is 6*100/256 = 2.34%. This value is used in the case of dynamic code rate or for a statistical purpose. The choice of calculation is left to the Tetrys decoder, depending on a window observation, but should be the PLR seen before decoding.</dd>
        <dt>sack_size:</dt><dd>The size of the SACK vector in 32-bit words. For instance, with a value of 2, the SACK vector is 64 bits long.</dd>
        <dt>SACK vector:</dt><dd>Bit vector indicating symbols that must be removed in the encoding window from the first source symbol ID. In most cases, these symbols were received by the receiver. The other cases concern some events with non-recoverable packets (i.e., in the case of a burst of losses) where it is better to drop and abandon some packets and remove them from the encoding window to allow the recovery of the following packets.     
				The "First Source Symbol" is included in this bit vector.
A bit equal to 1 at the i-th position means that this window update packet removes the source symbol of the ID equal to "First Source Symbol ID" + i from the encoding window.</dd>
</dl>
      </section>
    </section>
      <section anchor="research" numbered="true" toc="default">
      <name>Research Issues</name>
      <t>The present document describes the baseline protocol, allowing communications between a Tetrys encoder and Tetrys decoder.  In practice, Tetrys can be used either as a standalone protocol or embedded inside an existing protocol, and either above, within, or below the transport layer.  There are different research questions related to each of these scenarios that should be investigated for future protocol improvements. We summarize them in the following subsections.</t>
      <section anchor="transport-issue" numbered="true" toc="default">
        <name>Interaction with Congestion Control</name>
        <t>
The Tetrys and congestion control components generate two separate channels (see <xref target="RFC9265" sectionFormat="comma" section="2.1"/>):
</t>
        <ul spacing="normal">
          <li>The Tetrys channel carries source and coded packets (from the sender to the receiver) and information from the receiver to the sender (e.g., signaling which symbols have been recovered, loss rate before and/or after decoding, etc.).</li>
          <li>The congestion control channel carries packets from a sender to a receiver and packets signaling information about the network (e.g., number of packets received versus lost, Explicit Congestion Notification (ECN) marks, etc.) from the receiver to the sender. </li>
        </ul>
        <t>
The following topics, which are identified and discussed by <xref target="RFC9265" format="default"/>, are adapted to the particular deployment cases of Tetrys (i.e., above, within, or below the transport layer):
</t>
        <ul spacing="normal">
          <li>Congestion-related losses may be hidden if Tetrys is deployed below the transport layer without any precaution (i.e., Tetrys recovering packets lost because of a congested router), which can severely impact the congestion control efficiency. An approach is suggested to avoid hiding such signals in <xref target="RFC9265" sectionFormat="comma" section="5"/>.</li>
          <li>Tetrys and non-Tetrys flows sharing the same network links can raise fairness issues between these flows. In particular, the situation depends on whether some of these flows and not others are congestion controlled and which type of congestion control is used. The details are out of scope of this document, but may have major impacts in practice.</li>
          <li>Coding rate adaptation within Tetrys can have major impacts on congestion control if done inappropriately. This topic is discussed more in detail in <xref target="adaptive" format="default"/>.</li>
          <li>Tetrys can leverage multipath transmissions, with the Tetrys packets being sent to the same receiver through multiple paths. Since paths can largely differ, a per-path flow control and congestion control adaptation could be needed.</li>
          <li>Protecting several application flows within a single Tetrys flow raises additional questions. This topic is discussed more in detail in <xref target="tunnel" format="default"/>.</li>
        </ul>
         </section>
      <section anchor="adaptive" numbered="true" toc="default">
        <name>Adaptive Coding Rate</name>
        <t>
When the network conditions (e.g., delay and loss rate) strongly vary over time, an adaptive coding rate can be used to increase or reduce the amount of coded packets among a transmission dynamically (i.e., the added redundancy) with the help of a dedicated algorithm similar to <xref target="A-FEC" format="default"/>. Once again, the strategy differs depending on which layer Tetrys is deployed (i.e., above, within, or below the transport layer). Basically, we can split these strategies into two distinct classes: Tetrys deployment inside the transport layer versus outside the transport layer (i.e., above or below). A deployment within the transport layer means 
that interactions between transport protocol mechanisms such as error recovery, congestion control, and/or flow control are envisioned. Otherwise, deploying Tetrys within a transport protocol that is not congestion controlled, like UDP, would not bring out any other advantage than deploying it below or above the transport layer.
        </t>
        <t>The impact deploying a FEC mechanism within the transport layer is further discussed in <xref target="RFC9265" sectionFormat="of" section="4"/>, where considerations concerning the interactions between congestion control and coding rates, or the impact of fairness, are investigated. This adaptation may be done jointly with the congestion control mechanism of a transport layer protocol as proposed by <xref target="CTCP" format="default"/>. This allows the use of monitored congestion control metrics (e.g., RTT, congestion events, or current congestion window size) to adapt the coding rate conjointly with the computed transport sending rate. The rationale is to compute an amount of repair traffic that does not lead to congestion.  This joint optimization is mandatory to prevent flows from consuming the whole available capacity as discussed in <xref target="I-D.singh-rmcat-adaptive-fec" format="default"/>, where the authors point out that an increase in the repair ratio should be done conjointly with a decrease in the source sending rate.
        </t>
        <t>
	    Finally, adapting a coding rate can also be done outside the transport layer without considering transport-layer metrics. In particular, this adaptation may be done jointly with the network as proposed in <xref target="RED-FEC" format="default"/>. In this paper, the authors propose a Random Early Detection FEC mechanism in the context of video transmission over wireless networks. Briefly, the idea is to add more redundancy packets if the queue at the access point is less occupied and vice versa. A first theoretical attempt for video delivery with Tetrys has been proposed <xref target="THAI" format="default"/>. This approach is interesting as it illustrates a joint collaboration between the application requirements and the network conditions and combines both signals coming from the application needs and the network state (i.e., signals below or above the transport layer).
        </t>
        <t>
	    To conclude, there are multiple ways to enable an adaptive coding rate. However, all of them depend on:
        </t>
        <ul spacing="normal">
          <li>the signal metrics that can be monitored and used to adapt the coding rate;</li>
          <li>the transport layer used, whether it is congestion controlled or not; and</li>
          <li>the objective sought (e.g., to minimize congestion or to fit application requirements).</li>
        </ul>
      </section>
      <section anchor="tunnel" numbered="true" toc="default">
        <name>Using Tetrys below the IP Layer for Tunneling</name>
        <t>
        The use of Tetrys to protect an aggregate of flows raises research questions when Tetrys is used to recover from IP datagram losses while tunneling.  Applying redundancy without flow differentiation may contradict the service requirements of individual flows: some flows may be penalized more by high latency and jitter than by partial reliability, while other flows may be penalized more by partial reliability.  In practice, head-of-line blocking impacts all flows in a similar manner despite their different needs, which indicates that more elaborate strategies inside Tetrys are needed.
        </t>
      </section>
    </section>
      <section anchor="security" numbered="true" toc="default">
      <name>Security Considerations</name>
        <t>
        First of all, it must be clear that the use of FEC protection on a data stream does not provide any kind of security per se. On the contrary, the use of FEC protection on a data stream raises security risks. 
        The situation with Tetrys is mostly similar to that of other content delivery protocols making use of FEC protection; this is well described in FECFRAME <xref target="RFC6363" format="default"/>.
        This section builds on this reference, adding new considerations to comply with Tetrys specificities when meaningful.
      </t>
      <section anchor="security-problem-statement" numbered="true" toc="default">
        <name>Problem Statement</name>
        <t>
          An attacker can either target the content, protocol, or network.
          The consequences will largely differ reflecting various types of goals, like gaining access to confidential content, corrupting the content, compromising the Tetrys encoder and/or Tetrys decoder, or compromising the network behavior.
          In particular, several of these attacks aim at creating a Denial-of-Service (DoS) with consequences that may be limited to a single node (e.g., the Tetrys decoder), or that may impact all the nodes attached to the targeted network (e.g., by making flows unresponsive to congestion signals).
        </t>
        <t>
          In the following sections, we discuss these attacks, according to the component targeted by the attacker.
        </t>
      </section>
      <section anchor="security-attack-against-data-flow" numbered="true" toc="default">
        <name>Attacks against the Data Flow</name>
        <t>
          An attacker may want to access confidential content by eavesdropping the traffic between the Tetrys encoder/decoder.
          Traffic encryption is the usual approach to mitigate this risk, and this encryption can be applied to the source flow upstream of the Tetrys encoder or to the output packets downstream of the Tetrys encoder.
          The choice on where to apply encryption depends on various criteria,
          in particular the attacker model (e.g., when encryption happens
          below Tetrys, the security risk is assumed to be on the
          interconnection network).
        </t>
        <t>
          An attacker may also want to corrupt the content (e.g., by injecting forged or modified source and coded packets to prevent the Tetrys decoder from recovering the original source flow).
          Content integrity and source authentication services at the packet level are then needed to mitigate this risk.
          Here, these services need to be provided below Tetrys in order to enable the receiver to drop undesired packets and only transfer legitimate packets to the Tetrys decoder.
          It should be noted that forging or modifying feedback packets will not corrupt the content, although it will certainly compromise Tetrys operation (see <xref target="security-attack-against-signaling"/>).
        </t>
      </section>
      <section anchor="security-attack-against-signaling" numbered="true" toc="default">
        <name>Attacks against Signaling</name>
        <t>
          Attacks on signaling information (e.g., by forging or modifying feedback packets to falsify the good reception or recovery of source content) can easily prevent the Tetrys decoder from recovering the source flow, thereby creating a DoS.
          In order to prevent this type of attack, content integrity and source authentication services at the packet level are needed for the feedback flow from the Tetrys decoder to the Tetrys encoder as well.
          These services need to be provided below Tetrys in order to drop undesired packets and only transfer legitimate feedback packets to the Tetrys encoder.
        </t>
        <t>
          Conversely, an attacker in position to selectively drop feedback packets (instead of modifying them) will not severely impact the function of Tetrys since it is naturally robust when challenged with such losses.
          However, it will have side impacts, such as the use of bigger linear systems (since the Tetrys encoder cannot remove well-received or decoded source packets from its linear system), which mechanically increases computational costs on both sides (encoder and decoder).
        </t>
      </section>
      <section anchor="security-attack-against-network" numbered="true" toc="default">
        <name>Attacks against the Network</name>
        <t>
          Tetrys can react to congestion signals (<xref target="transport-issue" format="default"/>) in order to provide a certain level of fairness with other flows on a shared network.
          This ability could be exploited by an attacker to create or reinforce congestion events (e.g., by forging or modifying feedback packets) that can potentially impact a significant number of nodes attached to the network.
          In order to mitigate the risk, content integrity and source authentication services at the packet level are needed to enable the receiver to drop undesired packets and only transfer legitimate packets to the Tetrys encoder and decoder.
        </t>
      </section>
      <section anchor="security-baseline-security" numbered="true" toc="default">
        <name>Baseline Security Operation</name>
        <t>
          Tetrys can benefit from an IPsec / Encapsulating Security Payload (IPsec/ESP) <xref target="RFC4303" format="default"/> that provides confidentiality, origin authentication, integrity, and anti-replay services in particular.
  	IPsec/ESP can be used to protect the Tetrys data flows (both directions) against attackers located within the interconnection network or attackers in position to eavesdrop traffic, inject forged traffic, or replay legitimate traffic.
        </t>
      </section>
    </section>
      <section anchor="iana" numbered="true" toc="default">
      <name>IANA Considerations</name>
<t>This document has no IANA actions.</t>
    </section>
  </middle>
  <back>

<displayreference target="I-D.singh-rmcat-adaptive-fec" to="RMCAT-ADAPTIVE-FEC"/>

    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.5052.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.5445.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4303.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.5510.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.5651.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.5740.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6363.xml"/>
         <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8406.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8680.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9265.xml"/>
      </references>
      <references>
        <name>Informative References</name>

	 <xi:include href="https://datatracker.ietf.org/doc/bibxml3/reference.I-D.singh-rmcat-adaptive-fec.xml"/>

        <reference anchor="AHL-00" target="https://doi.org/10.1109/18.850663">
          <front>
            <title>Network information flow</title>
            <author initials="R." surname="Ahlswede">
              <organization/>
            </author>
            <author initials="N." surname="Cai">
              <organization/>
            </author>
            <author initials="S." surname="Li">
              <organization/>
            </author>
            <author initials="R." surname="Yeung">
              <organization/>
            </author>
            <date month="July" year="2000"/>
          </front>
          <seriesInfo name="DOI" value="10.1109/18.850663"/>
	  <refcontent>IEEE Transactions on Information Theory, Vol. 46, Issue 4, pp. 1204-1216</refcontent>
        </reference>

        <reference anchor="Tetrys" target="https://doi.org/10.1109/IWSSC.2008.4656755">
          <front>
            <title>Rethinking reliability for long-delay networks</title>
            <author initials="J." surname="Lacan">
              <organization/>
            </author>
            <author initials="E." surname="Lochin">
              <organization/>
            </author>
            <date month="October" year="2008"/>
          </front>
	  <seriesInfo name="DOI" value="10.1109/IWSSC.2008.4656755"/>
          <refcontent>International Workshop on Satellite and Space Communications, Toulouse, France, pp. 90-94</refcontent>
        </reference>

        <reference anchor="Tetrys-RT" target="http://dx.doi.org/10.1109/TMM.2011.2126564">
          <front>
            <title>On-the-Fly Erasure Coding for Real-Time Video Applications</title>
            <author initials="P." surname="Tournoux">
              <organization/>
            </author>
            <author initials="E." surname="Lochin">
              <organization/>
            </author>
            <author initials="J." surname="Lacan">
              <organization/>
            </author>
            <author initials="A." surname="Bouabdallah">
              <organization/>
            </author>
            <author initials="V." surname="Roca">
              <organization/>
            </author>
            <date month="August" year="2011"/>
          </front>
	  <seriesInfo name="DOI" value="10.1109/TMM.2011.2126564"/>
          <refcontent>IEEE Transactions on Multimedia, Vol. 13, Issue 4, pp. 797-812</refcontent>
        </reference>

        <reference anchor="CTCP" target="https://arxiv.org/abs/1212.2291">
          <front>
            <title>Network Coded TCP (CTCP)</title>
            <author initials="M." surname="Kim">
            </author>
            <author initials="J." surname="Cloud">
	    </author> 
            <author initials="A." surname="ParandehGheibi">
	    </author>
            <author initials="L." surname="Urbina">
	    </author>
            <author initials="K." surname="Fouli">
	    </author>
            <author initials="D." surname="Leith">
	    </author>	    
            <author initials="M." surname="Medard">
	    </author>
            <date month="April" year="2013"/>
          </front>
          <seriesInfo name="arXiv" value="1212.2291v3"/>
        </reference>

        <reference anchor="A-FEC" target="https://doi.org/10.1109/INFCOM.1999.752166">
          <front>
            <title>Adaptive FEC-based error control for Internet telephony</title>
            <author initials="J." surname="Bolot">
              <organization/>
            </author>
            <author initials="S." surname="Fosse-Parisis">
              <organization/>
            </author>
            <author initials="D." surname="Towsley">
              <organization/>
            </author>
            <date month="March" year="1999"/>
          </front>
          <refcontent>IEEE INFOCOM '99, Conference on Computer Communications, New York, NY, USA, Vol. 3, pp. 1453-1460</refcontent>
	  <seriesInfo name="DOI" value="10.1109/INFCOM.1999.752166"/>
        </reference>

        <reference anchor="RED-FEC" target="https://doi.org/10.1109/TBC.2008.2001713">
          <front>
            <title>A RED-FEC Mechanism for Video Transmission Over WLANs</title>
            <author initials="C." surname="Lin">
              <organization/>
            </author>
            <author initials="C." surname="Shieh">
              <organization/>
            </author>
            <author initials="N." surname="Chilamkurti">
              <organization/>
            </author>
            <author initials="C." surname="Ke">
              <organization/>
            </author>
            <author initials="W." surname="Hwang">
              <organization/>
            </author>
            <date month="September" year="2008"/>
          </front>
          <refcontent>IEEE Transactions on Broadcasting, Vol. 54, Issue 3, pp. 517-524</refcontent> 
	  <seriesInfo name="DOI" value="10.1109/TBC.2008.2001713"/>
        </reference>

        <reference anchor="THAI" target="https://doi.org/10.1016/j.image.2014.02.003">
          <front>
            <title>Joint on-the-fly network coding/video quality adaptation for real-time delivery</title>
            <author initials="T." surname="Tran Thai">
              <organization/>
            </author>
            <author initials="J." surname="Lacan">
              <organization/>
            </author>
            <author initials="E." surname="Lochin">
              <organization/>
            </author>
            <date month="April" year="2014"/>
          </front>
          <refcontent>Signal Processing: Image Communication, Vol. 29 Issue 4, pp. 449-461</refcontent>
<seriesInfo name="DOI" value="10.1016/j.image.2014.02.003"/>
        </reference>
      </references>
    </references>
    <section anchor="ack" numbered="false" toc="default">
      <name>Acknowledgments</name>
         <t>First, the authors want sincerely to thank <contact fullname="Marie-Jose         
Montpetit"/> for continuous help and support on Tetrys. Marie-Jo, many thanks!</t>
      <t>The authors also wish to thank NWCRG group members for numerous discussions on      
on-the-fly coding that helped finalize this document.</t>
      <t>Finally, the authors would like to thank <contact fullname="Colin Perkins"/> for    
providing comments and feedback on the document.</t>
    </section>
  </back>
</rfc>
