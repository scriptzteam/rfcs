<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" category="std" obsoletes="793, 879, 2873, 6093, 6429, 6528, 6691" updates="1011, 1122, 5961" ipr="pre5378Trust200902" number="9293" docName="draft-ietf-tcpm-rfc793bis-28" submissionType="IETF" consensus="true" xml:lang="en" tocInclude="true" tocDepth="3" symRefs="false" sortRefs="true" version="3">
<front>
    <title abbrev="TCP">Transmission Control Protocol (TCP)</title>
    <seriesInfo name="STD" value="7" />
    <seriesInfo name="RFC" value="9293" />
    <author fullname="Wesley M. Eddy" initials="W." surname="Eddy" role="editor">
        <organization abbrev="MTI Systems">MTI Systems</organization>
      <address>
        <postal>
                <country>United States of America</country>
        </postal>
        <email>wes@mti-systems.com</email>
        </address>
    </author>

    <date year="2022" month="August"/>
    <area>Transport</area>
    <workgroup>TCPM</workgroup>
    <keyword>TCP</keyword> 
    <keyword>TCPM</keyword> 
    <keyword>transport layer</keyword> 
    <keyword>internet transport</keyword> 
    <abstract>
      <t>This document specifies the Transmission Control Protocol (TCP).  TCP is an important transport-layer protocol in the Internet protocol stack, and it has continuously evolved over decades of use and growth of the Internet.  Over this time, a number of changes have been made to TCP as it was specified in RFC 793, though these have only been documented in a piecemeal fashion.  This document collects and brings those changes together with the protocol specification from RFC 793.  This document obsoletes RFC 793, as well as RFCs 879, 2873, 6093, 6429, 6528, and 6691 that updated parts of RFC 793.  It updates RFCs 1011 and 1122, and it should be considered as a replacement for the portions of those documents dealing with TCP requirements.  It also updates RFC 5961 by adding a small clarification in reset handling while in the SYN-RECEIVED state.  The TCP header control bits from RFC 793 have also been updated based on RFC 3168.</t>
    </abstract>
  </front>
  <middle>
    <section numbered="true" toc="default">
      <name>Purpose and Scope</name>
      <t>
        In 1981, <xref target="RFC0793" format="default">RFC 793</xref> was released, documenting the Transmission Control Protocol (TCP) and replacing earlier published specifications for TCP.
      </t>
      <t>
        Since then, TCP has been widely implemented, and it has been used as a transport protocol for numerous applications on the Internet.
      </t>
      <t>
        For several decades, RFC 793 plus a number of other documents have combined to serve as the core specification for TCP <xref target="RFC7414" format="default"/>.  Over time, a number of errata have been filed against RFC 793.  There have also been deficiencies found and resolved in security, performance, and many other aspects.  The number of enhancements has grown over time across many separate documents.  These were never accumulated together into a comprehensive update to the base specification.
      </t>
      <t>
        The purpose of this document is to bring together all of the IETF Standards Track changes and other clarifications that have been made to the base TCP functional specification (RFC 793) and to unify them into an updated version of the specification.
      </t>
      <t>
	Some companion documents are referenced for important algorithms that are used by TCP (e.g., for congestion control) but have not been completely included in this document.  This is a conscious choice, as this base specification can be used with multiple additional algorithms that are developed and incorporated separately. This document focuses on the common basis that all TCP implementations must support in order to interoperate.  Since some additional TCP features have become quite complicated themselves (e.g., advanced loss recovery and congestion control), future companion documents may attempt to similarly bring these together.
      </t>
      <t>
        In addition to the protocol specification that describes the TCP segment format, generation, and processing rules that are to be implemented in code, RFC 793 and other updates also contain informative and descriptive text for readers to understand aspects of the protocol design and operation.  This document does not attempt to alter or update this informative text and is focused only on updating the normative protocol specification.  This document preserves references to the documentation containing the important explanations and rationale, where appropriate.
      </t>
      <t>
        This document is intended to be useful both in checking existing TCP implementations for conformance purposes, as well as in writing new implementations.
      </t>
    </section>
    <section numbered="true" toc="default">
      <name>Introduction</name>
      <t>RFC 793 contains a discussion of the TCP design goals and provides examples of its operation, including examples of connection establishment, connection termination, and packet retransmission to repair losses.
      </t>
      <t>
        This document describes the basic functionality expected in modern TCP implementations and replaces the protocol specification in RFC 793.  It does not replicate or attempt to update the introduction and philosophy content in Sections 1 and 2 of RFC 793.  Other documents are referenced to provide explanations of the theory of operation, rationale, and detailed discussion of design decisions.  This document only focuses on the normative behavior of the protocol.
      </t>
      <t>
	The "TCP Roadmap" <xref target="RFC7414" format="default"/> provides a more extensive guide to the RFCs that define TCP and describe various important algorithms. The TCP Roadmap contains sections on strongly encouraged enhancements that improve performance and other aspects of TCP beyond the basic operation specified in this document.  As one example, implementing congestion control (e.g., <xref target="RFC5681" format="default"/>) is a TCP requirement, but it is a complex topic on its own and not described in detail in this document, as there are many options and possibilities that do not impact basic interoperability.  Similarly, most TCP implementations today include the high-performance extensions in <xref target="RFC7323" format="default"/>, but these are not strictly required or discussed in this document.  Multipath considerations for TCP are also specified separately in <xref target="RFC8684" format="default"/>.
      </t>
      <t>
        A list of changes from RFC 793 is contained in <xref target="changes" format="default"/>.
      </t>
      <section numbered="true" toc="default">
        <name>Requirements Language</name>
        <t>

The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", 
"<bcp14>SHALL</bcp14>", "<bcp14>SHALL NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD 
NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
"<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be
interpreted as described in BCP&nbsp;14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they appear in all capitals, as shown 
here.

</t>
        <t>

Each use of RFC 2119 keywords in the document is individually labeled and
referenced in <xref target="reqs" format="default"/>, which summarizes implementation
requirements.

</t>
        <t>

Sentences using "<bcp14>MUST</bcp14>" are labeled as "MUST-X" with X being
a numeric identifier enabling the requirement to be located easily when
referenced from <xref target="reqs" format="default"/>.

</t>
        <t>

Similarly, sentences using "<bcp14>SHOULD</bcp14>" are labeled with
"SHLD-X", "<bcp14>MAY</bcp14>" with "MAY-X", and
"<bcp14>RECOMMENDED</bcp14>" with "REC-X".

</t>
        <t>

For the purposes of this labeling, "<bcp14>SHOULD NOT</bcp14>" and "<bcp14>MUST
NOT</bcp14>" are labeled the same as "<bcp14>SHOULD</bcp14>" and "<bcp14>MUST</bcp14>"
instances.

</t>
      </section>
      <section numbered="true" toc="default">
        <name>Key TCP Concepts</name>
        <t>TCP provides a reliable, in-order, byte-stream service to applications.</t>
        <t>The application byte-stream is conveyed over the network via TCP segments,
with each TCP segment sent as an Internet Protocol (IP) datagram.</t>
        <t>TCP reliability consists of detecting packet losses (via sequence numbers)
and errors (via per-segment checksums), as well as correction
via retransmission.</t>
        <t>TCP supports unicast delivery of data.  There are anycast applications that
can successfully use TCP without modifications, though there is some risk of
instability due to changes of lower-layer forwarding behavior <xref target="RFC7094" format="default"/>.</t>
        <t>TCP is connection oriented, though it does not inherently include a liveness
detection capability.</t>
        <t>Data flow is supported bidirectionally over TCP connections, though
applications are free to send data only unidirectionally, if they so
choose.</t>
        <t>TCP uses port numbers to identify application services and to multiplex
distinct flows between hosts.</t>
        <t>A more detailed description of TCP features compared to other transport
protocols can be found in <xref target="RFC8095" section="3.1" sectionFormat="of" format="default"/>.  Further
description of the motivations for developing TCP and its role in the Internet
protocol stack can be found in <xref target="RFC0793" section="2" sectionFormat="of" format="default"/> and earlier versions
of the TCP specification.</t>
      </section>
    </section>
    <section numbered="true" toc="default">
      <name>Functional Specification</name>
      <section numbered="true" toc="default">
        <name>Header Format</name>
        <t>
  TCP segments are sent as internet datagrams.  The Internet Protocol (IP)
  header carries several information fields, including the source and
  destination host addresses <xref target="RFC0791" format="default"/> <xref target="RFC8200" format="default"/>.  A TCP header follows the IP
  headers, supplying information specific to TCP.  This
  division allows for the existence of host-level protocols other than
  TCP.  In the early development of the Internet suite of protocols, the IP header fields had been a part of TCP.
</t>
        <t>
  This document describes TCP, which uses TCP headers.
</t>
        <t>A TCP header, followed by any user data in the segment, is formatted as follows, using the style from <xref target="I-D.mcquistin-augmented-ascii-diagrams" format="default"/>:</t>
        <figure anchor="header_format">
          <name>TCP Header Format</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
    0                   1                   2                   3   
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Source Port          |       Destination Port        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Sequence Number                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Acknowledgment Number                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Data |       |C|E|U|A|P|R|S|F|                               |
   | Offset| Rsrvd |W|C|R|C|S|S|Y|I|            Window             |
   |       |       |R|E|G|K|H|T|N|N|                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           Checksum            |         Urgent Pointer        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           [Options]                           | 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               :
   :                             Data                              :
   :                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

          Note that one tick mark represents one bit position.
]]></artwork>
        </figure>
        <t>
where:
</t>
        <dl newline="false" spacing="normal" indent="2">
          <dt>Source Port:</dt> 
          <dd>
            <t>
    16 bits
            </t>
            <t>
    The source port number.
            </t>
          </dd>
          <dt>Destination Port:</dt>
          <dd>
            <t>
    16 bits
            </t>
            <t>
    The destination port number.
            </t>
          </dd>
          <dt>Sequence Number:</dt>
          <dd>
            <t>
    32 bits
            </t>
            <t>
    The sequence number of the first data octet in this segment (except
    when the SYN flag is set). If SYN is set, the sequence number is the
    initial sequence number (ISN) and the first data octet is ISN+1.
            </t>
          </dd>
          <dt>Acknowledgment Number:</dt>
          <dd>
            <t>
    32 bits
            </t>
            <t>
    If the ACK control bit is set, this field contains the value of the
    next sequence number the sender of the segment is expecting to
    receive.  Once a connection is established, this is always sent.
            </t>
          </dd>
          <dt>Data Offset (DOffset):</dt>
          <dd>
            <t>
    4 bits
            </t>
            <t>
    The number of 32-bit words in the TCP header.  This indicates where
    the data begins.  The TCP header (even one including options) is an
    integer multiple of 32 bits long.
            </t>
          </dd>
          <dt>Reserved (Rsrvd):</dt>
          <dd>
            <t>
    4 bits
            </t>
            <t>
    A set of control bits reserved for future use.  Must be zero in generated segments and must be ignored in received segments if the corresponding future features are not implemented by the sending or receiving host.
            </t>
          </dd>
          <dt>Control bits:</dt>
          <dd>
            <t>
   The control bits are also known as "flags".  Assignment is managed by IANA from the "TCP Header Flags" registry <xref target="TCP-parameters-registry" format="default"/>.  The currently assigned control bits are CWR, ECE, URG, ACK, PSH, RST, SYN, and FIN.
            </t>
            <dl newline="false" spacing="normal" indent="4">
              <dt>CWR:</dt>
              <dd>
                <t>
    1 bit
                </t>
                <t>
    Congestion Window Reduced (see <xref target="RFC3168" format="default"/>).
                </t>
              </dd>
              <dt>ECE:</dt>
              <dd>
                <t>
    1 bit
                </t>
                <t>
    ECN-Echo (see <xref target="RFC3168" format="default"/>).
                </t>
              </dd>
              <dt>URG:</dt>
              <dd>
                <t>
    1 bit
                </t>
                <t>
    Urgent pointer field is significant.
                </t>
              </dd>
              <dt>ACK:</dt>
              <dd>
                <t>
    1 bit
                </t>
                <t>
    Acknowledgment field is significant.
                </t>
              </dd>
              <dt>PSH:</dt>
              <dd>
                <t>
    1 bit
                </t>
                <t>
    Push function (see the Send Call description in <xref target="user-api" format="default"/>).
                </t>
              </dd>
              <dt>RST:</dt>
              <dd>
                <t>
    1 bit
                </t>
                <t>
    Reset the connection.
                </t>
              </dd>
              <dt>SYN:</dt>
              <dd>
                <t>
    1 bit
                </t>
                <t>
    Synchronize sequence numbers.
                </t>
              </dd>
              <dt>FIN:</dt>
              <dd>
                <t>
    1 bit
                </t>
                <t>
    No more data from sender.
                </t>
              </dd>
            </dl>
          </dd>
          <dt>Window:</dt>
          <dd>
            <t>
    16 bits
            </t>
            <t>
    The number of data octets beginning with the one indicated in the
    acknowledgment field that the sender of this segment is willing to
    accept.  The value is shifted when the window scaling extension is used
    <xref target="RFC7323" format="default"/>.
            </t>
            <t>
    The window size <bcp14>MUST</bcp14> be treated as an unsigned number, or else
    large window sizes will appear like negative windows and TCP will
    not work (MUST-1).  It is <bcp14>RECOMMENDED</bcp14> that implementations will reserve
    32-bit fields for the send and receive window sizes in the connection
    record and do all window computations with 32 bits (REC-1).
            </t>
          </dd>
          <dt>Checksum:</dt>
          <dd>
            <t>
    16 bits
            </t>
            <t>
    The checksum field is the 16-bit ones' complement of the ones'
    complement sum of all 16-bit words in the header and text.  The checksum computation needs to ensure the 16-bit alignment of the data being summed.  If a
    segment contains an odd number of header and text octets, alignment can be achieved by
    padding the last octet with zeros on its right to
    form a 16-bit word for checksum purposes.  The pad is not
    transmitted as part of the segment.  While computing the checksum,
    the checksum field itself is replaced with zeros.
            </t>
            <t>
    The checksum also covers a pseudo-header (<xref target="v4pseudo" format="default"/>) conceptually prefixed to the TCP
    header.  The pseudo-header is 96 bits for IPv4 and 320 bits for IPv6.
    Including the pseudo-header in the checksum gives the TCP connection
    protection against misrouted segments.  This information is carried in IP headers
    and is transferred across the TCP/network interface in the arguments or
    results of calls by the TCP implementation on the IP layer.
            </t>
            <figure anchor="v4pseudo">
              <name>IPv4 Pseudo-header</name>
              <artwork name="" type="" align="left" alt=""><![CDATA[
                +--------+--------+--------+--------+
                |           Source Address          |
                +--------+--------+--------+--------+
                |         Destination Address       |
                +--------+--------+--------+--------+
                |  zero  |  PTCL  |    TCP Length   |
                +--------+--------+--------+--------+
]]></artwork>
            </figure>
            <dl newline="true" spacing="normal" indent="2">
              <dt>Pseudo-header components for IPv4:</dt>
              <dd>
                <dl newline="false" spacing="normal">
                  <dt>Source Address:</dt>
                  <dd>the IPv4 source address in network byte order</dd>
                  <dt>Destination Address:</dt>
                  <dd>the IPv4 destination address in network byte order</dd>
                  <dt>zero:</dt>
                  <dd>bits set to zero</dd>
                  <dt>PTCL:</dt>
                  <dd>the protocol number from the IP header</dd>
                  <dt>TCP Length:</dt>
                  <dd>
       the TCP header length plus the data length in
       octets (this is not an explicitly transmitted quantity but is
       computed), and it does not count the 12 octets of the pseudo-header.</dd>
                </dl>
              </dd>
            </dl>
            <t>
       For IPv6, the pseudo-header is defined in Section <xref target="RFC8200" section="8.1" sectionFormat="bare" format="default"/> of RFC 8200 <xref target="RFC8200" format="default"/> and contains the IPv6 Source Address and Destination Address, an Upper-Layer Packet Length (a 32-bit value otherwise equivalent to TCP Length in the IPv4 pseudo-header), three bytes of zero padding, and a Next Header value, which differs from the IPv6 header value if there are extension headers present between IPv6 and TCP.
   </t>
            <t>
       The TCP checksum is never optional.  The sender <bcp14>MUST</bcp14> generate it (MUST-2)
       and the receiver <bcp14>MUST</bcp14> check it (MUST-3).
   </t>
          </dd>
          <dt>Urgent Pointer:</dt>
          <dd>
            <t>
    16 bits
            </t>
            <t>
    This field communicates the current value of the urgent pointer as a
    positive offset from the sequence number in this segment.  The
    urgent pointer points to the sequence number of the octet following the urgent data.  This field is only to be interpreted in segments with
    the URG control bit set.  

            </t>
          </dd>
          <dt>Options:</dt>
          <dd>
            <t>
    [TCP Option]; size(Options) == (DOffset-5)*32; present only when DOffset &gt; 5.
    Note that this size expression also includes any padding trailing the actual options present.
            </t>
            <t>
    Options may occupy space at the end of the TCP header and are a
    multiple of 8 bits in length.  All options are included in the
    checksum.  An option may begin on any octet boundary.  There are two
    cases for the format of an option:
            </t>
            <dl newline="false" spacing="normal">
              <dt>Case 1:</dt>
              <dd>A single octet of option-kind.</dd>
              <dt>Case 2:</dt>
              <dd>An octet of option-kind (Kind), an octet of option-length, and
               the actual option-data octets.</dd>
            </dl>
          <t>
    The option-length counts the two octets of option-kind and
    option-length as well as the option-data octets.
  </t>
          <t>
    Note that the list of options may be shorter than the Data Offset
    field might imply.  The content of the header beyond the
    End of Option List Option <bcp14>MUST</bcp14> be header padding of zeros (MUST-69).
  </t>
          <t>
    The list of all currently defined options is managed by IANA <xref target="TCP-parameters-registry" format="default"/>, and each option is defined in other RFCs, as indicated there.  That set includes experimental options that can be extended to support multiple concurrent usages <xref target="RFC6994" format="default"/>.</t>
          <t>
   A given TCP implementation can support any currently defined options, but the following options <bcp14>MUST</bcp14> be supported (MUST-4 -- note Maximum Segment Size Option support is also part of MUST-14 in <xref target="mss" format="default"/>):</t>
            <table>
              <name>Mandatory Option Set</name>
              <thead>
	        <tr>
	          <th>Kind</th>
	          <th>Length</th>
	          <th>Meaning</th>
	       </tr>
             </thead>
             <tbody>
	       <tr>
	         <td>0</td>
	         <td>-</td>
	         <td>End of Option List Option.</td>
	       </tr>
	       <tr>
	         <td>1</td>
	         <td>-</td>
	         <td>No-Operation.</td>
	      </tr>
	      <tr>
	        <td>2</td>
                <td>4</td>
	        <td>Maximum Segment Size.</td>
             </tr>
           </tbody>
         </table>
            <t>
    These options are specified in detail in <xref target="Option-Definitions" format="default"/>.</t>
            <t>
    A TCP implementation <bcp14>MUST</bcp14> be able to receive a TCP Option in any segment (MUST-5).</t>
            <t>
    A TCP implementation <bcp14>MUST</bcp14> (MUST-6) ignore without error any TCP Option it does not
    implement, assuming that the option has a length field. All
    TCP Options except End of Option List Option (EOL) and No-Operation (NOP) <bcp14>MUST</bcp14> have length fields, including all future options (MUST-68).
    TCP implementations <bcp14>MUST</bcp14> be prepared to handle an illegal option length
    (e.g., zero); a suggested procedure is to
    reset the connection and log the error cause (MUST-7).
            </t>
          <t>Note: There is ongoing work to extend the space available for TCP Options, such as <xref target="I-D.ietf-tcpm-tcp-edo" format="default"/>.</t>
          </dd>
          <dt>Data:</dt>
          <dd>
            <t>
    variable length
            </t>
            <t>
    User data carried by the TCP segment.
            </t>
          </dd>
        </dl>
      </section>
      <section anchor="Option-Definitions" numbered="true" toc="default">
        <name>Specific Option Definitions</name>
        <t>
        A TCP Option, in the mandatory option set, is one of an End of Option List Option, a No-Operation Option, or a Maximum Segment Size Option.
        </t>
        <t>An End of Option List Option is formatted as follows:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
    0
    0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+
   |       0       |
   +-+-+-+-+-+-+-+-+
]]></artwork>
        <t>
where:
        </t>
        <dl newline="false" spacing="normal" indent="2">
          <dt>Kind:</dt>
          <dd>
            <t>
       1 byte; Kind == 0.
            </t>
            <t>
       This option code indicates the end of the option list.  This
       might not coincide with the end of the TCP header according to
       the Data Offset field.  This is used at the end of all options,
       not the end of each option, and need only be used if the end of
       the options would not otherwise coincide with the end of the TCP
       header.
            </t>
          </dd>
        </dl>
        <t>A No-Operation Option is formatted as follows:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
    0
    0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+
   |       1       |
   +-+-+-+-+-+-+-+-+
]]></artwork>
        <t>where:
        </t>
        <dl newline="false" spacing="normal" indent="2">
          <dt>Kind:</dt>
          <dd>
            <t>
        1 byte; Kind == 1.
            </t>
            <t>
        This option code can be used between options, for example, to
        align the beginning of a subsequent option on a word boundary.
        There is no guarantee that senders will use this option, so
        receivers <bcp14>MUST</bcp14> be prepared to process options even if they do
        not begin on a word boundary (MUST-64).
            </t>
          </dd>
        </dl>
        <t>A Maximum Segment Size Option is formatted as follows:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |       2       |     Length    |   Maximum Segment Size (MSS)  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
        <t>where:
        </t>
        <dl newline="false" spacing="normal" indent="2">
          <dt>Kind:</dt>
          <dd>
            <t>
        1 byte; Kind == 2.
            </t>
            <t>
        If this option is present, then it communicates the maximum
        receive segment size at the TCP endpoint that sends this segment.
        This value is limited by the IP reassembly limit.  This field may be sent in the initial connection request
        (i.e., in segments with the SYN control bit set) and <bcp14>MUST NOT</bcp14>
        be sent in other segments (MUST-65).  If this
        option is not used, any segment size is allowed.
        A more complete description of this option is provided in <xref target="mss" format="default"/>.
            </t>
          </dd>
          <dt>Length:</dt>
          <dd>
            <t>
         1 byte; Length == 4.
            </t>
            <t>
        Length of the option in bytes.
            </t>
          </dd>
          <dt>Maximum Segment Size (MSS):</dt>
          <dd>
            <t>
        2 bytes.
            </t>
            <t>
        The maximum receive segment size at the TCP endpoint that sends this segment.
            </t>
          </dd>
        </dl>
        <section numbered="true" toc="default">
          <name>Other Common Options</name>
          <t>
Additional RFCs define some other commonly used options that are recommended to implement for high performance but are not necessary for basic TCP interoperability.  These are the TCP Selective Acknowledgment (SACK) Option <xref target="RFC2018" format="default"/> <xref target="RFC2883" format="default"/>, TCP Timestamp (TS) Option <xref target="RFC7323" format="default"/>, and TCP Window Scale (WS) Option <xref target="RFC7323" format="default"/>.
          </t>
        </section>
        <section numbered="true" toc="default">
          <name>Experimental TCP Options</name>
          <t>
Experimental TCP Option values are defined in <xref target="RFC4727" format="default"/>, and <xref target="RFC6994" format="default"/> describes the current recommended usage for these experimental values.
          </t>
        </section>
      </section>
      <section numbered="true" toc="default">
        <name>TCP Terminology Overview</name>
        <t>
This section includes an overview of key terms needed to understand the detailed protocol operation in the rest of the document.  There is a glossary of terms in <xref target="glossary" format="default"/>.
</t>
        <section numbered="true" toc="default">
          <name>Key Connection State Variables</name>
          <t>
  Before we can discuss the operation of the TCP implementation in detail, we need
  to introduce some detailed terminology.  The maintenance of a TCP
  connection requires maintaining state for several variables.  We conceive
  of these variables being stored in a connection record called a
  Transmission Control Block or TCB.  Among the variables stored in the
  TCB are the local and remote IP addresses and port numbers, the IP security level, and compartment 
  of the connection (see <xref target="seccomp" format="default"/>), pointers to the user's send and receive
  buffers, pointers to the retransmit queue and to the current segment.
  In addition, several variables relating to the send and receive
  sequence numbers are stored in the TCB.
</t>
          <table>
	    <name>Send Sequence Variables</name>
            <thead>
              <tr>
                <th>Variable</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>SND.UNA</td>
                <td>send unacknowledged</td>
              </tr>
              <tr>
                <td>SND.NXT</td>
                <td>send next</td>
              </tr>
              <tr>
                <td>SND.WND</td>
                <td>send window</td>
              </tr>
              <tr>
                <td>SND.UP</td>
                <td>send urgent pointer</td>
              </tr>
              <tr>
                <td>SND.WL1</td>
                <td>segment sequence number used for last window update</td>
              </tr>
              <tr>
                <td>SND.WL2</td>
                <td>segment acknowledgment number used for last window update</td>
              </tr>
              <tr>
                <td>ISS</td>
                <td>initial send sequence number</td>
              </tr>
            </tbody>
          </table>
          <table>
            <name>Receive Sequence Variables</name>
            <thead>
              <tr>
                <th>Variable</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>RCV.NXT</td>
                <td>receive next</td>
              </tr>
              <tr>
                <td>RCV.WND</td>
                <td>receive window</td>
              </tr>
              <tr>
                <td>RCV.UP</td>
                <td>receive urgent pointer</td>
              </tr>
              <tr>
                <td>IRS</td>
                <td>initial receive sequence number</td>
              </tr>
            </tbody>
          </table>
          <t>
  The following diagrams may help to relate some of these variables to
  the sequence space.
</t>
          <figure anchor="send_seq_space">
            <name>Send Sequence Space</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[
                   1         2          3          4      
              ----------|----------|----------|---------- 
                     SND.UNA    SND.NXT    SND.UNA        
                                          +SND.WND        

        1 - old sequence numbers that have been acknowledged  
        2 - sequence numbers of unacknowledged data            
        3 - sequence numbers allowed for new data transmission 
        4 - future sequence numbers that are not yet allowed  
 ]]></artwork>
          </figure>
          <t>
  The send window is the portion of the sequence space labeled 3 in
  <xref target="send_seq_space" format="default"/>.
</t>
          <figure anchor="recv_seq_space">
            <name>Receive Sequence Space</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[
                       1          2          3      
                   ----------|----------|---------- 
                          RCV.NXT    RCV.NXT        
                                    +RCV.WND        

        1 - old sequence numbers that have been acknowledged  
        2 - sequence numbers allowed for new reception         
        3 - future sequence numbers that are not yet allowed  
]]></artwork>
          </figure>
          <t>
  The receive window is the portion of the sequence space labeled 2 in
  <xref target="recv_seq_space" format="default"/>.
</t>
          <t>
  There are also some variables used frequently in the discussion that
  take their values from the fields of the current segment.
</t>
          <table>
            <name>Current Segment Variables</name>
            <thead>
              <tr>
                <th>Variable</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>SEG.SEQ</td>
                <td>segment sequence number</td>
              </tr>
              <tr>
                <td>SEG.ACK</td>
                <td>segment acknowledgment number</td>
              </tr>
              <tr>
                <td>SEG.LEN</td>
                <td>segment length</td>
              </tr>
              <tr>
                <td>SEG.WND</td>
                <td>segment window</td>
              </tr>
              <tr>
                <td>SEG.UP</td>
                <td>segment urgent pointer</td>
              </tr>
            </tbody>
          </table>
        </section>
        <section numbered="true" toc="default">
          <name>State Machine Overview</name>
          <t>
  A connection progresses through a series of states during its
  lifetime.  The states are:  LISTEN, SYN-SENT, SYN-RECEIVED,
  ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK,
  TIME-WAIT, and the fictional state CLOSED.  CLOSED is fictional
  because it represents the state when there is no TCB, and therefore,
  no connection.  Briefly the meanings of the states are:
</t>
          <dl>
            <dt>LISTEN -</dt><dd>represents waiting for a connection request from any remote
    TCP peer and port.</dd>
            <dt>SYN-SENT -</dt><dd>represents waiting for a matching connection request
    after having sent a connection request.</dd>
            <dt>SYN-RECEIVED -</dt><dd>represents waiting for a confirming connection
    request acknowledgment after having both received and sent a
    connection request.</dd>
            <dt>ESTABLISHED -</dt><dd>represents an open connection, data received can be
    delivered to the user.  The normal state for the data transfer phase
    of the connection.</dd>
            <dt>FIN-WAIT-1 -</dt><dd>represents waiting for a connection termination request
    from the remote TCP peer, or an acknowledgment of the connection
    termination request previously sent.</dd>
            <dt>FIN-WAIT-2 -</dt><dd>represents waiting for a connection termination request
    from the remote TCP peer.</dd>
            <dt>CLOSE-WAIT -</dt><dd>represents waiting for a connection termination request
    from the local user.</dd>
            <dt>CLOSING -</dt><dd>represents waiting for a connection termination request
    acknowledgment from the remote TCP peer.</dd>
            <dt>LAST-ACK -</dt><dd>represents waiting for an acknowledgment of the
    connection termination request previously sent to the remote TCP peer
    (this termination request sent to the remote TCP peer already included an acknowledgment of the termination request sent from the remote TCP peer).</dd>
            <dt>TIME-WAIT -</dt><dd>represents waiting for enough time to pass to be sure
    the remote TCP peer received the acknowledgment of its connection
    termination request and to avoid new connections being impacted by delayed
    segments from previous connections.</dd>
            <dt>CLOSED -</dt><dd>represents no connection state at all.</dd>
          </dl>
          <t>
  A TCP connection progresses from one state to another in response to
  events.  The events are the user calls, OPEN, SEND, RECEIVE, CLOSE,
  ABORT, and STATUS; the incoming segments, particularly those
  containing the SYN, ACK, RST, and FIN flags; and timeouts.
</t>
          <t>
  The OPEN call specifies
  whether connection establishment is to be actively pursued, or to
  be passively waited for.
</t>
          <t>
  A passive OPEN request means that the process wants to accept incoming
  connection requests, in contrast to an active OPEN attempting to initiate a connection.
</t>
          <t>
  The state diagram in <xref target="conn_states" format="default"/> illustrates only state changes, together
  with the causing events and resulting actions, but addresses neither
  error conditions nor actions that are not connected with state
  changes.  In a later section, more detail is offered with respect to
  the reaction of the TCP implementation to events.  Some state names are abbreviated or hyphenated differently in the diagram from how they appear elsewhere in the document. 
</t>
          <dl>
            <dt>
  NOTA BENE:</dt><dd>This diagram is only a summary and must not be taken as
  the total specification.  Many details are not included.
</dd>
          </dl>
          <figure anchor="conn_states">
            <name>TCP Connection State Diagram</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[
                            +---------+ ---------\      active OPEN  
                            |  CLOSED |            \    -----------  
                            +---------+<---------\   \   create TCB  
                              |     ^              \   \  snd SYN    
                 passive OPEN |     |   CLOSE        \   \           
                 ------------ |     | ----------       \   \         
                  create TCB  |     | delete TCB         \   \       
                              V     |                      \   \     
          rcv RST (note 1)  +---------+            CLOSE    |    \   
       -------------------->|  LISTEN |          ---------- |     |  
      /                     +---------+          delete TCB |     |  
     /           rcv SYN      |     |     SEND              |     |  
    /           -----------   |     |    -------            |     V  
+--------+      snd SYN,ACK  /       \   snd SYN          +--------+
|        |<-----------------           ------------------>|        |
|  SYN   |                    rcv SYN                     |  SYN   |
|  RCVD  |<-----------------------------------------------|  SENT  |
|        |                  snd SYN,ACK                   |        |
|        |------------------           -------------------|        |
+--------+   rcv ACK of SYN  \       /  rcv SYN,ACK       +--------+
   |         --------------   |     |   -----------                  
   |                x         |     |     snd ACK                    
   |                          V     V                                
   |  CLOSE                 +---------+                              
   | -------                |  ESTAB  |                              
   | snd FIN                +---------+                              
   |                 CLOSE    |     |    rcv FIN                     
   V                -------   |     |    -------                     
+---------+         snd FIN  /       \   snd ACK         +---------+
|  FIN    |<----------------          ------------------>|  CLOSE  |
| WAIT-1  |------------------                            |   WAIT  |
+---------+          rcv FIN  \                          +---------+
  | rcv ACK of FIN   -------   |                          CLOSE  |  
  | --------------   snd ACK   |                         ------- |  
  V        x                   V                         snd FIN V  
+---------+               +---------+                    +---------+
|FINWAIT-2|               | CLOSING |                    | LAST-ACK|
+---------+               +---------+                    +---------+
  |              rcv ACK of FIN |                 rcv ACK of FIN |  
  |  rcv FIN     -------------- |    Timeout=2MSL -------------- |  
  |  -------            x       V    ------------        x       V  
   \ snd ACK              +---------+delete TCB          +---------+
     -------------------->|TIME-WAIT|------------------->| CLOSED  |
                          +---------+                    +---------+
]]></artwork>
          </figure>
          <t>The following notes apply to <xref target="conn_states" format="default"/>:
</t>
          <dl>
            <dt>
Note 1:</dt><dd>The transition from SYN-RECEIVED to LISTEN on receiving a RST is
conditional on having reached SYN-RECEIVED after a passive OPEN.
</dd>
            <dt>
Note 2:</dt><dd>The figure omits a transition from FIN-WAIT-1 to TIME-WAIT if
a FIN is received and the local FIN is also acknowledged.
</dd>
            <dt>
Note 3:</dt><dd>A RST can be sent from any state with a corresponding transition to TIME-WAIT (see <xref target="FTY99" format="default"/> for rationale).  These transitions are not explicitly shown; otherwise, the diagram would become very difficult to read.  Similarly, receipt of a RST from any state results in a transition to LISTEN or CLOSED, though this is also omitted from the diagram for legibility.
</dd>
          </dl>
        </section>
      </section>
      <section anchor="sequence-numbers" numbered="true" toc="default">
        <name>Sequence Numbers</name>
        <t>
  A fundamental notion in the design is that every octet of data sent
  over a TCP connection has a sequence number.  Since every octet is
  sequenced, each of them can be acknowledged.  The acknowledgment
  mechanism employed is cumulative so that an acknowledgment of sequence
  number X indicates that all octets up to but not including X have been
  received.  This mechanism allows for straightforward duplicate
  detection in the presence of retransmission.  The numbering scheme of octets
  within a segment is as follows: the first data octet immediately following
  the header is the lowest numbered, and the following octets are
  numbered consecutively.
</t>
        <t>
  It is essential to remember that the actual sequence number space is
  finite, though large.  This space ranges from 0 to 2<sup>32</sup> - 1.
  Since the space is finite, all arithmetic dealing with sequence
  numbers must be performed modulo 2<sup>32</sup>.  This unsigned arithmetic
  preserves the relationship of sequence numbers as they cycle from
  2<sup>32</sup> - 1 to 0 again.  There are some subtleties to computer modulo
  arithmetic, so great care should be taken in programming the
  comparison of such values.  The symbol "=&lt;" means "less than or equal"
  (modulo 2<sup>32</sup>).
</t>
        <t>
  The typical kinds of sequence number comparisons that the TCP implementation must
  perform include:
</t>
        <ol type="(%c)" spacing="normal">
          <li>Determining that an acknowledgment refers to some sequence
         number sent but not yet acknowledged.</li>
          <li>Determining that all sequence numbers occupied by a segment
         have been acknowledged (e.g., to remove the segment from a
         retransmission queue).</li>
          <li>Determining that an incoming segment contains sequence numbers
         that are expected (i.e., that the segment "overlaps" the
         receive window).</li>
        </ol>
        <t>
  In response to sending data, the TCP endpoint will receive acknowledgments.  The
  following comparisons are needed to process the acknowledgments:
</t>
        <t indent="3">
  SND.UNA = oldest unacknowledged sequence number
</t>
        <t indent="3">
  SND.NXT = next sequence number to be sent
</t>
        <t indent="3">
  SEG.ACK = acknowledgment from the receiving TCP peer (next sequence
  number expected by the receiving TCP peer)
</t>
        <t indent="3">
  SEG.SEQ = first sequence number of a segment
</t>
        <t indent="3">
  SEG.LEN = the number of octets occupied by the data in the segment
  (counting SYN and FIN)
</t>
        <t indent="3">
  SEG.SEQ+SEG.LEN-1 = last sequence number of a segment
</t>   
         <t>
  A new acknowledgment (called an "acceptable ack") is one for which
  the inequality below holds:
</t>
          <t indent="3">
  SND.UNA &lt; SEG.ACK =&lt; SND.NXT
</t>   
        <t>
  A segment on the retransmission queue is fully acknowledged if the sum
  of its sequence number and length is less than or equal to the
  acknowledgment value in the incoming segment.
</t>
        <t>
  When data is received, the following comparisons are needed:
</t>
        <t indent="3">
  RCV.NXT = next sequence number expected on an incoming segment, and
  is the left or lower edge of the receive window
</t>
        <t indent="3">
  RCV.NXT+RCV.WND-1 = last sequence number expected on an incoming
  segment, and is the right or upper edge of the receive window
</t>
        <t indent="3">
  SEG.SEQ = first sequence number occupied by the incoming segment
</t>
        <t indent="3">
  SEG.SEQ+SEG.LEN-1 = last sequence number occupied by the incoming
  segment
</t>
        <t>
  A segment is judged to occupy a portion of valid receive sequence
  space if
</t>
        <t indent="3">
  RCV.NXT =&lt; SEG.SEQ &lt; RCV.NXT+RCV.WND
</t>
     
        <t>
  or
</t>
        <t indent="3">
  RCV.NXT =&lt; SEG.SEQ+SEG.LEN-1 &lt; RCV.NXT+RCV.WND
</t>
        <t>
  The first part of this test checks to see if the beginning of the
  segment falls in the window, the second part of the test checks to see
  if the end of the segment falls in the window; if the segment passes
  either part of the test, it contains data in the window.
</t>
        <t>
  Actually, it is a little more complicated than this.  Due to zero
  windows and zero-length segments, we have four cases for the
  acceptability of an incoming segment:
</t>
        <table>
         <name>Segment Acceptability Tests</name>
         <thead>
           <tr>
             <th>Segment Length</th> 
             <th>Receive Window</th>
             <th>Test</th>
           </tr>
         </thead>
         <tbody>
           <tr>
             <td>0</td>
             <td>0</td>
             <td>SEG.SEQ = RCV.NXT</td>
           </tr>
           <tr>
             <td>0</td>
             <td>&gt;0</td>
             <td>RCV.NXT =&lt; SEG.SEQ  &lt; RCV.NXT+RCV.WND</td>
           </tr>
           <tr>
             <td>&gt;0</td>
             <td>0</td>
             <td>not acceptable</td>
           </tr>
           <tr>
             <td>&gt;0</td>
             <td>&gt;0</td>
             <td>
               <t>RCV.NXT =&lt; SEG.SEQ  &lt; RCV.NXT+RCV.WND</t>
               <t>or</t>
               <t>RCV.NXT =&lt; SEG.SEQ+SEG.LEN-1  &lt; RCV.NXT+RCV.WND</t>
             </td>
           </tr>
         </tbody>
       </table>
        <t>
  Note that when the receive window is zero no segments should be
  acceptable except ACK segments.  Thus, it is possible for a TCP implementation to
  maintain a zero receive window while transmitting data and receiving
  ACKs. A TCP receiver <bcp14>MUST</bcp14> 
  process the RST and URG fields of all incoming segments, even when the receive window is zero (MUST-66).
</t>
        <t>
  We have taken advantage of the numbering scheme to protect certain
  control information as well.  This is achieved by implicitly including
  some control flags in the sequence space so they can be retransmitted
  and acknowledged without confusion (i.e., one and only one copy of the
  control will be acted upon).  Control information is not physically
  carried in the segment data space.  Consequently, we must adopt rules
  for implicitly assigning sequence numbers to control.  The SYN and FIN
  are the only controls requiring this protection, and these controls
  are used only at connection opening and closing.  For sequence number
  purposes, the SYN is considered to occur before the first actual data
  octet of the segment in which it occurs, while the FIN is considered
  to occur after the last actual data octet in a segment in which it
  occurs.  The segment length (SEG.LEN) includes both data and sequence
  space-occupying controls.  When a SYN is present, then SEG.SEQ is the
  sequence number of the SYN.
</t>
        <section numbered="true" toc="default">
          <name>Initial Sequence Number Selection</name>
          <t>
  A connection is defined by a pair of
  sockets.  Connections can be reused.  New instances of a connection will be referred to as
  incarnations of the connection.  The problem that arises from this is
  -- "how does the TCP implementation identify duplicate segments from previous
  incarnations of the connection?"  This problem becomes apparent if the
  connection is being opened and closed in quick succession, or if the
  connection breaks with loss of memory and is then reestablished.
  To support this, the TIME-WAIT state limits the rate of connection reuse,
  while the initial sequence number selection described below further protects
  against ambiguity about which incarnation of a connection an incoming packet
  corresponds to.

</t>
          <t>
  To avoid confusion, we must prevent segments from one incarnation of a
  connection from being used while the same sequence numbers may still
  be present in the network from an earlier incarnation.  We want to
  assure this even if a TCP endpoint loses all knowledge of the
  sequence numbers it has been using.  When new connections are created,
  an initial sequence number (ISN) generator is employed that selects a
  new 32-bit ISN.  There are security issues that result if an off-path
  attacker is able to predict or guess ISN values <xref target="RFC6528" format="default"/>.
</t>
          <t>

TCP initial sequence numbers are generated from a number sequence that
monotonically increases until it wraps, known loosely as a "clock".
This clock is a 32-bit counter that typically increments at least once every
roughly 4 microseconds, although it is neither assumed to be realtime nor
precise, and need not persist across reboots.  The clock component is intended
to ensure that with a Maximum Segment Lifetime (MSL), generated ISNs will be
unique since it cycles approximately every 4.55 hours, which is much longer
than the MSL. Please note that for modern networks that support high data 
rates where the connection might start and quickly advance sequence numbers to 
overlap within the MSL, it is recommended to implement the Timestamp Option as 
mentioned later in <xref target="tcp_quiet_time_concept"/>.
</t>
          <t>
  A TCP implementation <bcp14>MUST</bcp14> use the above type of "clock" for clock-driven selection of initial sequence numbers (MUST-8), and
  <bcp14>SHOULD</bcp14> generate its initial sequence numbers with the expression:
</t>
          <t>
      ISN = M + F(localip, localport, remoteip, remoteport, secretkey)
</t>
          <t>
   where M is the 4 microsecond timer, and F() is a pseudorandom
   function (PRF) of the connection's identifying parameters ("localip, localport, remoteip, remoteport") and a secret key ("secretkey") (SHLD-1).  F() <bcp14>MUST NOT</bcp14> be computable from the outside (MUST-9), or an attacker could still guess at sequence numbers from the ISN used for some other connection.  The PRF could be implemented as a cryptographic hash of the concatenation of the TCP connection parameters and some secret data.  For discussion of the selection of a specific hash algorithm and management of the secret key data, please see <xref target="RFC6528" section="3" sectionFormat="of" format="default"/>.
</t>
          <t>
  For each connection there is a send sequence number and a receive
  sequence number.  The initial send sequence number (ISS) is chosen by
  the data sending TCP peer, and the initial receive sequence number (IRS) is
  learned during the connection-establishing procedure.
</t>
          <t>
  For a connection to be established or initialized, the two TCP peers must
  synchronize on each other's initial sequence numbers.  This is done in
  an exchange of connection-establishing segments carrying a control bit
  called "SYN" (for synchronize) and the initial sequence numbers.  As a
  shorthand, segments carrying the SYN bit are also called "SYNs".
  Hence, the solution requires a suitable mechanism for picking an
  initial sequence number and a slightly involved handshake to exchange
  the ISNs.
</t>
          <t>
  The synchronization requires each side to send its own initial
  sequence number and to receive a confirmation of it in acknowledgment
  from the remote TCP peer.  Each side must also receive the remote peer's
  initial sequence number and send a confirming acknowledgment.
</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
    1) A --> B  SYN my sequence number is X
    2) A <-- B  ACK your sequence number is X
    3) A <-- B  SYN my sequence number is Y
    4) A --> B  ACK your sequence number is Y
]]></artwork>
          <t>
  Because steps 2 and 3 can be combined in a single message this is
  called the three-way (or three message) handshake (3WHS).
</t>
          <t>
  A 3WHS is necessary because sequence numbers are not
  tied to a global clock in the network, and TCP implementations may have different
  mechanisms for picking the ISNs.  The receiver of the first SYN has
  no way of knowing whether the segment was an old one or not,
  unless it remembers the last sequence number used on the connection
  (which is not always possible), and so it must ask the sender to
  verify this SYN.  The three-way handshake and the advantages of a
  clock-driven scheme for ISN selection are discussed in <xref target="DS78" format="default"/>.
</t>
        </section>
        <section numbered="true" toc="default">
          <name>Knowing When to Keep Quiet</name>
          <t>
  A theoretical problem exists where data could be corrupted due to confusion
  between old segments in the network and new ones after a host reboots if the
  same port numbers and sequence space are reused.  The "quiet time"
  concept discussed below addresses this, and the discussion of it is included
  for situations where it might be relevant, although it is not felt to be
  necessary in most current implementations.  The problem was more relevant
  earlier in the history of TCP.  In practical use on the Internet today, the
  error-prone conditions are sufficiently unlikely that it is safe to
  ignore.  Reasons why it is now negligible include: (a) ISS and ephemeral port
  randomization have reduced likelihood of reuse of port numbers and sequence numbers
  after reboots, (b) the effective MSL of the Internet has declined as links
  have become faster, and (c) reboots often taking longer than an MSL anyways.
          </t>
          <t>
  To be sure that a TCP implementation does not create a segment carrying a
  sequence number that may be duplicated by an old segment remaining in the
  network, the TCP endpoint must keep quiet for an MSL before assigning any
  sequence numbers upon starting up or recovering from a situation where memory
  of sequence numbers in use was lost.  For this specification the MSL is taken
  to be 2 minutes.  This is an engineering choice, and may be changed if
  experience indicates it is desirable to do so.  Note that if a TCP endpoint
  is reinitialized in some sense, yet retains its memory of sequence numbers in
  use, then it need not wait at all; it must only be sure to use sequence
  numbers larger than those recently used.
</t>
        </section>
        <section anchor="tcp_quiet_time_concept" numbered="true" toc="default">
          <name>The TCP Quiet Time Concept</name>
          <t>
    Hosts that for any reason lose
    knowledge of the last sequence numbers transmitted on
    each active (i.e., not closed) connection shall delay emitting any
    TCP segments for at least the agreed MSL
    in the internet system that the host is a part of.  In the
    paragraphs below, an explanation for this specification is given.
    TCP implementers may violate the "quiet time" restriction, but only
    at the risk of causing some old data to be accepted as new or new
    data rejected as old duplicated data by some receivers in the internet
    system.
</t>
          <t>
    TCP endpoints consume sequence number space each time a segment is formed and
    entered into the network output queue at a source host. The
    duplicate detection and sequencing algorithm in TCP
    relies on the unique binding of segment data to sequence space to
    the extent that sequence numbers will not cycle through all 2<sup>32</sup>
    values before the segment data bound to those sequence numbers has
    been delivered and acknowledged by the receiver and all duplicate
    copies of the segments have "drained" from the internet.  Without
    such an assumption, two distinct TCP segments could conceivably be
    assigned the same or overlapping sequence numbers, causing confusion
    at the receiver as to which data is new and which is old.  Remember
    that each segment is bound to as many consecutive sequence numbers
    as there are octets of data and SYN or FIN flags in the segment.
</t>
          <t>
    Under normal conditions, TCP implementations keep track of the next sequence number
    to emit and the oldest awaiting acknowledgment so as to avoid
    mistakenly reusing a sequence number before its first use has
    been acknowledged.  This alone does not guarantee that old duplicate
    data is drained from the net, so the sequence space has been made
    large to reduce the probability that a wandering duplicate will
    cause trouble upon arrival.  At 2 megabits/sec., it takes 4.5 hours
    to use up 2<sup>32</sup> octets of sequence space.  Since the maximum segment
    lifetime in the net is not likely to exceed a few tens of seconds,
    this is deemed ample protection for foreseeable nets, even if data
    rates escalate to 10s of megabits/sec.  At 100 megabits/sec., the
    cycle time is 5.4 minutes, which may be a little short but still
    within reason.  Much higher data rates are possible today, with implications
    described in the final paragraph of this subsection.
</t>
          <t>
    The basic duplicate detection and sequencing algorithm in TCP can be
    defeated, however, if a source TCP endpoint does not have any memory of the
    sequence numbers it last used on a given connection. For example, if
    the TCP implementation were to start all connections with sequence number 0, then
    upon the host rebooting, a TCP peer might re-form an earlier
    connection (possibly after half-open connection resolution) and emit
    packets with sequence numbers identical to or overlapping with
    packets still in the network, which were emitted on an earlier
    incarnation of the same connection.  In the absence of knowledge
    about the sequence numbers used on a particular connection, the TCP
    specification recommends that the source delay for MSL seconds
    before emitting segments on the connection, to allow time for
    segments from the earlier connection incarnation to drain from the
    system.
</t>
          <t>
    Even hosts that can remember the time of day and use it to select
    initial sequence number values are not immune from this problem
    (i.e., even if time of day is used to select an initial sequence
    number for each new connection incarnation).
</t>
          <t>
    Suppose, for example, that a connection is opened starting with
    sequence number S.  Suppose that this connection is not used much
    and that eventually the initial sequence number function (ISN(t))
    takes on a value equal to the sequence number, say S1, of the last
    segment sent by this TCP endpoint on a particular connection.  Now suppose,
    at this instant, the host reboots and establishes a new
    incarnation of the connection. The initial sequence number chosen is
    S1 = ISN(t) -- last used sequence number on old incarnation of
    connection!  If the recovery occurs quickly enough, any old
    duplicates in the net bearing sequence numbers in the neighborhood
    of S1 may arrive and be treated as new packets by the receiver of
    the new incarnation of the connection.
</t>
          <t>
    The problem is that the recovering host may not know for how long it
    was down between rebooting nor does it know whether there are still old duplicates in
    the system from earlier connection incarnations.
</t>
          <t>
    One way to deal with this problem is to deliberately delay emitting
    segments for one MSL after recovery from a reboot -- this is the "quiet
    time" specification.  Hosts that prefer to avoid waiting and are
    willing to risk possible confusion of old and new packets at a given
    destination may choose not to wait for the "quiet time".
    Implementers may provide TCP users with the ability to select on a
    connection-by-connection basis whether to wait after a reboot, or may
    informally implement the "quiet time" for all connections.
    Obviously, even where a user selects to "wait", this is not
    necessary after the host has been "up" for at least MSL seconds.
</t>
          <t>
    To summarize: every segment emitted occupies one or more sequence
    numbers in the sequence space, and the numbers occupied by a segment are
    "busy" or "in use" until MSL seconds have passed. Upon rebooting, a
    block of space-time is occupied by the octets and SYN or FIN flags of any potentially still in-flight
    segments. If a new connection is started too soon and uses any of the
    sequence numbers in the space-time footprint of those potentially still in-flight segments of
    the previous connection incarnation, there is a potential sequence
    number overlap area that could cause confusion at the receiver.
</t>
          <t>
    High-performance cases will have shorter cycle times than those in the
    megabits per second that the base TCP design described above considers.
    At 1 Gbps, the cycle time is 34 seconds, only 3 seconds at 10 Gbps, and
    around a third of a second at 100 Gbps.  In these higher-performance cases,
    TCP Timestamp Options and Protection Against Wrapped Sequences (PAWS) <xref target="RFC7323" format="default"/> provide the needed capability to detect and discard old
    duplicates.
</t>
        </section>
      </section>
      <section numbered="true" toc="default">
        <name>Establishing a Connection</name>
        <t>
  The "three-way handshake" is the procedure used to establish a
  connection.  This procedure normally is initiated by one TCP peer and
  responded to by another TCP peer.  The procedure also works if two TCP peers
  simultaneously initiate the procedure.  When simultaneous open
  occurs, each TCP peer receives a SYN segment that carries no
  acknowledgment after it has sent a SYN.  Of course, the arrival of
  an old duplicate SYN segment can potentially make it appear, to the
  recipient, that a simultaneous connection initiation is in progress.
  Proper use of "reset" segments can disambiguate these cases.
</t>
        <t>
  Several examples of connection initiation follow.  Although these
  examples do not show connection synchronization using data-carrying
  segments, this is perfectly legitimate, so long as the receiving TCP endpoint
  doesn't deliver the data to the user until it is clear the data is
  valid (e.g., the data is buffered at the receiver until the
  connection reaches the ESTABLISHED state, given that the three-way handshake
  reduces the possibility of false connections).  It is
  a trade-off between memory and messages to provide
  information for this checking.
</t>
        <t>
  The simplest 3WHS is shown in <xref target="handshake" format="default"/>.  The
  figures should be interpreted in the following way.  Each line is
  numbered for reference purposes.  Right arrows (--&gt;) indicate
  departure of a TCP segment from TCP Peer A to TCP Peer B or arrival of a
  segment at B from A.  Left arrows (&lt;--) indicate the reverse.
  Ellipses (...) indicate a segment that is still in the network
  (delayed).
  Comments appear in parentheses.  TCP connection states represent the state AFTER
  the departure or arrival of the segment (whose contents are shown in
  the center of each line).  Segment contents are shown in abbreviated
  form, with sequence number, control flags, and ACK field.  Other
  fields such as window, addresses, lengths, and text have been left out
  in the interest of clarity.
</t>
        <figure anchor="handshake">
          <name>Basic Three-Way Handshake for Connection Synchronization</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
    TCP Peer A                                           TCP Peer B

1.  CLOSED                                               LISTEN

2.  SYN-SENT    --> <SEQ=100><CTL=SYN>               --> SYN-RECEIVED

3.  ESTABLISHED <-- <SEQ=300><ACK=101><CTL=SYN,ACK>  <-- SYN-RECEIVED

4.  ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK>       --> ESTABLISHED

5.  ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK><DATA> --> ESTABLISHED
]]></artwork>
        </figure>
        <t>
  In line 2 of <xref target="handshake" format="default"/>, TCP Peer A begins by sending a SYN segment
  indicating that it will use sequence numbers starting with sequence
  number 100.  In line 3, TCP Peer B sends a SYN and acknowledges the SYN it
  received from TCP Peer A.  Note that the acknowledgment field indicates TCP Peer
  B is now expecting to hear sequence 101, acknowledging the SYN that
  occupied sequence 100.
</t>
        <t>
  At line 4, TCP Peer A responds with an empty segment containing an ACK for
  TCP Peer B's SYN; and in line 5, TCP Peer A sends some data.  Note that the
  sequence number of the segment in line 5 is the same as in line 4
  because the ACK does not occupy sequence number space (if it did, we
  would wind up ACKing ACKs!).
</t>
        <t>
  Simultaneous initiation is only slightly more complex, as is shown in
  <xref target="simul_connect" format="default"/>.  Each TCP peer's connection state cycles from CLOSED to SYN-SENT to SYN-RECEIVED to ESTABLISHED.
</t>
        <figure anchor="simul_connect">
          <name>Simultaneous Connection Synchronization</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
    TCP Peer A                                       TCP Peer B

1.  CLOSED                                           CLOSED

2.  SYN-SENT     --> <SEQ=100><CTL=SYN>              ...

3.  SYN-RECEIVED <-- <SEQ=300><CTL=SYN>              <-- SYN-SENT

4.               ... <SEQ=100><CTL=SYN>              --> SYN-RECEIVED

5.  SYN-RECEIVED --> <SEQ=100><ACK=301><CTL=SYN,ACK> ...

6.  ESTABLISHED  <-- <SEQ=300><ACK=101><CTL=SYN,ACK> <-- SYN-RECEIVED

7.               ... <SEQ=100><ACK=301><CTL=SYN,ACK> --> ESTABLISHED
]]></artwork>
        </figure>
        <t>
A TCP implementation <bcp14>MUST</bcp14> support simultaneous open attempts (MUST-10).
</t>
        <t>
Note that a TCP implementation <bcp14>MUST</bcp14> keep track of whether a
connection has reached SYN-RECEIVED state as the result of a
passive OPEN or an active OPEN (MUST-11).
</t>
        <t>
  The principal reason for the three-way handshake is to prevent old
  duplicate connection initiations from causing confusion.  To deal with
  this, a special control message, reset, is specified.  If the
  receiving TCP peer is in a  non-synchronized state (i.e., SYN-SENT,
  SYN-RECEIVED), it returns to LISTEN on receiving an acceptable reset.
  If the TCP peer is in one of the synchronized states (ESTABLISHED,
  FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT), it
  aborts the connection and informs its user.  We discuss this latter
  case under "half-open" connections below.
</t>
        <figure anchor="dup_syn">
          <name>Recovery from Old Duplicate SYN</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
    TCP Peer A                                           TCP Peer B

1.  CLOSED                                               LISTEN

2.  SYN-SENT    --> <SEQ=100><CTL=SYN>               ...

3.  (duplicate) ... <SEQ=90><CTL=SYN>               --> SYN-RECEIVED

4.  SYN-SENT    <-- <SEQ=300><ACK=91><CTL=SYN,ACK>  <-- SYN-RECEIVED

5.  SYN-SENT    --> <SEQ=91><CTL=RST>               --> LISTEN
  
6.              ... <SEQ=100><CTL=SYN>               --> SYN-RECEIVED

7.  ESTABLISHED <-- <SEQ=400><ACK=101><CTL=SYN,ACK>  <-- SYN-RECEIVED

8.  ESTABLISHED --> <SEQ=101><ACK=401><CTL=ACK>      --> ESTABLISHED
]]></artwork>
        </figure>
        <t>
  As a simple example of recovery from old duplicates, consider
  <xref target="dup_syn" format="default"/>.  At line 3, an old duplicate SYN arrives at TCP Peer B.  TCP Peer B
  cannot tell that this is an old duplicate, so it responds normally
  (line 4).  TCP Peer A detects that the ACK field is incorrect and returns a
  RST (reset) with its SEQ field selected to make the segment
  believable.  TCP Peer B, on receiving the RST, returns to the LISTEN state.
  When the original SYN finally arrives at line 6, the
  synchronization proceeds normally.  If the SYN at line 6 had arrived
  before the RST, a more complex exchange might have occurred with RSTs
  sent in both directions.
</t>
        <section numbered="true" toc="default">
          <name>Half-Open Connections and Other Anomalies</name>
          <t>
  An established connection is said to be  "half-open" if one of the
  TCP peers has closed or aborted the connection at its end without the
  knowledge of the other, or if the two ends of the connection have
  become desynchronized owing to a failure or reboot that resulted in loss of
  memory.  Such connections will automatically become reset if an
  attempt is made to send data in either direction.  However, half-open
  connections are expected to be unusual.
</t>
          <t>
  If at site A the connection no longer exists, then an attempt by the
  user at site B to send any data on it will result in the site B TCP endpoint
  receiving a reset control message.  Such a message indicates to the
  site B TCP endpoint that something is wrong, and it is expected to abort the
  connection.
</t>
          <t>
  Assume that two user processes A and B are communicating with one
  another when a failure or reboot occurs causing loss of memory to A's TCP implementation.
  Depending on the operating system supporting A's TCP implementation, it is likely
  that some error recovery mechanism exists.  When the TCP endpoint is up again,
  A is likely to start again from the beginning or from a recovery
  point.  As a result, A will probably try to OPEN the connection again
  or try to SEND on the connection it believes open.  In the latter
  case, it receives the error message "connection not open" from the
  local (A's) TCP implementation.  In an attempt to establish the connection, A's TCP implementation
  will send a segment containing SYN.  This scenario leads to the
  example shown in <xref target="half_open" format="default"/>.  After TCP Peer A reboots, the user attempts to
  reopen the connection.  TCP Peer B, in the meantime, thinks the connection
  is open.
</t>
          <figure anchor="half_open">
            <name>Half-Open Connection Discovery</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[
      TCP Peer A                                      TCP Peer B

  1.  (REBOOT)                              (send 300,receive 100)

  2.  CLOSED                                           ESTABLISHED

  3.  SYN-SENT --> <SEQ=400><CTL=SYN>              --> (??)

  4.  (!!)     <-- <SEQ=300><ACK=100><CTL=ACK>     <-- ESTABLISHED

  5.  SYN-SENT --> <SEQ=100><CTL=RST>              --> (Abort!!)

  6.  SYN-SENT                                         CLOSED

  7.  SYN-SENT --> <SEQ=400><CTL=SYN>              -->
]]></artwork>
          </figure>
          <t>
  When the SYN arrives at line 3, TCP Peer B, being in a synchronized state,
  and the incoming segment outside the window, responds with an
  acknowledgment indicating what sequence it next expects to hear (ACK
  100).  TCP Peer A sees that this segment does not acknowledge anything it
  sent and, being unsynchronized, sends a reset (RST) because it has
  detected a half-open connection.  TCP Peer B aborts at line 5.  TCP Peer A will
  continue to try to establish the connection; the problem is now
  reduced to the basic three-way handshake of <xref target="handshake" format="default"/>.
</t>
          <t>
  An interesting alternative case occurs when TCP Peer A reboots and TCP Peer B
  tries to send data on what it thinks is a synchronized connection.
  This is illustrated in <xref target="crash" format="default"/>.  In this case, the data arriving at
  TCP Peer A from TCP Peer B (line 2) is unacceptable because no such connection
  exists, so TCP Peer A sends a RST.  The RST is acceptable so TCP Peer B
  processes it and aborts the connection.
</t>
          <figure anchor="crash">
            <name>Active Side Causes Half-Open Connection Discovery</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[
      TCP Peer A                                         TCP Peer B

1.  (REBOOT)                                  (send 300,receive 100)

2.  (??)    <-- <SEQ=300><ACK=100><DATA=10><CTL=ACK> <-- ESTABLISHED

3.          --> <SEQ=100><CTL=RST>                   --> (ABORT!!)
]]></artwork>
          </figure>
          <t>
  In <xref target="passive_reset" format="default"/>, two TCP Peers A and B with passive connections
  waiting for SYN are depicted.  An old duplicate arriving at TCP Peer B (line 2) stirs B
  into action.  A SYN-ACK is returned (line 3) and causes TCP A to
  generate a RST (the ACK in line 3 is not acceptable).  TCP Peer B accepts
  the reset and returns to its passive LISTEN state.
</t>
          <figure anchor="passive_reset">
            <name>Old Duplicate SYN Initiates a Reset on Two Passive Sockets</name>
            <artwork name="" type="" align="left" alt=""><![CDATA[
    TCP Peer A                                    TCP Peer B

1.  LISTEN                                        LISTEN

2.       ... <SEQ=Z><CTL=SYN>                -->  SYN-RECEIVED

3.  (??) <-- <SEQ=X><ACK=Z+1><CTL=SYN,ACK>   <--  SYN-RECEIVED

4.       --> <SEQ=Z+1><CTL=RST>              -->  (return to LISTEN!)

5.  LISTEN                                        LISTEN
]]></artwork>
          </figure>
          <t>
  A variety of other cases are possible, all of which are accounted for
  by the following rules for RST generation and processing.
</t>
        </section>
        <section numbered="true" toc="default">
          <name>Reset Generation</name>
          <t>
  A TCP user or application can issue a reset on a connection at any time, though reset events are also generated by the protocol itself when various error conditions occur, as described below.  The side of a connection issuing a reset should enter the TIME-WAIT state, as this generally helps to reduce the load on busy servers for reasons described in <xref target="FTY99" format="default"/>.
</t>
          <t>
  As a general rule, reset (RST) is sent whenever a segment arrives
  that apparently is not intended for the current connection.  A reset
  must not be sent if it is not clear that this is the case.
</t>
          <t>
  There are three groups of states:
</t>
          <ol type="1"  spacing="normal">
            <li>
              <t>
    If the connection does not exist (CLOSED), then a reset is sent
    in response to any incoming segment except another reset.  A SYN
    segment that does not match an existing connection is rejected
    by this means.
</t>
              <t>
    If the incoming segment has the ACK bit set, the reset takes its
    sequence number from the ACK field of the segment; otherwise, the
    reset has sequence number zero and the ACK field is set to the sum
    of the sequence number and segment length of the incoming segment.
    The connection remains in the CLOSED state. 
</t> 
</li>
            <li>
              <t>
    If the connection is in any non-synchronized state (LISTEN,
    SYN-SENT, SYN-RECEIVED), and the incoming segment acknowledges
    something not yet sent (the segment carries an unacceptable ACK), or
    if an incoming segment has a security level or compartment (<xref target="seccomp" format="default"/>) that
    does not exactly match the level and compartment requested for the
    connection, a reset is sent.
</t>
              <t>
    If the incoming segment has an ACK field, the reset takes its
    sequence number from the ACK field of the segment; otherwise, the
    reset has sequence number zero and the ACK field is set to the sum
    of the sequence number and segment length of the incoming segment.
    The connection remains in the same state.
</t>
</li>   
            <li>
              <t>
    If the connection is in a synchronized state (ESTABLISHED,
    FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT),
    any unacceptable segment (out-of-window sequence number or
    unacceptable acknowledgment number) must be responded to with an empty
    acknowledgment segment (without any user data) containing the current send sequence number
    and an acknowledgment indicating the next sequence number expected
    to be received, and the connection remains in the same state.
</t>
              <t>
    If an incoming segment has a security level or compartment
    that does not exactly match the level and compartment
    requested for the connection, a reset is sent and
    the connection goes to the CLOSED state.  The reset takes its sequence
    number from the ACK field of the incoming segment.
</t>
</li>
          </ol>
        </section>
        <section numbered="true" toc="default">
          <name>Reset Processing</name>
          <t>
  In all states except SYN-SENT, all reset (RST) segments are validated
  by checking their SEQ fields.  A reset is valid if its sequence number
  is in the window.  In the SYN-SENT state (a RST received in response
  to an initial SYN), the RST is acceptable if the ACK field
  acknowledges the SYN.
</t>
          <t>
  The receiver of a RST first validates it, then changes state.  If the
  receiver was in the LISTEN state, it ignores it.  If the receiver was
  in SYN-RECEIVED state and had previously been in the LISTEN state,
  then the receiver returns to the LISTEN state; otherwise, the receiver
  aborts the connection and goes to the CLOSED state.  If the receiver
  was in any other state, it aborts the connection and advises the user
  and goes to the CLOSED state.
</t>
          <t>
  TCP implementations <bcp14>SHOULD</bcp14> allow a received RST segment to include data (SHLD-2).
  It has been suggested that a RST segment could contain diagnostic data that
  explains the cause of the RST.  No standard has yet been established for such data.
</t>
        </section>
      </section>
      <section numbered="true" toc="default">
        <name>Closing a Connection</name>
        <t>
  CLOSE is an operation meaning "I have no more data to send."  The
  notion of closing a full-duplex connection is subject to ambiguous
  interpretation, of course, since it may not be obvious how to treat
  the receiving side of the connection.  We have chosen to treat CLOSE
  in a simplex fashion.  The user who CLOSEs may continue to RECEIVE
  until the TCP receiver is told that the remote peer has CLOSED also.  Thus, a program
  could initiate several SENDs followed by a CLOSE, and then continue to
  RECEIVE until signaled that a RECEIVE failed because the remote peer
  has CLOSED.  The TCP implementation will signal a user, even if no
  RECEIVEs are outstanding, that the remote peer has closed, so the user
  can terminate their side gracefully.  A TCP implementation will reliably deliver all
  buffers SENT before the connection was CLOSED so a user who expects no
  data in return need only wait to hear the connection was CLOSED
  successfully to know that all their data was received at the destination
  TCP endpoint.  Users must keep reading connections they close for sending until
  the TCP implementation indicates there is no more data.
</t>
        <t>
  There are essentially three cases:
</t>
        <ol type="%d)" spacing="normal">
          <li>
    The user initiates by telling the TCP implementation to CLOSE the connection (TCP Peer A in <xref target="normal_close" format="default"/>).
</li>
          <li>
    The remote TCP endpoint initiates by sending a FIN control signal (TCP Peer B in <xref target="normal_close" format="default"/>).
</li>
          <li>
    Both users CLOSE simultaneously (<xref target="simul_close" format="default"/>).
</li>
        </ol>
        <dl newline="false" spacing="normal">
          <dt>Case 1:</dt>
          <dd>
            <t>
    Local user initiates the close
</t>
            <t>
    In this case, a FIN segment can be constructed and placed on the
    outgoing segment queue.  No further SENDs from the user will be
    accepted by the TCP implementation, and it enters the FIN-WAIT-1 state.  RECEIVEs
    are allowed in this state.  All segments preceding and including FIN
    will be retransmitted until acknowledged.  When the other TCP peer has
    both acknowledged the FIN and sent a FIN of its own, the first TCP peer
    can ACK this FIN.  Note that a TCP endpoint receiving a FIN will ACK but not
    send its own FIN until its user has CLOSED the connection also.
            </t>
          </dd>
          <dt>Case 2:</dt>
          <dd>
            <t>
    TCP endpoint receives a FIN from the network
            </t>
            <t>
    If an unsolicited FIN arrives from the network, the receiving TCP endpoint
    can ACK it and tell the user that the connection is closing.  The
    user will respond with a CLOSE, upon which the TCP endpoint can send a FIN to
    the other TCP peer after sending any remaining data.  The TCP endpoint then waits
    until its own FIN is acknowledged whereupon it deletes the
    connection.  If an ACK is not forthcoming, after the user timeout
    the connection is aborted and the user is told.
            </t>
          </dd>
          <dt>Case 3:</dt>
          <dd>
            <t>
    Both users close simultaneously
            </t>
            <t>
    A simultaneous CLOSE by users at both ends of a connection causes
    FIN segments to be exchanged (<xref target="simul_close" format="default"/>).  When all segments preceding the FINs
    have been processed and acknowledged, each TCP peer can ACK the FIN it
    has received.  Both will, upon receiving these ACKs, delete the
    connection.
            </t>
          </dd>
        </dl>
        <figure anchor="normal_close">
          <name>Normal Close Sequence</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
    TCP Peer A                                           TCP Peer B

1.  ESTABLISHED                                          ESTABLISHED

2.  (Close)
    FIN-WAIT-1  --> <SEQ=100><ACK=300><CTL=FIN,ACK>  --> CLOSE-WAIT

3.  FIN-WAIT-2  <-- <SEQ=300><ACK=101><CTL=ACK>      <-- CLOSE-WAIT

4.                                                       (Close)
    TIME-WAIT   <-- <SEQ=300><ACK=101><CTL=FIN,ACK>  <-- LAST-ACK

5.  TIME-WAIT   --> <SEQ=101><ACK=301><CTL=ACK>      --> CLOSED

6.  (2 MSL)
    CLOSED                                                      
]]></artwork>
        </figure>
        <figure anchor="simul_close">
          <name>Simultaneous Close Sequence</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
    TCP Peer A                                           TCP Peer B

1.  ESTABLISHED                                          ESTABLISHED

2.  (Close)                                              (Close)
    FIN-WAIT-1  --> <SEQ=100><ACK=300><CTL=FIN,ACK>  ... FIN-WAIT-1
                <-- <SEQ=300><ACK=100><CTL=FIN,ACK>  <--
                ... <SEQ=100><ACK=300><CTL=FIN,ACK>  -->

3.  CLOSING     --> <SEQ=101><ACK=301><CTL=ACK>      ... CLOSING
                <-- <SEQ=301><ACK=101><CTL=ACK>      <--
                ... <SEQ=101><ACK=301><CTL=ACK>      -->

4.  TIME-WAIT                                            TIME-WAIT
    (2 MSL)                                              (2 MSL)
    CLOSED                                               CLOSED
]]></artwork>
        </figure>
        <t>
            A TCP connection may terminate in two ways: (1) the normal
            TCP close sequence using a FIN handshake (<xref target="normal_close" format="default"/>), and (2) an "abort"
            in which one or more RST segments are sent and the
            connection state is immediately discarded.  If the local
            TCP connection is closed by the remote side due to a FIN or
	    RST received from the remote side, then the local
            application <bcp14>MUST</bcp14> be informed whether it closed normally or
            was aborted (MUST-12).
</t>
        <t>

</t>
        <section numbered="true" toc="default">
          <name>Half-Closed Connections</name>
          <t>
            The normal TCP close sequence delivers buffered data
            reliably in both directions.  Since the two directions of a
            TCP connection are closed independently, it is possible for
            a connection to be "half closed", i.e., closed in only one
            direction, and a host is permitted to continue sending data
            in the open direction on a half-closed connection.
</t>
          <t>
            A host <bcp14>MAY</bcp14> implement a "half-duplex" TCP close sequence, so
            that an application that has called CLOSE cannot continue to
            read data from the connection (MAY-1).  If such a host issues a
            CLOSE call while received data is still pending in the TCP connection, or
            if new data is received after CLOSE is called, its TCP implementation
	    <bcp14>SHOULD</bcp14> send a RST to show that data was lost (SHLD-3).  See <xref target="RFC2525" section="2.17" sectionFormat="comma" format="default"/> for discussion.

</t>
          <t>
            When a connection is closed actively, it <bcp14>MUST</bcp14> linger in the
            TIME-WAIT state for a time 2xMSL (Maximum Segment Lifetime) (MUST-13).
            However, it <bcp14>MAY</bcp14> accept a new SYN from the remote TCP endpoint to
            reopen the connection directly from TIME-WAIT state (MAY-2), if it:
</t>
          <ol type="(%d)" spacing="normal">
            <li>
                 assigns its initial sequence number for the new
                 connection to be larger than the largest sequence
                 number it used on the previous connection incarnation,
                 and
</li>
            <li>
                 returns to TIME-WAIT state if the SYN turns out to be
                 an old duplicate.
</li>
          </ol>
          <t>

When the TCP Timestamp Options are available, an improved algorithm is
described in <xref target="RFC6191" format="default"/> in order to support higher connection
establishment rates.  This algorithm for reducing TIME-WAIT is a Best Current
Practice that <bcp14>SHOULD</bcp14> be implemented since Timestamp Options are commonly used,
and using them to reduce TIME-WAIT provides benefits for busy Internet servers (SHLD-4).

</t>
        </section>
      </section>
      <section numbered="true" toc="default">
        <name>Segmentation</name>
        <t> The term "segmentation" refers to the activity TCP performs when ingesting a stream of bytes from a sending application and packetizing that stream of bytes into TCP segments.  Individual TCP segments often do not correspond one-for-one to individual send (or socket write) calls from the application.  Applications may perform writes at the granularity of messages in the upper-layer protocol, but TCP guarantees no correlation between the boundaries of TCP segments sent and received and the boundaries of the read or write buffers of user application data.  In some specific protocols, such as Remote Direct Memory Access (RDMA) using Direct Data Placement (DDP) and Marker PDU Aligned Framing (MPA) <xref target="RFC5044" format="default"/>, there are performance optimizations possible when the relation between TCP segments and application data units can be controlled, and MPA includes a specific mechanism for detecting and verifying this relationship between TCP segments and application message data structures, but this is specific to applications like RDMA.  In general, multiple goals influence the sizing of TCP segments created by a TCP implementation.</t>
        <t>Goals driving the sending of larger segments include:
        </t>
        <ul spacing="normal">
          <li>Reducing the number of packets in flight within the network.</li>
          <li>Increasing processing efficiency and potential performance by enabling a smaller number of interrupts and inter-layer interactions.</li>
          <li>Limiting the overhead of TCP headers.</li>
        </ul>
        <t>Note that the performance benefits of sending larger segments may decrease as the size increases, and there may be boundaries where advantages are reversed.  For instance, on some implementation architectures, 1025 bytes within a segment could lead to worse performance than 1024 bytes, due purely to data alignment on copy operations.</t>
        <t>Goals driving the sending of smaller segments include:
        </t>
        <ul spacing="normal">
          <li>Avoiding sending a TCP segment that would result in an IP datagram larger than the smallest MTU along an IP network path because this  results in either packet loss or packet fragmentation.  Making matters worse, some firewalls or middleboxes may drop fragmented packets or ICMP messages related to fragmentation.</li>
          <li>Preventing delays to the application data stream, especially when TCP is waiting on the application to generate more data, or when the application is waiting on an event or input from its peer in order to generate more data.</li>
          <li>Enabling "fate sharing" between TCP segments and lower-layer data units (e.g., below IP, for links with cell or frame sizes smaller than the IP MTU).</li>
        </ul>
        <t>Towards meeting these competing sets of goals, TCP includes several mechanisms, including the Maximum Segment Size Option, Path MTU Discovery, the Nagle algorithm, and support for IPv6 Jumbograms, as discussed in the following subsections.</t>
        <section anchor="mss" numbered="true" toc="default">
          <name>Maximum Segment Size Option</name>
          <t>
    TCP endpoints <bcp14>MUST</bcp14> implement both sending and receiving the MSS Option (MUST-14).
          </t>
          <t>
    TCP implementations <bcp14>SHOULD</bcp14> send an MSS Option in
    every SYN segment when its receive MSS differs from the
    default 536 for IPv4 or 1220 for IPv6 (SHLD-5), and <bcp14>MAY</bcp14> send it always (MAY-3).
          </t>
          <t>
    If an MSS Option is not received at connection setup, TCP implementations
    <bcp14>MUST</bcp14> assume a default send MSS of 536 (576 - 40) for IPv4 or 1220 (1280 - 60) for IPv6 (MUST-15).
          </t>
          <t>
    The maximum size of a segment that a TCP endpoint really sends, the
    "effective send MSS", <bcp14>MUST</bcp14> be the smaller (MUST-16) of the send MSS
    (that reflects the available reassembly buffer size at the
    remote host, the EMTU_R <xref target="RFC1122" format="default"/>) and the largest transmission size permitted by the IP layer (EMTU_S <xref target="RFC1122" format="default"/>):
          </t>
          <t>
    Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
          </t>
          <t>
    where:
          </t>
          <ul spacing="normal">
            <li>
        SendMSS is the MSS value received from the remote host,
        or the default 536 for IPv4 or 1220 for IPv6, if no MSS Option is received.
        </li>
            <li>
        MMS_S is the maximum size for a transport-layer message
        that TCP may send.
        </li>
            <li>
        TCPhdrsize is the size of the fixed TCP header and any options.  This is 20 in the (rare) case that no options are present but may be larger if TCP Options are to be sent.  Note that some options might not be included on all segments, but that for each segment sent, the sender should adjust the data length accordingly, within the Eff.snd.MSS.
        </li>
            <li>
        IPoptionsize is the size of any IPv4 options or IPv6 extension headers associated with a TCP connection.  Note that some options or extension headers might not be included on all packets, but that for each segment sent, the sender should adjust the data length accordingly, within the Eff.snd.MSS.
        </li>
          </ul>
          <t>
   The MSS value to be sent in an MSS Option should be equal to the
   effective MTU minus the fixed IP and TCP headers.  By ignoring both
   IP and TCP Options when calculating the value for the MSS Option, if
   there are any IP or TCP Options to be sent in a packet, then the
   sender must decrease the size of the TCP data accordingly.  RFC 6691 <xref target="RFC6691" format="default"/>
   discusses this in greater detail.
          </t>
          <t>
    The MSS value to be sent in an MSS Option must be less than
    or equal to:
          </t>
          <t indent="3">
            MMS_R - 20
          </t>
          <t>
    where MMS_R is the maximum size for a transport-layer
    message that can be received (and reassembled at the IP layer) (MUST-67).  TCP obtains
    MMS_R and MMS_S from the IP layer; see the generic call
    GET_MAXSIZES in Section <xref target="RFC1122" section="3.4" sectionFormat="bare" format="default"/> of RFC 1122.  These are defined in terms of their IP MTU equivalents, EMTU_R and EMTU_S <xref target="RFC1122" format="default"/>.
          </t>
          <t>
    When TCP is used in a situation where either the IP or TCP headers
    are not fixed, the sender must reduce the amount of TCP data in
    any given packet by the number of octets used by the IP and TCP
    options.  This has been a point of confusion historically, as explained in RFC 6691, Section <xref target="RFC6691" section="3.1" sectionFormat="bare" format="default"/>.
          </t>
        </section>
        <section anchor="pmtud" numbered="true" toc="default">
          <name>Path MTU Discovery</name>
          <t>A TCP implementation may be aware of the MTU on directly connected links, but will rarely have insight about MTUs across an entire network path.  For IPv4, RFC 1122 recommends an IP-layer default effective MTU of less than or equal to 576 for destinations not directly connected, and for IPv6 this would be 1280.  Using these fixed values limits TCP connection performance and efficiency.  Instead, implementation of Path MTU Discovery (PMTUD) and Packetization Layer Path MTU Discovery (PLPMTUD) is strongly recommended in order for TCP to improve segmentation decisions.  Both PMTUD and PLPMTUD help TCP choose segment sizes that avoid both on-path (for IPv4) and source fragmentation (IPv4 and IPv6).</t>
          <t>PMTUD for IPv4 <xref target="RFC1191" format="default"/> or IPv6 <xref target="RFC8201" format="default"/> is implemented in conjunction between TCP, IP, and ICMP.  It relies both on avoiding source fragmentation and setting the IPv4 DF (don't fragment) flag, the latter to inhibit on-path fragmentation.  It relies on ICMP errors from routers along the path whenever a segment is too large to traverse a link.  Several adjustments to a TCP implementation with PMTUD are described in RFC 2923 in order to deal with problems experienced in practice <xref target="RFC2923" format="default"/>.  PLPMTUD <xref target="RFC4821" format="default"/> is a Standards Track improvement to PMTUD that relaxes the requirement for ICMP support across a path, and improves performance in cases where ICMP is not consistently conveyed, but still tries to avoid source fragmentation.  The mechanisms in all four of these RFCs are recommended to be included in TCP implementations.</t>
          <t>
   The TCP MSS Option specifies an upper bound for the size of packets
   that can be received (see <xref target="RFC6691" format="default"/>).  Hence, setting the value in the MSS Option too
   small can impact the ability for PMTUD or PLPMTUD to find a larger
   path MTU.  RFC 1191 discusses this implication of many older TCP implementations setting the TCP MSS to 536 (corresponding to the IPv4 576 byte default MTU) for non-local destinations, rather than deriving it from the MTUs of connected interfaces as recommended.
          </t>
        </section>
        <section numbered="true" toc="default">
          <name>Interfaces with Variable MTU Values</name>
          <t>
   The effective MTU can sometimes vary, as when used with variable
   compression, e.g., RObust Header Compression (ROHC) <xref target="RFC5795" format="default"/>.  It is
   tempting for a TCP implementation to advertise the largest possible MSS, to
   support the most efficient use of compressed payloads.
   Unfortunately, some compression schemes occasionally need to transmit
   full headers (and thus smaller payloads) to resynchronize state at
   their endpoint compressors/decompressors.  If the largest MTU is used
   to calculate the value to advertise in the MSS Option, TCP
   retransmission may interfere with compressor resynchronization.
          </t>
          <t>
   As a result, when the effective MTU of an interface varies packet-to-packet, TCP implementations
   <bcp14>SHOULD</bcp14> use the smallest effective MTU of the interface to calculate
   the value to advertise in the MSS Option (SHLD-6).
          </t>
        </section>
        <section anchor="nagle" numbered="true" toc="default">
          <name>Nagle Algorithm</name>
          <t>The "Nagle algorithm" was described in RFC 896 <xref target="RFC0896" format="default"/> and was recommended in RFC 1122 <xref target="RFC1122" format="default"/> for mitigation of an early problem of too many small packets being generated.  It has been implemented in most current TCP code bases, sometimes with minor variations (see <xref target="minshall" format="default"/>).</t>
          <t>If there is unacknowledged data (i.e., SND.NXT &gt; SND.UNA), then the sending TCP endpoint buffers all user data (regardless of the PSH bit) until the outstanding data has been acknowledged or until the TCP endpoint can send a full-sized segment (Eff.snd.MSS bytes).</t>
          <t>A TCP implementation <bcp14>SHOULD</bcp14> implement the Nagle algorithm to coalesce short segments (SHLD-7).  However, there <bcp14>MUST</bcp14> be a way for an application to disable the Nagle algorithm on an individual connection (MUST-17).  In all cases, sending data is also subject to the limitation imposed by the slow start algorithm <xref target="RFC5681" format="default"/>.</t>
          <t>
    Since there can be problematic interactions between the Nagle algorithm and delayed acknowledgments, some implementations use minor variations of the Nagle algorithm, such as the one described in <xref target="minshall" format="default"/>.
          </t>
        </section>
        <section numbered="true" toc="default">
          <name>IPv6 Jumbograms</name>
          <t>
   In order to support TCP over IPv6 Jumbograms, implementations need to
   be able to send TCP segments larger than the 64-KB limit that the MSS Option can convey.  RFC 2675 <xref target="RFC2675" format="default"/>
   defines that an MSS value of 65,535 bytes is to be treated as infinity, and Path
   MTU Discovery <xref target="RFC8201" format="default"/> is used to determine the actual MSS.
          </t>
          <t>
   The Jumbo Payload Option need not be implemented or understood by IPv6 nodes that do not support attachment to links with an MTU greater than 65,575 <xref target="RFC2675" format="default"/>, and the present IPv6 Node Requirements does not include support for Jumbograms <xref target="RFC8504" format="default"/>.
          </t>
        </section>
      </section>
      <section anchor="datacomm" numbered="true" toc="default">
        <name>Data Communication</name>
        <t>
  Once the connection is established, data is communicated by the
  exchange of segments.  Because segments may be lost due to errors
  (checksum test failure) or network congestion, TCP uses
  retransmission to ensure delivery of every segment.
  Duplicate segments may arrive due to network or TCP retransmission.
  As discussed in the section on sequence numbers (<xref target="sequence-numbers"/>), the TCP implementation performs
  certain tests on the sequence and acknowledgment numbers in the
  segments to verify their acceptability.
</t>
        <t>
  The sender of data keeps track of the next sequence number to use in
  the variable SND.NXT.  The receiver of data keeps track of the next
  sequence number to expect in the variable RCV.NXT.  The sender of data
  keeps track of the oldest unacknowledged sequence number in the
  variable SND.UNA.  If the data flow is momentarily idle and all data
  sent has been acknowledged, then the three variables will be equal.
</t>
        <t>
  When the sender creates a segment and transmits it, the sender advances
  SND.NXT.  When the receiver accepts a segment, it advances RCV.NXT and
  sends an acknowledgment.  When the data sender receives an
  acknowledgment, it advances SND.UNA.  The extent to which the values of
  these variables differ is a measure of the delay in the communication.
  The amount by which the variables are advanced is the length of the
  data and SYN or FIN flags in the segment.  Note that, once in the ESTABLISHED state, all
  segments must carry current acknowledgment information.
</t>
        <t>
  The CLOSE user call implies a push function (see <xref target="user-api" format="default"/>), as does the FIN control
  flag in an incoming segment.
</t>
        <section anchor="RTO" numbered="true" toc="default">
          <name>Retransmission Timeout</name>
          <t>
  Because of the variability of the networks that compose an
  internetwork system and the wide range of uses of TCP connections, the
  retransmission timeout (RTO) must be dynamically determined.
</t>
          <t>
      The RTO <bcp14>MUST</bcp14> be computed according to the
      algorithm in <xref target="RFC6298" format="default"/>, including Karn's algorithm for taking RTT samples (MUST-18).
</t>
          <t>
      RFC 793 contains an early example procedure for computing the RTO, based on work mentioned in IEN 177 <xref target="IEN177" format="default"/>.  This was then replaced by the algorithm described in RFC 1122, which was subsequently updated in RFC 2988 and then again in RFC 6298.
</t>
          <t>
RFC 1122 allows that if a retransmitted packet is identical to the original
packet (which implies not only that the data boundaries have not changed, but
also that none of the headers have changed), then the same IPv4 Identification
field <bcp14>MAY</bcp14> be used (see Section <xref target="RFC1122" section="3.2.1.5" sectionFormat="bare" format="default"/> of RFC 1122) (MAY-4).  The same IP
Identification field may be reused anyways since it is only meaningful when a
datagram is fragmented <xref target="RFC6864" format="default"/>.  TCP implementations should not rely on or typically
interact with this IPv4 header field in any way.  It is not a reasonable way to
indicate duplicate sent segments nor to identify duplicate received
segments.
</t>
        </section>
        <section numbered="true" toc="default">
          <name>TCP Congestion Control</name>
          <t>RFC 2914 <xref target="RFC2914" format="default"/> explains the importance of congestion control for the Internet.</t>
          <t>RFC 1122 required implementation of Van Jacobson's congestion control algorithms slow start and congestion avoidance together with exponential backoff for successive RTO values for the same segment.  RFC 2581 provided IETF Standards Track description of slow start and congestion avoidance, along with fast retransmit and fast recovery.  RFC 5681 is the current description of these algorithms and is the current Standards Track specification providing guidelines for TCP congestion control. RFC 6298 describes exponential backoff of RTO values, including keeping the backed-off value until a subsequent segment with new data has been sent and acknowledged without retransmission.</t>
          <t>A TCP endpoint <bcp14>MUST</bcp14> implement the basic congestion control algorithms slow start, congestion avoidance, and exponential backoff of RTO to avoid creating congestion collapse conditions (MUST-19).  RFC 5681 and RFC 6298 describe the basic algorithms on the IETF Standards Track that are broadly applicable.  Multiple other suitable algorithms exist and have been widely used.  Many TCP implementations support a set of alternative algorithms that can be configured for use on the endpoint.  An endpoint <bcp14>MAY</bcp14> implement such alternative algorithms provided that the algorithms are conformant with the TCP specifications from the IETF Standards Track as described in RFC 2914, RFC 5033 <xref target="RFC5033" format="default"/>, and RFC 8961 <xref target="RFC8961" format="default"/> (MAY-18).</t>
          <t>Explicit Congestion Notification (ECN) was defined in RFC 3168 and is an IETF Standards Track enhancement that has many benefits <xref target="RFC8087" format="default"/>.</t>
          <t>A TCP endpoint <bcp14>SHOULD</bcp14> implement ECN as described in RFC 3168 (SHLD-8).</t>
        </section>
        <section anchor="connfail" numbered="true" toc="default">
          <name>TCP Connection Failures</name>
          <t>
            Excessive retransmission of the same segment by a TCP endpoint
            indicates some failure of the remote host or the internetwork
            path.  This failure may be of short or long duration.  The
            following procedure <bcp14>MUST</bcp14> be used to handle excessive
            retransmissions of data segments (MUST-20):
</t>
          <ol type="(%c)" spacing="normal">
            <li>
                 There are two thresholds R1 and R2 measuring the amount
                 of retransmission that has occurred for the same
                 segment.  R1 and R2 might be measured in time units or
                 as a count of retransmissions (with the current RTO and
		 corresponding backoffs as a conversion factor, if needed).
</li>
            <li>
                 When the number of transmissions of the same segment
                 reaches or exceeds threshold R1, pass negative advice
                 (see <xref target="RFC1122" section="3.3.1.4" sectionFormat="of" format="default"/>) to the IP layer, to trigger
                 dead-gateway diagnosis.
</li>
            <li>
                 When the number of transmissions of the same segment
                 reaches a threshold R2 greater than R1, close the
                 connection.
</li>
            <li>
                 An application <bcp14>MUST</bcp14> (MUST-21) be able to set the value for R2 for
                 a particular connection.  For example, an interactive
                 application might set R2 to "infinity", giving the user
                 control over when to disconnect.
</li>
            <li>
                 TCP implementations <bcp14>SHOULD</bcp14> inform the application of the delivery
                 problem (unless such information has been disabled by
                 the application; see the "Asynchronous Reports" section (<xref target="asynchronous-reports"/>)), when R1 is
                 reached and before R2 (SHLD-9).  This will allow a remote login
                 application program to inform the user,
                 for example.
</li>
          </ol>
          <t>
            The value of R1 <bcp14>SHOULD</bcp14> correspond to at least 3
            retransmissions, at the current RTO (SHLD-10).  The value of R2 <bcp14>SHOULD</bcp14>
            correspond to at least 100 seconds (SHLD-11).
</t>
          <t>
            An attempt to open a TCP connection could fail with
            excessive retransmissions of the SYN segment or by receipt
            of a RST segment or an ICMP Port Unreachable.  SYN
            retransmissions <bcp14>MUST</bcp14> be handled in the general way just
            described for data retransmissions, including notification
            of the application layer.
</t>
          <t>
            However, the values of R1 and R2 may be different for SYN
            and data segments.  In particular, R2 for a SYN segment <bcp14>MUST</bcp14>
            be set large enough to provide retransmission of the segment
            for at least 3 minutes (MUST-23).  The application can close the
            connection (i.e., give up on the open attempt) sooner, of
            course.
</t>
        </section>
        <section numbered="true" toc="default">
          <name>TCP Keep-Alives</name>
          <t>

            A TCP connection is said to be "idle" if for some long
            amount of time there have been no incoming segments received and
            there is no new or unacknowledged data to be sent.

</t>
          <t>
	    Implementers <bcp14>MAY</bcp14> include "keep-alives" in their TCP implementations
	    (MAY-5), although this practice is not universally accepted. Some
	    TCP implementations, however, have included a keep-alive mechanism.
	    To confirm that an idle connection is still active, these
	    implementations send a probe segment designed to elicit a response
	    from the TCP peer.  Such a segment generally contains SEG.SEQ =
	    SND.NXT-1 and may or may not contain one garbage octet of data.
	    If keep-alives are included, the application <bcp14>MUST</bcp14> be able to turn
	    them on or off for each TCP connection (MUST-24), and they <bcp14>MUST</bcp14>
	    default to off (MUST-25).
</t>
          <t>
            Keep-alive packets <bcp14>MUST</bcp14> only be sent when no sent data is outstanding,
	    and no data or
            acknowledgment packets have been received for the
            connection within an interval (MUST-26).  This interval <bcp14>MUST</bcp14> be
            configurable (MUST-27) and <bcp14>MUST</bcp14> default to no less than two hours (MUST-28).
</t>
          <t>
            It is extremely important to remember that ACK segments that
            contain no data are not reliably transmitted by TCP.
            Consequently, if a keep-alive mechanism is implemented it
            <bcp14>MUST NOT</bcp14> interpret failure to respond to any specific probe
            as a dead connection (MUST-29).
</t>
          <t>
            An implementation <bcp14>SHOULD</bcp14> send a keep-alive segment with no
            data (SHLD-12); however, it <bcp14>MAY</bcp14> be configurable to send a keep-alive
            segment containing one garbage octet (MAY-6), for compatibility with
            erroneous TCP implementations.
</t>
        </section>
        <section anchor="urgent" numbered="true" toc="default">
          <name>The Communication of Urgent Information</name>
          <t>
  As a result of implementation differences and middlebox interactions, new applications <bcp14>SHOULD NOT</bcp14> employ the TCP urgent mechanism (SHLD-13).  However, TCP implementations <bcp14>MUST</bcp14> still include support for the urgent mechanism (MUST-30).  Information on how some TCP implementations interpret the urgent pointer can be found in RFC 6093 <xref target="RFC6093" format="default"/>.
</t>
          <t>
  The objective of the TCP urgent mechanism is to allow the sending user
  to stimulate the receiving user to accept some urgent data and to
  permit the receiving TCP endpoint to indicate to the receiving user when all
  the currently known urgent data has been received by the user.
</t>
          <t>
  This mechanism permits a point in the data stream to be designated as
  the end of urgent information.  Whenever this point is in advance of
  the receive sequence number (RCV.NXT) at the receiving TCP endpoint, then the TCP implementation
  must tell the user to go into "urgent mode"; when the receive sequence
  number catches up to the urgent pointer, the TCP implementation must tell user to go
  into "normal mode".  If the urgent pointer is updated while the user
  is in "urgent mode", the update will be invisible to the user.
</t>
          <t>
  The method employs an urgent field that is carried in all segments
  transmitted.  The URG control flag indicates that the urgent field is
  meaningful and must be added to the segment sequence number to yield
  the urgent pointer.  The absence of this flag indicates that there is
  no urgent data outstanding.
</t>
          <t>
  To send an urgent indication, the user must also send at least one data
  octet.  If the sending user also indicates a push, timely delivery of
  the urgent information to the destination process is enhanced.  Note that because changes in the urgent pointer correspond to data being written by a sending application, the urgent pointer cannot "recede" in the sequence space, but a TCP receiver should be robust to invalid urgent pointer values.
</t>
          <t>
  A TCP implementation <bcp14>MUST</bcp14> support a sequence of urgent data of any length (MUST-31) <xref target="RFC1122" format="default"/>.
          </t>
          <t>
The urgent pointer <bcp14>MUST</bcp14> point to the sequence number of the octet following the urgent data (MUST-62).
</t>
          <t>
  A TCP implementation <bcp14>MUST</bcp14> (MUST-32) inform the application layer asynchronously whenever it receives an urgent pointer and there was previously no pending urgent data, or whenever the urgent pointer advances in the data stream.  The TCP implementation <bcp14>MUST</bcp14> (MUST-33) provide a way for the application to learn how much urgent data remains to be read from the connection, or at least to determine whether more urgent data remains to be read <xref target="RFC1122" format="default"/>.
</t>
        </section>
        <section numbered="true" toc="default">
          <name>Managing the Window</name>
          <t>
  The window sent in each segment indicates the range of sequence
  numbers the sender of the window (the data receiver) is currently
  prepared to accept.  There is an assumption that this is related to
  the data buffer space currently available for this
  connection.
</t>
          <t>
  The sending TCP endpoint packages the data to be transmitted into segments
  that fit the current window, and may repackage segments on the
  retransmission queue.  Such repackaging is not required but may be
  helpful.
</t>
          <t>
  In a connection with a one-way data flow, the window information will
  be carried in acknowledgment segments that all have the same sequence
  number, so there will be no way to reorder them if they arrive out of
  order.  This is not a serious problem, but it will allow the window
  information to be on occasion temporarily based on old reports from
  the data receiver.  A refinement to avoid this problem is to act on
  the window information from segments that carry the highest
  acknowledgment number (that is, segments with an acknowledgment number
  equal to or greater than the highest previously received).
</t>
          <t>
  Indicating a large window encourages transmissions.  If more data
  arrives than can be accepted, it will be discarded.  This will result
  in excessive retransmissions, adding unnecessarily to the load on the
  network and the TCP endpoints.  Indicating a small window may restrict the
  transmission of data to the point of introducing a round-trip delay
  between each new segment transmitted.
</t>
          <t>
  The mechanisms provided allow a TCP endpoint to advertise a large window and to
  subsequently advertise a much smaller window without having accepted
  that much data.  This so-called "shrinking the window" is strongly
  discouraged.  The robustness principle <xref target="RFC1122" format="default"/> dictates that TCP peers will not
  shrink the window themselves, but will be prepared for such behavior
  on the part of other TCP peers.
</t>
          <t>
  A TCP receiver <bcp14>SHOULD NOT</bcp14> shrink the window, i.e., move the
  right window edge to the left (SHLD-14).  However, a sending TCP peer <bcp14>MUST</bcp14>
  be robust against window shrinking, which may cause the
  "usable window" (see <xref target="SWSsender" format="default"/>) to become negative (MUST-34).
</t>
          <t>
  If this happens, the sender <bcp14>SHOULD NOT</bcp14> send new data (SHLD-15), but
  <bcp14>SHOULD</bcp14> retransmit normally the old unacknowledged data
  between SND.UNA and SND.UNA+SND.WND (SHLD-16).  The sender <bcp14>MAY</bcp14> also
  retransmit old data beyond SND.UNA+SND.WND (MAY-7), but <bcp14>SHOULD NOT</bcp14>
  time out the connection if data beyond the right window edge
  is not acknowledged (SHLD-17).  If the window shrinks to zero, the TCP implementation
  <bcp14>MUST</bcp14> probe it in the standard way (described below) (MUST-35).
</t>
          <section anchor="zwp" numbered="true" toc="default">
            <name>Zero-Window Probing</name>
            <t>

  The sending TCP peer must regularly transmit at least one octet of new data
  (if available), or retransmit to the receiving TCP peer even if the send
  window is zero, in order to "probe" the window.  This
  retransmission is essential to guarantee that when either TCP peer has a zero
  window the reopening of the window will be reliably reported to the other.
  This is referred to as Zero-Window Probing (ZWP) in other documents.

</t>
            <t>
  Probing of zero (offered) windows <bcp14>MUST</bcp14> be supported (MUST-36).
</t>
            <t>
  A TCP implementation <bcp14>MAY</bcp14> keep its offered receive window closed
  indefinitely (MAY-8).  As long as the receiving TCP peer continues to
  send acknowledgments in response to the probe segments, the
  sending TCP peer <bcp14>MUST</bcp14> allow the connection to stay open (MUST-37).  This
  enables TCP to function in scenarios such as the "printer
  ran out of paper" situation described in 
  <xref target="RFC1122" section="4.2.2.17" sectionFormat="of" format="default"/>.  The behavior is subject to the implementation's resource
  management concerns, as noted in <xref target="RFC6429" format="default"/>.

</t>
            <t>
  When the receiving TCP peer has a zero window and a segment arrives, it must
  still send an acknowledgment showing its next expected sequence number
  and current window (zero).
</t>
            <t>

The transmitting host <bcp14>SHOULD</bcp14> send the first zero-window probe when a zero
window has existed for the retransmission timeout period (SHLD-29) (<xref target="RTO" format="default"/>), and <bcp14>SHOULD</bcp14> increase exponentially the interval between
successive probes (SHLD-30).

</t>
          </section>
          <section numbered="true" toc="default">
            <name>Silly Window Syndrome Avoidance</name>
            <t>The "Silly Window Syndrome" (SWS) is a stable pattern of small incremental window movements resulting in extremely poor TCP performance.  Algorithms to avoid SWS are described below for both the sending side and the receiving side.  RFC 1122 contains more detailed discussion of the SWS problem.  Note that the Nagle algorithm and the sender SWS avoidance algorithm play complementary roles in improving performance.  The Nagle algorithm discourages sending tiny segments when the data to be sent increases in small increments, while the SWS avoidance algorithm discourages small segments resulting from the right window edge advancing in small increments.</t>
            <section anchor="SWSsender" numbered="true" toc="default">
              <name>Sender's Algorithm -- When to Send Data</name>
              <t>
            A TCP implementation <bcp14>MUST</bcp14> include a SWS avoidance algorithm in the sender (MUST-38).
</t>
              <t>
The Nagle algorithm from <xref target="nagle" format="default"/> additionally describes how to coalesce short segments.
</t>
              <t>
            The sender's SWS avoidance algorithm is more difficult
            than the receiver's because the sender does not know
            (directly) the receiver's total buffer space (RCV.BUFF).
            An approach that has been found to work well is for
            the sender to calculate Max(SND.WND), which is the maximum send
            window it has seen so far on the connection, and to use
            this value as an estimate of RCV.BUFF.  Unfortunately,
            this can only be an estimate; the receiver may at any
            time reduce the size of RCV.BUFF.  To avoid a resulting
            deadlock, it is necessary to have a timeout to force
            transmission of data, overriding the SWS avoidance
            algorithm.  In practice, this timeout should seldom
            occur.
</t>
              <t>
            The "usable window" is:</t>

                   <t indent="3">U = SND.UNA + SND.WND - SND.NXT</t>
              
              <t>

            i.e., the offered window less the amount of data sent
            but not acknowledged.  If D is the amount of data
            queued in the sending TCP endpoint but not yet sent, then the
            following set of rules is recommended.
</t>
              <t>
            Send data:</t>
              <ol type="(%d)" spacing="normal">
                <li>
                  <t>
            if a maximum-sized segment can be sent, i.e., if:</t>
                  <t indent="3"> 

            min(D,U) &gt;= Eff.snd.MSS;</t>
                </li>
                <li> 
                  <t>
             or if the data is pushed and all queued data can
             be sent now, i.e., if:</t>
                  <t indent="3"> 

                 [SND.NXT = SND.UNA and] PUSHed and D &lt;= U
                  </t>
                  <t> 
             (the bracketed condition is imposed by the Nagle
             algorithm);
                  </t>
                </li>
                <li>
                  <t> 
             or if at least a fraction Fs of the maximum window
             can be sent, i.e., if:</t>
                  <t indent="3">

                 [SND.NXT = SND.UNA and]</t>    
                  <t indent="6">
  
                         min(D,U) &gt;= Fs * Max(SND.WND);</t>
                 </li>   
                 <li>
             or if the override timeout
             occurs.</li>
              </ol>
              <t>
            Here Fs is a fraction whose recommended value is 1/2.
            The override timeout should be in the range 0.1 - 1.0
            seconds.  It may be convenient to combine this timer
            with the timer used to probe zero windows
            (<xref target="zwp" format="default"/>).
</t>
            </section>
            <section numbered="true" toc="default">
              <name>Receiver's Algorithm -- When to Send a Window Update</name>
              <t>
            A TCP implementation <bcp14>MUST</bcp14> include a SWS avoidance algorithm in the receiver (MUST-39).
</t>
              <t>
            The receiver's SWS avoidance algorithm determines when
            the right window edge may be advanced; this is
            customarily known as "updating the window".  This
            algorithm combines with the delayed ACK algorithm
            (<xref target="delACK" format="default"/>) to determine when an ACK segment
            containing the current window will really be sent to
            the receiver. 
</t>
              <t>
            The solution to receiver SWS is to avoid advancing the
            right window edge RCV.NXT+RCV.WND in small increments,
            even if data is received from the network in small
            segments.
</t>
              <t>
            Suppose the total receive buffer space is RCV.BUFF.  At
            any given moment, RCV.USER octets of this total may be
            tied up with data that has been received and
            acknowledged but that the user process has not yet
            consumed.  When the connection is quiescent, RCV.WND =
            RCV.BUFF and RCV.USER = 0.
</t>
              <t>
            Keeping the right window edge fixed as data arrives and
            is acknowledged requires that the receiver offer less
            than its full buffer space, i.e., the receiver must
            specify a RCV.WND that keeps RCV.NXT+RCV.WND constant
            as RCV.NXT increases.  Thus, the total buffer space
            RCV.BUFF is generally divided into three parts:
</t>
              <artwork name="" type="" align="left" alt=""><![CDATA[
               |<------- RCV.BUFF ---------------->|
                    1             2            3
           ----|---------|------------------|------|----
                      RCV.NXT               ^
                                         (Fixed)

           1 - RCV.USER =  data received but not yet consumed;
           2 - RCV.WND =   space advertised to sender;
           3 - Reduction = space available but not yet
                           advertised.
]]></artwork>
              <t>
          The suggested SWS avoidance algorithm for the receiver
          is to keep RCV.NXT+RCV.WND fixed until the reduction
          satisfies:
</t>
              <artwork name="" type="" align="left" alt=""><![CDATA[
             RCV.BUFF - RCV.USER - RCV.WND  >=

                    min( Fr * RCV.BUFF, Eff.snd.MSS )
]]></artwork>
              <t>
            where Fr is a fraction whose recommended value is 1/2,
            and Eff.snd.MSS is the effective send MSS for the
            connection (see <xref target="mss" format="default"/>).  When the inequality
            is satisfied, RCV.WND is set to RCV.BUFF-RCV.USER.
</t>
              <t>
            Note that the general effect of this algorithm is to
            advance RCV.WND in increments of Eff.snd.MSS (for
            realistic receive buffers:  Eff.snd.MSS &lt; RCV.BUFF/2).
            Note also that the receiver must use its own
            Eff.snd.MSS, making the assumption that it is the same as the sender's.
</t>
            </section>
          </section>
          <section anchor="delACK" numbered="true" toc="default">
            <name>Delayed Acknowledgments -- When to Send an ACK Segment</name>
            <t>
            A host that is receiving a stream of TCP data segments can
            increase efficiency in both the network and the hosts by
            sending fewer than one ACK (acknowledgment) segment per data
            segment received; this is known as a "delayed ACK".
</t>
            <t>
	    A TCP endpoint <bcp14>SHOULD</bcp14> implement a delayed ACK (SHLD-18), but an ACK
	    should not be excessively delayed; in particular, the delay <bcp14>MUST</bcp14> be
	    less than 0.5 seconds (MUST-40).  An ACK <bcp14>SHOULD</bcp14> be generated for at
	    least every second full-sized segment or 2*RMSS bytes of new data
	    (where RMSS is the MSS specified by the TCP endpoint receiving the
	    segments to be acknowledged, or the default value if not specified)
	    (SHLD-19). Excessive delays on ACKs can disturb the round-trip
	    timing and packet "clocking" algorithms.  More complete
	    discussion of delayed ACK behavior is in Section <xref target="RFC5681" section="4.2" sectionFormat="bare" format="default"/> of RFC 5681
	    <xref target="RFC5681" format="default"/>, including recommendations to immediately
	    acknowledge out-of-order segments, segments above a gap in sequence
	    space, or segments that fill all or part of a gap, in order to
	    accelerate loss recovery.
</t>
            <t>
	    Note that there are several current
	    practices that further lead to a reduced number of ACKs, including
	    generic receive offload (GRO) <xref target="offload" format="default"/>, ACK compression, and ACK decimation
	    <xref target="RFC3449" format="default"/>. 
</t>
          </section>
        </section>
      </section>
      <section numbered="true" toc="default">
        <name>Interfaces</name>
        <t>
  There are of course two interfaces of concern:  the user/TCP interface
  and the TCP/lower-level interface.  We have a fairly elaborate model
  of the user/TCP interface, but the interface to the lower-level
  protocol module is left unspecified here since it will be specified
  in detail by the specification of the lower-level protocol.  For the
  case that the lower level is IP, we note some of the parameter values
  that TCP implementations might use.
</t>
        <section anchor="user-api" numbered="true" toc="default">
          <name>User/TCP Interface</name>
          <t>
    The following functional description of user commands to the TCP implementation is,
    at best, fictional, since every operating system will have different
    facilities.  Consequently, we must warn readers that different TCP
    implementations may have different user interfaces.  However, all
    TCP implementations must provide a certain minimum set of services to guarantee
    that all TCP implementations can support the same protocol
    hierarchy.  This section specifies the functional interfaces
    required of all TCP implementations.
</t>
          <t>
<xref target="RFC8303" section="3.1" sectionFormat="of" format="default"/> also identifies primitives provided by TCP and could be used as an additional reference for implementers.
</t>
          <t>
      The following sections functionally characterize a user/TCP
      interface.  The notation used is similar to most procedure or
      function calls in high-level languages, but this usage is not
      meant to rule out trap-type service calls.
</t>
          <t>
      The user commands described below specify the basic functions the
      TCP implementation must perform to support interprocess communication.
      Individual implementations must define their own exact format and
      may provide combinations or subsets of the basic functions in
      single calls.  In particular, some implementations may wish to
      automatically OPEN a connection on the first SEND or RECEIVE
      issued by the user for a given connection.
</t>
          <t>
      In providing interprocess communication facilities, the TCP implementation must
      not only accept commands, but must also return information to the
      processes it serves.  The latter consists of:
          </t>
          <ol type="(%c)" spacing="normal">
            <li>
        general information about a connection (e.g., interrupts,
        remote close, binding of unspecified remote socket).
        </li>
            <li>
        replies to specific user commands indicating success or
        various types of failure.
        </li>
          </ol>
<section numbered="true" toc="default">
            <name>Open</name>
              <t>
        Format:  OPEN (local port, remote socket, active/passive
        [, timeout] [, Diffserv field] [, security/compartment]
        [, local IP address] [, options])
        -&gt; local connection name
</t>
              <t>
        If the active/passive flag is set to passive, then this is a
        call to LISTEN for an incoming connection.  A passive OPEN may
        have either a fully specified remote socket to wait for a
        particular connection or an unspecified remote socket to wait
        for any call.  A fully specified passive call can be made active
        by the subsequent execution of a SEND.
</t>
              <t>
        A transmission control block (TCB) is created and partially
        filled in with data from the OPEN command parameters.
</t>
              <t>
        Every passive OPEN call either creates a new connection
        record in LISTEN state, or it returns an error; it <bcp14>MUST NOT</bcp14>
        affect any previously created connection record (MUST-41).
</t>
              <t>
        A TCP implementation that supports multiple concurrent connections <bcp14>MUST</bcp14> provide
        an OPEN call that will functionally allow an application to
        LISTEN on a port while a connection block with the same
        local port is in SYN-SENT or SYN-RECEIVED state (MUST-42).
</t>
              <t>
        On an active OPEN command, the TCP endpoint will begin the procedure to
        synchronize (i.e., establish) the connection at once.
</t>
              <t>
        The timeout, if present, permits the caller to set up a timeout
        for all data submitted to TCP.  If data is not successfully
        delivered to the destination within the timeout period, the TCP endpoint
        will abort the connection.  The present global default is five
        minutes.
</t>
              <t>
        The TCP implementation or some component of the operating system will verify
        the user's authority to open a connection with the specified
        Diffserv field value or security/compartment.  The absence of a
	Diffserv field value
        or security/compartment specification in the OPEN call indicates
        the default values must be used.
</t>
              <t>
        TCP will accept incoming requests as matching only if the
        security/compartment information is exactly the same as that
        requested in the OPEN call.
</t>
              <t>
The Diffserv field value indicated by the user only impacts outgoing packets, may be altered en route through the network, and has no direct bearing or relation to received packets.
</t>
              <t>
        A local connection name will be returned to the user by the TCP implementation.
        The local connection name can then be used as a shorthand term
        for the connection defined by the &lt;local socket, remote socket&gt;
        pair.
</t>
              <t>
	The optional "local IP address" parameter <bcp14>MUST</bcp14> be supported
        to allow the specification of the local IP address (MUST-43).  This enables
        applications that need to select the local IP address used when
        multihoming is present. 
</t>
              <t>
        A passive OPEN call with a specified "local IP address"
        parameter will await an incoming connection request to
        that address.  If the parameter is unspecified, a
        passive OPEN will await an incoming connection request
        to any local IP address and then bind the local IP
        address of the connection to the particular address
        that is used.
</t>
              <t>
For an active OPEN call, a specified "local IP address" parameter
will be used for opening the connection.  If the parameter is unspecified, the
host will choose an appropriate local IP address (see RFC 1122, Section <xref target="RFC1122" section="3.3.4.2" sectionFormat="bare" format="default"/>).
</t>
              <t>
        If an application on a multihomed host does not specify the
        local IP address when actively opening a TCP connection,
        then the TCP implementation <bcp14>MUST</bcp14> ask the IP layer to select a local IP
        address before sending the (first) SYN (MUST-44).  See the function
        GET_SRCADDR() in Section <xref target="RFC1122" section="3.4" sectionFormat="bare" format="default"/> of RFC 1122.
</t>
              <t>
        At all other times, a previous segment has either been sent
        or received on this connection, and TCP implementations <bcp14>MUST</bcp14> use the same
        local address that was used in those previous
        segments (MUST-45).
</t>
              <t>
            A TCP implementation <bcp14>MUST</bcp14> reject as an error a local OPEN
            call for an invalid remote IP address (e.g., a broadcast or
            multicast address) (MUST-46).
</t>
          
          </section>
          <section numbered="true" toc="default">
            <name>Send</name>
              <t>
        Format:  SEND (local connection name, buffer address, byte
        count, URGENT flag [, PUSH flag] [, timeout])
</t>
              <t>
        This call causes the data contained in the indicated user buffer
        to be sent on the indicated connection.  If the connection has
        not been opened, the SEND is considered an error.  Some
        implementations may allow users to SEND first; in which case, an
        automatic OPEN would be done.  For example, this might be one way
	for application data to be included in SYN segments. If the calling process is not
        authorized to use this connection, an error is returned.
</t>
              <t>

A TCP endpoint <bcp14>MAY</bcp14> implement PUSH flags on SEND calls (MAY-15).  If PUSH flags are not
implemented, then the sending TCP peer: (1) <bcp14>MUST NOT</bcp14> buffer data indefinitely (MUST-60), and
(2) <bcp14>MUST</bcp14> set the PSH bit in the last buffered segment (i.e., when there is no
more queued data to be sent) (MUST-61).  The remaining description below assumes the PUSH
flag is supported on SEND calls.

</t>
              <t>

If the PUSH flag is set, the application intends the data to be
transmitted promptly to the receiver, and the PSH bit will be set in the last
TCP segment created from the buffer.

</t>
              <t>

The PSH bit is not a record marker and is independent of segment boundaries.
The transmitter <bcp14>SHOULD</bcp14> collapse successive bits when it packetizes data, to
send the largest possible segment (SHLD-27).

</t>
              <t>

If the PUSH flag is not set, the data may be combined with data from
subsequent SENDs for transmission efficiency.
When an application issues a series of
SEND calls without setting the PUSH flag, the TCP implementation <bcp14>MAY</bcp14> aggregate the data
internally without sending it (MAY-16).
Note that when the Nagle
algorithm is in use, TCP implementations may buffer the data before sending, without regard to
the PUSH flag (see <xref target="nagle" format="default"/>).


</t>
              <t>

An application program is logically required to set the PUSH flag in a SEND
call whenever it needs to force delivery of the data to avoid a communication
deadlock.  However, a TCP implementation <bcp14>SHOULD</bcp14> send a maximum-sized segment whenever
possible (SHLD-28) to improve performance (see <xref target="SWSsender" format="default"/>).

</t>
              <t>
        New applications <bcp14>SHOULD NOT</bcp14> set the URGENT flag <xref target="RFC6093" format="default"/> due to implementation differences and middlebox issues (SHLD-13).
</t>
              <t>
        If the URGENT flag is set, segments sent to the destination TCP peer
        will have the urgent pointer set.  The receiving TCP peer will signal
        the urgent condition to the receiving process if the urgent
        pointer indicates that data preceding the urgent pointer has not
        been consumed by the receiving process.  The purpose of the URGENT flag 
        is to stimulate the receiver to process the urgent data and to
        indicate to the receiver when all the currently known urgent
        data has been received.  The number of times the sending user's
        TCP implementation signals urgent will not necessarily be equal to the number
        of times the receiving user will be notified of the presence of
        urgent data.
</t>
              <t>
        If no remote socket was specified in the OPEN, but the
        connection is established (e.g., because a LISTENing connection
        has become specific due to a remote segment arriving for the
        local socket), then the designated buffer is sent to the implied
        remote socket.  Users who make use of OPEN with an unspecified
        remote socket can make use of SEND without ever explicitly
        knowing the remote socket address.
</t>
              <t>
        However, if a SEND is attempted before the remote socket
        becomes specified, an error will be returned.  Users can use the
        STATUS call to determine the status of the connection.  Some
        TCP implementations may notify the user when an unspecified
        socket is bound.
</t>
              <t>
        If a timeout is specified, the current user timeout for this
        connection is changed to the new one.
</t>
              <t>
        In the simplest implementation, SEND would not return control to
        the sending process until either the transmission was complete
        or the timeout had been exceeded.  However, this simple method
        is both subject to deadlocks (for example, both sides of the
        connection might try to do SENDs before doing any RECEIVEs) and
        offers poor performance, so it is not recommended.  A more
        sophisticated implementation would return immediately to allow
        the process to run concurrently with network I/O, and,
        furthermore, to allow multiple SENDs to be in progress.
        Multiple SENDs are served in first come, first served order, so
        the TCP endpoint will queue those it cannot service immediately.
</t>
              <t>
        We have implicitly assumed an asynchronous user interface in
        which a SEND later elicits some kind of SIGNAL or
        pseudo-interrupt from the serving TCP endpoint.  An alternative is to
        return a response immediately.  For instance, SENDs might return
        immediate local acknowledgment, even if the segment sent had not
        been acknowledged by the distant TCP endpoint.  We could optimistically
        assume eventual success.  If we are wrong, the connection will
        close anyway due to the timeout.  In implementations of this
        kind (synchronous), there will still be some asynchronous
        signals, but these will deal with the connection itself, and not
        with specific segments or buffers.
</t>
              <t>
        In order for the process to distinguish among error or success
        indications for different SENDs, it might be appropriate for the
        buffer address to be returned along with the coded response to
        the SEND request.  TCP-to-user signals are discussed below,
        indicating the information that should be returned to the
        calling process.
</t>
          
          </section>
          <section numbered="true" toc="default">
            <name>Receive</name>
          
              <t>
        Format:  RECEIVE (local connection name, buffer address, byte
        count) -&gt; byte count, URGENT flag [, PUSH flag]
</t>
              <t>
        This command allocates a receiving buffer associated with the
        specified connection.  If no OPEN precedes this command or the
        calling process is not authorized to use this connection, an
        error is returned.
</t>
              <t>
        In the simplest implementation, control would not return to the
        calling program until either the buffer was filled or some
        error occurred, but this scheme is highly subject to deadlocks.
        A more sophisticated implementation would permit several
        RECEIVEs to be outstanding at once.  These would be filled as
        segments arrive.  This strategy permits increased throughput at
        the cost of a more elaborate scheme (possibly asynchronous) to
        notify the calling program that a PUSH has been seen or a buffer
        filled.
</t>

              <t>

A TCP receiver <bcp14>MAY</bcp14> pass a received PSH bit to the application layer via the
PUSH flag in the interface (MAY-17), but it is not required (this was clarified in RFC
1122, Section <xref target="RFC1122" section="4.2.2.2" sectionFormat="bare" format="default"/>).  The remainder of text describing the RECEIVE call below
assumes that passing the PUSH indication is supported.

</t>
              <t>
        If enough data arrive to fill the buffer before a PUSH is seen,
        the PUSH flag will not be set in the response to the RECEIVE.
        The buffer will be filled with as much data as it can hold.  If
        a PUSH is seen before the buffer is filled, the buffer will be
        returned partially filled and PUSH indicated.
</t>
              <t>
        If there is urgent data, the user will have been informed as soon
        as it arrived via a TCP-to-user signal.  The receiving user
        should thus be in "urgent mode".  If the URGENT flag is on,
        additional urgent data remains.  If the URGENT flag is off, this
        call to RECEIVE has returned all the urgent data, and the user
        may now leave "urgent mode".  Note that data following the
        urgent pointer (non-urgent data) cannot be delivered to the user
        in the same buffer with preceding urgent data unless the
        boundary is clearly marked for the user.
</t>
              <t>
        To distinguish among several outstanding RECEIVEs and to take
        care of the case that a buffer is not completely filled, the
        return code is accompanied by both a buffer pointer and a byte
        count indicating the actual length of the data received.
</t>
              <t>
        Alternative implementations of RECEIVE might have the TCP endpoint
        allocate buffer storage, or the TCP endpoint might share a ring buffer
        with the user.
</t>
           
          </section>
          <section numbered="true" toc="default">
            <name>Close</name>
           
              <t>
        Format:  CLOSE (local connection name)
</t>
              <t>
        This command causes the connection specified to be closed.  If
        the connection is not open or the calling process is not
        authorized to use this connection, an error is returned.
        Closing connections is intended to be a graceful operation in
        the sense that outstanding SENDs will be transmitted (and
        retransmitted), as flow control permits, until all have been
        serviced.  Thus, it should be acceptable to make several SEND
        calls, followed by a CLOSE, and expect all the data to be sent
        to the destination.  It should also be clear that users should
        continue to RECEIVE on CLOSING connections since the remote peer
        may be trying to transmit the last of its data.  Thus, CLOSE
        means "I have no more to send" but does not mean "I will not
        receive any more."  It may happen (if the user-level protocol is
        not well thought out) that the closing side is unable to get rid
        of all its data before timing out.  In this event, CLOSE turns
        into ABORT, and the closing TCP peer gives up.
</t>
              <t>
        The user may CLOSE the connection at any time on their own
        initiative, or in response to various prompts from the TCP implementation
        (e.g., remote close executed, transmission timeout exceeded,
        destination inaccessible).
</t>
              <t>
        Because closing a connection requires communication with the
        remote TCP peer, connections may remain in the closing state for a
        short time.  Attempts to reopen the connection before the TCP peer
        replies to the CLOSE command will result in error responses.
</t>
              <t>
        Close also implies push function.
</t>
          
          </section>
          <section numbered="true" toc="default">
            <name>Status</name>
         
              <t>
        Format:  STATUS (local connection name) -&gt; status data
</t>
              <t>
        This is an implementation-dependent user command and could be
        excluded without adverse effect.  Information returned would
        typically come from the TCB associated with the connection.
</t>
              
                <t>
        This command returns a data block containing the following
        information:
                </t>
                <ul spacing="normal" empty="true">
                  
                    <li>local socket,</li>
                    <li>
          remote socket,</li>
                    <li>
          local connection name,</li>
                    <li>
          receive window,</li>
                    <li>
          send window,</li>
                    <li>
          connection state,</li>
                    <li>
          number of buffers awaiting acknowledgment,</li>
                    <li>
          number of buffers pending receipt,</li>
                    <li>
          urgent state,</li>
                    <li>
          Diffserv field value,</li>
                    <li>
          security/compartment, and</li>
                    <li>
          transmission timeout.</li>
                
                </ul>
             
              <t>
        Depending on the state of the connection, or on the
        implementation itself, some of this information may not be
        available or meaningful.  If the calling process is not
        authorized to use this connection, an error is returned.  This
        prevents unauthorized processes from gaining information about a
        connection.
</t>
        
          </section>
          <section numbered="true" toc="default">
            <name>Abort</name>
      
              <t>
        Format:  ABORT (local connection name)
</t>
              <t>
        This command causes all pending SENDs and RECEIVES to be
        aborted, the TCB to be removed, and a special RST message to
        be sent to the remote TCP peer of the connection.
        Depending on the implementation, users may receive abort
        indications for each outstanding SEND or RECEIVE, or may simply
        receive an ABORT-acknowledgment.
</t>
      
          </section>
          <section numbered="true" toc="default">
            <name>Flush</name>
  
              <t>
            Some TCP implementations have included a FLUSH call, which
            will empty the TCP send queue of any data that the user
            has issued SEND calls for but is still to the right of the
            current send window.  That is, it flushes as much queued
            send data as possible without losing sequence number
            synchronization.  The FLUSH call <bcp14>MAY</bcp14> be implemented (MAY-14).
     </t>
    
          </section>
          <section anchor="asynchronous-reports" numbered="true" toc="default">
            <name>Asynchronous Reports</name>
          
                <t>
            There <bcp14>MUST</bcp14> be a mechanism for reporting soft TCP error
            conditions to the application (MUST-47).  Generically, we assume this
            takes the form of an application-supplied ERROR_REPORT
            routine that may be upcalled asynchronously from
            the transport layer:
                </t>
                <ul spacing="normal" empty="true">
                  <li>
               ERROR_REPORT(local connection name, reason, subreason)
                  </li>
                </ul>
                <t>
            The precise encoding of the reason and subreason parameters
            is not specified here.  However, the conditions that are
            reported asynchronously to the application <bcp14>MUST</bcp14> include:
                </t>
                <ul spacing="normal">
                  <li>
                 ICMP error message arrived (see <xref target="icmp" format="default"/> for description of handling each ICMP message type since some message types need to be suppressed from generating reports to the application)
                  </li>
                  <li>
                Excessive retransmissions (see <xref target="connfail" format="default"/>)
                  </li>
                  <li>
                 Urgent pointer advance (see <xref target="urgent" format="default"/>)
                  </li>
                </ul>
                <t>
            However, an application program that does not want to
            receive such ERROR_REPORT calls <bcp14>SHOULD</bcp14> be able to
            effectively disable these calls (SHLD-20).
                </t>
            
           
          </section>
          <section numbered="true" toc="default">
            <name>Set Differentiated Services Field (IPv4 TOS or IPv6 Traffic Class)</name>
          
              <t>
            The application layer <bcp14>MUST</bcp14> be able to specify the Differentiated Services field
            for segments that are sent on a connection (MUST-48).  The Differentiated Services field includes the 6-bit Differentiated Services Codepoint (DSCP) value.
            It is not required, but the application <bcp14>SHOULD</bcp14> be able to
            change the Differentiated Services field during the connection lifetime (SHLD-21).  TCP implementations <bcp14>SHOULD</bcp14>
            pass the current Differentiated Services field value without change to the IP layer,
            when it sends segments on the connection (SHLD-22).
</t>
              <t>
            The Differentiated Services field will be specified independently in each direction on
            the connection, so that the receiver application will
            specify the Differentiated Services field used for ACK segments.
</t>
              <t>
            TCP implementations <bcp14>MAY</bcp14> pass the most recently received Differentiated Services field up to the
            application (MAY-9).
</t>
          
          </section>
        </section>
        <section numbered="true" toc="default">
          <name>TCP/Lower-Level Interface</name>
          <t>
    The TCP endpoint calls on a lower-level protocol module to actually send and
    receive information over a network.  The two current standard Internet Protocol (IP) versions layered below TCP are IPv4 <xref target="RFC0791" format="default"/> and IPv6 <xref target="RFC8200" format="default"/>.
</t>
          <t>
    If the lower-level protocol is IPv4, it provides arguments for a type
    of service (used within the Differentiated Services field) and for a time to live.  TCP uses the following settings
    for these parameters:
          </t>
          <dl>
            <dt>           
      Diffserv field:</dt><dd>The IP header value for the Diffserv field is given by the user.  This includes the bits of the Diffserv Codepoint (DSCP).
</dd>
            <dt>
      Time to Live (TTL):</dt><dd><t>The TTL value used to send TCP segments <bcp14>MUST</bcp14> be configurable (MUST-49).
            </t>
              <ul spacing="normal">
                <li>
        Note that RFC 793 specified one minute (60 seconds) as a constant for
the TTL because the assumed maximum segment lifetime was two minutes.  This was
intended to explicitly ask that a segment be destroyed if it could not be
delivered by the internet system within one minute.  RFC 1122 updated RFC 793 to require that the TTL be configurable.
</li>
                <li>
       Note that the Diffserv field is permitted to change during a connection
       (Section <xref target="RFC1122" section="4.2.4.2" sectionFormat="bare" format="default"/> of RFC 1122).  However, the application interface might
       not support this ability, and the application does not have knowledge
       about individual TCP segments, so this can only be done on a coarse
       granularity, at best.  This limitation is further discussed in RFC 7657
       (Sections <xref target="RFC7657" section="5.1" sectionFormat="bare" format="default"/>, <xref target="RFC7657" section="5.3" sectionFormat="bare" format="default"/>, and <xref target="RFC7657" section="6" sectionFormat="bare" format="default"/>) <xref target="RFC7657" format="default"/>.   Generally, an
       application <bcp14>SHOULD NOT</bcp14> change the Diffserv field value during the course
       of a connection (SHLD-23).
</li>

              </ul>
            </dd>
          </dl>
          <t>
    Any lower-level protocol will have to provide the source address,
    destination address, and protocol fields, and some way to determine
    the "TCP length", both to provide the functional equivalent service
    of IP and to be used in the TCP checksum.
</t>
          <t>
    When received options are passed up to TCP from the IP
    layer, a TCP implementation <bcp14>MUST</bcp14> ignore options that it does not understand (MUST-50).
</t>
          <t>
    A TCP implementation <bcp14>MAY</bcp14> support the Timestamp (MAY-10) and Record Route (MAY-11) Options.
</t>
          <section numbered="true" toc="default">
            <name>Source Routing</name>
            <t>
    If the lower level is IP (or other protocol that provides this
    feature) and source routing is used, the interface must allow the
    route information to be communicated.  This is especially important
    so that the source and destination addresses used in the TCP
    checksum be the originating source and ultimate destination. It is
    also important to preserve the return route to answer connection
    requests.
</t>
            <t>
    An application <bcp14>MUST</bcp14> be able to specify a source route when
    it actively opens a TCP connection (MUST-51), and this <bcp14>MUST</bcp14> take
    precedence over a source route received in a datagram (MUST-52).
</t>
            <t>
    When a TCP connection is OPENed passively and a packet
    arrives with a completed IP Source Route Option (containing
    a return route), TCP implementations <bcp14>MUST</bcp14> save the return route and use it
    for all segments sent on this connection (MUST-53).  If a different
    source route arrives in a later segment, the later
    definition <bcp14>SHOULD</bcp14> override the earlier one (SHLD-24).
</t>
          </section>
          <section anchor="icmp" numbered="true" toc="default">
            <name>ICMP Messages</name>
            <t>
            TCP implementations <bcp14>MUST</bcp14> act on an ICMP error message passed up from the IP
            layer, directing it to the connection that created the
            error (MUST-54).  The necessary demultiplexing information can be
            found in the IP header contained within the ICMP message.
</t>
            <t>
            This applies to ICMPv6 in addition to IPv4 ICMP.
</t>
            <t>
            <xref target="RFC5461" format="default"/> contains discussion of specific ICMP and ICMPv6 messages classified as either "soft" or "hard" errors that may bear different responses.  Treatment for classes of ICMP messages is described below:
</t>
            <dl newline="true" spacing="normal" indent="2">
              <dt>Source Quench</dt>
              <dd>

                 TCP implementations <bcp14>MUST</bcp14> silently discard any received ICMP Source Quench messages (MUST-55).  See <xref target="RFC6633" format="default"/> for discussion.
</dd>
              <dt>Soft Errors</dt>
              <dd>
                <t>
                 For IPv4 ICMP, these include: Destination Unreachable -- codes 0, 1, 5; Time Exceeded -- codes 0, 1; and Parameter Problem.</t>
                <t>
                 For ICMPv6, these include: Destination Unreachable -- codes 0, 3; Time Exceeded -- codes 0, 1; and Parameter Problem  -- codes 0, 1, 2.</t>
                <t>

                 Since these Unreachable messages indicate soft error
                 conditions, a TCP implementation <bcp14>MUST NOT</bcp14> abort the connection (MUST-56), and it
                 <bcp14>SHOULD</bcp14> make the information available to the
                 application (SHLD-25).
</t>
              </dd>
              <dt>Hard Errors</dt>
              <dd>
                <t>
                 For ICMP these include Destination Unreachable -- codes 2-4.</t>
                <t>

                 These are hard error conditions, so TCP implementations <bcp14>SHOULD</bcp14> abort
                 the connection (SHLD-26).  <xref target="RFC5461" format="default"/> notes that
                 some implementations do not abort connections when an
                 ICMP hard error is received for a connection that is
                 in any of the synchronized states.
</t>
              </dd>
            </dl>
            <t>
Note that <xref target="RFC5461" section="4" sectionFormat="comma" format="default"/> describes widespread implementation behavior that treats soft errors as hard errors during connection establishment.
</t>
          </section>
          <section numbered="true" toc="default">
            <name>Source Address Validation</name>
            <t>
RFC 1122 requires addresses to be validated in incoming SYN packets:
</t>
           <blockquote>
            <t>
            An incoming SYN with an invalid source address <bcp14>MUST</bcp14> be
            ignored either by TCP or by the IP layer [(MUST-63)] (see Section
            <xref target="RFC1122" section="3.2.1.3" sectionFormat="bare"/>).
</t>
            <t>
            A TCP implementation <bcp14>MUST</bcp14> silently discard an incoming SYN
            segment that is addressed to a broadcast or multicast
            address [(MUST-57)].
</t>
</blockquote>
           
            <t>This prevents connection state and replies from being erroneously generated, and implementers should note that this guidance is applicable to all incoming segments, not just SYNs, as specifically indicated in RFC 1122.</t>
          </section>
        </section>
      </section>
      <section numbered="true" toc="default">
        <name>Event Processing</name>
        <t>
  The processing depicted in this section is an example of one possible
  implementation.  Other implementations may have slightly different
  processing sequences, but they should differ from those in this
  section only in detail, not in substance.
</t>
        <t>
  The activity of the TCP endpoint can be characterized as responding to events.
  The events that occur can be cast into three categories:  user calls,
  arriving segments, and timeouts.  This section describes the
  processing the TCP endpoint does in response to each of the events.  In many
  cases, the processing required depends on the state of the connection.
</t>
        <t>
    Events that occur:

        </t>
        <ul spacing="normal" empty="true">  
          <li>
            <t>User Calls</t>
            <ul spacing="normal" empty="true"> 
              <li>OPEN</li>
              <li>SEND</li>
              <li>RECEIVE</li>
              <li>CLOSE</li>
              <li>ABORT</li>
              <li>STATUS</li>
            </ul>
           </li>
           <li>
             <t>Arriving Segments</t>
             <ul spacing="normal" empty="true">
              <li>SEGMENT ARRIVES</li>
             </ul>
           </li>
           <li>
             <t>Timeouts</t>
             <ul spacing="normal" empty="true"> 
               <li>USER TIMEOUT</li>
               <li>RETRANSMISSION TIMEOUT</li>
               <li>TIME-WAIT TIMEOUT</li>
            </ul>
           </li>
         </ul>
        <t>
  The model of the TCP/user interface is that user commands receive an
  immediate return and possibly a delayed response via an event or
  pseudo-interrupt.  In the following descriptions, the term "signal"
  means cause a delayed response.
</t>
        <t>
  Error responses in this document are identified by character strings.  For example, user
  commands referencing connections that do not exist receive "error:
  connection not open".
</t>
        <t>
  Please note in the following that all arithmetic on sequence numbers,
  acknowledgment numbers, windows, et cetera, is modulo 2<sup>32</sup> (the size
  of the sequence number space).  Also note that "=&lt;" means less than or
  equal to (modulo 2<sup>32</sup>).
</t>
        <t>
  A natural way to think about processing incoming segments is to
  imagine that they are first tested for proper sequence number (i.e.,
  that their contents lie in the range of the expected "receive window"
  in the sequence number space) and then that they are generally queued
  and processed in sequence number order.
</t>
        <t>
  When a segment overlaps other already received segments, we reconstruct
  the segment to contain just the new data and adjust the header fields
  to be consistent.
</t>
        <t>
  Note that if no state change is mentioned, the TCP connection stays in the same
  state.
</t>
        <section numbered="true" toc="default">
          <name>OPEN Call</name>
              <t>CLOSED STATE (i.e., TCB does not exist)
              </t>
              <ul spacing="normal">
                <li>
      Create a new transmission control block (TCB) to hold connection
      state information.  Fill in local socket identifier, remote
      socket, Diffserv field, security/compartment, and user timeout
      information.  Note that some parts of the remote socket may be
      unspecified in a passive OPEN and are to be filled in by the
      parameters of the incoming SYN segment.  Verify the security and
      Diffserv value requested are allowed for this user, if not, return
      "error:  Diffserv value not allowed" or "error:  security/compartment
      not allowed".  If passive, enter the LISTEN state and return.  If
      active and the remote socket is unspecified, return "error:
      remote socket unspecified"; if active and the remote socket is
      specified, issue a SYN segment.  An initial send sequence number
      (ISS) is selected.  A SYN segment of the form &lt;SEQ=ISS&gt;&lt;CTL=SYN&gt;
      is sent.  Set SND.UNA to ISS, SND.NXT to ISS+1, enter SYN-SENT
      state, and return.
    </li>
                <li>
      If the caller does not have access to the local socket specified,
      return "error:  connection illegal for this process".  If there is
      no room to create a new connection, return "error:  insufficient
      resources".
    </li>
              </ul>
              <t>LISTEN STATE
              </t>
              <ul spacing="normal">
                <li>
      If the OPEN call is active and the remote socket is specified, then change the
      connection from passive to active, select an ISS.  Send a SYN
      segment, set SND.UNA to ISS, SND.NXT to ISS+1.  Enter SYN-SENT
      state.  Data associated with SEND may be sent with SYN segment or
      queued for transmission after entering ESTABLISHED state.  The
      urgent bit if requested in the command must be sent with the data
      segments sent as a result of this command.  If there is no room to
      queue the request, respond with "error:  insufficient resources".
      If the remote socket was not specified, then return "error:  remote
      socket unspecified".
    </li>
              </ul>
              <t>SYN-SENT STATE</t>
              <t>
SYN-RECEIVED STATE</t>
              <t>
ESTABLISHED STATE</t>
              <t>
FIN-WAIT-1 STATE</t>
              <t>
FIN-WAIT-2 STATE</t>
              <t>
CLOSE-WAIT STATE</t>
              <t>
CLOSING STATE</t>
              <t>
LAST-ACK STATE</t>
              <t>
TIME-WAIT STATE
              </t>
              <ul spacing="normal">
                <li>Return "error:  connection already exists".</li>
              </ul>
        </section>
        <section numbered="true" toc="default">
          <name>SEND Call</name>
              <t>
    CLOSED STATE (i.e., TCB does not exist)
              </t>
              <ul spacing="normal">
                <li>
      If the user does not have access to such a connection, then return
      "error:  connection illegal for this process".
      </li>
                <li>
      Otherwise, return "error:  connection does not exist".
      </li>
              </ul>
              <t>
    LISTEN STATE
              </t>
              <ul spacing="normal">
                <li>
      If the remote socket is specified, then change the connection
      from passive to active, select an ISS.  Send a SYN segment, set
      SND.UNA to ISS, SND.NXT to ISS+1.  Enter SYN-SENT state.  Data
      associated with SEND may be sent with SYN segment or queued for
      transmission after entering ESTABLISHED state.  The urgent bit if
      requested in the command must be sent with the data segments sent
      as a result of this command.  If there is no room to queue the
      request, respond with "error:  insufficient resources".  If
      the remote socket was not specified, then return "error:  remote
      socket unspecified".
      </li>
              </ul>
              <t>
    SYN-SENT STATE</t>
              <t>
    SYN-RECEIVED STATE
              </t>
              <ul spacing="normal">
                <li>
      Queue the data for transmission after entering ESTABLISHED state.
      If no space to queue, respond with "error:  insufficient
      resources".
      </li>
              </ul>
              <t>
    ESTABLISHED STATE</t>
              <t>
    CLOSE-WAIT STATE
              </t>
              <ul spacing="normal">
                <li>
      Segmentize the buffer and send it with a piggybacked
      acknowledgment (acknowledgment value = RCV.NXT).  If there is
      insufficient space to remember this buffer, simply return "error:
      insufficient resources".
      </li>
                <li>
      If the URGENT flag is set, then SND.UP &lt;- SND.NXT and set the
      urgent pointer in the outgoing segments.
      </li>
              </ul>
              <t>
    FIN-WAIT-1 STATE</t>
              <t>
    FIN-WAIT-2 STATE</t>
              <t>
    CLOSING STATE</t>
              <t>
    LAST-ACK STATE</t>
              <t>
    TIME-WAIT STATE
              </t>
              <ul spacing="normal">
                <li>
      Return "error:  connection closing" and do not service request.
      </li>
              </ul>
        </section>
        <section numbered="true" toc="default">
          <name>RECEIVE Call</name>
              <t>
    CLOSED STATE (i.e., TCB does not exist)
              </t>
              <ul spacing="normal">
                <li>
      If the user does not have access to such a connection, return
      "error:  connection illegal for this process".
      </li>
                <li>
      Otherwise, return "error:  connection does not exist".
      </li>
              </ul>
              <t>
    LISTEN STATE</t>
              <t>
    SYN-SENT STATE</t>
              <t>
    SYN-RECEIVED STATE
              </t>
              <ul spacing="normal">
                <li>
      Queue for processing after entering ESTABLISHED state.  If there
      is no room to queue this request, respond with "error:
      insufficient resources".
      </li>
              </ul>
              <t>
    ESTABLISHED STATE</t>
              <t>
    FIN-WAIT-1 STATE</t>
              <t>
    FIN-WAIT-2 STATE
              </t>
              <ul spacing="normal">
                <li>
      If insufficient incoming segments are queued to satisfy the
      request, queue the request.  If there is no queue space to
      remember the RECEIVE, respond with "error:  insufficient
      resources".
      </li>
                <li>
      Reassemble queued incoming segments into receive buffer and return
      to user.  Mark "push seen" (PUSH) if this is the case.
      </li>
                <li>
      If RCV.UP is in advance of the data currently being passed to the
      user, notify the user of the presence of urgent data.
      </li>
                <li>
      When the TCP endpoint takes responsibility for delivering data to the user,
      that fact must be communicated to the sender via an
      acknowledgment.  The formation of such an acknowledgment is
      described below in the discussion of processing an incoming
      segment.
      </li>
              </ul>
              <t>
    CLOSE-WAIT STATE
              </t>
              <ul spacing="normal">
                <li>
      Since the remote side has already sent FIN, RECEIVEs must be
      satisfied by data already on hand, but not yet delivered to the
      user.  If no text is awaiting delivery, the RECEIVE will get an
      "error:  connection closing" response.  Otherwise, any remaining
      data can be used to satisfy the RECEIVE.
      </li>
              </ul>
              <t>
    CLOSING STATE</t>
              <t>
    LAST-ACK STATE</t>
              <t>
    TIME-WAIT STATE
              </t>
              <ul spacing="normal">
                <li>
      Return "error:  connection closing".
      </li>
              </ul>
        </section>
        <section numbered="true" toc="default">
          <name>CLOSE Call</name>
              <t>
    CLOSED STATE (i.e., TCB does not exist)
              </t>
              <ul spacing="normal">
                <li>
      If the user does not have access to such a connection, return
      "error:  connection illegal for this process".
      </li>
                <li>
      Otherwise, return "error:  connection does not exist".
      </li>
              </ul>
              <t>
    LISTEN STATE
              </t>
              <ul spacing="normal">
                <li>
      Any outstanding RECEIVEs are returned with "error:  closing"
      responses.  Delete TCB, enter CLOSED state, and return.
      </li>
              </ul>
              <t>
    SYN-SENT STATE
              </t>
              <ul spacing="normal">
                <li>
      Delete the TCB and return "error:  closing" responses to any
      queued SENDs, or RECEIVEs.
      </li>
              </ul>
              <t>
    SYN-RECEIVED STATE
              </t>
              <ul spacing="normal">
                <li>
      If no SENDs have been issued and there is no pending data to send,
      then form a FIN segment and send it, and enter FIN-WAIT-1 state;
      otherwise, queue for processing after entering ESTABLISHED state.
      </li>
              </ul>
              <t>
    ESTABLISHED STATE
              </t>
              <ul spacing="normal">
                <li>
      Queue this until all preceding SENDs have been segmentized, then
      form a FIN segment and send it.  In any case, enter FIN-WAIT-1
      state.
      </li>
              </ul>
              <t>
    FIN-WAIT-1 STATE</t>
              <t>
    FIN-WAIT-2 STATE
              </t>
              <ul spacing="normal">
                <li>
      Strictly speaking, this is an error and should receive an "error:
      connection closing" response.  An "ok" response would be
      acceptable, too, as long as a second FIN is not emitted (the first
      FIN may be retransmitted, though).
      </li>
              </ul>
              <t>
    CLOSE-WAIT STATE
              </t>
              <ul spacing="normal">
                <li>
      Queue this request until all preceding SENDs have been
      segmentized; then send a FIN segment, enter LAST-ACK state.
      </li>
              </ul>
              <t>
    CLOSING STATE</t>
              <t>
    LAST-ACK STATE</t>
              <t>
    TIME-WAIT STATE
              </t>
              <ul spacing="normal">
                <li>
      Respond with "error:  connection closing".
      </li>
              </ul>
        </section>
        <section numbered="true" toc="default">
          <name>ABORT Call</name>
              <t>
    CLOSED STATE (i.e., TCB does not exist)
              </t>
              <ul spacing="normal">
                <li>
      If the user should not have access to such a connection, return
      "error:  connection illegal for this process". 
      </li>
                <li>
      Otherwise, return "error:  connection does not exist".
      </li>
              </ul>
              <t>
    LISTEN STATE
              </t>
              <ul spacing="normal">
                <li>
      Any outstanding RECEIVEs should be returned with "error:
      connection reset" responses.  Delete TCB, enter CLOSED state, and
      return.
      </li>
              </ul>
              <t>
    SYN-SENT STATE
              </t>
              <ul spacing="normal">
                <li>
      All queued SENDs and RECEIVEs should be given "connection reset"
      notification. Delete the TCB, enter CLOSED state, and return.
      </li>
              </ul>
              <t>
    SYN-RECEIVED STATE</t>
              <t>
    ESTABLISHED STATE</t>
              <t>
    FIN-WAIT-1 STATE</t>
              <t>
    FIN-WAIT-2 STATE</t>
              <t>
    CLOSE-WAIT STATE
              </t>
              <ul spacing="normal">
                <li>
                  <t>
      Send a reset segment:
                  </t>
                  <t>
        &lt;SEQ=SND.NXT&gt;&lt;CTL=RST&gt;
                  </t>
                </li>
                <li>
      All queued SENDs and RECEIVEs should be given "connection reset"
      notification; all segments queued for transmission (except for the
      RST formed above) or retransmission should be flushed. Delete the
      TCB, enter CLOSED state, and return.
      </li>
              </ul>
              <t>
    CLOSING STATE
              </t>
              <t>
    LAST-ACK STATE
              </t>
              <t>
    TIME-WAIT STATE
              </t>
              <ul spacing="normal">
                <li>
      Respond with "ok" and delete the TCB, enter CLOSED state, and
      return.
      </li>
              </ul>
        </section>
        <section numbered="true" toc="default">
          <name>STATUS Call</name>
              <t>
    CLOSED STATE (i.e., TCB does not exist)
              </t>
              <ul spacing="normal">
                <li>
      If the user should not have access to such a connection, return
      "error:  connection illegal for this process".
      </li>
                <li>
      Otherwise, return "error:  connection does not exist".
      </li>
              </ul>
              <t>
    LISTEN STATE
              </t>
              <ul spacing="normal">
                <li>
      Return "state = LISTEN" and the TCB pointer.
      </li>
              </ul>
              <t>
    SYN-SENT STATE
              </t>
              <ul spacing="normal">
                <li>
      Return "state = SYN-SENT" and the TCB pointer.
      </li>
              </ul>
              <t>
    SYN-RECEIVED STATE
              </t>
              <ul spacing="normal">
                <li>
      Return "state = SYN-RECEIVED" and the TCB pointer.
      </li>
              </ul>
              <t>
    ESTABLISHED STATE
              </t>
              <ul spacing="normal">
                <li>
      Return "state = ESTABLISHED" and the TCB pointer.
      </li>
              </ul>
              <t>
    FIN-WAIT-1 STATE
              </t>
              <ul spacing="normal">
                <li>
      Return "state = FIN-WAIT-1" and the TCB pointer.
      </li>
              </ul>
              <t>
    FIN-WAIT-2 STATE
              </t>
              <ul spacing="normal">
                <li>
      Return "state = FIN-WAIT-2" and the TCB pointer.
      </li>
              </ul>
              <t>
    CLOSE-WAIT STATE
              </t>
              <ul spacing="normal">
                <li>
      Return "state = CLOSE-WAIT" and the TCB pointer.
      </li>
              </ul>
              <t>
    CLOSING STATE
              </t>
              <ul spacing="normal">
                <li>
      Return "state = CLOSING" and the TCB pointer.
      </li>
              </ul>
              <t>
    LAST-ACK STATE
              </t>
              <ul spacing="normal">
                <li>
      Return "state = LAST-ACK" and the TCB pointer.
    </li>
              </ul>
              <t>
    TIME-WAIT STATE
              </t>
              <ul spacing="normal">
                <li>
      Return "state = TIME-WAIT" and the TCB pointer.
    </li>
              </ul>
        </section>
        <section numbered="true" toc="default">
          <name>SEGMENT ARRIVES</name>
          <section numbered="true" toc="default">
            <name>CLOSED STATE</name>
            <t>
    If the state is CLOSED (i.e., TCB does not exist), then
            </t>
            <ul empty="true" spacing="normal">
              <li>
      all data in the incoming segment is discarded.  An incoming
      segment containing a RST is discarded.  An incoming segment not
      containing a RST causes a RST to be sent in response.  The
      acknowledgment and sequence field values are selected to make the
      reset sequence acceptable to the TCP endpoint that sent the offending
      segment.
      </li>
              <li>
                <t>
      If the ACK bit is off, sequence number zero is used,
                </t>
                <ul spacing="normal" empty="true">
                  <li>
        &lt;SEQ=0&gt;&lt;ACK=SEG.SEQ+SEG.LEN&gt;&lt;CTL=RST,ACK&gt;
        </li>
                </ul>
              </li>
              <li>
                <t>
      If the ACK bit is on,
                </t>
                <ul spacing="normal" empty="true">
                  <li>
        &lt;SEQ=SEG.ACK&gt;&lt;CTL=RST&gt;
        </li>
                </ul>
              </li>
              <li>
      Return.
      </li>
            </ul>
          </section>
          <section numbered="true" toc="default">
            <name>LISTEN STATE</name>
            <t>
    If the state is LISTEN, then
            </t>
            <ul empty="true" spacing="normal">
              <li>
                <t>
      First, check for a RST:
                </t>
                <ul spacing="normal">
                  <li>
	An incoming RST segment could not be valid since
        it could not have been sent in response to anything sent by this
        incarnation of the connection.
        An incoming RST should be ignored.  Return.
        </li>
                </ul>
              </li>
              <li>
                <t>
      Second, check for an ACK:
                </t>
                <ul spacing="normal">
                  <li>
                    <t>
        Any acknowledgment is bad if it arrives on a connection still in
        the LISTEN state.  An acceptable reset segment should be formed
        for any arriving ACK-bearing segment.  The RST should be
        formatted as follows:
                    </t>
                    <ul spacing="normal" empty="true">
                      <li>
          &lt;SEQ=SEG.ACK&gt;&lt;CTL=RST&gt;
          </li>
                    </ul>
                  </li>
                  <li>
        Return.
        </li>
                </ul>
              </li>
              <li>
                <t>
      Third, check for a SYN:
                </t>
                <ul spacing="normal">
                  <li>
                    <t>
        If the SYN bit is set, check the security.  If the
        security/compartment on the incoming segment does not exactly
        match the security/compartment in the TCB, then send a reset and
        return.
                    </t>
                    <ul spacing="normal" empty="true">
                      <li>
          &lt;SEQ=0&gt;&lt;ACK=SEG.SEQ+SEG.LEN&gt;&lt;CTL=RST,ACK&gt;
          </li>
                    </ul>
                  </li>
                  <li>
                    <t>
        Set RCV.NXT to SEG.SEQ+1, IRS is set to SEG.SEQ, and any other
        control or text should be queued for processing later.  ISS
        should be selected and a SYN segment sent of the form:
                    </t>
                    <ul spacing="normal" empty="true">
                      <li>
          &lt;SEQ=ISS&gt;&lt;ACK=RCV.NXT&gt;&lt;CTL=SYN,ACK&gt;
          </li>
                    </ul>
                  </li>
                  <li>
        SND.NXT is set to ISS+1 and SND.UNA to ISS.  The connection
        state should be changed to SYN-RECEIVED.  Note that any other
        incoming control or data (combined with SYN) will be processed
        in the SYN-RECEIVED state, but processing of SYN and ACK should
        not be repeated.  If the listen was not fully specified (i.e.,
        the remote socket was not fully specified), then the
        unspecified fields should be filled in now.
        </li>
                </ul>
              </li>
              <li>
                <t>
      Fourth, other data or control:
                </t>
                <ul spacing="normal">
                  <li>
        This should not be reached.  Drop the segment and return.  Any other control or data-bearing segment (not containing SYN)
        must have an ACK and thus would have been discarded by the ACK
        processing in the second step, unless it was first discarded by
	RST checking in the first step.
        </li>
                </ul>
              </li>
            </ul>
          </section>
          <section numbered="true" toc="default">
            <name>SYN-SENT STATE</name>
            <t>
    If the state is SYN-SENT, then
            </t>
            <ul empty="true" spacing="normal">
              <li>
                <t>
      First, check the ACK bit:
                </t>
                <ul spacing="normal">
                  <li>
                    <t>
        If the ACK bit is set,
                    </t>
                    <ul spacing="normal">
                      <li>
                        <t>
          If SEG.ACK =&lt; ISS or SEG.ACK &gt; SND.NXT, send a reset (unless
          the RST bit is set, if so drop the segment and return)
                        </t>
                        <ul spacing="normal" empty="true">
                          <li>
            &lt;SEQ=SEG.ACK&gt;&lt;CTL=RST&gt;
            </li>
                        </ul>
                      </li>
                      <li>
          and discard the segment.  Return.
          </li>
                      <li>
          If SND.UNA &lt; SEG.ACK =&lt; SND.NXT, then the ACK is acceptable.  Some deployed TCP code has used the check SEG.ACK == SND.NXT (using "==" rather than "=&lt;"), but this is not appropriate when the stack is capable of sending data on the SYN because the TCP peer may not accept and acknowledge all of the data on the SYN.
          </li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li>
                <t>
      Second, check the RST bit:
                </t>
                <ul spacing="normal">
                  <li>
                    <t>
        If the RST bit is set,
                    </t>
                    <ul spacing="normal">
                      <li>
          A potential blind reset attack is described in RFC 5961 <xref target="RFC5961" format="default"/>.  The mitigation described in that document has specific applicability explained therein, and is not a substitute for cryptographic protection (e.g., IPsec or TCP-AO).  A TCP implementation that supports the mitigation described in RFC 5961 <bcp14>SHOULD</bcp14> first check that the sequence number exactly matches RCV.NXT prior to executing the action in the next paragraph.
	  </li>
                      <li>
          If the ACK was acceptable, then signal to the user "error:
          connection reset", drop the segment, enter CLOSED state,
          delete TCB, and return.  Otherwise (no ACK), drop the segment
          and return.
          </li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li>
                <t>
      Third, check the security:
                </t>
                <ul spacing="normal">
                  <li>
                    <t>
        If the security/compartment in the segment does not exactly
        match the security/compartment in the TCB, send a reset:
                    </t>
                    <ul spacing="normal">
                      <li>
                        <t>
          If there is an ACK,
                        </t>
                        <ul spacing="normal" empty="true">
                          <li>
            &lt;SEQ=SEG.ACK&gt;&lt;CTL=RST&gt;
            </li>
                        </ul>
                      </li>
                      <li>
                        <t>
          Otherwise,
                        </t>
                        <ul spacing="normal" empty="true">
                          <li>
            &lt;SEQ=0&gt;&lt;ACK=SEG.SEQ+SEG.LEN&gt;&lt;CTL=RST,ACK&gt;
            </li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                  <li>
        If a reset was sent, discard the segment and return.
        </li>
                </ul>
              </li>
              <li>
                <t>
      Fourth, check the SYN bit:
                </t>
                <ul spacing="normal">
                  <li>
        This step should be reached only if the ACK is ok, or there is
        no ACK, and the segment did not contain a RST.
        </li>
                  <li>
        If the SYN bit is on and the security/compartment 
        is acceptable, then RCV.NXT is set to SEG.SEQ+1, IRS is set to
        SEG.SEQ.  SND.UNA should be advanced to equal SEG.ACK (if there
        is an ACK), and any segments on the retransmission queue that
        are thereby acknowledged should be removed.
        </li>
                  <li>
                    <t>
        If SND.UNA &gt; ISS (our SYN has been ACKed), change the connection
        state to ESTABLISHED, form an ACK segment
                    </t>
                    <ul spacing="normal" empty="true">
                      <li>
          &lt;SEQ=SND.NXT&gt;&lt;ACK=RCV.NXT&gt;&lt;CTL=ACK&gt;
          </li>
                    </ul>
                  </li>
                  <li>
        and send it.  Data or controls that were queued for
	transmission <bcp14>MAY</bcp14> be included.  Some TCP implementations suppress
	sending this segment when the received segment contains data that will
	anyways generate an acknowledgment in the later processing steps,
	saving this extra acknowledgment of the SYN from being sent.  If there
	are other controls or text in the segment, then continue processing at
	the <xref target="check-urg-bit" format="none">sixth step</xref> under <xref target="other-states" format="default"/> where the URG
	bit is checked; otherwise, return.
        </li>
                  <li>
                    <t>
        Otherwise, enter SYN-RECEIVED, form a SYN,ACK segment
                    </t>
                    <ul spacing="normal" empty="true">
                      <li>
          &lt;SEQ=ISS&gt;&lt;ACK=RCV.NXT&gt;&lt;CTL=SYN,ACK&gt;
          </li>
                    </ul>
                  </li>
                  <li>
                    <t>
        and send it.  Set the variables:
                    </t>
                    <ul spacing="normal" empty="true">
                      <li>
                        <t>SND.WND &lt;- SEG.WND</t>
                        <t>
        SND.WL1 &lt;- SEG.SEQ</t>
                        <t>
        SND.WL2 &lt;- SEG.ACK</t>
                      </li>
                    </ul>
                    <t>

        If there are other controls or text in the
        segment, queue them for processing after the ESTABLISHED state
        has been reached, return.  
                    </t>
                  </li>
                  <li>
	Note that it is legal to send and receive application data on SYN segments (this is the "text in the segment" mentioned above).  There has been significant misinformation and misunderstanding of this topic historically.  Some firewalls and security devices consider this suspicious.  However, the capability was used in T/TCP <xref target="RFC1644" format="default"/> and is used in TCP Fast Open (TFO) <xref target="RFC7413" format="default"/>, so is important for implementations and network devices to permit.
	</li>
                </ul>
              </li>
              <li>
      Fifth, if neither of the SYN or RST bits is set, then drop the
      segment and return.
      </li>
            </ul>
          </section>
          <section anchor="other-states" numbered="true" toc="default">
            <name>Other States</name>
            <t>
    Otherwise,
            </t>
            <ul spacing="normal" empty="true">
              <li>
                <t>
    First, check sequence number:
                </t>
                <ul spacing="normal">
                  <li>
      SYN-RECEIVED STATE</li>
                  <li>
      ESTABLISHED STATE</li>
                  <li>
      FIN-WAIT-1 STATE</li>
                  <li>
      FIN-WAIT-2 STATE</li>
                  <li>
      CLOSE-WAIT STATE</li>
                  <li>
      CLOSING STATE</li>
                  <li>
      LAST-ACK STATE</li>
                  <li>
                    <t>
      TIME-WAIT STATE</t>
                    <ul spacing="normal">
                      <li>
        Segments are processed in sequence.  Initial tests on arrival
        are used to discard old duplicates, but further processing is
        done in SEG.SEQ order.  If a segment's contents straddle the
        boundary between old and new, only the new parts are
        processed.
        </li>
                      <li>
            In general, the processing of received segments <bcp14>MUST</bcp14> be
            implemented to aggregate ACK segments whenever possible (MUST-58).
            For example, if the TCP endpoint is processing a series of queued
            segments, it <bcp14>MUST</bcp14> process them all before sending any ACK
            segments (MUST-59).
        </li>
                      <li>
                        <t>
        There are four cases for the acceptability test for an incoming
        segment:
        </t>
                        <table>
                          <name>Segment Acceptability Tests</name>
                          <thead>
                            <tr>
                              <th>Segment Length</th>
                              <th>Receive Window</th>
                              <th>Test</th>
                            </tr>
                          </thead>
                          <tbody>
                            <tr>
                              <td>0</td>
                              <td>0</td>
                              <td>SEG.SEQ = RCV.NXT</td>
                            </tr>
                            <tr>
                              <td>0</td>
                              <td>&gt;0</td>
                              <td>RCV.NXT =&lt; SEG.SEQ &lt; RCV.NXT+RCV.WND</td>
                            </tr>
                            <tr>
                              <td>&gt;0</td>
                              <td>0</td>
                              <td>not acceptable</td>
                            </tr>
                            <tr>
                              <td>&gt;0</td>
                              <td>&gt;0</td>
                              <td>
                                <t>RCV.NXT =&lt; SEG.SEQ &lt; RCV.NXT+RCV.WND</t>
                                <t>or</t>
                                <t>RCV.NXT =&lt; SEG.SEQ+SEG.LEN-1 &lt; RCV.NXT+RCV.WND</t> 
                              </td>
                            </tr>
	                  </tbody>
                        </table>
                      </li>
                      <li>
	In implementing sequence number validation as described here, please note <xref target="seqval" format="default"/>.
	</li>
                      <li>
        If the RCV.WND is zero, no segments will be acceptable, but
        special allowance should be made to accept valid ACKs, URGs, and
        RSTs.
        </li>
                      <li>
                        <t>
        If an incoming segment is not acceptable, an acknowledgment
        should be sent in reply (unless the RST bit is set, if so drop
        the segment and return):
                        </t>
                        <t>
          &lt;SEQ=SND.NXT&gt;&lt;ACK=RCV.NXT&gt;&lt;CTL=ACK&gt;
          </t>
                      </li>
                      <li>
        After sending the acknowledgment, drop the unacceptable segment
        and return.
        </li>
                      <li>
        Note that for the TIME-WAIT state, there is an improved algorithm
	described in <xref target="RFC6191" format="default"/> for handling incoming SYN
	segments that utilizes timestamps rather than relying on
	the sequence number check described here.  When the improved
	algorithm is implemented, the logic above is not applicable for
	incoming SYN segments with Timestamp Options, received on a
	connection in the TIME-WAIT state.
	</li>
                      <li>
        In the following it is assumed that the segment is the idealized
        segment that begins at RCV.NXT and does not exceed the window.
        One could tailor actual segments to fit this assumption by
        trimming off any portions that lie outside the window (including
        SYN and FIN) and only processing further if the segment then
        begins at RCV.NXT.  Segments with higher beginning sequence
        numbers <bcp14>SHOULD</bcp14> be held for later processing (SHLD-31).
        </li>
                    </ul>
                  </li>
                  </ul>
                  </li>
                  <li>
                    <t>
    Second, check the RST bit:
                    </t>
                    <ul spacing="normal">
                      <li>
                        <t>
RFC 5961 <xref target="RFC5961" format="default"/>, Section <xref target="RFC5961" section="3" sectionFormat="bare" format="default"/>  describes a potential blind reset attack and optional mitigation approach.  This does not provide a cryptographic protection (e.g., as in IPsec or TCP-AO) but can be applicable in situations described in RFC 5961.  For stacks implementing the protection described in RFC 5961, the three checks below apply; otherwise, processing for these states is indicated further below.
</t>
                        <ol type="%d)">
                          <li>If the RST bit is set and the sequence number is outside the current receive window, silently drop the segment.</li>
                          <li>If the RST bit is set and the sequence number exactly matches the next expected sequence number (RCV.NXT), then TCP endpoints <bcp14>MUST</bcp14> reset the connection in the manner prescribed below according to the connection state.</li>
                          <li>
                            <t>If the RST bit is set and the sequence number does not exactly match the next expected sequence value, yet is within the current receive window, TCP endpoints <bcp14>MUST</bcp14> send an acknowledgment (challenge ACK):</t>
                            <t>
&lt;SEQ=SND.NXT&gt;&lt;ACK=RCV.NXT&gt;&lt;CTL=ACK&gt;</t>
                            <t>
After sending the challenge ACK, TCP endpoints <bcp14>MUST</bcp14> drop the unacceptable segment and stop processing the incoming packet further.  Note that RFC 5961 and Errata ID 4772 <xref target="Err4772" format="default"/> contain additional considerations for ACK throttling in an implementation.</t>
                          </li>
                        </ol>
                      </li>
                      <li>
                        <t>
      SYN-RECEIVED STATE
                        </t>
                        <ul spacing="normal">
                          <li>
                            <t>
        If the RST bit is set,

                            </t>
                            <ul spacing="normal">
                              <li>
          If this connection was initiated with a passive OPEN (i.e.,
          came from the LISTEN state), then return this connection to
          LISTEN state and return.  The user need not be informed.  If
          this connection was initiated with an active OPEN (i.e., came
          from SYN-SENT state), then the connection was refused; signal
          the user "connection refused".  In either case,
          the retransmission queue should be flushed.  And in the
          active OPEN case, enter the CLOSED state and delete the TCB,
          and return.
          </li>
                            </ul>
                          </li>
                        </ul>
                      </li>
                      <li>
      ESTABLISHED STATE</li>
                      <li>
      FIN-WAIT-1 STATE</li>
                      <li>
      FIN-WAIT-2 STATE</li>
                      <li>
                        <t>
      CLOSE-WAIT STATE</t>
                        <ul spacing="normal">
                          <li>
        If the RST bit is set, then any outstanding RECEIVEs and SEND
        should receive "reset" responses.  All segment queues should be
        flushed.  Users should also receive an unsolicited general
        "connection reset" signal.  Enter the CLOSED state, delete the
        TCB, and return.
        </li>
                        </ul>
                      </li>
                      <li>
      CLOSING STATE</li>
                      <li>
      LAST-ACK STATE</li>
                      <li>
                        <t>
      TIME-WAIT STATE</t>
                        <ul spacing="normal">
                          <li>
        If the RST bit is set, then enter the CLOSED state, delete the
        TCB, and return.
        </li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                  <li>
                    <t>
    Third, check security:
                    </t>
                    <ul spacing="normal">
                      <li>
                        <t>
      SYN-RECEIVED STATE
                        </t>
                        <ul spacing="normal">
                          <li>
        If the security/compartment in the segment does not
        exactly match the security/compartment in the TCB,
        then send a reset and return.
        </li>
                        </ul>
                      </li>
                      <li>
      ESTABLISHED STATE</li>
                      <li>
      FIN-WAIT-1 STATE</li>
                      <li>
      FIN-WAIT-2 STATE</li>
                      <li>
      CLOSE-WAIT STATE</li>
                      <li>
      CLOSING STATE</li>
                      <li>
      LAST-ACK STATE</li>
                      <li>
                        <t>
      TIME-WAIT STATE
                        </t>
                        <ul spacing="normal">
                          <li>
        If the security/compartment in the segment does not
        exactly match the security/compartment in the TCB,
        then send a reset; any outstanding RECEIVEs and SEND should
        receive "reset" responses.  All segment queues should be
        flushed.  Users should also receive an unsolicited general
        "connection reset" signal.  Enter the CLOSED state, delete the
        TCB, and return.
        </li>
                        </ul>
                      </li>
                      <li>
      Note this check is placed following the sequence check to prevent
      a segment from an old connection between these port numbers with a
      different security from causing an abort of the
      current connection.
      </li>
                    </ul>
                  </li>
                  <li>
                    <t>
    Fourth, check the SYN bit:
                    </t>
                    <ul spacing="normal">
                      <li>
                        <t>
      SYN-RECEIVED STATE</t>
                        <ul spacing="normal">
                          <li>If the connection was initiated with a passive OPEN, then return this connection to the LISTEN state and return.  Otherwise, handle per the directions for synchronized states below.</li>
                        </ul>
                      </li>
                      <li>
      ESTABLISHED STATE</li>
                      <li>
      FIN-WAIT-1 STATE</li>
                      <li>
      FIN-WAIT-2 STATE</li>
                      <li>
      CLOSE-WAIT STATE</li>
                      <li>
      CLOSING STATE</li>
                      <li>
      LAST-ACK STATE</li>
                      <li>
                        <t>
      TIME-WAIT STATE
                        </t>
                        <ul spacing="normal">
                          <li>
                            <t>
If the SYN bit is set in these synchronized states, it may be either a legitimate new connection attempt (e.g., in the case of TIME-WAIT), an error where the connection should be reset, or the result of an attack attempt, as described in RFC 5961 <xref target="RFC5961" format="default"/>.  For the TIME-WAIT state, new connections can be accepted if the Timestamp Option is used and meets expectations (per <xref target="RFC6191" format="default"/>).  For all other cases, RFC 5961 provides a mitigation with applicability to some situations, though there are also alternatives that offer cryptographic protection (see <xref target="Security" format="default"/>).  RFC 5961 recommends that in these synchronized states, if the SYN bit is set, irrespective of the sequence number, TCP endpoints <bcp14>MUST</bcp14> send a "challenge ACK" to the remote peer:</t>
                          <t>
        &lt;SEQ=SND.NXT&gt;&lt;ACK=RCV.NXT&gt;&lt;CTL=ACK&gt;
        </t>
                          </li>
                          <li>
After sending the acknowledgment, TCP implementations <bcp14>MUST</bcp14> drop the unacceptable segment and stop processing further.  Note that RFC 5961 and Errata ID 4772 <xref target="Err4772" format="default"/> contain additional ACK throttling notes for an implementation.
        </li>
                          <li>
        For implementations that do not follow RFC 5961, the original behavior described in RFC 793 follows in this paragraph.  If the SYN is in the window it is an error: send a reset, any
        outstanding RECEIVEs and SEND should receive "reset" responses,
        all segment queues should be flushed, the user should also
        receive an unsolicited general "connection reset" signal, enter
        the CLOSED state, delete the TCB, and return.
        </li>
                          <li>
        If the SYN is not in the window, this step would not be reached
        and an ACK would have been sent in the first step (sequence
        number check).
        </li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                  <li>
                    <t>
    Fifth, check the ACK field:
                    </t>
                    <ul spacing="normal">
                      <li>
      if the ACK bit is off, drop the segment and return
      </li>
                      <li>
                        <t>
      if the ACK bit is on,
                        </t>
                        <ul spacing="normal">
                          <li>
RFC 5961 <xref target="RFC5961" section="5" sectionFormat="comma" format="default"/> describes a potential blind data injection attack, and mitigation that implementations <bcp14>MAY</bcp14> choose to include (MAY-12).  TCP stacks that implement RFC 5961 <bcp14>MUST</bcp14> add an input check that the ACK value is acceptable only if it is in the range of ((SND.UNA - MAX.SND.WND) =&lt; SEG.ACK =&lt; SND.NXT).  All incoming segments whose ACK value doesn't satisfy the above condition <bcp14>MUST</bcp14> be discarded and an ACK sent back.  The new state variable MAX.SND.WND is defined as the largest window that the local sender has ever received from its peer (subject to window scaling) or may be hard-coded to a maximum permissible window value.  When the ACK value is acceptable, the per-state processing below applies:
        </li>
                          <li>
                            <t>
        SYN-RECEIVED STATE
                            </t>
                            <ul spacing="normal">
                              <li>
                                <t>
          If SND.UNA &lt; SEG.ACK =&lt; SND.NXT, then enter ESTABLISHED state
          and continue processing with the variables below set to:
                                </t>
                                <ul spacing="normal" empty="true">
                                  <li>
                                    SND.WND &lt;- SEG.WND</li>
                                  <li>
           SND.WL1 &lt;- SEG.SEQ</li>
                                    <li>
           SND.WL2 &lt;- SEG.ACK</li>
                                </ul>
                              </li>
                              <li>
                                <t>
          If the segment acknowledgment is not acceptable, form a
          reset segment
                                </t>
                                <ul spacing="normal" empty="true">
                                  <li>
            &lt;SEQ=SEG.ACK&gt;&lt;CTL=RST&gt;
            </li>
                                </ul>
                              </li>
                              <li>
          and send it.
          </li>
                            </ul>
                          </li>
                          <li>
                            <t>
        ESTABLISHED STATE
                            </t>
                            <ul spacing="normal">
                              <li>
          If SND.UNA &lt; SEG.ACK =&lt; SND.NXT, then set SND.UNA &lt;- SEG.ACK.
          Any segments on the retransmission queue that are thereby
          entirely acknowledged are removed.  Users should receive
          positive acknowledgments for buffers that have been SENT and
          fully acknowledged (i.e., SEND buffer should be returned with
          "ok" response).  If the ACK is a duplicate
          (SEG.ACK =&lt; SND.UNA), it can be ignored.  If the ACK acks
          something not yet sent (SEG.ACK &gt; SND.NXT), then send an ACK,
          drop the segment, and return.
          </li>
                              <li>
          If SND.UNA =&lt; SEG.ACK =&lt; SND.NXT, the send window should be
          updated.  If (SND.WL1 &lt; SEG.SEQ or (SND.WL1 = SEG.SEQ and
          SND.WL2 =&lt; SEG.ACK)), set SND.WND &lt;- SEG.WND, set
          SND.WL1 &lt;- SEG.SEQ, and set SND.WL2 &lt;- SEG.ACK.
          </li>
                              <li>
          Note that SND.WND is an offset from SND.UNA, that SND.WL1
          records the sequence number of the last segment used to update
          SND.WND, and that SND.WL2 records the acknowledgment number of
          the last segment used to update SND.WND.  The check here
          prevents using old segments to update the window.
          </li>
                            </ul>
                          </li>
                          <li>
                            <t>
        FIN-WAIT-1 STATE
                            </t>
                            <ul spacing="normal">
                              <li>
          In addition to the processing for the ESTABLISHED state, if
          the FIN segment is now acknowledged, then enter FIN-WAIT-2 and continue
          processing in that state.
          </li>
                            </ul>
                          </li>
                          <li>
                            <t>
        FIN-WAIT-2 STATE
                            </t>
                            <ul spacing="normal">
                              <li>
          In addition to the processing for the ESTABLISHED state, if
          the retransmission queue is empty, the user's CLOSE can be
          acknowledged ("ok") but do not delete the TCB.
          </li>
                            </ul>
                          </li>
                          <li>
                            <t>
        CLOSE-WAIT STATE
                            </t>
                            <ul spacing="normal">
                              <li>
          Do the same processing as for the ESTABLISHED state.
          </li>
                            </ul>
                          </li>
                          <li>
                            <t>
        CLOSING STATE
                            </t>
                            <ul spacing="normal">
                              <li>
          In addition to the processing for the ESTABLISHED state, if
          the ACK acknowledges our FIN, then enter the TIME-WAIT state;
          otherwise, ignore the segment.
          </li>
                            </ul>
                          </li>
                          <li>
                            <t>
        LAST-ACK STATE
                            </t>
                            <ul spacing="normal">
                              <li>
          The only thing that can arrive in this state is an
          acknowledgment of our FIN.  If our FIN is now acknowledged,
          delete the TCB, enter the CLOSED state, and return.
          </li>
                            </ul>
                          </li>
                          <li>
                            <t>
        TIME-WAIT STATE
                            </t>
                            <ul spacing="normal">
                              <li>
          The only thing that can arrive in this state is a
          retransmission of the remote FIN.  Acknowledge it, and restart
          the 2 MSL timeout.
          </li>
                            </ul>
                          </li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                  <li>
                    <t anchor="check-urg-bit">
    Sixth, check the URG bit:
                    </t>
                    <ul spacing="normal">
                      <li>
      ESTABLISHED STATE</li>
                      <li>
      FIN-WAIT-1 STATE</li>
                      <li>
                        <t>
      FIN-WAIT-2 STATE
                        </t>
                        <ul spacing="normal">
                          <li>
        If the URG bit is set, RCV.UP &lt;- max(RCV.UP,SEG.UP), and signal
        the user that the remote side has urgent data if the urgent
        pointer (RCV.UP) is in advance of the data consumed.  If the
        user has already been signaled (or is still in the "urgent
        mode") for this continuous sequence of urgent data, do not
        signal the user again.
        </li>
                        </ul>
                      </li>
                      <li>
      CLOSE-WAIT STATE</li>
                      <li>
      CLOSING STATE</li>
                      <li>
      LAST-ACK STATE</li>
                      <li>
                        <t>
      TIME-WAIT STATE
                        </t>
                        <ul spacing="normal">
                          <li>
        This should not occur since a FIN has been received from the
        remote side.  Ignore the URG.
        </li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                  <li>
                    <t>
    Seventh, process the segment text:
                    </t>
                    <ul spacing="normal">
                      <li>
      ESTABLISHED STATE</li>
                      <li>
      FIN-WAIT-1 STATE</li>
                      <li>
                        <t>
      FIN-WAIT-2 STATE
                        </t>
                        <ul spacing="normal">
                          <li>
        Once in the ESTABLISHED state, it is possible to deliver segment
        data to user RECEIVE buffers.  Data from segments can be moved
        into buffers until either the buffer is full or the segment is
        empty.  If the segment empties and carries a PUSH flag, then
        the user is informed, when the buffer is returned, that a PUSH
        has been received.
        </li>
                          <li>
        When the TCP endpoint takes responsibility for delivering the data to the
        user, it must also acknowledge the receipt of the data.
        </li>
                          <li>
        Once the TCP endpoint takes responsibility for the data, it advances
        RCV.NXT over the data accepted, and adjusts RCV.WND as
        appropriate to the current buffer availability.  The total of
        RCV.NXT and RCV.WND should not be reduced.
        </li>
                          <li>
        A TCP implementation <bcp14>MAY</bcp14> send an ACK segment acknowledging RCV.NXT when a
        valid segment arrives that is in the window but not at the
        left window edge (MAY-13).
        </li>
                          <li>
        Please note the window management suggestions in <xref target="datacomm" format="default"/>.
        </li>
                          <li>
                            <t>
        Send an acknowledgment of the form:
                            </t>
                            <t>
          &lt;SEQ=SND.NXT&gt;&lt;ACK=RCV.NXT&gt;&lt;CTL=ACK&gt;
          </t>
                          </li>
                          <li>
        This acknowledgment should be piggybacked on a segment being
        transmitted if possible without incurring undue delay.
        </li>
                        </ul>
                      </li>
                      <li>
      CLOSE-WAIT STATE</li>
                      <li>
      CLOSING STATE</li>
                      <li>
      LAST-ACK STATE</li>
                      <li>
                        <t>
      TIME-WAIT STATE
                        </t>
                        <ul spacing="normal">
                          <li>
        This should not occur since a FIN has been received from the
        remote side.  Ignore the segment text.
        </li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                  <li>
                    <t>
    Eighth, check the FIN bit:
                    </t>
                    <ul spacing="normal">
                      <li>
      Do not process the FIN if the state is CLOSED, LISTEN, or SYN-SENT
      since the SEG.SEQ cannot be validated; drop the segment and
      return.
      </li>
                      <li>
                        <t>
      If the FIN bit is set, signal the user "connection closing" and
      return any pending RECEIVEs with same message, advance RCV.NXT
      over the FIN, and send an acknowledgment for the FIN.  Note that
      FIN implies PUSH for any segment text not yet delivered to the
      user.
                        </t>
                        <ul spacing="normal">
                          <li>
        SYN-RECEIVED STATE</li>
                          <li>
                            <t>
        ESTABLISHED STATE
                            </t>
                            <ul spacing="normal">
                              <li>
          Enter the CLOSE-WAIT state.
          </li>
                            </ul>
                          </li>
                          <li>
                            <t>
        FIN-WAIT-1 STATE
                            </t>
                            <ul spacing="normal">
                              <li>
          If our FIN has been ACKed (perhaps in this segment), then
          enter TIME-WAIT, start the time-wait timer, turn off the other
          timers; otherwise, enter the CLOSING state.
          </li>
                            </ul>
                          </li>
                          <li>
                            <t>
        FIN-WAIT-2 STATE
                            </t>
                            <ul spacing="normal">
                              <li>
          Enter the TIME-WAIT state.  Start the time-wait timer, turn
          off the other timers.
          </li>
                            </ul>
                          </li>
                          <li>
                            <t>
        CLOSE-WAIT STATE
                            </t>
                            <ul spacing="normal">
                              <li>
          Remain in the CLOSE-WAIT state.
          </li>
                            </ul>
                          </li>
                          <li>
                            <t>
        CLOSING STATE
                            </t>
                            <ul spacing="normal">
                              <li>
          Remain in the CLOSING state.
          </li>
                            </ul>
                          </li>
                          <li>
                            <t>
        LAST-ACK STATE
                            </t>
                            <ul spacing="normal">
                              <li>
          Remain in the LAST-ACK state.
          </li>
                            </ul>
                          </li>
                          <li>
                            <t>
        TIME-WAIT STATE
                            </t>
                            <ul spacing="normal">
                              <li>
          Remain in the TIME-WAIT state.  Restart the 2 MSL time-wait
          timeout.
          </li>
                            </ul>
                          </li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                  <li>
    and return.
    </li>
</ul>
          </section>
        </section>
        <section numbered="true" toc="default">
          <name>Timeouts</name>
              <t>
  USER TIMEOUT
              </t>
              <ul spacing="normal">
                <li>
    For any state if the user timeout expires, flush all queues, signal
    the user "error:  connection aborted due to user timeout" in general
    and for any outstanding calls, delete the TCB, enter the CLOSED
    state, and return.
  </li>
              </ul>
              <t>
  RETRANSMISSION TIMEOUT
              </t>
              <ul spacing="normal">
                <li>
    For any state if the retransmission timeout expires on a segment in
    the retransmission queue, send the segment at the front of the
    retransmission queue again, reinitialize the retransmission timer,
    and return.
  </li>
              </ul>
              <t>
  TIME-WAIT TIMEOUT
              </t>
              <ul spacing="normal">
                <li>
    If the time-wait timeout expires on a connection, delete the TCB,
    enter the CLOSED state, and return.
  </li>
              </ul>
        </section>
      </section>
    </section>
    <section anchor="glossary" numbered="true" toc="default">
      <name>Glossary</name>
      <dl newline="true" spacing="normal" indent="8">
        <dt>ACK</dt>
        <dd>
          A control bit (acknowledge) occupying no sequence space, which
          indicates that the acknowledgment field of this segment
          specifies the next sequence number the sender of this segment
          is expecting to receive, hence acknowledging receipt of all
          previous sequence numbers.</dd>
        <dt>connection</dt>
        <dd>
          A logical communication path identified by a pair of sockets.</dd>
        <dt>datagram</dt>
        <dd>
          A message sent in a packet-switched computer communications
          network.</dd>
        <dt>Destination Address</dt>
        <dd>
          The network-layer address of the endpoint intended to receive a segment.</dd>
        <dt>FIN</dt>
        <dd>
          A control bit (finis) occupying one sequence number, which
          indicates that the sender will send no more data or control
          occupying sequence space.</dd>
        <dt>flush</dt>
        <dd>
          To remove all of the contents (data or segments) from a store (buffer or queue).</dd>
        <dt>fragment</dt>
        <dd>
          A portion of a logical unit of data. In particular, an internet
          fragment is a portion of an internet datagram.</dd>
        <dt>header</dt>
        <dd>
          Control information at the beginning of a message, segment,
          fragment, packet, or block of data.</dd>
        <dt>host</dt>
        <dd>
          A computer.  In particular, a source or destination of messages
          from the point of view of the communication network.</dd>
        <dt>Identification</dt>
        <dd>
          An Internet Protocol field.  This identifying value assigned
          by the sender aids in assembling the fragments of a datagram.</dd>
        <dt>internet address</dt>
        <dd>
          A network-layer address.</dd>
        <dt>internet datagram</dt>
        <dd>
          A unit of data exchanged between internet hosts, together with the internet header
	  that allows the datagram to be routed from source to destination.</dd>
        <dt>internet fragment</dt>
        <dd>
          A portion of the data of an internet datagram with an internet
          header.</dd>
        <dt>IP</dt>
        <dd>
          Internet Protocol. See <xref target="RFC0791" format="default"/> and <xref target="RFC8200" format="default"/>.</dd>
        <dt>IRS</dt>
        <dd>
          The Initial Receive Sequence number.  The first sequence
          number used by the sender on a connection.</dd>
        <dt>ISN</dt>
        <dd>
          The Initial Sequence Number.  The first sequence number used
          on a connection (either ISS or IRS).  Selected in a way that is unique within a given period of time and is unpredictable to attackers.</dd>
        <dt>ISS</dt>
        <dd>
          The Initial Send Sequence number.  The first sequence number
          used by the sender on a connection.</dd>
        <dt>left sequence</dt>
        <dd>
          This is the next sequence number to be acknowledged by the
          data-receiving TCP endpoint (or the lowest currently unacknowledged
          sequence number) and is sometimes referred to as the left edge
          of the send window.</dd>
        <dt>module</dt>
        <dd>
          An implementation, usually in software, of a protocol or other
          procedure.</dd>
        <dt>MSL</dt>
        <dd>
          Maximum Segment Lifetime, the time a TCP segment can exist in
          the internetwork system.  Arbitrarily defined to be 2 minutes.</dd>
        <dt>octet</dt>
        <dd>
          An eight-bit byte.</dd>
        <dt>Options</dt>
        <dd>
          An Option field may contain several options, and each option
          may be several octets in length.</dd>
        <dt>packet</dt>
        <dd>
          A package of data with a header that may or may not be
          logically complete.  More often a physical packaging than a
          logical packaging of data.</dd>
        <dt>port</dt>
        <dd>
          The portion of a connection identifier used for demultiplexing connections
	  at an endpoint.</dd>
        <dt>process</dt>
        <dd>
          A program in execution.  A source or destination of data from
          the point of view of the TCP endpoint or other host-to-host protocol.</dd>
        <dt>PUSH</dt>
        <dd>
          A control bit occupying no sequence space, indicating that
          this segment contains data that must be pushed through to the
          receiving user.</dd>
        <dt>RCV.NXT</dt>
        <dd>
          receive next sequence number</dd>
        <dt>RCV.UP</dt>
        <dd>
          receive urgent pointer</dd>
        <dt>RCV.WND</dt>
        <dd>
          receive window</dd>
        <dt>receive next sequence number</dt>
        <dd>
          This is the next sequence number the local TCP endpoint is expecting to
              receive.</dd>
        <dt>receive window</dt>
        <dd>
          This represents the sequence numbers the local (receiving) TCP endpoint
          is willing to receive.  Thus, the local TCP endpoint considers that
          segments overlapping the range RCV.NXT to
          RCV.NXT + RCV.WND - 1 carry acceptable data or control.
          Segments containing sequence numbers entirely outside this
          range are considered duplicates or injection attacks and discarded.</dd>
        <dt>RST</dt>
        <dd>
          A control bit (reset), occupying no sequence space, indicating
          that the receiver should delete the connection without further
          interaction.  The receiver can determine, based on the
          sequence number and acknowledgment fields of the incoming
          segment, whether it should honor the reset command or ignore
          it.  In no case does receipt of a segment containing RST give
          rise to a RST in response.</dd>
        <dt>SEG.ACK</dt>
        <dd>
          segment acknowledgment</dd>
        <dt>SEG.LEN</dt>
        <dd>
          segment length</dd>
        <dt>SEG.SEQ</dt>
        <dd>
          segment sequence</dd>
        <dt>SEG.UP</dt>
        <dd>
          segment urgent pointer field</dd>
        <dt>SEG.WND</dt>
        <dd>
          segment window field</dd>
        <dt>segment</dt>
        <dd>
          A logical unit of data. In particular, a TCP segment is the
          unit of data transferred between a pair of TCP modules.</dd>
        <dt>segment acknowledgment</dt>
        <dd>
          The sequence number in the acknowledgment field of the
          arriving segment.</dd>
        <dt>segment length</dt>
        <dd>
          The amount of sequence number space occupied by a segment,
          including any controls that occupy sequence space.</dd>
        <dt>segment sequence</dt>
        <dd>
          The number in the sequence field of the arriving segment.</dd>
        <dt>send sequence</dt>
        <dd>
          This is the next sequence number the local (sending) TCP endpoint will
          use on the connection.  It is initially selected from an
          initial sequence number curve (ISN) and is incremented for
          each octet of data or sequenced control transmitted.</dd>
        <dt>send window</dt>
        <dd>
          This represents the sequence numbers that the remote
          (receiving) TCP endpoint is willing to receive.  It is the value of the
          window field specified in segments from the remote (data-receiving)
          TCP endpoint.  The range of new sequence numbers that may
          be emitted by a TCP implementation lies between SND.NXT and
          SND.UNA + SND.WND - 1. (Retransmissions of sequence numbers
          between SND.UNA and SND.NXT are expected, of course.)</dd>
        <dt>SND.NXT</dt>
        <dd>
          send sequence</dd>
        <dt>SND.UNA</dt>
        <dd>
          left sequence</dd>
        <dt>SND.UP</dt>
        <dd>
          send urgent pointer</dd>
        <dt>SND.WL1</dt>
        <dd>
          segment sequence number at last window update</dd>
        <dt>SND.WL2</dt>
        <dd>
          segment acknowledgment number at last window update</dd>
        <dt>SND.WND</dt>
        <dd>
          send window</dd>
        <dt>socket (or socket number, or socket address, or socket identifier)</dt>
        <dd>
          An address that specifically includes a port identifier, that
          is, the concatenation of an Internet Address with a TCP port.</dd>
        <dt>Source Address</dt>
        <dd>
          The network-layer address of the sending endpoint.</dd>
        <dt>SYN</dt>
        <dd>
          A control bit in the incoming segment, occupying one sequence
          number, used at the initiation of a connection to indicate
          where the sequence numbering will start.</dd>
        <dt>TCB</dt>
        <dd>
          Transmission control block, the data structure that records
          the state of a connection.</dd>
        <dt>TCP</dt>
        <dd>
          Transmission Control Protocol:  a host-to-host protocol for
          reliable communication in internetwork environments.</dd>
        <dt>TOS</dt>
        <dd>
          Type of Service, an obsoleted IPv4 field.  The same header bits currently are used for the Differentiated Services field <xref target="RFC2474" format="default"/> containing the Differentiated Services Codepoint (DSCP) value and the 2-bit ECN codepoint <xref target="RFC3168" format="default"/>.</dd>
        <dt>Type of Service</dt>
        <dd>
          See "TOS".</dd>
        <dt>URG</dt>
        <dd>
          A control bit (urgent), occupying no sequence space, used to
          indicate that the receiving user should be notified to do
          urgent processing as long as there is data to be consumed with
          sequence numbers less than the value indicated by the urgent
          pointer.</dd>
        <dt>urgent pointer</dt>
        <dd>
          A control field meaningful only when the URG bit is on.  This
          field communicates the value of the urgent pointer that
          indicates the data octet associated with the sending user's
          urgent call.</dd>
      </dl>
    </section>
    <section anchor="changes" numbered="true" toc="default">
      <name>Changes from RFC 793</name>
      <t>
            This document obsoletes RFC 793 as well as RFCs 6093 and 6528, which updated 793.  In all cases, only the normative protocol specification and requirements have been incorporated into this document, and some informational text with background and rationale may not have been carried in.  The informational content of those documents is still valuable in learning about and understanding TCP, and they are valid Informational references, even though their normative content has been incorporated into this document.
      </t>
      <t>
            The main body of this document was adapted from RFC 793's Section <xref target="RFC0793" section="3" sectionFormat="bare" format="default"/>, titled "FUNCTIONAL SPECIFICATION", with an attempt to keep formatting and layout as close as possible.
      </t>
      <t>
            The collection of applicable RFC errata that have been reported and either accepted or held for an update to RFC 793 were incorporated (Errata IDs: 573 <xref target="Err573" format="default"/>, 574 <xref target="Err574" format="default"/>, 700 <xref target="Err700" format="default"/>, 701 <xref target="Err701" format="default"/>, 1283 <xref target="Err1283" format="default"/>, 1561 <xref target="Err1561" format="default"/>, 1562 <xref target="Err1562" format="default"/>, 1564 <xref target="Err1564" format="default"/>, 1571 <xref target="Err1571" format="default"/>, 1572 <xref target="Err1572" format="default"/>, 2297 <xref target="Err2297" format="default"/>, 2298 <xref target="Err2298" format="default"/>, 2748 <xref target="Err2748" format="default"/>, 2749 <xref target="Err2749" format="default"/>, 2934 <xref target="Err2934" format="default"/>, 3213 <xref target="Err3213" format="default"/>, 3300 <xref target="Err3300" format="default"/>, 3301 <xref target="Err3301" format="default"/>, 6222 <xref target="Err6222" format="default"/>).  Some errata were not applicable due to other changes (Errata IDs: 572 <xref target="Err572" format="default"/>, 575 <xref target="Err575" format="default"/>, 1565 <xref target="Err1565" format="default"/>, 1569 <xref target="Err1569" format="default"/>, 2296 <xref target="Err2296" format="default"/>, 3305 <xref target="Err3305" format="default"/>, 3602 <xref target="Err3602" format="default"/>).
      </t>
      <t>
            Changes to the specification of the urgent pointer described in RFCs 1011, 1122, and 6093 were incorporated.  See RFC 6093 for detailed discussion of why these changes were necessary.
      </t>
      <t>
The discussion of the RTO from RFC 793 was updated to refer to RFC 6298.  The text on the RTO in RFC 1122 originally replaced the text in RFC 793; however, RFC 2988 should have updated RFC 1122 and has subsequently been obsoleted by RFC 6298.
      </t>
      <t>
RFC 1011 <xref target="RFC1011" format="default"/> contains a number of comments about RFC 793, including some needed changes to the TCP specification.  These are expanded in RFC 1122, which contains a collection of other changes and clarifications to RFC 793.  The normative items impacting the protocol have been incorporated here, though some historically useful implementation advice and informative discussion from RFC 1122 is not included here.  The present document, which is now the TCP specification rather than RFC 793, updates RFC 1011, and the comments noted in RFC 1011 have been incorporated.
      </t>
      <t>
RFC 1122 contains more than just TCP requirements, so this document can't obsolete RFC 1122 entirely.  It is only marked as "updating" RFC 1122; however, it should be understood to effectively obsolete all of the material on TCP found in RFC 1122.
      </t>
      <t>
            The more secure initial sequence number generation algorithm from RFC 6528 was incorporated.  See RFC 6528 for discussion of the attacks that this mitigates, as well as advice on selecting PRF algorithms and managing secret key data.
      </t>
      <t>
A note based on RFC 6429 was added to explicitly clarify that system resource management concerns allow connection resources to be reclaimed.  RFC 6429 is obsoleted in the sense that the clarification it describes has been reflected within this base TCP specification.
      </t>
      <t>
	The description of congestion control implementation was added based on the set of documents that are IETF BCP or Standards Track on the topic and the current state of common implementations.
      </t>
    </section>
    <section anchor="IANA" numbered="true" toc="default">
      <name>IANA Considerations</name>
      <t>
    In the "Transmission Control Protocol (TCP) Header Flags" registry, IANA has made several changes as described in this section.</t>
      <t>RFC 3168 originally created this registry but only populated it with the new bits defined in RFC 3168, neglecting the other bits that had previously been described in RFC 793 and other documents.  Bit 7 has since also been updated by RFC 8311 <xref target="RFC8311" format="default"/>.</t>
      <t>The "Bit" column has been renamed below as the "Bit Offset" column because it references each header flag's offset within the 16-bit aligned view of the TCP header in <xref target="header_format" format="default"/>.  The bits in offsets 0 through 3 are the TCP segment Data Offset field, and not header flags.</t>
      <t>IANA has added a column for "Assignment Notes".</t>
      <t>IANA has assigned values as indicated below.</t>
      <table>
        <name>TCP Header Flags</name>
        <thead>
          <tr>
            <th>Bit Offset</th>
            <th>Name</th>                                      
            <th>Reference</th>      
            <th>Assignment Notes</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>4</td>   
            <td>Reserved for future use</td>    
            <td>RFC 9293</td>
            <td></td>
          </tr>
          <tr>
            <td>5</td>
            <td>Reserved for future use</td>  
            <td>RFC 9293</td>
            <td></td>
          </tr>
          <tr>
            <td>6</td>
            <td>Reserved for future use</td>    
            <td>RFC 9293</td>
            <td></td>
          </tr>
          <tr>
            <td>7</td> 
            <td>Reserved for future use</td>  
            <td>RFC 8311</td>     
            <td>Previously used by Historic RFC 3540 as NS (Nonce Sum).</td>      
          </tr>
          <tr>
            <td>8</td>    
            <td>CWR (Congestion Window Reduced)</td>    
            <td>RFC 3168</td>
            <td></td>
          </tr>
          <tr>
            <td>9</td> 
            <td>ECE (ECN-Echo)</td>   
            <td>RFC 3168</td>
            <td></td>
          </tr>
          <tr>
            <td>10</td>    
            <td>Urgent pointer field is significant (URG)</td>  
            <td>RFC 9293</td>
            <td></td>
          </tr>
          <tr>
            <td>11</td>  
            <td>Acknowledgment field is significant (ACK)</td>  
            <td>RFC 9293</td>
            <td></td>
          </tr>
          <tr>
            <td>12</td>     
            <td>Push function (PSH)</td>  
            <td>RFC 9293</td>
            <td></td>
          </tr>
          <tr>
            <td>13</td>    
            <td>Reset the connection (RST)</td>   
            <td>RFC 9293</td>
            <td></td>
          </tr>
          <tr>
            <td>14</td>   
            <td>Synchronize sequence numbers (SYN)</td>  
            <td>RFC 9293</td>
            <td></td>
          </tr>
          <tr>
            <td>15</td>    
            <td>No more data from sender (FIN)</td>     
            <td>RFC 9293</td>
            <td></td>
          </tr>
        </tbody>
     </table>

      <t>The "TCP Header Flags" registry has also been moved to a subregistry under the global "Transmission Control Protocol (TCP) Parameters" registry <eref target="https://www.iana.org/assignments/tcp-parameters/" brackets="angle"/>.</t>
      <t>The registry's Registration Procedure remains Standards Action, but the Reference has been updated to this document, and the Note has been removed.</t>
    </section>
    <section anchor="Security" numbered="true" toc="default">
      <name>Security and Privacy Considerations</name>
      <t>
The TCP design includes only rudimentary security features that improve the robustness and reliability of connections and application data transfer, but there are no built-in cryptographic capabilities to support any form of confidentiality, authentication, or other typical security functions.  Non-cryptographic enhancements (e.g., <xref target="RFC5961" format="default"/>) have been developed to improve robustness of TCP connections to particular types of attacks, but the applicability and protections of non-cryptographic enhancements are limited (e.g., see <xref target="RFC5961" section="1.1" sectionFormat="of" format="default"/>).
Applications typically utilize lower-layer (e.g., IPsec) and upper-layer (e.g., TLS) protocols to provide security and privacy for TCP connections and application data carried in TCP.  Methods based on TCP Options have been developed as well, to support some security capabilities.
      </t>
      <t>
In order to fully provide confidentiality, integrity protection, and authentication for TCP connections (including their control flags), IPsec is the only current effective method.  For integrity protection and authentication, the TCP Authentication Option (TCP-AO) <xref target="RFC5925" format="default"/> is available, with a proposed extension to also provide confidentiality for the segment payload.
Other methods discussed in this section may provide confidentiality or integrity protection for
the payload, but for the TCP header only cover either a subset of the fields (e.g., tcpcrypt <xref target="RFC8548" format="default"/>) or none at
all (e.g., TLS).  Other security features that have been added to TCP (e.g., ISN
generation, sequence number checks, and others) are only capable of partially
hindering attacks.

      </t>
      <t>
Applications using long-lived TCP flows have been vulnerable to attacks that exploit the processing of control flags described in earlier TCP specifications <xref target="RFC4953" format="default"/>.  TCP-MD5 was a commonly implemented TCP Option to support authentication for some of these connections, but had flaws and is now deprecated.  TCP-AO provides a capability to protect long-lived TCP connections from attacks and has superior properties to TCP-MD5.  It does not provide any privacy for application data or for the TCP headers.
      </t>
      <t>
The "tcpcrypt" <xref target="RFC8548" format="default"/> experimental extension to TCP provides the ability to cryptographically protect connection data.  Metadata aspects of the TCP flow are still visible, but the application stream is well protected.  Within the TCP header, only the urgent pointer and FIN flag are protected through tcpcrypt.
      </t>
      <t>
The TCP Roadmap <xref target="RFC7414" format="default"/> includes notes about several RFCs related to TCP security.  Many of the enhancements provided by these RFCs have been integrated into the present document, including ISN generation, mitigating blind in-window attacks, and improving handling of soft errors and ICMP packets.  These are all discussed in greater detail in the referenced RFCs that originally described the changes needed to earlier TCP specifications.  Additionally, see RFC 6093 <xref target="RFC6093" format="default"/> for discussion of security considerations related to the urgent pointer field, which also discourages new applications from using the urgent pointer.
      </t>
      <t>
Since TCP is often used for bulk transfer flows, some attacks are possible that abuse the TCP congestion control logic.  An example is "ACK-division" attacks. Updates that have been made to the TCP congestion control specifications include mechanisms like Appropriate Byte Counting (ABC) <xref target="RFC3465" format="default"/> that act as mitigations to these attacks.
      </t>
      <t>
Other attacks are focused on exhausting the resources of a TCP server.  Examples include SYN flooding <xref target="RFC4987" format="default"/> or wasting resources on non-progressing connections <xref target="RFC6429" format="default"/>.  Operating systems commonly implement mitigations for these attacks.  Some common defenses also utilize proxies, stateful firewalls, and other technologies outside the end-host TCP implementation.
</t>
      <t>
The concept of a protocol's "wire image" is described in RFC 8546 <xref target="RFC8546" format="default"/>, which describes how TCP's cleartext headers expose more metadata to nodes on the path than is strictly required to route the packets to their destination.  On-path adversaries may be able to leverage this metadata.  Lessons learned in this respect from TCP have been applied in the design of newer transports like QUIC <xref target="RFC9000" format="default"/>.  Additionally, based partly on experiences with TCP and its extensions, there are considerations that might be applicable for future TCP extensions and other transports that the IETF has documented in RFC 9065 <xref target="RFC9065" format="default"/>, along with IAB recommendations in RFC 8558 <xref target="RFC8558" format="default"/> and <xref target="RFC9170" format="default"/>.
      </t>
      <t>
There are also methods of "fingerprinting" that can be used to infer the host TCP implementation (operating system) version or platform information.  These collect observations of several aspects, such as the options present in segments, the ordering of options, the specific behaviors in the case of various conditions, packet timing, packet sizing, and other aspects of the protocol that are left to be determined by an implementer, and can use those observations to identify information about the host and implementation.
      </t>
      <t>
Since ICMP message processing also can interact with TCP connections, there is potential for ICMP-based attacks against TCP connections.  These are discussed in RFC 5927 <xref target="RFC5927" format="default"/>, along with mitigations that have been implemented.
      </t>
    </section>
  </middle>
<back>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.0791.xml"/>
        <reference anchor="RFC1191" target="https://www.rfc-editor.org/info/rfc1191">
          <front>
            <title>Path MTU discovery</title>
            <author fullname="J.C. Mogul" initials="J." surname="Mogul"/>
            <author fullname="S.E.  Deering" initials="S." surname="Deering"/>
            <date month="November" year="1990"/>
          </front>
          <seriesInfo name="RFC" value="1191"/>
          <seriesInfo name="DOI" value="10.17487/RFC1191"/>
        </reference>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2474.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2914.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3168.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5033.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5681.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5961.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6298.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6633.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8200.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8201.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8961.xml"/>
      </references>
      <references>
        <name>Informative References</name>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.0793.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.0896.xml"/>
        <reference anchor="RFC1011" target="https://www.rfc-editor.org/info/rfc1011">
          <front>
            <title>Official Internet protocols</title>
            <author fullname="J.K. Reynolds" initials="J." surname="Reynolds"/>
            <author fullname="J. Postel" initials="J." surname="Postel"/>
            <date month="May" year="1987"/>
          </front>
          <seriesInfo name="RFC" value="1011"/>
          <seriesInfo name="DOI" value="10.17487/RFC1011"/>
        </reference>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1122.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1349.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1644.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2018.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2525.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2675.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2873.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2883.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2923.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3449.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3465.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4727.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4821.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4987.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4953.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5044.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5461.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5570.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5795.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5925.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6093.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6191.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6429.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6528.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6691.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6864.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6994.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7094.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7323.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7413.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7414.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7657.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8087.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8095.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8303.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8311.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8504.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8546.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8548.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8558.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8684.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.9000.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.9065.xml"/>
        <reference anchor="TCP-parameters-registry" target="https://www.iana.org/assignments/tcp-parameters/">
          <front>
            <title>Transmission Control Protocol (TCP) Parameters
            </title>
            <author>
              <organization>IANA</organization>
            </author>
          </front>
        </reference>
        <xi:include href="https://datatracker.ietf.org/doc/bibxml3/draft-gont-tcpm-tcp-seccomp-prec.xml"/>
        <xi:include href="https://datatracker.ietf.org/doc/bibxml3/draft-gont-tcpm-tcp-seq-validation.xml"/>
        <xi:include href="https://datatracker.ietf.org/doc/bibxml3/draft-ietf-tcpm-tcp-edo.xml"/>
        <xi:include href="https://datatracker.ietf.org/doc/bibxml3/draft-mcquistin-augmented-ascii-diagrams.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.9170.xml"/>
        <xi:include href="https://datatracker.ietf.org/doc/bibxml3/draft-minshall-nagle.xml"/>
        <reference anchor="DS78">
          <front>
            <title>Connection Management in Transport Protocols</title>
            <author initials="Y" surname="Dalal"/>
            <author initials="C" surname="Sunshine"/>
            <date year="1978" month="December"/>
          </front>
          <refcontent>Computer Networks, Vol. 2, No. 6, pp. 454-473</refcontent>
          <seriesInfo name="DOI" value="10.1016/0376-5075(78)90053-3"/>
        </reference>
        <reference anchor="FTY99">
          <front>
            <title>The TIME-WAIT state in TCP and Its Effect on Busy Servers</title>
            <author initials="T" surname="Faber"/>
            <author initials="J" surname="Touch"/>
            <author initials="W" surname="Yui"/>
            <date year="1999" month="March"/>
          </front>
          <refcontent>Proceedings of IEEE INFOCOM, pp. 1573-1583</refcontent>
          <seriesInfo name="DOI" value="10.1109/INFCOM.1999.752180"/>
        </reference>
        <reference anchor="IEN177" target="https://www.rfc-editor.org/ien/ien177.txt">
          <front>
            <title>Comments on Action Items from the January Meeting</title>
            <author initials="J" surname="Postel"/>
            <date year="1981" month="March"/>
          </front>
          <seriesInfo name="IEN" value="177"/>
        </reference>
        <reference anchor="offload" target="https://www.kernel.org/doc/html/latest/networking/segmentation-offloads.html">
          <front>
            <title>Segmentation Offloads</title>
            <author/>
            <date/>
          </front>
          <refcontent>The Linux Kernel Documentation</refcontent>
        </reference>
        <reference anchor="Err573" quote-title="false" target="https://www.rfc-editor.org/errata/eid573"> 
          <front> 
             <title>Erratum ID 573</title>
             <author>
                <organization>RFC Errata</organization>
             </author> 
          </front> 
          <refcontent>RFC 793</refcontent>
        </reference>
        <reference anchor="Err574" quote-title="false" target="https://www.rfc-editor.org/errata/eid574"> 
          <front> 
             <title>Erratum ID 574</title>
             <author>
                <organization>RFC Errata</organization>
             </author> 
          </front> 
          <refcontent>RFC 793</refcontent>
        </reference>
        <reference anchor="Err700" quote-title="false" target="https://www.rfc-editor.org/errata/eid700"> 
          <front> 
             <title>Erratum ID 700</title>
             <author>
                <organization>RFC Errata</organization>
             </author> 
          </front> 
          <refcontent>RFC 793</refcontent>
        </reference>
        <reference anchor="Err701" quote-title="false" target="https://www.rfc-editor.org/errata/eid701"> 
          <front> 
             <title>Erratum ID 701</title>
             <author>
                <organization>RFC Errata</organization>
             </author> 
          </front> 
          <refcontent>RFC 793</refcontent>
        </reference>
        <reference anchor="Err1283" quote-title="false" target="https://www.rfc-editor.org/errata/eid1283"> 
          <front> 
             <title>Erratum ID 1283</title>
             <author>
                <organization>RFC Errata</organization>
             </author> 
          </front> 
          <refcontent>RFC 793</refcontent>
        </reference>
        <reference anchor="Err1561" quote-title="false" target="https://www.rfc-editor.org/errata/eid1561"> 
          <front> 
             <title>Erratum ID 1561</title>
             <author>
                <organization>RFC Errata</organization>
             </author> 
          </front> 
          <refcontent>RFC 793</refcontent>
        </reference>
        <reference anchor="Err1562" quote-title="false" target="https://www.rfc-editor.org/errata/eid1562"> 
          <front> 
             <title>Erratum ID 1562</title>
             <author>
                <organization>RFC Errata</organization>
             </author> 
          </front> 
          <refcontent>RFC 793</refcontent>
        </reference> 
        <reference anchor="Err1564" quote-title="false" target="https://www.rfc-editor.org/errata/eid1564"> 
          <front> 
             <title>Erratum ID 1564</title>
             <author>
                <organization>RFC Errata</organization>
             </author> 
          </front> 
          <refcontent>RFC 793</refcontent>
        </reference>
        <reference anchor="Err1571" quote-title="false" target="https://www.rfc-editor.org/errata/eid1571"> 
          <front> 
             <title>Erratum ID 1571</title>
             <author>
                <organization>RFC Errata</organization>
             </author> 
          </front> 
          <refcontent>RFC 793</refcontent>
        </reference>
        <reference anchor="Err1572" quote-title="false" target="https://www.rfc-editor.org/errata/eid1572"> 
          <front> 
             <title>Erratum ID 1572</title>
             <author>
                <organization>RFC Errata</organization>
             </author> 
          </front> 
          <refcontent>RFC 793</refcontent>
       </reference> 
       <reference anchor="Err2297" quote-title="false" target="https://www.rfc-editor.org/errata/eid2297"> 
          <front> 
             <title>Erratum ID 2297</title>
             <author>
                <organization>RFC Errata</organization>
             </author> 
          </front> 
          <refcontent>RFC 793</refcontent>
        </reference>
        <reference anchor="Err2298" quote-title="false" target="https://www.rfc-editor.org/errata/eid2298"> 
          <front> 
             <title>Erratum ID 2298</title>
             <author>
                <organization>RFC Errata</organization>
             </author> 
          </front> 
          <refcontent>RFC 793</refcontent>
        </reference> 
        <reference anchor="Err2748" quote-title="false" target="https://www.rfc-editor.org/errata/eid2748"> 
          <front> 
             <title>Erratum ID 2748</title>
             <author>
                <organization>RFC Errata</organization>
             </author> 
          </front> 
          <refcontent>RFC 793</refcontent>
        </reference>
        <reference anchor="Err2749" quote-title="false" target="https://www.rfc-editor.org/errata/eid2749"> 
          <front> 
             <title>Erratum ID 2749</title>
             <author>
                <organization>RFC Errata</organization>
             </author> 
          </front> 
          <refcontent>RFC 793</refcontent>
        </reference>
        <reference anchor="Err2934" quote-title="false" target="https://www.rfc-editor.org/errata/eid2934"> 
          <front> 
             <title>Erratum ID 2934</title>
             <author>
                <organization>RFC Errata</organization>
             </author> 
          </front> 
          <refcontent>RFC 793</refcontent>
        </reference>
        <reference anchor="Err3213" quote-title="false" target="https://www.rfc-editor.org/errata/eid3213"> 
         <front> 
             <title>Erratum ID 3213</title>
             <author>
                <organization>RFC Errata</organization>
             </author> 
          </front> 
          <refcontent>RFC 793</refcontent>
        </reference>
        <reference anchor="Err3300" quote-title="false" target="https://www.rfc-editor.org/errata/eid3300"> 
          <front> 
             <title>Erratum ID 3300</title>
             <author>
                <organization>RFC Errata</organization>
             </author> 
          </front> 
          <refcontent>RFC 793</refcontent>
        </reference> 
        <reference anchor="Err3301" quote-title="false" target="https://www.rfc-editor.org/errata/eid3301"> 
          <front> 
             <title>Erratum ID 3301</title>
             <author>
                <organization>RFC Errata</organization>
             </author> 
          </front> 
          <refcontent>RFC 793</refcontent>
        </reference>
        <reference anchor="Err6222" quote-title="false" target="https://www.rfc-editor.org/errata/eid6222"> 
          <front> 
             <title>Erratum ID 6222</title>
             <author>
                <organization>RFC Errata</organization>
             </author> 
          </front> 
          <refcontent>RFC 793</refcontent>
        </reference>
        <reference anchor="Err572" quote-title="false" target="https://www.rfc-editor.org/errata/eid572"> 
          <front> 
             <title>Erratum ID 572</title>
             <author>
                <organization>RFC Errata</organization>
             </author> 
          </front> 
          <refcontent>RFC 793</refcontent>
        </reference>
        <reference anchor="Err575" quote-title="false" target="https://www.rfc-editor.org/errata/eid575"> 
          <front> 
             <title>Erratum ID 575</title>
             <author>
                <organization>RFC Errata</organization>
             </author> 
          </front> 
          <refcontent>RFC 793</refcontent>
        </reference>
        <reference anchor="Err1565" quote-title="false" target="https://www.rfc-editor.org/errata/eid1565"> 
          <front> 
             <title>Erratum ID 1565</title>
             <author>
                <organization>RFC Errata</organization>
             </author> 
          </front> 
          <refcontent>RFC 793</refcontent>
        </reference>
        <reference anchor="Err1569" quote-title="false" target="https://www.rfc-editor.org/errata/eid1569"> 
          <front> 
             <title>Erratum ID 1569</title>
             <author>
                <organization>RFC Errata</organization>
             </author> 
          </front> 
          <refcontent>RFC 793</refcontent>
        </reference>
        <reference anchor="Err2296" quote-title="false" target="https://www.rfc-editor.org/errata/eid2296"> 
          <front> 
             <title>Erratum ID 2296</title>
             <author>
                <organization>RFC Errata</organization>
             </author> 
          </front> 
          <refcontent>RFC 793</refcontent>
        </reference>
        <reference anchor="Err3305" quote-title="false" target="https://www.rfc-editor.org/errata/eid3305"> 
          <front> 
             <title>Erratum ID 3305</title>
             <author>
                <organization>RFC Errata</organization>
             </author> 
          </front> 
          <refcontent>RFC 793</refcontent>
        </reference>
        <reference anchor="Err3602" quote-title="false" target="https://www.rfc-editor.org/errata/eid3602"> 
          <front> 
             <title>Erratum ID 3602</title>
             <author>
                <organization>RFC Errata</organization>
             </author> 
          </front> 
          <refcontent>RFC 793</refcontent>
        </reference>
        <reference anchor="Err4772" quote-title="false" target="https://www.rfc-editor.org/errata/eid4772"> 
          <front> 
             <title>Erratum ID 4772</title>
             <author>
                <organization>RFC Errata</organization>
             </author> 
          </front> 
          <refcontent>RFC 5961</refcontent>
        </reference>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5927.xml"/>
      </references>
    </references>
    <section numbered="true" toc="default">
      <name>Other Implementation Notes</name>
      <t>
This section includes additional notes and references on TCP implementation decisions that are currently not a part of the RFC series or included within the TCP standard.  These items can be considered by implementers, but there was not yet a consensus to include them in the standard.
      </t>
      <section anchor="seccomp" numbered="true" toc="default">
        <name>IP Security Compartment and Precedence</name>
        <t>

The IPv4 specification <xref target="RFC0791" format="default"/> includes a precedence value in
the (now obsoleted) Type of Service (TOS) field.  It was modified in
<xref target="RFC1349" format="default"/> and then obsoleted by the definition of
Differentiated Services (Diffserv) <xref target="RFC2474" format="default"/>.  Setting and
conveying TOS between the network layer, TCP implementation, and applications is obsolete
and is replaced by Diffserv in the current TCP specification.

</t>
        <t>

RFC 793 required checking the IP security compartment and precedence on
incoming TCP segments for consistency within a connection and with
application requests.  Each of these aspects of IP have become outdated,
without specific updates to RFC 793.  The issues with precedence were
fixed by <xref target="RFC2873" format="default"/>, which is Standards Track, and so this
present TCP specification includes those changes.  However, the state of
IP security options that may be used by Multi-Level Secure (MLS) systems is not as apparent in
the IETF currently.

</t>
        <t>

Resetting connections when incoming packets do not meet expected security
compartment or precedence expectations has been recognized as a possible
attack vector <xref target="I-D.gont-tcpm-tcp-seccomp-prec" format="default"/>, and there has
been discussion about amending the TCP specification to prevent connections
from being aborted due to nonmatching IP security compartment and Diffserv
codepoint values.

</t>
        <section numbered="true" toc="default">
          <name>Precedence</name>
          <t>

In Diffserv, the former precedence values are treated as Class Selector
codepoints, and methods for compatible treatment are described in the Diffserv
architecture.  The RFC TCP specification defined by RFCs 793 and 1122 included logic intending to
have connections use the highest precedence requested by either endpoint
application, and to keep the precedence consistent throughout a connection.
This logic from the obsolete TOS is not applicable to Diffserv and should
not be included in TCP implementations, though changes to Diffserv values
within a connection are discouraged.  For discussion of this, see RFC 7657 (Sections <xref target="RFC7657" section="5.1" sectionFormat="bare" format="default"/>, <xref target="RFC7657" section="5.3" sectionFormat="bare" format="default"/>, and <xref target="RFC7657" section="6" sectionFormat="bare" format="default"/>) <xref target="RFC7657" format="default"/>.

</t>
          <t>

The obsoleted TOS processing rules in TCP assumed bidirectional (or symmetric) precedence values
used on a connection, but the Diffserv architecture is asymmetric.
Problems with the old TCP logic in this regard were described in <xref target="RFC2873" format="default"/>, and the solution described is to ignore IP precedence in
TCP.  Since RFC 2873 is a Standards Track document (although not marked as
updating RFC 793), current implementations are expected to be robust in these
conditions.  Note that the Diffserv field value used in each direction is a
part of the interface between TCP and the network layer, and values in use can be
indicated both ways between TCP and the application.

</t>
        </section>
        <section numbered="true" toc="default">
          <name>MLS Systems</name>
          <t>

  The IP Security Option (IPSO) and compartment defined in <xref target="RFC0791" format="default"/> was refined in RFC 1038, which was later obsoleted by RFC
  1108.  The Commercial IP Security Option (CIPSO) is defined in FIPS-188 (withdrawn by NIST in 2015) and
  is supported by some vendors and operating systems.  RFC 1108 is now
  Historic, though RFC 791 itself has not been updated to remove the IP
  Security Option.  For IPv6, a similar option (Common Architecture Label IPv6 Security Option (CALIPSO)) has been defined <xref target="RFC5570" format="default"/>.  RFC 793 includes logic that includes the IP
  security/compartment information in treatment of TCP segments.  References to
  the IP "security/compartment" in this document may be relevant for
  Multi-Level Secure (MLS) system implementers but can be ignored for non-MLS
  implementations, consistent with running code on the Internet.  See <xref target="seccomp" format="default"/> for further discussion.  Note that RFC 5570 describes some
  MLS networking scenarios where IPSO, CIPSO, or CALIPSO may be used.  In these
  special cases, TCP implementers should see Section <xref target="RFC5570" section="7.3.1" sectionFormat="bare" format="default"/> of RFC 5570 and
  follow the guidance in that document.

</t>
        </section>
      </section>
      <section anchor="seqval" numbered="true" toc="default">
        <name>Sequence Number Validation</name>
        <t>
There are cases where the TCP sequence number validation rules can prevent ACK fields from being processed.  This can result in connection issues, as described in
     <xref target="I-D.gont-tcpm-tcp-seq-validation" format="default"/>, which includes descriptions of potential problems in conditions of simultaneous open, self-connects, simultaneous close, and simultaneous window probes.  The document also describes potential changes to the TCP specification to mitigate the issue by expanding the acceptable sequence numbers.
</t>
        <t>
In Internet usage of TCP, these conditions rarely occur.  Common operating systems include different alternative mitigations, and the standard has not been updated yet to codify one of them, but implementers should consider the problems described in <xref target="I-D.gont-tcpm-tcp-seq-validation" format="default"/>.
</t>
      </section>
      <section anchor="minshall" numbered="true" toc="default">
        <name>Nagle Modification</name>
        <t>In common operating systems, both the Nagle algorithm and delayed acknowledgments are implemented and enabled by default.  TCP is used by many applications that have a request-response style of communication, where the combination of the Nagle algorithm and delayed acknowledgments can result in poor application performance.  A modification to the Nagle algorithm is described in <xref target="I-D.minshall-nagle" format="default"/> that improves the situation for these applications.
</t>
        <t>This modification is implemented in some common operating systems and does not impact TCP interoperability.  Additionally, many applications simply disable Nagle since this is generally supported by a socket option.  The TCP standard has not been updated to include this Nagle modification, but implementers may find it beneficial to consider.</t>
      </section>
      <section numbered="true" toc="default">
        <name>Low Watermark Settings</name>
        <t>Some operating system kernel TCP implementations include socket options that allow specifying the number of bytes in the buffer until the socket layer will pass sent data to TCP (SO_SNDLOWAT) or to the application on receiving (SO_RCVLOWAT).</t>
        <t>In addition, another socket option (TCP_NOTSENT_LOWAT) can be used to control the amount of unsent bytes in the write queue. This can help a sending TCP application to avoid creating large amounts of buffered data (and corresponding latency). As an example, this may be useful for applications that are multiplexing data from multiple upper-level streams onto a connection, especially when streams may be a mix of interactive/real-time and bulk data transfer.</t>
      </section>
    </section>
    <section anchor="reqs" numbered="true" toc="default">
      <name>TCP Requirement Summary</name>
      <t>This section is adapted from RFC 1122.</t>
      <t>Note that there is no requirement related to PLPMTUD in this list, but that PLPMTUD is recommended.</t>

<table anchor="tcp-req-summary">
  <name>TCP Requirements Summary</name>
  <thead>
    <tr>
      <th align="center">Feature</th>
      <th align="center">ReqID</th>
      <th align="center"><bcp14>MUST</bcp14></th>
      <th align="center"><bcp14>SHOULD</bcp14></th>
      <th align="center"><bcp14>MAY</bcp14></th>
      <th align="center"><bcp14>SHOULD NOT</bcp14></th>
      <th align="center"><bcp14>MUST NOT</bcp14></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th colspan="7">PUSH flag</th>
    </tr>
    <tr>
      <td>Aggregate or queue un-pushed data</td>
      <td>MAY-16</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Sender collapse successive PSH bits</td>
      <td>SHLD-27</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>SEND call can specify PUSH</td>
      <td>MAY-15</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><ul><li>If cannot: sender buffer indefinitely</li></ul></td>
      <td>MUST-60</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
    </tr>
    <tr>
      <td><ul><li>If cannot: PSH last segment</li></ul></td>
      <td>MUST-61</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Notify receiving ALP<sup>1</sup> of PSH</td>
      <td>MAY-17</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Send max size segment when possible</td>
      <td>SHLD-28</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <th colspan="7">Window</th>
    </tr>
    <tr>
      <td>Treat as unsigned number</td>
      <td>MUST-1</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Handle as 32-bit number</td>
      <td>REC-1</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Shrink window from right</td>
      <td>SHLD-14</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><ul><li>Send new data when window shrinks</li></ul></td>
      <td>SHLD-15</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><ul><li>Retransmit old unacked data within window</li></ul></td>
      <td>SHLD-16</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><ul><li>Time out conn for data past right edge</li></ul></td>
      <td>SHLD-17</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Robust against shrinking window</td>
      <td>MUST-34</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Receiver's window closed indefinitely</td>
      <td>MAY-8</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Use standard probing logic</td>
      <td>MUST-35</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Sender probe zero window</td>
      <td>MUST-36</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><ul><li>First probe after RTO</li></ul></td>
      <td>SHLD-29</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><ul><li>Exponential backoff</li></ul></td>
      <td>SHLD-30</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Allow window stay zero indefinitely</td>
      <td>MUST-37</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Retransmit old data beyond SND.UNA+SND.WND</td>
      <td>MAY-7</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Process RST and URG even with zero window</td>
      <td>MUST-66</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <th colspan="7">Urgent Data</th>
    </tr>
    <tr>
      <td>Include support for urgent pointer</td>
      <td>MUST-30</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Pointer indicates first non-urgent octet</td>
      <td>MUST-62</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Arbitrary length urgent data sequence</td>
      <td>MUST-31</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Inform ALP<sup>1</sup> asynchronously of urgent data </td>
      <td>MUST-32</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>ALP<sup>1</sup> can learn if/how much urgent data Q'd</td>
      <td>MUST-33</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>ALP employ the urgent mechanism</td>
      <td>SHLD-13</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <th colspan="7">TCP Options</th>
    </tr>
    <tr>
      <td>Support the mandatory option set</td>
      <td>MUST-4</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Receive TCP Option in any segment</td>
      <td>MUST-5</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Ignore unsupported options</td>
      <td>MUST-6</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Include length for all options except EOL+NOP</td>
      <td>MUST-68</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Cope with illegal option length</td>
      <td>MUST-7</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Process options regardless of word alignment</td>
      <td>MUST-64</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Implement sending &amp; receiving MSS Option</td>
      <td>MUST-14</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>IPv4 Send MSS Option unless 536</td>
      <td>SHLD-5</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>IPv6 Send MSS Option unless 1220</td>
      <td>SHLD-5</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Send MSS Option always</td>
      <td>MAY-3</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>IPv4 Send-MSS default is 536</td>
      <td>MUST-15</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>IPv6 Send-MSS default is 1220</td>
      <td>MUST-15</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Calculate effective send seg size</td>
      <td>MUST-16</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>MSS accounts for varying MTU</td>
      <td>SHLD-6</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>MSS not sent on non-SYN segments</td>
      <td>MUST-65</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
    </tr>
    <tr>
      <td>MSS value based on MMS_R</td>
      <td>MUST-67</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Pad with zero</td>
      <td>MUST-69</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <th colspan="7">TCP Checksums</th>
    </tr>
    <tr>
      <td>Sender compute checksum</td>
      <td>MUST-2</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Receiver check checksum</td>
      <td>MUST-3</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <th colspan="7">ISN Selection</th>
    </tr>
    <tr>
      <td>Include a clock-driven ISN generator component</td>
      <td>MUST-8</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Secure ISN generator with a PRF component</td>
      <td>SHLD-1</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>PRF computable from outside the host</td>
      <td>MUST-9</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
    </tr>
    <tr>
      <th colspan="7">Opening Connections</th>
    </tr>
    <tr>
      <td>Support simultaneous open attempts</td>
      <td>MUST-10</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>SYN-RECEIVED remembers last state</td>
      <td>MUST-11</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Passive OPEN call interfere with others</td>
      <td>MUST-41</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
    </tr>
    <tr>
      <td>Function: simultaneously LISTENs for same port</td>
      <td>MUST-42</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Ask IP for src address for SYN if necessary</td>
      <td>MUST-44</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><ul><li>Otherwise, use local addr of connection</li></ul></td>
      <td>MUST-45</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>OPEN to broadcast/multicast IP address</td>
      <td>MUST-46</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
    </tr>
    <tr>
      <td>Silently discard seg to bcast/mcast addr</td>
      <td>MUST-57</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <th colspan="7">Closing Connections</th>
    </tr>
    <tr>
      <td>RST can contain data</td>
      <td>SHLD-2</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Inform application of aborted conn</td>
      <td>MUST-12</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Half-duplex close connections</td>
      <td>MAY-1</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><ul><li>Send RST to indicate data lost</li></ul></td>
      <td>SHLD-3</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>In TIME-WAIT state for 2MSL seconds</td>
      <td>MUST-13</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><ul><li>Accept SYN from TIME-WAIT state</li></ul></td>
      <td>MAY-2</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><ul><li>Use Timestamps to reduce TIME-WAIT</li></ul></td>
      <td>SHLD-4</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <th colspan="7">Retransmissions</th>
    </tr>
    <tr>
      <td>Implement exponential backoff, slow start, and congestion avoidance</td>
      <td>MUST-19</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Retransmit with same IP identity</td>
      <td>MAY-4</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Karn's algorithm</td>
      <td>MUST-18</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <th colspan="7">Generating ACKs</th>
    </tr>
    <tr>
      <td>Aggregate whenever possible</td>
      <td>MUST-58</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Queue out-of-order segments</td>
      <td>SHLD-31</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Process all Q'd before send ACK</td>
      <td>MUST-59</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Send ACK for out-of-order segment</td>
      <td>MAY-13</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Delayed ACKs</td>
      <td>SHLD-18</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><ul><li>Delay &lt; 0.5 seconds</li></ul></td>
      <td>MUST-40</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><ul><li>Every 2nd full-sized segment or 2*RMSS ACK'd</li></ul></td>
      <td>SHLD-19</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Receiver SWS-Avoidance Algorithm</td>
      <td>MUST-39</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <th colspan="7">Sending Data</th>
    </tr>
    <tr>
      <td>Configurable TTL</td>
      <td>MUST-49</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Sender SWS-Avoidance Algorithm </td>
      <td>MUST-38</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Nagle algorithm</td>
      <td>SHLD-7</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><ul><li>Application can disable Nagle algorithm</li></ul></td>
      <td>MUST-17</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <th colspan="7">Connection Failures</th>
    </tr>
    <tr>
      <td>Negative advice to IP on R1 retransmissions</td>
      <td>MUST-20</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Close connection on R2 retransmissions</td>
      <td>MUST-20</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>ALP<sup>1</sup> can set R2</td>
      <td>MUST-21</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Inform ALP of  R1&lt;=retxs&lt;R2 </td>
      <td>SHLD-9</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Recommended value for R1</td>
      <td>SHLD-10</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Recommended value for R2</td>
      <td>SHLD-11</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Same mechanism for SYNs</td>
      <td>MUST-22</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><ul><li>R2 at least 3 minutes for SYN</li></ul></td>
      <td>MUST-23</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <th colspan="7">Send Keep-alive Packets</th>
    </tr>
    <tr>
      <td>Send Keep-alive Packets:</td>
      <td>MAY-5</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><ul><li>Application can request</li></ul></td>
      <td>MUST-24</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><ul><li>Default is "off"</li></ul></td>
      <td>MUST-25</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><ul><li>Only send if idle for interval</li></ul></td>
      <td>MUST-26</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><ul><li>Interval configurable</li></ul></td>
      <td>MUST-27</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><ul><li>Default at least 2 hrs.</li></ul></td>
      <td>MUST-28</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><ul><li>Tolerant of lost ACKs</li></ul></td>
      <td>MUST-29</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><ul><li>Send with no data</li></ul></td>
      <td>SHLD-12</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><ul><li>Configurable to send garbage octet</li></ul></td>
      <td>MAY-6</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <th colspan="7">IP Options</th>
    </tr>
    <tr>
      <td>Ignore options TCP doesn't understand</td>
      <td>MUST-50</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Timestamp support</td>
      <td>MAY-10</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Record Route support</td>
      <td>MAY-11</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Source Route:</td>
      <td></td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><ul><li>ALP<sup>1</sup> can specify</li></ul></td>
      <td>MUST-51</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><ul indent="6"><li>Overrides src route in datagram</li></ul></td>
      <td>MUST-52</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><ul><li>Build return route from src route</li></ul></td>
      <td>MUST-53</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><ul><li>Later src route overrides</li></ul></td>
      <td>SHLD-24</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <th colspan="7">Receiving ICMP Messages from IP</th>
    </tr>
    <tr>
      <td>Receiving ICMP messages from IP</td>
      <td>MUST-54</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><ul><li>Dest Unreach (0,1,5) =&gt; inform ALP</li></ul></td>
      <td>SHLD-25</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><ul><li>Abort on Dest Unreach (0,1,5)</li></ul></td>
      <td>MUST-56</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
    </tr>
    <tr>
      <td><ul><li>Dest Unreach (2-4) =&gt; abort conn</li></ul></td>
      <td>SHLD-26</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><ul><li>Source Quench =&gt; silent discard</li></ul></td>
      <td>MUST-55</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><ul><li>Abort on Time Exceeded</li></ul></td>
      <td>MUST-56</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
    </tr>
    <tr>
      <td><ul><li>Abort on Param Problem</li></ul></td>
      <td>MUST-56</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
    </tr>
    <tr>
      <th colspan="7">Address Validation</th>
    </tr>
    <tr>
      <td>Reject OPEN call to invalid IP address</td>
      <td>MUST-46</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Reject SYN from invalid IP address</td>
      <td>MUST-63</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Silently discard SYN to bcast/mcast addr</td>
      <td>MUST-57</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <th colspan="7">TCP/ALP Interface Services</th>
    </tr>
    <tr>
      <td>Error Report mechanism</td>
      <td>MUST-47</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>ALP can disable Error Report Routine</td>
      <td>SHLD-20</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>ALP can specify Diffserv field for sending</td>
      <td>MUST-48</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><ul><li>Passed unchanged to IP</li></ul></td>
      <td>SHLD-22</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>ALP can change Diffserv field during connection</td>
      <td>SHLD-21</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>ALP generally changing Diffserv during conn.</td>
      <td>SHLD-23</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Pass received Diffserv field up to ALP</td>
      <td>MAY-9</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>FLUSH call</td>
      <td>MAY-14</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Optional local IP addr param in OPEN</td>
      <td>MUST-43</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <th colspan="7">RFC 5961 Support</th>
    </tr>
    <tr>
      <td>Implement data injection protection</td>
      <td>MAY-12</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <th colspan="7">Explicit Congestion Notification</th>
    </tr>
    <tr>
      <td>Support ECN</td>
      <td>SHLD-8</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <th colspan="7">Alternative Congestion Control</th>
    </tr>
    <tr>
      <td>Implement alternative conformant algorithm(s)</td>
      <td>MAY-18</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td align="center">X</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
  </tbody>
</table>
      <t>
FOOTNOTES:

(1)  "ALP" means Application-Layer Program.
</t>
    </section>
    <section numbered="false" toc="default">
      <name>Acknowledgments</name>
      <t>
    This document is largely a revision of RFC 793, of which <contact fullname="Jon Postel"/> was the editor.  Due to his excellent work, it was able to last for three decades before we felt the need to revise it.
      </t>
      <t>
   <contact fullname="Andre Oppermann"/> was a contributor and helped to edit the first revision of this document.
      </t>
      <t>
    We are thankful for the assistance of the IETF TCPM working group chairs over the course of work on this document:
      </t>
        
          <contact fullname="Michael Scharf"/>
          
          <contact fullname="Yoshifumi Nishida"/>
     
          <contact fullname="Pasi Sarolahti"/>
        
          <contact fullname="Michael Tüxen"/>
      
      <t>
    During the discussions of this work on the TCPM mailing list, in
    working group meetings, and via area reviews, helpful comments,
    critiques, and reviews were received from (listed alphabetically
    by last name): <contact fullname="Praveen Balasubramanian"/>, <contact fullname="David Borman"/>, <contact fullname="Mohamed
    Boucadair"/>, <contact fullname="Bob Briscoe"/>, <contact fullname="Neal Cardwell"/>, <contact fullname="Yuchung Cheng"/>, <contact fullname="Martin Duke"/>,
    <contact fullname="Francis Dupont"/>, <contact fullname="Ted Faber"/>, <contact fullname="Gorry Fairhurst"/>, <contact fullname="Fernando Gont"/>, <contact fullname="Rodney
    Grimes"/>, <contact fullname="Yi Huang"/>, <contact fullname="Rahul Jadhav"/>, <contact fullname="Markku Kojo"/>, <contact fullname="Mike Kosek"/>, <contact fullname="Juhamatti
    Kuusisaari"/>, <contact fullname="Kevin Lahey"/>, <contact fullname="Kevin Mason"/>, <contact fullname="Matt Mathis"/>, <contact fullname="Stephen
    McQuistin"/>, <contact fullname="Jonathan Morton"/>, <contact fullname="Matt Olson"/>, <contact fullname="Tommy Pauly"/>, <contact fullname="Tom Petch"/>,
   <contact fullname="Hagen Paul Pfeifer"/>, <contact fullname="Kyle Rose"/>, <contact fullname="Anthony Sabatini"/>, <contact fullname="Michael Scharf"/>,
    <contact fullname="Greg Skinner"/>, <contact fullname="Joe Touch"/>, <contact fullname="Michael Tüxen"/>, <contact fullname="Reji Varghese"/>, <contact fullname="Bernie
    Volz"/>, <contact fullname="Tim Wicinski"/>, <contact fullname="Lloyd Wood"/>, and <contact fullname="Alex Zimmermann"/>.
      </t>
      <t>
   <contact fullname="Joe Touch"/> provided additional help in clarifying the description of segment size parameters and PMTUD/PLPMTUD recommendations.  Markku Kojo helped put together the text in the section on TCP Congestion Control.
      </t>
      <t>
    This document includes content from errata that were reported by (listed chronologically): <contact fullname="Yin Shuming"/>, <contact fullname="Bob Braden"/>, <contact fullname="Morris M. Keesan"/>, <contact fullname="Pei-chun Cheng"/>, <contact fullname="Constantin Hagemeier"/>, <contact fullname="Vishwas Manral"/>, <contact fullname="Mykyta Yevstifeyev"/>, <contact fullname="EungJun Yi"/>, <contact fullname="Botong Huang"/>, <contact fullname="Charles Deng"/>, <contact fullname="Merlin Buge"/>.
      </t>
    </section>
  </back>
</rfc>
