<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>


<rfc xmlns:xi="http://www.w3.org/2001/XInclude" ipr="trust200902" docName="draft-ietf-rats-architecture-22" number="9334" submissionType="IETF" category="info" consensus="true" tocInclude="true" sortRefs="true" symRefs="true" updates="" obsoletes="" xml:lang="en" version="3">

  <!-- xml2rfc v2v3 conversion 3.15.0 -->
  <front>

<title abbrev="RATS Arch &amp; Terms">Remote ATtestation procedureS (RATS) Architecture</title>
    <seriesInfo name="RFC" value="9334"/>
    <author initials="H." surname="Birkholz" fullname="Henk Birkholz">
      <organization abbrev="Fraunhofer SIT">Fraunhofer SIT</organization>
      <address>
        <postal>
          <street>Rheinstrasse 75</street>
          <city>Darmstadt</city>
          <code>64295</code>
          <country>Germany</country>
        </postal>
        <email>henk.birkholz@sit.fraunhofer.de</email>
      </address>
    </author>
    <author initials="D." surname="Thaler" fullname="Dave Thaler">
      <organization>Microsoft</organization>
      <address>
        <postal>
          <country>United States of America</country>
        </postal>
        <email>dthaler@microsoft.com</email>
      </address>
    </author>
    <author initials="M." surname="Richardson" fullname="Michael Richardson">
      <organization>Sandelman Software Works</organization>
      <address>
        <postal> 
         <country>Canada</country>
        </postal>
        <email>mcr+ietf@sandelman.ca</email>
      </address>
    </author>
    <author initials="N." surname="Smith" fullname="Ned Smith">
      <organization abbrev="Intel">Intel Corporation</organization>
      <address>
        <postal>
          <country>United States of America</country>
        </postal>
        <email>ned.smith@intel.com</email>
      </address>
    </author>
    <author initials="W." surname="Pan" fullname="Wei Pan">
      <organization abbrev="Huawei">Huawei Technologies</organization>
      <address>
        <email>william.panwei@huawei.com</email>
      </address>
    </author>
    <date year="2023" month="January"/>

    <area>sec</area>
    <workgroup>rats</workgroup>

    <abstract>
      <t>In network protocol exchanges, it is often useful for one end of a
communication to know whether the other end is in an intended operating state.
This document provides an architectural overview of the entities involved
that make such tests possible through the process of generating,
conveying, and evaluating evidentiary Claims.  It provides a model that is neutral toward
     processor architectures, the content of Claims, and protocols.</t>
    </abstract>
  </front>
  <middle>
    <section anchor="introduction">
      <name>Introduction</name>
      <t>The question of how one system can know that another system can be trusted has found new interest and relevance in a world where trusted computing elements are maturing in processor architectures.</t>
      <t>Systems that have been attested and verified to be in a good state
(for some value of "good") can improve overall system posture.
Conversely, systems that cannot be attested and verified to be in a
good state can be given reduced access or privileges, taken out of
service, or otherwise flagged for repair.</t>
      <t>For example:</t>
      <ul spacing="normal">
        <li>A bank backend system might refuse to transact with another system
that is not known to be in a good state.</li>
        <li>A healthcare system might refuse to transmit electronic healthcare
records to a system that is not known to be in a good state.</li>
      </ul>
      <t>In Remote ATtestation procedureS (RATS), one peer (the "Attester")
produces believable information about itself ("Evidence") to enable
a remote peer (the "Relying Party") to decide whether or not to consider that
Attester a trustworthy peer.
Remote attestation procedures are facilitated by an additional vital party (the "Verifier").</t>
      <t>The Verifier appraises Evidence via appraisal policies and creates
the Attestation Results to support Relying Parties in their decision
process.
This document defines a flexible architecture consisting of attestation roles
and their interactions via conceptual messages.  Additionally, this document defines a universal set of terms that can be mapped to various existing and emerging remote attestation procedures.
Common topological patterns and the sequence of data flows associated with them, such as
the "Passport Model" and the "Background-Check Model", are illustrated.
The purpose is to define useful terminology for remote attestation and enable readers to map
their solution architecture to the canonical attestation architecture provided here.
Having a common terminology that provides well-understood meanings for common themes,
such as roles, device composition, topological patterns, and appraisal procedures, is vital for
semantic interoperability across solutions and platforms involving multiple vendors and providers.</t>
      <t>Amongst other things, this document is about trust and trustworthiness.
Trust is a choice one makes about another system.  Trustworthiness is a
quality about the other system that can be used in making one's decision to
trust it or not.  This is a subtle difference; being familiar with the
difference is crucial for using this document.  Additionally, the concepts of freshness and trust relationships are specified to enable implementers to choose appropriate solutions
to compose their remote attestation procedures.</t>
    </section>
    <section anchor="referenceusecases">
      <name>Reference Use Cases</name>
      <t>This section covers a number of representative and generic use cases
      for remote attestation, independent of specific solutions.  The
      purpose is to provide motivation for various aspects of the architecture
      presented in this document.  Many other use cases exist; this document
      does not contain a complete list.  It only 
      illustrates a set of use cases that collectively cover all the
      functionality required in the architecture.</t>
      <t>Each use case includes a description followed by an additional summary of the
Attester and Relying Party roles derived from the use case.</t>
      <section anchor="network-endpoint-assessment">
        <name>Network Endpoint Assessment</name>
        <t>Network operators want trustworthy reports that include identity
and version information about the hardware and software on the
machines attached to their network. 
Examples of reports include purposes (such as inventory summaries), audit
results, and anomaly notifications (which typically include the maintenance of log
records or trend reports).  
The network operator may also want a policy by which full access is only
granted to devices that meet some definition of hygiene, and so wants to get
Claims about such information and verify its validity.  Remote attestation is
desired to prevent vulnerable or compromised devices from getting access to
the network and potentially harming others.</t>
        <t>Typically, a solution starts with a specific component (sometimes referred to as a "root of trust") that often
provides a trustworthy device identity and performs a series of operations that enables trustworthiness appraisals for other components.
Such components perform operations that help determine the trustworthiness of yet other components
by collecting, protecting, or signing measurements.
Measurements that have been signed by such components are comprised of Evidence that either supports or refutes a claim of trustworthiness when evaluated.
Measurements can describe a variety of attributes of system components, such as hardware, firmware, BIOS, software, etc., and how they are hardened.</t>
        <dl>
          <dt>Attester:</dt>
          <dd>A device desiring access to a network.
          </dd>
          <dt>Relying Party:</dt>
          <dd>Network equipment (such as a router, switch, or access point) that is
responsible for admission of the device into the network.
          </dd>
        </dl>
      </section>
      <section anchor="confidential-machine-learning-model-protection">
        <name>Confidential Machine Learning Model Protection</name>
        <t>A device manufacturer wants to protect its intellectual property.
The intellectual property's scope primarily encompasses the machine learning (ML) model that is deployed in the devices purchased by its customers.
The protection goals include preventing attackers, potentially
the customer themselves, from seeing the details of the model.</t>
        <t>Typically, this works by having some protected environment
in the device go through a remote attestation with some manufacturer service
that can assess its trustworthiness.  If remote attestation succeeds,
then the manufacturer service releases either the model or a key to decrypt
a model already deployed on the Attester in encrypted form to the requester.</t>
        <dl>
          <dt>Attester:</dt>
          <dd>
            A device desiring to run an ML model.
          </dd>
          <dt>Relying Party:</dt>
          <dd>
            A server or service holding ML models it desires to protect.
          </dd>
        </dl>
      </section>
      <section anchor="confidential-data-protection">
        <name>Confidential Data Protection</name>
        <t>This is a generalization of the ML model use case above where
the data can be any highly confidential data, such as health data
about customers, payroll data about employees, future business plans, etc.
As part of the attestation procedure, an assessment is made against a set
of policies to evaluate the state of the system that is requesting
the confidential data.  Attestation is desired to prevent leaking data via
compromised devices.</t>
        <dl>
          <dt>Attester:</dt>
          <dd>
           An entity desiring to retrieve confidential data.
          </dd>
          <dt>Relying Party:</dt>
          <dd>
            An entity that holds confidential data for release to authorized entities.
          </dd>
        </dl>
      </section>
      <section anchor="critical-infrastructure-control">
        <name>Critical Infrastructure Control</name>
        <t>Potentially harmful physical equipment (e.g., power grid, traffic
        control, hazardous chemical processing, etc.) is connected to a
        network in support of critical infrastructure.  The organization
        managing such infrastructure needs to ensure that only authorized code
        and users can control corresponding critical processes, and that these
        processes are protected from unauthorized manipulation or other
        threats.  
When a protocol operation can affect a critical system component of the
infrastructure, devices attached to that critical component require some
assurances depending on the security context, including assurances that a requesting
device or application has not been compromised and the requesters and actors
act on applicable policies.  As such, remote attestation can be used to only
accept commands from requesters that are within policy.</t>
        <dl>
          <dt>Attester:</dt>
          <dd>
            <t>A device or application wishing to control physical equipment.</t>
          </dd>
          <dt>Relying Party:</dt>
          <dd>
            <t>A device or application connected to potentially dangerous physical
equipment (hazardous chemical processing, traffic control, power grid,
etc.).</t>
          </dd>
        </dl>
      </section>
      <section anchor="trusted-execution-environment-provisioning">
        <name>Trusted Execution Environment Provisioning</name>
        <t>A Trusted Application Manager (TAM) server is responsible
for managing the applications running in a Trusted Execution Environment (TEE) of a client device, as described in <xref target="I-D.ietf-teep-architecture"/>.
To achieve its purpose, the TAM needs to assess the state of a TEE or applications
in the TEE of a client device.  The TEE conducts remote attestation
procedures with the TAM, which can
then decide whether the TEE is already in compliance with the TAM's latest
policy.  If not, the TAM has to uninstall, update, or install approved
applications in the TEE to bring it back into compliance with the TAM's policy.</t>
        <dl>
          <dt>Attester:</dt>
          <dd>
            <t>A device with a TEE capable of
running trusted applications that can be updated.</t>
          </dd>
          <dt>Relying Party:</dt>
          <dd>
            <t>A TAM.</t>
          </dd>
        </dl>
      </section>
      <section anchor="hardware-watchdog">
        <name>Hardware Watchdog</name>
        <t>There is a class of malware that holds a device hostage and does
not allow it to reboot to prevent updates from being applied.
This can be a significant problem because it allows a fleet of devices to be held hostage for ransom.</t>
        <t>A solution to this problem is a watchdog timer implemented in a protected
environment, such as a Trusted Platform Module (TPM),
as described in Section 43.3 of <xref target="TCGarch"/>.
If the watchdog does not receive regular and fresh Attestation Results regarding the system's health, then it forces a reboot.</t>
        <dl>
          <dt>Attester:</dt>
          <dd>
            <t>The device that should be protected from being held hostage for
a long period of time.</t>
          </dd>
          <dt>Relying Party:</dt>
          <dd>
            <t>A watchdog capable of triggering a procedure that resets a device into
a known, good operational state.</t>
          </dd>
        </dl>
      </section>
      <section anchor="fido-biometric-authentication">
        <name>FIDO Biometric Authentication</name>

     <t>In the Fast IDentity Online (FIDO) protocol <xref target="WebAuthN"/>
     <xref target="CTAP"/>, the device in the user's hand authenticates the
     human user, whether by biometrics (such as fingerprints) or by PIN and
     password.  FIDO authentication puts a large amount of trust in the device
     compared to typical password authentication because it is the device that
     verifies the biometric, PIN, and password inputs from the user, not the
     server.  For the Relying Party to know that the authentication is
     trustworthy, the Relying Party needs to know that the Authenticator part
     of the device is trustworthy.  The FIDO protocol employs remote
     attestation for this.</t>
        <t>The FIDO protocol supports several remote attestation protocols and a mechanism by which new ones can be registered and added; thus, remote attestation defined by the RATS architecture is a candidate for use in the FIDO protocol.</t>
        <dl>
          <dt>Attester:</dt>
          <dd>
            <t>FIDO Authenticator.</t>
          </dd>
          <dt>Relying Party:</dt>
          <dd>
            <t>Any website, mobile application backend, or service that relies on authentication data based on biometric information.</t>
          </dd>
        </dl>
      </section>
    </section>
    <section anchor="architectural-overview">
      <name>Architectural Overview</name>
      <t><xref target="dataflow"/> depicts the data that flows between different roles, independent of protocol or use case.</t>
      <figure anchor="dataflow">
        <name>Conceptual Data Flow</name>
        <artset>

<artwork type="svg" align="center"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="416" width="560" viewBox="0 0 560 416" class="diagram" text-anchor="middle" font-family="monospace" font-size="13px">
              <path d="M 8,352 L 8,384" fill="none" stroke="black"/>
              <path d="M 32,64 L 32,160" fill="none" stroke="black"/>
              <path d="M 56,256 L 56,352" fill="none" stroke="black"/>
              <path d="M 96,352 L 96,384" fill="none" stroke="black"/>
              <path d="M 128,48 L 128,80" fill="none" stroke="black"/>
              <path d="M 128,224 L 128,256" fill="none" stroke="black"/>
              <path d="M 144,192 L 144,216" fill="none" stroke="black"/>
              <path d="M 184,96 L 184,216" fill="none" stroke="black"/>
              <path d="M 224,48 L 224,80" fill="none" stroke="black"/>
              <path d="M 272,48 L 272,64" fill="none" stroke="black"/>
              <path d="M 312,80 L 312,216" fill="none" stroke="black"/>
              <path d="M 336,224 L 336,256" fill="none" stroke="black"/>
              <path d="M 360,48 L 360,64" fill="none" stroke="black"/>
              <path d="M 360,352 L 360,384" fill="none" stroke="black"/>
              <path d="M 392,256 L 392,344" fill="none" stroke="black"/>
              <path d="M 408,48 L 408,64" fill="none" stroke="black"/>
              <path d="M 456,80 L 456,344" fill="none" stroke="black"/>
              <path d="M 488,352 L 488,384" fill="none" stroke="black"/>
              <path d="M 536,48 L 536,64" fill="none" stroke="black"/>
              <path d="M 24,32 L 80,32" fill="none" stroke="black"/>
              <path d="M 144,32 L 208,32" fill="none" stroke="black"/>
              <path d="M 288,32 L 344,32" fill="none" stroke="black"/>
              <path d="M 424,32 L 520,32" fill="none" stroke="black"/>
              <path d="M 24,64 L 80,64" fill="none" stroke="black"/>
              <path d="M 288,80 L 344,80" fill="none" stroke="black"/>
              <path d="M 424,80 L 520,80" fill="none" stroke="black"/>
              <path d="M 144,96 L 208,96" fill="none" stroke="black"/>
              <path d="M 48,176 L 128,176" fill="none" stroke="black"/>
              <path d="M 128,224 L 336,224" fill="none" stroke="black"/>
              <path d="M 72,240 L 120,240" fill="none" stroke="black"/>
              <path d="M 336,240 L 376,240" fill="none" stroke="black"/>
              <path d="M 128,256 L 336,256" fill="none" stroke="black"/>
              <path d="M 8,352 L 96,352" fill="none" stroke="black"/>
              <path d="M 360,352 L 488,352" fill="none" stroke="black"/>
              <path d="M 8,384 L 96,384" fill="none" stroke="black"/>
              <path d="M 360,384 L 488,384" fill="none" stroke="black"/>
              <path d="M 24,32 C 15.16936,32 8,39.16936 8,48" fill="none" stroke="black"/>
              <path d="M 80,32 C 88.83064,32 96,39.16936 96,48" fill="none" stroke="black"/>
              <path d="M 144,32 C 135.16936,32 128,39.16936 128,48" fill="none" stroke="black"/>
              <path d="M 208,32 C 216.83064,32 224,39.16936 224,48" fill="none" stroke="black"/>
              <path d="M 288,32 C 279.16936,32 272,39.16936 272,48" fill="none" stroke="black"/>
              <path d="M 344,32 C 352.83064,32 360,39.16936 360,48" fill="none" stroke="black"/>
              <path d="M 424,32 C 415.16936,32 408,39.16936 408,48" fill="none" stroke="black"/>
              <path d="M 520,32 C 528.83064,32 536,39.16936 536,48" fill="none" stroke="black"/>
              <path d="M 24,64 C 15.16936,64 8,56.83064 8,48" fill="none" stroke="black"/>
              <path d="M 80,64 C 88.83064,64 96,56.83064 96,48" fill="none" stroke="black"/>
              <path d="M 288,80 C 279.16936,80 272,72.83064 272,64" fill="none" stroke="black"/>
              <path d="M 344,80 C 352.83064,80 360,72.83064 360,64" fill="none" stroke="black"/>
              <path d="M 424,80 C 415.16936,80 408,72.83064 408,64" fill="none" stroke="black"/>
              <path d="M 520,80 C 528.83064,80 536,72.83064 536,64" fill="none" stroke="black"/>
              <path d="M 144,96 C 135.16936,96 128,88.83064 128,80" fill="none" stroke="black"/>
              <path d="M 208,96 C 216.83064,96 224,88.83064 224,80" fill="none" stroke="black"/>
              <path d="M 48,176 C 39.16936,176 32,168.83064 32,160" fill="none" stroke="black"/>
              <path d="M 128,176 C 136.83064,176 144,183.16936 144,192" fill="none" stroke="black"/>
              <path d="M 72,240 C 63.16936,240 56,247.16936 56,256" fill="none" stroke="black"/>
              <path d="M 376,240 C 384.83064,240 392,247.16936 392,256" fill="none" stroke="black"/>
              <polygon class="arrowhead" points="464,344 452,338.4 452,349.6 " fill="black" transform="rotate(90,456,344)"/>
              <polygon class="arrowhead" points="400,344 388,338.4 388,349.6 " fill="black" transform="rotate(90,392,344)"/>
              <polygon class="arrowhead" points="320,216 308,210.4 308,221.6 " fill="black" transform="rotate(90,312,216)"/>
              <polygon class="arrowhead" points="192,216 180,210.4 180,221.6 " fill="black" transform="rotate(90,184,216)"/>
              <polygon class="arrowhead" points="152,216 140,210.4 140,221.6 " fill="black" transform="rotate(90,144,216)"/>
              <polygon class="arrowhead" points="128,240 116,234.4 116,245.6 " fill="black" transform="rotate(0,120,240)"/>
              <g class="text">
                <text x="52" y="52">Endorser</text>
                <text x="176" y="52">Reference</text>
                <text x="316" y="52">Verifier</text>
                <text x="448" y="52">Relying</text>
                <text x="504" y="52">Party</text>
                <text x="160" y="68">Value</text>
                <text x="304" y="68">Owner</text>
                <text x="440" y="68">Owner</text>
                <text x="172" y="84">Provider</text>
                <text x="92" y="132">Endorsements</text>
                <text x="232" y="132">Reference</text>
                <text x="360" y="132">Appraisal</text>
                <text x="504" y="132">Appraisal</text>
                <text x="220" y="148">Values</text>
                <text x="348" y="148">Policy</text>
                <text x="392" y="148">for</text>
                <text x="492" y="148">Policy</text>
                <text x="536" y="148">for</text>
                <text x="356" y="164">Evidence</text>
                <text x="512" y="164">Attestation</text>
                <text x="496" y="180">Results</text>
                <text x="236" y="244">Verifier</text>
                <text x="100" y="292">Evidence</text>
                <text x="336" y="292">Attestation</text>
                <text x="320" y="308">Results</text>
                <text x="52" y="372">Attester</text>
                <text x="400" y="372">Relying</text>
                <text x="456" y="372">Party</text>
              </g>
            </svg>
          </artwork>
          <artwork type="ascii-art" align="center"><![CDATA[
   .--------.     .---------.       .--------.       .-------------.
  | Endorser |   | Reference |     | Verifier |     | Relying Party |
   '-+------'    | Value     |     | Owner    |     | Owner         |
     |           | Provider  |      '---+----'       '----+--------'
     |            '-----+---'           |                 |
     |                  |               |                 |
     | Endorsements     | Reference     | Appraisal       | Appraisal
     |                  | Values        | Policy for      | Policy for
     |                  |               | Evidence        | Attestation
      '-----------.     |               |                 | Results
                   |    |               |                 |
                   v    v               v                 |
                 .-------------------------.              |
         .------>|         Verifier        +-----.        |
        |        '-------------------------'      |       |
        |                                         |       |
        | Evidence                    Attestation |       |
        |                             Results     |       |
        |                                         |       |
        |                                         v       v
  .-----+----.                                .---------------.
  | Attester |                                | Relying Party |
  '----------'                                '---------------']]></artwork>
        </artset>
      </figure>
      <t>The text below summarizes the activities conducted by the roles illustrated in <xref target="dataflow"/>.
Roles are assigned to entities. Entities are often system components <xref target="RFC4949"/>, such as devices. As the term "device" is typically more intuitive than the term "entity" or "system component", device is often used as an illustrative synonym throughout this document.</t>
      <t>The Attester role is assigned to entities that create Evidence that is conveyed to a Verifier.</t>
      <t>The Verifier role is assigned to entities that use the Evidence, any Reference Values from Reference Value Providers, and any Endorsements from Endorsers
by applying an Appraisal Policy for Evidence to assess the trustworthiness of the Attester.
This procedure is called the "appraisal of Evidence".</t>
      <t>Subsequently, the Verifier role generates Attestation Results for use by Relying Parties.</t>
      <t>The Appraisal Policy for Evidence might be obtained from the Verifier Owner via some protocol mechanism, configured into the Verifier by the Verifier Owner, programmed into the Verifier,
or obtained via some other mechanism.</t>
      <t>The Relying Party role is assigned to an entity that uses Attestation Results by applying its own
appraisal policy to make application-specific decisions, such as authorization decisions.
This procedure is called the "appraisal of Attestation Results".</t>
      <t>The Appraisal Policy for Attestation Results might be obtained from the Relying Party Owner via some protocol mechanism, configured into the Relying Party by the Relying Party Owner, programmed into the Relying Party, or obtained via some other mechanism.</t>
      <t>See <xref target="messages"/> for further discussion of the conceptual messages shown in <xref target="dataflow"/>.  <xref target="terminology"/> provides a more complete definition of all RATS roles.</t>
      <section anchor="twotypes">
        <name>Two Types of Environments of an Attester</name>
        <t>As shown in <xref target="twotypes-env"/>, an Attester consists of at least one Attesting Environment and at least one
Target Environment co-located in one entity.
In some implementations, the Attesting and Target Environments might be combined into one environment.
Other implementations might have multiple Attesting and Target Environments,
such as in the examples described in more detail in Sections <xref target="layered-attestation" format="counter"/>
and <xref target="compositedevice" format="counter"/>.  Other examples may exist. All compositions of Attesting and Target Environments discussed in this architecture can be combined into more complex implementations.</t>

        <figure anchor="twotypes-env">
          <name>Two Types of Environments within an Attester</name>
          <artset>
            <artwork type="svg" align="center"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="464" width="320" viewBox="0 0 320 464" class="diagram" text-anchor="middle" font-family="monospace" font-size="13px">
                <path d="M 8,144 L 8,448" fill="none" stroke="black"/>
                <path d="M 24,32 L 24,96" fill="none" stroke="black"/>
                <path d="M 48,176 L 48,240" fill="none" stroke="black"/>
                <path d="M 152,352 L 152,416" fill="none" stroke="black"/>
                <path d="M 168,240 L 168,344" fill="none" stroke="black"/>
                <path d="M 184,176 L 184,240" fill="none" stroke="black"/>
                <path d="M 216,104 L 216,352" fill="none" stroke="black"/>
                <path d="M 264,352 L 264,416" fill="none" stroke="black"/>
                <path d="M 288,32 L 288,96" fill="none" stroke="black"/>
                <path d="M 304,144 L 304,448" fill="none" stroke="black"/>
                <path d="M 24,32 L 288,32" fill="none" stroke="black"/>
                <path d="M 24,96 L 288,96" fill="none" stroke="black"/>
                <path d="M 8,144 L 208,144" fill="none" stroke="black"/>
                <path d="M 224,144 L 304,144" fill="none" stroke="black"/>
                <path d="M 48,176 L 184,176" fill="none" stroke="black"/>
                <path d="M 48,240 L 184,240" fill="none" stroke="black"/>
                <path d="M 152,352 L 264,352" fill="none" stroke="black"/>
                <path d="M 152,416 L 264,416" fill="none" stroke="black"/>
                <path d="M 8,448 L 304,448" fill="none" stroke="black"/>
                <polygon class="arrowhead" points="224,104 212,98.4 212,109.6 " fill="black" transform="rotate(270,216,104)"/>
                <polygon class="arrowhead" points="176,344 164,338.4 164,349.6 " fill="black" transform="rotate(90,168,344)"/>
                <g class="text">
                  <text x="156" y="68">Verifier</text>
                  <text x="84" y="196">Target</text>
                  <text x="104" y="212">Environment</text>
                  <text x="260" y="228">Evidence</text>
                  <text x="128" y="292">Collect</text>
                  <text x="132" y="308">Claims</text>
                  <text x="200" y="372">Attesting</text>
                  <text x="208" y="388">Environment</text>
                  <text x="164" y="436">Attester</text>
                </g>
              </svg>
            </artwork>
            <artwork type="ascii-art" align="center"><![CDATA[
  .--------------------------------.
  |                                |
  |            Verifier            |
  |                                |
  '--------------------------------'
                          ^
                          |
.-------------------------|----------.
|                         |          |
|    .----------------.   |          |
|    | Target         |   |          |
|    | Environment    |   |          |
|    |                |   | Evidence |
|    '--------------+-'   |          |
|                   |     |          |
|                   |     |          |
|           Collect |     |          | 
|            Claims |     |          |
|                   |     |          |
|                   v     |          |
|                 .-------+-----.    |
|                 | Attesting   |    |
|                 | Environment |    |
|                 |             |    |
|                 '-------------'    |
|               Attester             |
'------------------------------------']]></artwork>
          </artset>
        </figure>
        <t>Claims are collected from Target Environments.
That is, Attesting Environments collect the values and the information to be represented in Claims by reading system registers and variables, calling into subsystems, and taking measurements on code, memory, or other relevant assets of the Target Environment.
Attesting Environments then format the Claims appropriately; typically, they
use key material and
cryptographic functions, such as signing or cipher algorithms, to
generate Evidence.
There is no limit or requirement on the types of hardware or software environments that can be used to implement an Attesting Environment. For example, TEEs, embedded Secure Elements
(eSEs), TPMs <xref target="TCGarch"/>, or BIOS firmware.</t>
        <t>An arbitrary execution environment may not, by default, be capable of Claims collection for a given Target Environment.
Execution environments that are designed specifically to be capable of Claims collection are referred to in this document as "Attesting Environments".
For example, a TPM doesn't actively collect Claims itself.  Instead, it
requires another component to feed various values to the TPM.
Thus, an Attesting Environment in such a case would be the combination
of the TPM together with whatever component is feeding it the measurements.</t>
      </section>
      <section anchor="layered-attestation">
        <name>Layered Attestation Environments</name>
        <t>By definition, the Attester role generates Evidence.  An Attester
        may consist of one or more nested environments (layers).  The bottom
        layer of an Attester has an Attesting Environment that is typically
        designed to be immutable or difficult to modify by malicious code.  In
        order to appraise Evidence generated by an Attester, the Verifier
        needs to trust various layers, including the bottom Attesting
        Environment.  Trust in the Attester's layers, including the bottom
        layer, can be established in various ways, as discussed in <xref
        target="verifier"/>.</t>
        <t>In layered attestation, Claims can be collected from or about each
        layer beginning with an initial layer.  The corresponding Claims can
        be structured in a nested fashion that reflects the nesting of the
        Attester's layers.  Normally, Claims are not self-asserted.  Rather, a
        previous layer acts as the Attesting Environment for the next layer.
        Claims about an initial layer are typically asserted by an
        Endorser.</t>
	<t>The example device illustrated in <xref target="layered"/> includes
        (A) a BIOS stored in read-only memory, (B) a bootloader, and (C) an
        operating system kernel.</t>
        <figure anchor="layered">
          <name>Layered Attester</name>
          <artset>
            <artwork type="svg" align="center"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="656" width="448" viewBox="0 0 448 656" class="diagram" text-anchor="middle" font-family="monospace" font-size="13px">
                <path d="M 8,192 L 8,640" fill="none" stroke="black"/>
                <path d="M 40,32 L 40,64" fill="none" stroke="black"/>
                <path d="M 40,96 L 40,160" fill="none" stroke="black"/>
                <path d="M 40,224 L 40,304" fill="none" stroke="black"/>
                <path d="M 40,352 L 40,480" fill="none" stroke="black"/>
                <path d="M 40,528 L 40,608" fill="none" stroke="black"/>
                <path d="M 152,32 L 152,64" fill="none" stroke="black"/>
                <path d="M 152,96 L 152,160" fill="none" stroke="black"/>
                <path d="M 160,384 L 160,448" fill="none" stroke="black"/>
                <path d="M 168,480 L 168,520" fill="none" stroke="black"/>
                <path d="M 176,304 L 176,376" fill="none" stroke="black"/>
                <path d="M 192,456 L 192,528" fill="none" stroke="black"/>
                <path d="M 256,384 L 256,448" fill="none" stroke="black"/>
                <path d="M 272,224 L 272,304" fill="none" stroke="black"/>
                <path d="M 272,352 L 272,408" fill="none" stroke="black"/>
                <path d="M 272,424 L 272,480" fill="none" stroke="black"/>
                <path d="M 272,528 L 272,608" fill="none" stroke="black"/>
                <path d="M 304,96 L 304,160" fill="none" stroke="black"/>
                <path d="M 312,192 L 312,408" fill="none" stroke="black"/>
                <path d="M 312,424 L 312,640" fill="none" stroke="black"/>
                <path d="M 344,48 L 344,88" fill="none" stroke="black"/>
                <path d="M 352,168 L 352,416" fill="none" stroke="black"/>
                <path d="M 392,96 L 392,160" fill="none" stroke="black"/>
                <path d="M 40,32 L 152,32" fill="none" stroke="black"/>
                <path d="M 152,48 L 344,48" fill="none" stroke="black"/>
                <path d="M 40,64 L 152,64" fill="none" stroke="black"/>
                <path d="M 40,96 L 152,96" fill="none" stroke="black"/>
                <path d="M 304,96 L 392,96" fill="none" stroke="black"/>
                <path d="M 152,128 L 296,128" fill="none" stroke="black"/>
                <path d="M 40,160 L 152,160" fill="none" stroke="black"/>
                <path d="M 304,160 L 392,160" fill="none" stroke="black"/>
                <path d="M 8,192 L 312,192" fill="none" stroke="black"/>
                <path d="M 40,224 L 272,224" fill="none" stroke="black"/>
                <path d="M 40,304 L 272,304" fill="none" stroke="black"/>
                <path d="M 40,352 L 168,352" fill="none" stroke="black"/>
                <path d="M 184,352 L 272,352" fill="none" stroke="black"/>
                <path d="M 160,384 L 256,384" fill="none" stroke="black"/>
                <path d="M 256,416 L 352,416" fill="none" stroke="black"/>
                <path d="M 160,448 L 256,448" fill="none" stroke="black"/>
                <path d="M 40,480 L 184,480" fill="none" stroke="black"/>
                <path d="M 200,480 L 272,480" fill="none" stroke="black"/>
                <path d="M 40,528 L 272,528" fill="none" stroke="black"/>
                <path d="M 40,608 L 272,608" fill="none" stroke="black"/>
                <path d="M 8,640 L 312,640" fill="none" stroke="black"/>
                <polygon class="arrowhead" points="360,168 348,162.4 348,173.6 " fill="black" transform="rotate(270,352,168)"/>
                <polygon class="arrowhead" points="352,88 340,82.4 340,93.6 " fill="black" transform="rotate(90,344,88)"/>
                <polygon class="arrowhead" points="304,128 292,122.4 292,133.6 " fill="black" transform="rotate(0,296,128)"/>
                <polygon class="arrowhead" points="200,456 188,450.4 188,461.6 " fill="black" transform="rotate(270,192,456)"/>
                <polygon class="arrowhead" points="184,376 172,370.4 172,381.6 " fill="black" transform="rotate(90,176,376)"/>
                <polygon class="arrowhead" points="176,520 164,514.4 164,525.6 " fill="black" transform="rotate(90,168,520)"/>
                <g class="text">
                  <text x="224" y="36">Endorsement</text>
                  <text x="288" y="36">for</text>
                  <text x="320" y="36">ROM</text>
                  <text x="92" y="52">Endorser</text>
                  <text x="216" y="100">Reference</text>
                  <text x="88" y="116">Reference</text>
                  <text x="204" y="116">Values</text>
                  <text x="248" y="116">for</text>
                  <text x="72" y="132">Value</text>
                  <text x="348" y="132">Verifier</text>
                  <text x="96" y="148">Provider(s)</text>
                  <text x="180" y="148">ROM,</text>
                  <text x="248" y="148">bootloader,</text>
                  <text x="200" y="164">and</text>
                  <text x="244" y="164">kernel</text>
                  <text x="88" y="244">Kernel(C)</text>
                  <text x="392" y="260">Layered</text>
                  <text x="92" y="276">Target</text>
                  <text x="396" y="276">Evidence</text>
                  <text x="96" y="292">Environment</text>
                  <text x="392" y="292">for</text>
                  <text x="404" y="308">bootloader</text>
                  <text x="136" y="324">Collect</text>
                  <text x="392" y="324">and</text>
                  <text x="132" y="340">Claims</text>
                  <text x="388" y="340">kernel</text>
                  <text x="104" y="372">Bootloader(B)</text>
                  <text x="92" y="404">Target</text>
                  <text x="208" y="404">Attesting</text>
                  <text x="96" y="420">Environment</text>
                  <text x="208" y="420">Environment</text>
                  <text x="128" y="500">Collect</text>
                  <text x="236" y="500">Evidence</text>
                  <text x="288" y="500">for</text>
                  <text x="124" y="516">Claims</text>
                  <text x="244" y="516">bootloader</text>
                  <text x="76" y="548">ROM(A)</text>
                  <text x="208" y="580">Attesting</text>
                  <text x="208" y="596">Environment</text>
                </g>
              </svg>
            </artwork>
            <artwork type="ascii-art" align="center"><![CDATA[
    .-------------.   Endorsement for ROM
    |  Endorser   +-----------------------.
    '-------------'                       |
                                          v
    .-------------.   Reference      .----------.
    | Reference   |   Values for     |          |
    | Value       +----------------->| Verifier |
    | Provider(s) | ROM, bootloader, |          |
    '-------------'    and kernel    '----------'
                                          ^
.------------------------------------.    |
|                                    |    |
|   .---------------------------.    |    |
|   | Kernel(C)                 |    |    |
|   |                           |    |    | Layered
|   |   Target                  |    |    | Evidence
|   | Environment               |    |    |   for
|   '---------------+-----------'    |    | bootloader
|           Collect |                |    |   and
|           Claims  |                |    | kernel
|   .---------------|-----------.    |    |
|   | Bootloader(B) v           |    |    |
|   |             .-----------. |    |    |
|   |   Target    | Attesting | |    |    |
|   | Environment |Environment+-----------'
|   |             |           | |    |
|   |             '-----------' |    |
|   |                 ^         |    |
|   '--------------+--|---------'    |
|          Collect |  | Evidence for |
|          Claims  v  | bootloader   |
|   .-----------------+---------.    |
|   | ROM(A)                    |    |
|   |                           |    |
|   |               Attesting   |    |
|   |              Environment  |    |
|   '---------------------------'    |
|                                    |
'------------------------------------']]></artwork>
          </artset>
        </figure>
        <t>The first Attesting Environment (the ROM in this example)
has to ensure the integrity of the bootloader (the first Target Environment).
There are
potentially multiple kernels to boot; the decision is up to the bootloader.
Only a bootloader with intact integrity will make an appropriate decision.
Therefore, the Claims relating to the integrity of the bootloader have to be measured securely.
At this stage of the boot cycle of the
device, the Claims collected typically cannot be composed into Evidence.</t>
        <t>After the boot sequence is started, the BIOS conducts the most
        important and defining feature of layered attestation: the
        successfully measured bootloader now becomes (or contains) an
        Attesting Environment for the next layer.  This procedure in layered
        attestation is sometimes called "staging".  It is important that the
        bootloader not be able to alter any Claims about itself that were
        collected by the BIOS.  This can be ensured having those Claims be
        either signed by the BIOS or stored in a tamper-proof manner by the
        BIOS.</t>
        <t>Continuing with this example, the bootloader's Attesting
        Environment is now in charge of collecting Claims about the next
        Target Environment.  In this example, it is the kernel to be booted.

The final Evidence thus contains two sets of Claims: one set about the
bootloader as measured and signed by the BIOS and another set of Claims about the
kernel as measured and signed by the bootloader.</t>
        <t>This example could be extended further by making the kernel become another
Attesting Environment for an application as another Target Environment.
This would result in a third set of Claims in the Evidence pertaining to that application.</t>
        <t>The essence of this example is a cascade of staged environments. Each
environment has the responsibility
of measuring the next environment before the next environment is started.
In general, the number of layers may vary by device or implementation,
and an Attesting Environment might even have multiple Target Environments
that it measures, rather than only one as shown by example in <xref target="layered"/>.</t>
      </section>
      <section anchor="compositedevice">
        <name>Composite Device</name>
        <t>A composite device is an entity composed of multiple sub-entities such that its
trustworthiness has to be determined by the appraisal of all these sub-entities.</t>
        <t>Each sub-entity has at least one Attesting Environment collecting the Claims
from at least one Target Environment. Then, this sub-entity generates Evidence
about its trustworthiness; therefore, each sub-entity can be called an "Attester".
Among all the Attesters, there may be only some that have the ability to communicate
with the Verifier while others do not.</t>
        <t>For example, a carrier-grade router consists of a chassis and multiple slots.
The trustworthiness of the router depends on all its slots' trustworthiness.
Each slot has an Attesting Environment, such as a TEE, collecting the
Claims of its boot process, after which it generates Evidence from the Claims.</t>
        <t>Among these slots, only a "main" slot can communicate with the Verifier
while other slots cannot. However, other slots can communicate with the main
slot by the links between them inside the router.
The main slot collects the Evidence of other slots, produces the final Evidence of the whole router, and conveys the final Evidence to the Verifier.
Therefore, the router is a composite
device, each slot is an Attester, and the main slot is the lead Attester.</t>
        <t>Another example is a multi-chassis router composed of multiple single carrier-grade routers.
Multi-chassis router setups create redundancy groups that provide higher throughput by interconnecting
multiple routers in these groups, which can be treated as one logical router for simpler management.
A multi-chassis router setup provides a management point that connects to the Verifier.
Typically, one router in the group is designated as the main router.
Other routers in the multi-chassis setup are connected to the main router only via physical network links; therefore, they are managed and appraised via the main router's help.
Consequently, a multi-chassis router setup is a composite device,
each router is an Attester, and the main router is the lead Attester.</t>
        <t><xref target="composite"/> depicts the conceptual data flow for a composite device.</t>
   <figure anchor="composite">
          <name>Composite Device</name>
          <artset>
            <artwork type="svg" align="center"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="416" width="552" viewBox="0 0 552 416" class="diagram" text-anchor="middle" font-family="monospace" font-size="13px">
                <path d="M 8,160 L 8,400" fill="none" stroke="black"/>
                <path d="M 24,176 L 24,352" fill="none" stroke="black"/>
                <path d="M 48,240 L 48,304" fill="none" stroke="black"/>
                <path d="M 120,208 L 120,240" fill="none" stroke="black"/>
                <path d="M 160,32 L 160,64" fill="none" stroke="black"/>
                <path d="M 184,240 L 184,304" fill="none" stroke="black"/>
                <path d="M 208,192 L 208,288" fill="none" stroke="black"/>
                <path d="M 288,72 L 288,192" fill="none" stroke="black"/>
                <path d="M 312,192 L 312,288" fill="none" stroke="black"/>
                <path d="M 336,176 L 336,200" fill="none" stroke="black"/>
                <path d="M 336,280 L 336,352" fill="none" stroke="black"/>
                <path d="M 392,176 L 392,224" fill="none" stroke="black"/>
                <path d="M 400,32 L 400,64" fill="none" stroke="black"/>
                <path d="M 408,224 L 408,256" fill="none" stroke="black"/>
                <path d="M 424,256 L 424,288" fill="none" stroke="black"/>
                <path d="M 496,176 L 496,224" fill="none" stroke="black"/>
                <path d="M 512,208 L 512,256" fill="none" stroke="black"/>
                <path d="M 528,240 L 528,288" fill="none" stroke="black"/>
                <path d="M 544,160 L 544,400" fill="none" stroke="black"/>
                <path d="M 160,32 L 400,32" fill="none" stroke="black"/>
                <path d="M 160,64 L 400,64" fill="none" stroke="black"/>
                <path d="M 8,160 L 280,160" fill="none" stroke="black"/>
                <path d="M 296,160 L 544,160" fill="none" stroke="black"/>
                <path d="M 24,176 L 280,176" fill="none" stroke="black"/>
                <path d="M 296,176 L 336,176" fill="none" stroke="black"/>
                <path d="M 392,176 L 496,176" fill="none" stroke="black"/>
                <path d="M 208,192 L 312,192" fill="none" stroke="black"/>
                <path d="M 120,208 L 200,208" fill="none" stroke="black"/>
                <path d="M 320,208 L 392,208" fill="none" stroke="black"/>
                <path d="M 496,208 L 512,208" fill="none" stroke="black"/>
                <path d="M 392,224 L 496,224" fill="none" stroke="black"/>
                <path d="M 48,240 L 184,240" fill="none" stroke="black"/>
                <path d="M 320,240 L 408,240" fill="none" stroke="black"/>
                <path d="M 512,240 L 528,240" fill="none" stroke="black"/>
                <path d="M 408,256 L 512,256" fill="none" stroke="black"/>
                <path d="M 320,272 L 424,272" fill="none" stroke="black"/>
                <path d="M 208,288 L 312,288" fill="none" stroke="black"/>
                <path d="M 424,288 L 528,288" fill="none" stroke="black"/>
                <path d="M 48,304 L 184,304" fill="none" stroke="black"/>
                <path d="M 24,352 L 336,352" fill="none" stroke="black"/>
                <path d="M 8,400 L 544,400" fill="none" stroke="black"/>
                <polygon class="arrowhead" points="328,272 316,266.4 316,277.6 " fill="black" transform="rotate(180,320,272)"/>
                <polygon class="arrowhead" points="328,240 316,234.4 316,245.6 " fill="black" transform="rotate(180,320,240)"/>
                <polygon class="arrowhead" points="328,208 316,202.4 316,213.6 " fill="black" transform="rotate(180,320,208)"/>
                <polygon class="arrowhead" points="296,72 284,66.4 284,77.6 " fill="black" transform="rotate(270,288,72)"/>
                <polygon class="arrowhead" points="208,208 196,202.4 196,213.6 " fill="black" transform="rotate(0,200,208)"/>
                <g class="text">
                  <text x="284" y="52">Verifier</text>
                  <text x="332" y="116">Evidence</text>
                  <text x="380" y="116">of</text>
                  <text x="336" y="132">Composite</text>
                  <text x="404" y="132">Device</text>
                  <text x="72" y="196">Collect</text>
                  <text x="68" y="212">Claims</text>
                  <text x="264" y="212">Attesting</text>
                  <text x="436" y="212">Attester</text>
                  <text x="480" y="212">B</text>
                  <text x="256" y="228">Environment</text>
                  <text x="336" y="228">|</text>
                  <text x="452" y="244">Attester</text>
                  <text x="496" y="244">C</text>
                  <text x="116" y="260">Target</text>
                  <text x="336" y="260">|</text>
                  <text x="116" y="276">Environment(s)</text>
                  <text x="448" y="276">...</text>
                  <text x="380" y="292">Evidence</text>
                  <text x="380" y="308">of</text>
                  <text x="384" y="324">Attesters</text>
                  <text x="52" y="340">lead</text>
                  <text x="108" y="340">Attester</text>
                  <text x="152" y="340">A</text>
                  <text x="364" y="340">(via</text>
                  <text x="420" y="340">Internal</text>
                  <text x="480" y="340">Links</text>
                  <text x="516" y="340">or</text>
                  <text x="376" y="356">Network</text>
                  <text x="460" y="356">Connections)</text>
                  <text x="232" y="388">Composite</text>
                  <text x="300" y="388">Device</text>
                </g>
              </svg>
            </artwork>
            <artwork type="ascii-art" align="center"><![CDATA[
                   .-----------------------------.
                   |           Verifier          |
                   '-----------------------------'
                                   ^
                                   |
                                   | Evidence of
                                   | Composite Device
                                   |
.----------------------------------|-------------------------------.
| .--------------------------------|-----.      .------------.     |
| |  Collect             .---------+--.  |      |            |     |
| |  Claims   .--------->|  Attesting |<--------+ Attester B +-.   |
| |           |          |Environment |  |      '-+----------' |   |
| |  .--------+-------.  |            |<----------+ Attester C +-. |
| |  |     Target     |  |            |  |        '-+----------' | |
| |  | Environment(s) |  |            |<------------+ ...        | |
| |  |                |  '------------'  | Evidence '------------' |
| |  '----------------'                  |    of                   |
| |                                      | Attesters               |
| | lead Attester A                      | (via Internal Links or  |
| '--------------------------------------' Network Connections)    |
|                                                                  |
|                       Composite Device                           |
'------------------------------------------------------------------'
]]></artwork>
          </artset>
        </figure>

        <t>In a composite device, each Attester generates its own Evidence by its
Attesting Environment(s) collecting the Claims from its Target Environment(s).
The lead Attester collects Evidence from other Attesters and conveys it to a Verifier.
Collection of Evidence from sub-entities may itself be a form of Claims collection that results in Evidence asserted by the lead Attester.
The lead Attester generates Evidence about the layout of the whole composite device, while sub-Attesters generate Evidence about their respective (sub-)modules.</t>
        <t>In this scenario, the trust model described in <xref target="trustmodel"/> can also be applied to an inside Verifier.</t>
      </section>
      <section anchor="implementation-considerations">
        <name>Implementation Considerations</name>
        <t>An entity can take on multiple RATS roles (e.g., Attester, Verifier, Relying
Party, etc.) at the same time.
Multiple entities can cooperate to implement a single RATS role as well.
In essence, the combination of roles and entities can be arbitrary.
For example, in the composite device scenario, the entity inside
the lead Attester can also take on the role of a Verifier and the
outer entity of Verifier can take on the role of a Relying Party.
After collecting the Evidence of other Attesters, this inside Verifier uses
Endorsements and appraisal policies (obtained the same way as by any other
Verifier) as part of the appraisal procedures that generate Attestation Results.
The inside Verifier then conveys the Attestation Results of other Attesters to the outside Verifier,
whether in the same conveyance protocol as part of the Evidence or not.</t>
        <t>As explained in <xref target="terminology"/>, there are a variety of roles in the RATS architecture; they are defined by a unique combination of artifacts they produce and consume.
Conversely, artifacts are also defined by the roles that produce or consume them.
To produce an artifact means that a given role introduces it into the RATS architecture.
To consume an artifact means that a given role has responsibility for processing it in the RATS architecture.
Roles also have the ability to perform additional actions, such as caching or forwarding artifacts as opaque data.
As depicted in <xref target="overview"/>, these additional actions can be performed by several roles.</t>
      </section>
    </section>
    <section anchor="terminology">
      <name>Terminology</name>
      <t><xref target="RFC4949"/> has defined a number of terms that are also used in this document.
Some of the terms are close to, but not exactly the same.
Where the terms are similar, they are noted below with references.



As explained in <xref target="RFC4949" sectionFormat="of" section="2.6"/>, when this document says "Compare:", the terminology used in this document differs significantly from the definition in the reference.</t>
      <t>This document uses the terms in the subsections that follow.</t>
      <section anchor="roles">
        <name>Roles</name>
        <dl>
          <dt>Attester:</dt>
          <dd>
            <t>A role performed by an entity (typically a device) whose Evidence must be appraised in order to infer the extent to which the Attester is considered trustworthy, such as when deciding whether it is authorized to perform some operation.</t>
          <dl newline="false" spacing="normal">  
            <dt>Produces:</dt><dd>Evidence</dd>
	  </dl>
	</dd>
            <dt>Relying Party:</dt>
          <dd>
            <t>A role performed by an entity that depends on the validity of information about an Attester for purposes of reliably applying application-specific actions.  Compare: relying party <xref target="RFC4949"/>.</t>
<dl newline="false" spacing="normal">
            <dt>Consumes:</dt><dd>Attestation Results, Appraisal Policy for Attestation Results</dd>
          </dl>
	  </dd>
          <dt>Verifier:</dt>
          <dd>
            <t>A role performed by an entity that appraises the validity of Evidence about an Attester
 and produces Attestation Results to be used by a Relying Party.</t>
<dl newline="false" spacing="normal">
            <dt>Consumes:</dt><dd>Evidence, Reference Values, Endorsements, Appraisal Policy for Evidence</dd>
            <dt>Produces:</dt><dd>Attestation Results</dd>
</dl>
          </dd>
          <dt>Relying Party Owner:</dt>
          <dd>
            <t>A role performed by an entity (typically an administrator) that is authorized to configure an Appraisal Policy for Attestation Results in a Relying Party.</t>
<dl newline="false" spacing="normal">
            <dt>Produces:</dt><dd>Appraisal Policy for Attestation Results</dd>
</dl>
          </dd>
          <dt>Verifier Owner:</dt>
          <dd>
            <t>A role performed by an entity (typically an administrator) that is authorized to configure an Appraisal Policy for Evidence in a Verifier.</t>
          <dl newline="false" spacing="normal">
            <dt>Produces:</dt><dd>Appraisal Policy for Evidence</dd>
	  </dl>
          </dd>
          <dt>Endorser:</dt>
          <dd>
            <t>A role performed by an entity (typically a manufacturer) whose Endorsements may help Verifiers appraise the authenticity of Evidence and infer further capabilities of the Attester.</t>
<dl newline="false" spacing="normal">
          <dt>Produces:</dt><dd>Endorsements</dd>
          </dl>
	  </dd>
          <dt>Reference Value Provider:</dt>
          <dd>
            <t>A role performed by an entity (typically a manufacturer) whose Reference Values help Verifiers appraise Evidence to determine if acceptable known Claims have been recorded by the Attester.</t>
<dl newline="false" spacing="normal">
            <dt>Produces:</dt><dd>Reference Values</dd>
</dl>
          </dd>
        </dl>
      </section>
      <section anchor="artifacts">
        <name>Artifacts</name>
        <dl>
          <dt>Claim:</dt>
          <dd>
            <t>A piece of asserted information, often in the form of a name/value pair. Claims make up the usual structure of Evidence and other RATS conceptual messages.
Compare: claim <xref target="RFC7519"/>.</t>
          </dd>
          <dt>Endorsement:</dt>
          <dd>
            <t>A secure statement that an Endorser vouches for the integrity of an Attester's various capabilities, such as Claims collection and Evidence signing.</t>
<dl newline="false" spacing="normal">
          <dt>Consumed By:</dt><dd>Verifier</dd>
          <dt>Produced By:</dt><dd>Endorser</dd>
</dl>
          </dd>
          <dt>Evidence:</dt>
          <dd>
            <t>A set of Claims generated by an Attester to be appraised by a Verifier.
Evidence may include configuration data, measurements, telemetry, or inferences.</t>
<dl newline="false" spacing="normal">          
<dt>Consumed By:</dt><dd>Verifier</dd>
          <dt>Produced By:</dt><dd>Attester</dd>
</dl>
</dd>
          <dt>Attestation Result:</dt>
          <dd>
            <t>The output generated by a Verifier, typically including information about an Attester, where the Verifier vouches for the validity of the results.</t>
<dl newline="false" spacing="normal">
          <dt>Consumed By:</dt><dd>Relying Party</dd>
          <dt>Produced By:</dt><dd>Verifier</dd>
</dl>
	  </dd>
          <dt>Appraisal Policy for Evidence:</dt>
          <dd>
	   
            <t>A set of rules that
  a Verifier uses to evaluate the validity of information
  about an Attester. Compare: security policy <xref target="RFC4949"/>.</t>
<dl newline="false" spacing="normal">
          <dt>Consumed By:</dt><dd>Verifier</dd>
          <dt>Produced By:</dt><dd>Verifier Owner</dd>
</dl>
          </dd>
          <dt>Appraisal Policy for Attestation Results:</dt>
          <dd>
            <t>A set of rules that direct how a Relying Party uses the Attestation Results regarding an Attester generated by the Verifiers. Compare: security policy <xref target="RFC4949"/>.</t>
<dl newline="false" spacing="normal">
            <dt>Consumed by:</dt><dd>Relying Party</dd>
            <dt>Produced by:</dt><dd>Relying Party Owner</dd>
</dl>
          </dd>
          <dt>Reference Values:</dt>
          <dd>
            <t>A set of values against which values of Claims can be compared as part of
applying an Appraisal Policy for Evidence.  Reference Values are sometimes
referred to in other documents as "known-good values", "golden measurements",
or "nominal values". These terms typically assume comparison for
equality, whereas here, Reference Values might be more general and be used
in any sort of comparison.</t>
     <dl newline="false" spacing="normal">
            <dt>Consumed By:</dt><dd>Verifier</dd>
            <dt>Produced By:</dt><dd>Reference Value Provider</dd>
     </dl>
          </dd>
        </dl>
      </section>
    </section>
    <section anchor="overview">
      <name>Topological Patterns</name>
      <t><xref target="dataflow"/> shows a data flow diagram for communication between an Attester,
a Verifier, and a Relying Party. The Attester conveys its Evidence to the Verifier
for appraisal and the Relying Party receives the Attestation Result from the Verifier.
This section refines the data-flow diagram by describing two
reference models, as well as one example composition thereof. The
discussion that follows is for illustrative purposes only and does
not constrain the interactions between RATS roles to the presented models.</t>
      <section anchor="passport-model">
        <name>Passport Model</name>
        <t>The Passport Model is so named because of its resemblance to how nations issue
passports to their citizens. The nature of the Evidence that an individual needs
to provide to its local authority is specific to the country involved. The citizen
retains control of the resulting passport document and presents it to other entities
when it needs to assert a citizenship or identity Claim, such as at an airport immigration
desk. The passport is considered sufficient because it vouches for the citizenship and
identity Claims and it is issued by a trusted authority.</t>
        <t>Thus, in this immigration desk analogy,
the citizen is the Attester,
the passport-issuing agency is a Verifier,
and the passport application and identifying information (e.g., birth certificate) is the Evidence.
The passport is an Attestation Result and the immigration desk is a Relying Party.</t>
        <t>In this model, an Attester conveys Evidence to a Verifier that compares
the Evidence against its appraisal policy.
The Verifier then gives back an Attestation Result that the Attester treats as opaque data.</t>
        <t>The Attester does not consume the Attestation Result, but it might cache it.
The Attester can then present the Attestation Result (and possibly additional Claims)
to a Relying Party, which then compares this information against its own
appraisal policy.
The Attester may also present the same Attestation Result to other Relying Parties.</t>
        <t>There are three ways in which the process may fail: </t>
        <ul spacing="normal">
          <li>First, the Verifier may not issue a positive Attestation Result due to the Evidence not passing the Appraisal Policy for Evidence.</li>

	  
          <li>The second way in which the process may fail is when the Attestation Result
is examined by the Relying Party, and based upon the Appraisal Policy for
Attestation Results, the result does not comply with the policy.</li>
          <li>The third way is when the Verifier is unreachable or unavailable.</li>
        </ul>
        <t>As with any other information needed by the Relying Party to make an authorization decision,
an Attestation Result can be carried in a resource access protocol between the Attester and Relying Party.
In this model, the details of the resource access protocol
constrain the serialization format of the Attestation Result. On the other hand, the
format of the Evidence is only constrained by the
Attester-Verifier remote attestation protocol.
This implies that interoperability and standardization is more relevant for Attestation Results than it is for Evidence.</t>
        <figure anchor="passport">
          <name>Passport Model</name>
          <artset>
            <artwork type="svg" align="center"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="272" width="552" viewBox="0 0 552 272" class="diagram" text-anchor="middle" font-family="monospace" font-size="13px">
                <path d="M 48,32 L 48,96" fill="none" stroke="black"/>
                <path d="M 48,176 L 48,240" fill="none" stroke="black"/>
                <path d="M 80,104 L 80,176" fill="none" stroke="black"/>
                <path d="M 120,96 L 120,168" fill="none" stroke="black"/>
                <path d="M 152,32 L 152,96" fill="none" stroke="black"/>
                <path d="M 152,176 L 152,240" fill="none" stroke="black"/>
                <path d="M 272,176 L 272,240" fill="none" stroke="black"/>
                <path d="M 384,176 L 384,240" fill="none" stroke="black"/>
                <path d="M 48,32 L 152,32" fill="none" stroke="black"/>
                <path d="M 48,96 L 152,96" fill="none" stroke="black"/>
                <path d="M 48,176 L 152,176" fill="none" stroke="black"/>
                <path d="M 272,176 L 384,176" fill="none" stroke="black"/>
                <path d="M 152,192 L 264,192" fill="none" stroke="black"/>
                <path d="M 48,240 L 152,240" fill="none" stroke="black"/>
                <path d="M 272,240 L 384,240" fill="none" stroke="black"/>
                <polygon class="arrowhead" points="272,192 260,186.4 260,197.6 " fill="black" transform="rotate(0,264,192)"/>
                <polygon class="arrowhead" points="128,168 116,162.4 116,173.6 " fill="black" transform="rotate(90,120,168)"/>
                <polygon class="arrowhead" points="88,104 76,98.4 76,109.6 " fill="black" transform="rotate(270,80,104)"/>
                <g class="text">
                  <text x="192" y="52">Compare</text>
                  <text x="260" y="52">Evidence</text>
                  <text x="100" y="68">Verifier</text>
                  <text x="192" y="68">against</text>
                  <text x="264" y="68">appraisal</text>
                  <text x="332" y="68">policy</text>
                  <text x="36" y="132">Evidence</text>
                  <text x="176" y="132">Attestation</text>
                  <text x="156" y="148">Result</text>
                  <text x="424" y="196">Compare</text>
                  <text x="504" y="196">Attestation</text>
                  <text x="100" y="212">Attester</text>
                  <text x="208" y="212">Attestation</text>
                  <text x="328" y="212">Relying</text>
                  <text x="420" y="212">Result</text>
                  <text x="480" y="212">against</text>
                  <text x="188" y="228">Result</text>
                  <text x="328" y="228">Party</text>
                  <text x="432" y="228">appraisal</text>
                  <text x="500" y="228">policy</text>
                </g>
              </svg>
            </artwork>
            <artwork type="ascii-art" align="center"><![CDATA[
       .------------.
       |            | Compare Evidence
       |  Verifier  | against appraisal policy
       |            |
       '--------+---'
           ^    |
  Evidence |    | Attestation
           |    | Result
           |    v
       .---+--------.              .-------------.
       |            +------------->|             | Compare Attestation
       |  Attester  | Attestation  |   Relying   | Result against
       |            | Result       |    Party    | appraisal policy
       '------------'              '-------------']]></artwork>
          </artset>
        </figure>
      </section>
      <section anchor="background-check-model">
        <name>Background-Check Model</name>
        <t>The Background-Check Model is so named because of the resemblance
        of how employers and volunteer organizations perform background
        checks. When a prospective employee provides Claims about education or
        previous experience, the employer will contact the respective
        institutions or former employers to validate the Claim. Volunteer
        organizations often perform police background checks on volunteers in
        order to determine the volunteer's trustworthiness.  Thus, in this
        analogy, a prospective volunteer is an Attester, the organization is
        the Relying Party, and the organization that issues a report is a
        Verifier.</t>
        <t>In this model, an Attester conveys Evidence to a Relying Party,
        which treats it as opaque and simply forwards it on to a Verifier.
        The Verifier compares the Evidence against its appraisal policy and
        returns an Attestation Result to the Relying Party.  The Relying Party
        then compares the Attestation Result against its own appraisal
        policy.</t>
        <t>The resource access protocol between the Attester and Relying Party
        includes Evidence rather than an Attestation Result, but that Evidence
        is not processed by the Relying Party.</t>
        <t>Since the Evidence is merely forwarded on to a trusted Verifier, any serialization format can be used for Evidence because the Relying Party does not need a parser for it.  The only requirement is that the Evidence can be <em>encapsulated</em> in the format
required by the resource access protocol between the Attester and Relying Party.</t>
<t>However, as seen in the Passport Model, an Attestation Result is still consumed by the
Relying Party.  Code footprint and attack surface area can be minimized by
using a serialization format for which the Relying Party already needs a
parser to support the protocol between the Attester and Relying Party,
which may be an existing standard or widely deployed resource access protocol.
Such minimization is especially important if the Relying Party is a
constrained node.</t>
        <figure anchor="backgroundcheck">
          <name>Background-Check Model</name>
          <artset>
            <artwork type="svg" align="center"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="272" width="520" viewBox="0 0 520 272" class="diagram" text-anchor="middle" font-family="monospace" font-size="13px">
                <path d="M 8,176 L 8,240" fill="none" stroke="black"/>
                <path d="M 112,176 L 112,240" fill="none" stroke="black"/>
                <path d="M 240,32 L 240,96" fill="none" stroke="black"/>
                <path d="M 240,176 L 240,240" fill="none" stroke="black"/>
                <path d="M 280,104 L 280,176" fill="none" stroke="black"/>
                <path d="M 312,96 L 312,168" fill="none" stroke="black"/>
                <path d="M 352,32 L 352,96" fill="none" stroke="black"/>
                <path d="M 352,176 L 352,240" fill="none" stroke="black"/>
                <path d="M 240,32 L 352,32" fill="none" stroke="black"/>
                <path d="M 240,96 L 352,96" fill="none" stroke="black"/>
                <path d="M 8,176 L 112,176" fill="none" stroke="black"/>
                <path d="M 240,176 L 272,176" fill="none" stroke="black"/>
                <path d="M 288,176 L 352,176" fill="none" stroke="black"/>
                <path d="M 112,192 L 232,192" fill="none" stroke="black"/>
                <path d="M 248,192 L 264,192" fill="none" stroke="black"/>
                <path d="M 8,240 L 112,240" fill="none" stroke="black"/>
                <path d="M 240,240 L 352,240" fill="none" stroke="black"/>
                <path d="M 264,192 C 272.83064,192 280,184.83064 280,176" fill="none" stroke="black"/>
                <polygon class="arrowhead" points="320,168 308,162.4 308,173.6 " fill="black" transform="rotate(90,312,168)"/>
                <polygon class="arrowhead" points="288,104 276,98.4 276,109.6 " fill="black" transform="rotate(270,280,104)"/>
                <polygon class="arrowhead" points="240,192 228,186.4 228,197.6 " fill="black" transform="rotate(0,232,192)"/>
                <g class="text">
                  <text x="392" y="52">Compare</text>
                  <text x="460" y="52">Evidence</text>
                  <text x="300" y="68">Verifier</text>
                  <text x="392" y="68">against</text>
                  <text x="464" y="68">appraisal</text>
                  <text x="388" y="84">policy</text>
                  <text x="236" y="132">Evidence</text>
                  <text x="368" y="132">Attestation</text>
                  <text x="348" y="148">Result</text>
                  <text x="392" y="196">Compare</text>
                  <text x="472" y="196">Attestation</text>
                  <text x="60" y="212">Attester</text>
                  <text x="172" y="212">Evidence</text>
                  <text x="312" y="212">Relying</text>
                  <text x="388" y="212">Result</text>
                  <text x="448" y="212">against</text>
                  <text x="312" y="228">Party</text>
                  <text x="400" y="228">appraisal</text>
                  <text x="468" y="228">policy</text>
                </g>
              </svg>
            </artwork>
            <artwork type="ascii-art" align="center"><![CDATA[
                                .-------------.
                                |             | Compare Evidence
                                |   Verifier  | against appraisal
                                |             | policy
                                '--------+----'
                                     ^   |
                            Evidence |   | Attestation
                                     |   | Result
                                     |   v
   .------------.               .----|--------.
   |            +-------------->|---'         | Compare Attestation
   |  Attester  |   Evidence    |     Relying | Result against
   |            |               |      Party  | appraisal policy
   '------------'               '-------------']]></artwork>
          </artset>
        </figure>
      </section>
      <section anchor="combinations">
        <name>Combinations</name>
        <t>One variation of the Background-Check Model is where the Relying Party
and the Verifier are on the same machine, performing both functions together.
In this case, there is no need for a protocol between the two.</t>
        <t>It is also worth pointing out that the choice of model depends on the use case and that different Relying Parties may use different topological patterns.</t>
        <t>The same device may need to create Evidence for different Relying Parties and/or different use cases.
For instance, it would use one model to provide Evidence to a network infrastructure device to gain access to the network and
the other model to provide Evidence to a server holding confidential data to gain access to that data.
As such, both models may simultaneously be in use by the same device.</t>
        <t><xref target="combination"/> shows another example of a combination where Relying Party 1 uses the
Passport Model, whereas Relying Party 2 uses an extension of the Background-Check Model.
Specifically, in addition to the basic functionality shown in <xref target="backgroundcheck"/>, Relying Party 2
actually provides the Attestation Result back to the Attester, allowing the Attester to
use it with other Relying Parties.  This is the model that the TAM
plans to support in the TEEP architecture <xref target="I-D.ietf-teep-architecture"/>.</t>
        <figure anchor="combination">
          <name>Example Combination</name>
          <artset>
            <artwork type="svg"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="416" width="560" viewBox="0 0 560 416" class="diagram" text-anchor="middle" font-family="monospace" font-size="13px">
                <path d="M 40,32 L 40,96" fill="none" stroke="black"/>
                <path d="M 40,176 L 40,240" fill="none" stroke="black"/>
                <path d="M 40,320 L 40,384" fill="none" stroke="black"/>
                <path d="M 80,104 L 80,176" fill="none" stroke="black"/>
                <path d="M 80,248 L 80,320" fill="none" stroke="black"/>
                <path d="M 112,96 L 112,168" fill="none" stroke="black"/>
                <path d="M 112,240 L 112,312" fill="none" stroke="black"/>
                <path d="M 152,32 L 152,96" fill="none" stroke="black"/>
                <path d="M 152,176 L 152,240" fill="none" stroke="black"/>
                <path d="M 152,320 L 152,384" fill="none" stroke="black"/>
                <path d="M 280,320 L 280,384" fill="none" stroke="black"/>
                <path d="M 392,320 L 392,384" fill="none" stroke="black"/>
                <path d="M 40,32 L 152,32" fill="none" stroke="black"/>
                <path d="M 40,96 L 152,96" fill="none" stroke="black"/>
                <path d="M 40,176 L 152,176" fill="none" stroke="black"/>
                <path d="M 40,240 L 152,240" fill="none" stroke="black"/>
                <path d="M 40,320 L 152,320" fill="none" stroke="black"/>
                <path d="M 280,320 L 392,320" fill="none" stroke="black"/>
                <path d="M 152,336 L 272,336" fill="none" stroke="black"/>
                <path d="M 40,384 L 152,384" fill="none" stroke="black"/>
                <path d="M 280,384 L 392,384" fill="none" stroke="black"/>
                <polygon class="arrowhead" points="280,336 268,330.4 268,341.6 " fill="black" transform="rotate(0,272,336)"/>
                <polygon class="arrowhead" points="120,312 108,306.4 108,317.6 " fill="black" transform="rotate(90,112,312)"/>
                <polygon class="arrowhead" points="120,168 108,162.4 108,173.6 " fill="black" transform="rotate(90,112,168)"/>
                <polygon class="arrowhead" points="88,248 76,242.4 76,253.6 " fill="black" transform="rotate(270,80,248)"/>
                <polygon class="arrowhead" points="88,104 76,98.4 76,109.6 " fill="black" transform="rotate(270,80,104)"/>
                <g class="text">
                  <text x="192" y="52">Compare</text>
                  <text x="260" y="52">Evidence</text>
                  <text x="100" y="68">Verifier</text>
                  <text x="192" y="68">against</text>
                  <text x="264" y="68">appraisal</text>
                  <text x="332" y="68">policy</text>
                  <text x="36" y="132">Evidence</text>
                  <text x="168" y="132">Attestation</text>
                  <text x="148" y="148">Result</text>
                  <text x="192" y="196">Compare</text>
                  <text x="96" y="212">Relying</text>
                  <text x="208" y="212">Attestation</text>
                  <text x="284" y="212">Result</text>
                  <text x="88" y="228">Party</text>
                  <text x="120" y="228">2</text>
                  <text x="192" y="228">against</text>
                  <text x="264" y="228">appraisal</text>
                  <text x="332" y="228">policy</text>
                  <text x="36" y="276">Evidence</text>
                  <text x="168" y="276">Attestation</text>
                  <text x="148" y="292">Result</text>
                  <text x="432" y="340">Compare</text>
                  <text x="512" y="340">Attestation</text>
                  <text x="100" y="356">Attester</text>
                  <text x="216" y="356">Attestation</text>
                  <text x="336" y="356">Relying</text>
                  <text x="428" y="356">Result</text>
                  <text x="488" y="356">against</text>
                  <text x="220" y="372">Result</text>
                  <text x="328" y="372">Party</text>
                  <text x="360" y="372">1</text>
                  <text x="440" y="372">appraisal</text>
                  <text x="508" y="372">policy</text>
                </g>
              </svg>
            </artwork>
            <artwork type="ascii-art"><![CDATA[
      .-------------.
      |             | Compare Evidence
      |   Verifier  | against appraisal policy
      |             |
      '--------+----'
           ^   |
  Evidence |   | Attestation
           |   | Result
           |   v
      .----+--------.
      |             | Compare
      |   Relying   | Attestation Result
      |   Party 2   | against appraisal policy
      '--------+----'
           ^   |
  Evidence |   | Attestation
           |   | Result
           |   v
      .----+--------.               .-------------.
      |             +-------------->|             | Compare Attestation
      |   Attester  |  Attestation  |   Relying   | Result against
      |             |     Result    |   Party 1   | appraisal policy
      '-------------'               '-------------']]></artwork>
          </artset>
        </figure>
      </section>
    </section>
    <section anchor="rolesentities">
      <name>Roles and Entities</name>
      <t>An entity in the RATS architecture includes at least one of the roles defined
in this document.</t>
      <t>An entity can aggregate more than one role into itself, such as being both
a Verifier and a Relying Party or being both a Reference Value Provider and
an Endorser.
As such, any conceptual messages (see <xref target="messages"/> for more
discussion) originating from such roles might also be combined. For example,
Reference Values might be conveyed as part of an appraisal policy if the
Verifier Owner and Reference Value Provider roles are combined. Similarly,
Reference Values might be conveyed as part of an Endorsement if the Endorser
and Reference Value Provider roles are combined.</t>
      <t>Interactions between roles aggregated into the same entity do not necessarily use the
Internet Protocol.
Such interactions might use a loopback device or other IP-based
communication between separate environments, but they do not have to.



Alternative channels to convey conceptual messages include function calls, sockets, General-Purpose Input/Output (GPIO)
interfaces, local buses, or hypervisor calls. This type of conveyance is typically found
in composite devices. Most importantly, these conveyance methods are
out of scope of the  RATS architecture, but they are presumed to exist in order to convey
conceptual messages appropriately between roles.</t>
      <t>In essence, an entity that combines more than one role creates and consumes
the corresponding conceptual messages as defined in this document.</t>
    </section>
    <section anchor="trustmodel">
      <name>Trust Model</name>
      <section anchor="relying-party">
        <name>Relying Party</name>
        <t>This document covers scenarios for which a Relying Party
trusts a Verifier that can appraise the trustworthiness of
information about an Attester.  Such trust
is expressed by storing one or more "trust anchors" in a secure location
known as a "trust anchor store".</t>
        <t>As defined in <xref target="RFC6024"/>:</t><blockquote>A trust anchor represents an authoritative entity via a public
key and associated data.  The public key is used to verify digital
signatures, and the associated data is used to constrain the types
of information for which the trust anchor is authoritative.</blockquote><t>
The trust anchor may be a certificate or it may be a raw public key
along with additional data if necessary, such as its public key
algorithm and parameters.
In the context of this document, a trust anchor may also be a symmetric key, as
in <xref target="TCG-DICE-SIBDA"/>, or the symmetric mode described in
<xref target="I-D.tschofenig-rats-psa-token"/>.</t>
        <t>Thus, trusting a Verifier might be expressed by having the Relying
Party store the Verifier's key or certificate in its trust anchor store.  It might also
be expressed by storing the public key or certificate of an entity (e.g., a Certificate Authority) that is
in the Verifier's certificate path.
For example, the Relying Party can verify that the Verifier is an expected one by out-of-band establishment of key material combined with a protocol like TLS to communicate.
There is an assumption that the Verifier has not been compromised between the establishment of the trusted key material and the creation of the Evidence.</t>
        <t>For a stronger level of security, the
Relying Party might require that the Verifier first provide
information about itself that the Relying Party can use to assess
the trustworthiness of the Verifier before accepting its Attestation Results.
Such a process would provide a stronger level of confidence in the correctness of
the information provided, such as a belief that the authentic Verifier has
not been compromised by malware.</t>
        <t>For example, one explicit way for a Relying Party "A" to establish
such confidence in the correctness of a Verifier "B" would be for B to first act as an Attester
where A acts as a combined Verifier/Relying Party.  If A then accepts B as
trustworthy, it can choose to accept B as a Verifier for other Attesters.</t>
        <t>Similarly, the Relying Party also needs to trust the Relying Party Owner
for providing its Appraisal Policy for Attestation Results, and,
in some scenarios, the Relying Party might even require that the
Relying Party Owner go through a remote attestation procedure with it before the Relying Party will accept
an updated policy. This can be done in a manner similar to how a Relying Party
could establish trust in a Verifier as discussed above, i.e., verifying credentials against a trust anchor store
and optionally requiring Attestation Results from the Relying Party Owner.</t>
      </section>
      <section anchor="attester">
        <name>Attester</name>
        <t>In some scenarios, Evidence might contain sensitive information, such as
Personally Identifiable Information (PII) or system identifiable information.
Thus, an Attester must trust the entities to which it conveys Evidence to not
reveal sensitive data to unauthorized parties.



The Verifier might share this information with other
authorized parties according to a governing policy that addresses the
handling of sensitive information (potentially included in Appraisal
Policies for Evidence).
In the Background-Check Model, this Evidence may also be revealed to Relying Parties.</t>
        <t>When Evidence contains sensitive information, an Attester
typically requires that a Verifier authenticates itself (e.g., at TLS session establishment) and might even request a remote attestation before the Attester
sends the sensitive Evidence.  This can be done by having the
Attester first act as a Verifier/Relying Party and the Verifier act as its
own Attester, as discussed above.</t>
      </section>
      <section anchor="rpowner-trust">
        <name>Relying Party Owner</name>
        <t>The Relying Party Owner might also require that the
Relying Party first act as an Attester by providing Evidence that the Owner
can appraise before the Owner would give the Relying Party an updated
policy that might contain sensitive information.  
In such a case, authentication or attestation in both directions might
be needed. Typically, one side's Evidence must be considered safe to
share with an untrusted entity in order to bootstrap the sequence.
See <xref target="privacy-considerations"/> for more discussion.</t>
      </section>
      <section anchor="verifier">
        <name>Verifier</name>
        <t>The Verifier trusts (or more specifically, the Verifier's security
policy is written in a way that configures the Verifier to trust) a
manufacturer or the manufacturer's hardware so as to be able to
appraise the trustworthiness of that manufacturer's devices.  Such trust
is expressed by storing one or more trust anchors in the Verifier's
trust anchor store.</t>
        <t>In a typical solution, a Verifier comes to trust an Attester
        indirectly by having an Endorser (such as a manufacturer) vouch for
        the Attester's ability to securely generate Evidence through
        Endorsements (see <xref target="endorsements"/>). Endorsements might
        describe the ways in which the Attester resists attacks, protects
        secrets, and measures Target Environments. Consequently, the
        Endorser's key material is stored in the Verifier's trust anchor store
        so that Endorsements can be authenticated and used in the Verifier's
        appraisal process.</t>
	<t>In some solutions, a Verifier might be
        configured to directly trust an Attester by having the Verifier
        possess the Attester's key material (rather than the Endorser's) in
        its trust anchor store.</t>
        <t>Such direct trust must first be established at the time of trust anchor
store configuration either by checking with an Endorser at that
time or by conducting a security analysis of the specific device.
Having the Attester directly in the trust anchor store narrows
the Verifier's trust to only specific devices rather than all devices
the Endorser might vouch for, such as all devices manufactured by the
same manufacturer in the case that the Endorser is a manufacturer.</t>
        <t>Such narrowing is often important since physical possession of a device
can also be used to conduct a number of attacks, and so a device in
a physically secure environment (such as one's own premises) may be
considered trusted, whereas devices owned by others would not be.
This often results in a desire either to have the owner run their
own Endorser that would only endorse devices one owns or to use
Attesters directly in the trust anchor store.   When there are many
Attesters owned, the use of an Endorser enables better scalability.</t>
        <t>That is, a Verifier might appraise the trustworthiness of an application component, operating
system component, or service under the assumption that information
provided about it by the lower-layer firmware or software is true.
A stronger level of assurance of security comes when information can be vouched
for by hardware or by ROM code, especially if such hardware is
physically resistant to hardware tampering.
In most cases, components that have to be vouched for via Endorsements (because no Evidence is generated about them) are referred to as "roots of trust".</t>
        <t>The manufacturer having arranged for an Attesting Environment to be provisioned with key material with which to sign Evidence, the Verifier is then provided with
some way of verifying the signature on the Evidence.  This may be in the form of an appropriate trust anchor or the Verifier may be provided with a database of public keys (rather than certificates) or even carefully curated and secured lists of symmetric keys.</t>
        <t>The nature of how the Verifier manages to validate the signatures produced by the Attester is critical to the secure operation of a remote attestation system but is not the subject of standardization within this architecture.</t>
        <t>A conveyance protocol that provides authentication and integrity protection can be used
to convey Evidence that is otherwise unprotected (e.g., not signed). Appropriate conveyance of unprotected Evidence (e.g., <xref target="I-D.ietf-rats-uccs"/>) relies on the following conveyance protocol's protection capabilities:</t>
<ol spacing="normal" type="1">

<li>The key material used to authenticate and integrity protect the conveyance channel is trusted by the Verifier to speak for the Attesting Environment(s) that collected Claims about the Target Environment(s).</li>
          <li>All unprotected Evidence that is conveyed is supplied exclusively by the Attesting Environment that has the key material that protects the conveyance channel.</li>
          <li>A trusted environment protects the conveyance channel's key material, which may depend on other Attesting Environments with equivalent strength protections.</li>
        </ol>
        <t>As illustrated in <xref target="I-D.ietf-rats-uccs"/>, an entity that receives unprotected Evidence via a trusted conveyance channel always takes on the responsibility of vouching for the Evidence's authenticity and freshness.
If protected Evidence is generated, the Attester's Attesting Environments take on that responsibility.
In cases where unprotected Evidence is processed by a Verifier, Relying Parties have to trust that the Verifier is capable of handling Evidence in a manner that preserves the Evidence's authenticity and freshness.
Generating and conveying unprotected Evidence always creates significant risk and the benefits of that approach have to be carefully weighed against potential drawbacks.</t>
        <t>See <xref target="security-considerations"/> for discussion on security strength.</t>
      </section>
      <section anchor="endorser-reference-value-provider-and-verifier-owner">
        <name>Endorser, Reference Value Provider, and Verifier Owner</name>
<t>In some scenarios, the Endorser, Reference Value Provider, and Verifier Owner may need to trust the Verifier
before giving the Endorsement, Reference Values, or appraisal policy to it.  This can be done in a 
similar manner to how a Relying Party might establish trust in a Verifier.</t>
        <t>As discussed in <xref target="rpowner-trust"/>, authentication or attestation in both directions might be
needed. Typically, one side's identity or
Evidence in this case must be considered safe to share with an untrusted entity
in order to bootstrap the sequence.
See <xref target="privacy-considerations"/> for more discussion.</t>
      </section>
    </section>
    <section anchor="messages">
      <name>Conceptual Messages</name>
      <t><xref target="dataflow"/> illustrates the flow of conceptual messages between various roles.
This section provides additional elaboration and implementation considerations.
It is the responsibility of protocol specifications to define the actual data format
and semantics of any relevant conceptual messages.</t>
      <section anchor="evidence">
        <name>Evidence</name>
        <t>Evidence is a set of Claims about the Target Environment that reveal operational
status, health, configuration, or construction that have security relevance.
Evidence is appraised by a Verifier to establish its relevance, compliance, and timeliness.
Claims need to be collected in a manner that is reliable such that a Target Environment cannot lie to the Attesting Environment about its trustworthiness properties.
Evidence needs to be securely associated with the Target Environment
so that the Verifier cannot be tricked into accepting Claims originating
from a different environment (that may be more trustworthy).
Evidence also must be protected from an active on-path attacker who may observe,
change, or misdirect Evidence as it travels from the Attester to the Verifier.
The timeliness of Evidence can be captured using Claims that pinpoint the time
or interval when changes in operational status, health, and so forth occur.</t>
      </section>
      <section anchor="endorsements">
        <name>Endorsements</name>
        <t>An Endorsement is a secure statement that some entity (e.g., a
        manufacturer) vouches for the integrity of the device's various
        capabilities, such as Claims collection, signing, launching code,
        transitioning to other environments, storing secrets, and more.  For
        example, if the device's signing capability is in hardware, then an
        Endorsement might be a manufacturer certificate that signs a public
        key whose corresponding private key is only known inside the device's
        hardware.  Thus, when Evidence and such an Endorsement are used
        together, an appraisal procedure can be conducted based on appraisal
        policies that may not be specific to the device instance but are merely
        specific to the manufacturer providing the Endorsement. For example,
        an appraisal policy might simply check that devices from a given
        manufacturer have information matching a set of Reference Values. An appraisal policy might also have a set of more complex logic on how to
        appraise the validity of information.</t>
        <t>However, while an appraisal policy that treats all devices from a
        given manufacturer the same may be appropriate for some use cases, it
        would be inappropriate to use such an appraisal policy as the sole
        means of authorization for use cases that wish to constrain
        <em>which</em> compliant devices are considered authorized for some
        purpose.  For example, an enterprise using remote attestation for
        Network Endpoint Assessment (NEA) <xref target="RFC5209"/> may not wish to
        let every healthy laptop from the same manufacturer onto the network.
        Instead, it may only want to let devices that it legally owns onto the
        network.  Thus, an Endorsement may be helpful information in
        authenticating information about a device, but is not necessarily
        sufficient to authorize access to resources that may need
        device-specific information, such as a public key for the device or
        component or user on the device.</t>
      </section>
      <section anchor="reference-values">
        <name>Reference Values</name>
        <t>Reference Values used in appraisal procedures come from a Reference
        Value Provider and are then used by the Verifier to compare to
        Evidence.  Reference Values with matching Evidence produce acceptable
        Claims.  Additionally, an appraisal policy may play a role in determining
        the acceptance of Claims.</t>
      </section>
      <section anchor="attestation-results">
        <name>Attestation Results</name>
        <t>Attestation Results are the input used by the Relying Party to
        decide the extent to which it will trust a particular Attester and
        allow it to access some data or perform some operation.</t>
        <t>Attestation Results may carry a boolean value indicating compliance
        or non-compliance with a Verifier's appraisal policy or may carry a
        richer set of Claims about the Attester, against which the Relying
        Party applies its Appraisal Policy for Attestation Results.</t>
        <t>The quality of the Attestation Results depends upon the ability of the Verifier to evaluate the Attester.
Different Attesters have a different <em>Strength of Function</em> <xref target="strengthoffunction"/>, which results in the Attestation Results being qualitatively different in strength.</t>
        <t>An Attestation Result that indicates non-compliance can be used by an Attester (in the Passport Model) or
a Relying Party (in the Background-Check Model) to indicate that the Attester
should not be treated as authorized and may be in need of remediation.  In some cases,
it may even indicate that the Evidence itself cannot be authenticated as being correct.</t>
        <t>By default, the Relying Party does not believe the Attester to be compliant.
Upon receipt of an authentic Attestation Result and given the Appraisal Policy for Attestation Results is satisfied,
the Attester is allowed to perform the prescribed actions or access.
The simplest such appraisal policy might authorize granting the Attester full access or control over the resources guarded by the Relying Party.
A more complex appraisal policy might involve using the information
provided in the Attestation Result to compare against expected values or to apply complex analysis
of other information contained in the Attestation Result.</t>
        <t>Thus, Attestation Results can contain detailed information about an
        Attester, which can include privacy sensitive information as discussed
        in <xref target="privacy-considerations"/>.  Unlike Evidence, which is
        often very device- and vendor-specific, Attestation Results can be
        vendor-neutral, if the Verifier has a way to generate vendor-agnostic
        information based on the appraisal of vendor-specific information in
        Evidence.  This allows a Relying Party's appraisal policy to be
        simpler, potentially based on standard ways of expressing the
        information, while still allowing interoperability with heterogeneous
        devices.</t>
        <t>Finally, whereas Evidence is signed by the device (or indirectly by
        a manufacturer if Endorsements are used), Attestation Results are
        signed by a Verifier, allowing a Relying Party to only need a trust
        relationship with one entity rather than a larger set of entities
        for purposes of its appraisal policy.</t>
      </section>
      <section anchor="appraisal-policies">
        <name>Appraisal Policies</name>
        <t>The Verifier (when appraising Evidence) or the Relying Party (when
appraising Attestation Results) checks the values of matched Claims
against constraints specified in its appraisal policy.
Examples of such constraints checking include the following:</t>
        <ul spacing="normal">
          <li>Comparison for equality against a Reference Value.</li>
          <li>A check for being in a range bounded by Reference Values.</li>
          <li>Membership in a set of Reference Values.</li>
          <li>A check against values in other Claims.</li>
        </ul>
        <t>Upon completing all appraisal policy constraints, the remaining Claims are accepted
as input toward determining Attestation Results (when appraising Evidence)
or as input to a Relying Party (when appraising Attestation Results).</t>
      </section>
    </section>
    <section anchor="claims-encoding-formats">
      <name>Claims Encoding Formats</name>
      <t><xref target="clientserver"/> illustrates a relationship to which remote attestation is desired to be added:</t>
      <figure anchor="clientserver">
        <name>Typical Resource Access</name>
        <artset>
          <artwork type="svg"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="128" width="432" viewBox="0 0 432 128" class="diagram" text-anchor="middle" font-family="monospace" font-size="13px">
              <path d="M 8,32 L 8,96" fill="none" stroke="black"/>
              <path d="M 120,32 L 120,96" fill="none" stroke="black"/>
              <path d="M 248,32 L 248,96" fill="none" stroke="black"/>
              <path d="M 352,32 L 352,96" fill="none" stroke="black"/>
              <path d="M 8,32 L 120,32" fill="none" stroke="black"/>
              <path d="M 248,32 L 352,32" fill="none" stroke="black"/>
              <path d="M 120,48 L 240,48" fill="none" stroke="black"/>
              <path d="M 8,96 L 120,96" fill="none" stroke="black"/>
              <path d="M 248,96 L 352,96" fill="none" stroke="black"/>
              <polygon class="arrowhead" points="248,48 236,42.4 236,53.6 " fill="black" transform="rotate(0,240,48)"/>
              <g class="text">
                <text x="396" y="36">Evaluate</text>
                <text x="392" y="52">request</text>
                <text x="60" y="68">Attester</text>
                <text x="164" y="68">Access</text>
                <text x="212" y="68">some</text>
                <text x="304" y="68">Relying</text>
                <text x="392" y="68">against</text>
                <text x="188" y="84">resource</text>
                <text x="304" y="84">Party</text>
                <text x="396" y="84">security</text>
                <text x="388" y="100">policy</text>
              </g>
            </svg>
          </artwork>
          <artwork type="ascii-art"><![CDATA[
   .-------------.               .------------. Evaluate
   |             +-------------->|            | request
   |  Attester   |  Access some  |   Relying  | against
   |             |    resource   |    Party   | security
   '-------------'               '------------' policy]]></artwork>
        </artset>
      </figure>
      
      <t>In this diagram, the protocol between the Attester and a Relying Party
can be any new or existing protocol (e.g., HTTP(S), CoAP(S),
Resource-Oriented Lightweight Information Exchange (ROLIE) <xref target="RFC8322"/>,
802.1x, OPC UA <xref target="OPCUA"/>, etc.) depending on the use case.</t>
      <t>Typically, such protocols already have mechanisms for passing security information for authentication and authorization purposes.
Common formats include JSON Web Tokens (JWTs) <xref target="RFC7519"/>, CWTs <xref target="RFC8392"/>, and X.509 certificates.</t>
      <t>Retrofitting already-deployed protocols with remote attestation requires
adding RATS conceptual messages to the existing data flows. This must be
done in a way that does not degrade the security properties of the systems involved
and should use extension mechanisms provided by the underlying
protocol. For example, if a TLS handshake is to be extended with
remote attestation capabilities, attestation Evidence may be embedded
in an ad hoc X.509 certificate extension (e.g., <xref target="TCG-DICE"/>) or into a new
TLS Certificate Type (e.g., <xref target="I-D.tschofenig-tls-cwt"/>).</t>
      <t>Especially for constrained nodes, there is a desire to minimize
the amount of parsing code needed in a Relying Party in order to both
minimize footprint and the attack surface. While
it would be possible to embed a CWT inside a JWT, or a JWT inside an
X.509 extension, etc., there is a desire to encode the information
in a format that is already supported by the Relying Party.</t>
      <t>This motivates having a common "information model" that describes
the set of remote attestation related information in an encoding-agnostic
way and allows multiple encoding formats (CWT, JWT, X.509, etc.)
that encode the same information into the Claims format needed by the
Relying Party.</t>
      <t><xref target="multievidence_diag"/> illustrates that Evidence and
      Attestation Results might be expressed via multiple potential encoding
      formats so that they can be conveyed by various existing protocols.  It
      also motivates why the Verifier might also be responsible for accepting
      Evidence that encodes Claims in one format while issuing Attestation
      Results that encode Claims in a different format.</t>
      <figure anchor="multievidence_diag">
        <name>Multiple Attesters and Relying Parties with Different Formats</name>
        <artset>
          <artwork type="svg" align="center"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="352" width="560" viewBox="0 0 560 352" class="diagram" text-anchor="middle" font-family="monospace" font-size="13px">
              <path d="M 8,48 L 8,80" fill="none" stroke="black"/>
              <path d="M 8,112 L 8,144" fill="none" stroke="black"/>
              <path d="M 8,176 L 8,208" fill="none" stroke="black"/>
              <path d="M 8,240 L 8,272" fill="none" stroke="black"/>
              <path d="M 8,304 L 8,336" fill="none" stroke="black"/>
              <path d="M 128,48 L 128,80" fill="none" stroke="black"/>
              <path d="M 128,112 L 128,144" fill="none" stroke="black"/>
              <path d="M 128,176 L 128,208" fill="none" stroke="black"/>
              <path d="M 128,240 L 128,272" fill="none" stroke="black"/>
              <path d="M 128,304 L 128,336" fill="none" stroke="black"/>
              <path d="M 208,112 L 208,272" fill="none" stroke="black"/>
              <path d="M 232,80 L 232,104" fill="none" stroke="black"/>
              <path d="M 232,280 L 232,304" fill="none" stroke="black"/>
              <path d="M 288,80 L 288,112" fill="none" stroke="black"/>
              <path d="M 288,272 L 288,304" fill="none" stroke="black"/>
              <path d="M 312,112 L 312,272" fill="none" stroke="black"/>
              <path d="M 392,48 L 392,80" fill="none" stroke="black"/>
              <path d="M 392,112 L 392,144" fill="none" stroke="black"/>
              <path d="M 392,176 L 392,208" fill="none" stroke="black"/>
              <path d="M 392,240 L 392,272" fill="none" stroke="black"/>
              <path d="M 392,304 L 392,336" fill="none" stroke="black"/>
              <path d="M 552,48 L 552,80" fill="none" stroke="black"/>
              <path d="M 552,112 L 552,144" fill="none" stroke="black"/>
              <path d="M 552,176 L 552,208" fill="none" stroke="black"/>
              <path d="M 552,240 L 552,272" fill="none" stroke="black"/>
              <path d="M 552,304 L 552,336" fill="none" stroke="black"/>
              <path d="M 8,48 L 128,48" fill="none" stroke="black"/>
              <path d="M 392,48 L 552,48" fill="none" stroke="black"/>
              <path d="M 128,64 L 216,64" fill="none" stroke="black"/>
              <path d="M 304,64 L 384,64" fill="none" stroke="black"/>
              <path d="M 8,80 L 128,80" fill="none" stroke="black"/>
              <path d="M 392,80 L 552,80" fill="none" stroke="black"/>
              <path d="M 8,112 L 128,112" fill="none" stroke="black"/>
              <path d="M 208,112 L 312,112" fill="none" stroke="black"/>
              <path d="M 392,112 L 552,112" fill="none" stroke="black"/>
              <path d="M 128,128 L 200,128" fill="none" stroke="black"/>
              <path d="M 312,128 L 384,128" fill="none" stroke="black"/>
              <path d="M 8,144 L 128,144" fill="none" stroke="black"/>
              <path d="M 392,144 L 552,144" fill="none" stroke="black"/>
              <path d="M 8,176 L 128,176" fill="none" stroke="black"/>
              <path d="M 392,176 L 552,176" fill="none" stroke="black"/>
              <path d="M 128,192 L 200,192" fill="none" stroke="black"/>
              <path d="M 312,192 L 384,192" fill="none" stroke="black"/>
              <path d="M 8,208 L 128,208" fill="none" stroke="black"/>
              <path d="M 392,208 L 552,208" fill="none" stroke="black"/>
              <path d="M 8,240 L 128,240" fill="none" stroke="black"/>
              <path d="M 392,240 L 552,240" fill="none" stroke="black"/>
              <path d="M 128,256 L 200,256" fill="none" stroke="black"/>
              <path d="M 312,256 L 384,256" fill="none" stroke="black"/>
              <path d="M 8,272 L 128,272" fill="none" stroke="black"/>
              <path d="M 208,272 L 312,272" fill="none" stroke="black"/>
              <path d="M 392,272 L 552,272" fill="none" stroke="black"/>
              <path d="M 8,304 L 128,304" fill="none" stroke="black"/>
              <path d="M 392,304 L 552,304" fill="none" stroke="black"/>
              <path d="M 128,320 L 216,320" fill="none" stroke="black"/>
              <path d="M 304,320 L 384,320" fill="none" stroke="black"/>
              <path d="M 8,336 L 128,336" fill="none" stroke="black"/>
              <path d="M 392,336 L 552,336" fill="none" stroke="black"/>
              <path d="M 216,64 C 224.83064,64 232,71.16936 232,80" fill="none" stroke="black"/>
              <path d="M 304,64 C 295.16936,64 288,71.16936 288,80" fill="none" stroke="black"/>
              <path d="M 216,320 C 224.83064,320 232,312.83064 232,304" fill="none" stroke="black"/>
              <path d="M 304,320 C 295.16936,320 288,312.83064 288,304" fill="none" stroke="black"/>
              <polygon class="arrowhead" points="392,320 380,314.4 380,325.6 " fill="black" transform="rotate(0,384,320)"/>
              <polygon class="arrowhead" points="392,256 380,250.4 380,261.6 " fill="black" transform="rotate(0,384,256)"/>
              <polygon class="arrowhead" points="392,192 380,186.4 380,197.6 " fill="black" transform="rotate(0,384,192)"/>
              <polygon class="arrowhead" points="392,128 380,122.4 380,133.6 " fill="black" transform="rotate(0,384,128)"/>
              <polygon class="arrowhead" points="392,64 380,58.4 380,69.6 " fill="black" transform="rotate(0,384,64)"/>
              <polygon class="arrowhead" points="240,280 228,274.4 228,285.6 " fill="black" transform="rotate(270,232,280)"/>
              <polygon class="arrowhead" points="240,104 228,98.4 228,109.6 " fill="black" transform="rotate(90,232,104)"/>
              <polygon class="arrowhead" points="208,256 196,250.4 196,261.6 " fill="black" transform="rotate(0,200,256)"/>
              <polygon class="arrowhead" points="208,192 196,186.4 196,197.6 " fill="black" transform="rotate(0,200,192)"/>
              <polygon class="arrowhead" points="208,128 196,122.4 196,133.6 " fill="black" transform="rotate(0,200,128)"/>
              <g class="text">
                <text x="164" y="36">Evidence</text>
                <text x="328" y="36">Attestation</text>
                <text x="408" y="36">Results</text>
                <text x="168" y="52">CWT</text>
                <text x="352" y="52">CWT</text>
                <text x="68" y="68">Attester-A</text>
                <text x="440" y="68">Relying</text>
                <text x="496" y="68">Party</text>
                <text x="528" y="68">V</text>
                <text x="168" y="116">JWT</text>
                <text x="352" y="116">JWT</text>
                <text x="68" y="132">Attester-B</text>
                <text x="440" y="132">Relying</text>
                <text x="496" y="132">Party</text>
                <text x="528" y="132">W</text>
                <text x="168" y="180">X.509</text>
                <text x="352" y="180">X.509</text>
                <text x="68" y="196">Attester-C</text>
                <text x="260" y="196">Verifier</text>
                <text x="440" y="196">Relying</text>
                <text x="496" y="196">Party</text>
                <text x="528" y="196">X</text>
                <text x="168" y="244">TPM</text>
                <text x="352" y="244">TPM</text>
                <text x="68" y="260">Attester-D</text>
                <text x="440" y="260">Relying</text>
                <text x="496" y="260">Party</text>
                <text x="528" y="260">Y</text>
                <text x="168" y="308">other</text>
                <text x="352" y="308">other</text>
                <text x="68" y="324">Attester-E</text>
                <text x="440" y="324">Relying</text>
                <text x="496" y="324">Party</text>
                <text x="528" y="324">Z</text>
              </g>
            </svg>
          </artwork>
          <artwork type="ascii-art" align="center"><![CDATA[
                Evidence           Attestation Results
.--------------.   CWT                    CWT   .-------------------.
|  Attester-A  +-----------.        .---------->|  Relying Party V  |
'--------------'            |      |            `-------------------'
                            v      |
.--------------.   JWT   .---------+--.   JWT   .-------------------.
|  Attester-B  +-------->|            +-------->|  Relying Party W  |
'--------------'         |            |         `-------------------'
                         |            |
.--------------.  X.509  |            |  X.509  .-------------------.
|  Attester-C  +-------->|  Verifier  +-------->|  Relying Party X  |
'--------------'         |            |         `-------------------'
                         |            |
.--------------.   TPM   |            |   TPM   .-------------------.
|  Attester-D  +-------->|            +-------->|  Relying Party Y  |
'--------------'         '---------+--'         `-------------------'
                            ^      |
.--------------.  other     |      |     other  .-------------------.
|  Attester-E  +-----------'        '---------->|  Relying Party Z  |
'--------------'                                `-------------------']]></artwork>
        </artset>
      </figure>
    </section>
    <section anchor="freshness">
      <name>Freshness</name>
      <t>A Verifier or Relying Party might need to learn the point in time
(i.e., the "epoch") an Evidence or Attestation Result has been produced.  This is essential in deciding whether the included Claims can be considered fresh,
meaning they still reflect the latest state of the Attester, and that any
Attestation Result was generated using the latest Appraisal Policy for Evidence, Endorsements, and Reference Values.</t>
      <t>This section provides a number of details.
However, it does not define any protocol formats and the interactions shown are abstract.
This section is intended for those creating protocols and solutions to understand the options available to ensure freshness.
The way in which freshness is provisioned in a protocol is an architectural decision.
Provisioning of freshness has an impact on the number of needed round trips in a protocol; therefore, it must be made very early in the design.
Different decisions will have significant impacts on resulting interoperability,
which is why this section goes into sufficient detail such that choices in freshness will be compatible across interacting protocols, such as depicted in <xref target="multievidence_diag"/>.</t>
      <t>Freshness is assessed based on the Appraisal Policy for Evidence or
      Attestation Results that compares the estimated epoch against an
      "expiry" threshold defined locally to that policy.  There is, however,
      always a race condition possible in that the state of the Attester and
      the appraisal policies might change immediately after the Evidence or
      Attestation Result was generated.  The goal is merely to narrow their
      recentness to something the Verifier (for Evidence) or Relying Party
      (for Attestation Result) is willing to accept.  Some flexibility on the
      freshness requirement is a key component for enabling caching and reuse
      of both Evidence and Attestation Results, which is especially valuable
      in cases where their computation uses a substantial part of the resource
      budget (e.g., energy in constrained devices).</t>
      <t>There are three common approaches for determining the epoch of Evidence or an
Attestation Result.</t>
      <section anchor="explicit-timekeeping-using-synchronized-clocks">
        <name>Explicit Timekeeping Using Synchronized Clocks</name>
        <t>The first approach is to rely on synchronized and trustworthy clocks and
include a signed timestamp (see <xref target="I-D.birkholz-rats-tuda"/>) along with the
Claims in the Evidence or Attestation Result.  Timestamps can also be added on a
per-Claim basis to distinguish the time of generation of Evidence or Attestation
Result from the time that a specific Claim was generated.  The clock's
trustworthiness can generally be established via Endorsements and typically requires additional Claims about the signer's time
synchronization mechanism.</t>
        <t>However, a trustworthy clock might not be available in some use cases. For
example, in many TEEs today, a clock is only
available outside the TEE; thus, it cannot be trusted by the TEE.</t>
      </section>
      <section anchor="implicit-timekeeping-using-nonces">
        <name>Implicit Timekeeping Using Nonces</name> <t>A second approach
        places the onus of timekeeping solely on the Verifier (for Evidence)
        or the Relying Party (for Attestation Results). For example, this
        approach might be suitable in case the Attester does not have a
        trustworthy clock or time synchronization is otherwise impaired.
	In
        this approach, an unpredictable nonce is sent by the appraising
        entity and the nonce is then signed and included along with the Claims
        in the Evidence or Attestation Result.  After checking that the sent
        and received nonces are the same, the appraising entity knows that the
        Claims were signed after the nonce was generated.  This allows
        associating a "rough" epoch to the Evidence or Attestation Result.  In
        this case, the epoch is said to be rough because:</t>
        <ul spacing="normal">
          <li>The epoch applies to the entire Claim set instead of a more granular
association, and</li>
          <li>The time between the creation of Claims and the collection of Claims is
indistinguishable.</li>
        </ul>
      </section>
      <section anchor="epochfreshness">
        <name>Implicit Timekeeping Using Epoch IDs</name>
        <t>A third approach relies on having epoch identifiers (IDs)
periodically sent to both the sender and receiver of Evidence or
Attestation Results by some "epoch ID distributor".</t>
        <t>Epoch IDs are different from nonces as they can be used more than once and
can even be used by more than one entity at the same time.
Epoch IDs are different from timestamps as they do not have to convey information about a point in time, i.e., they are not necessarily monotonically increasing integers.</t>
        <t>Like the nonce approach, this allows associating a "rough" epoch without
requiring a trustworthy clock or time synchronization in order to generate or
appraise the freshness of Evidence or Attestation Results.  Only the
epoch ID distributor requires access to a clock so it can periodically send
new epoch IDs.</t>
        <t>The most recent epoch ID is included in the produced Evidence or Attestation
Results, and the appraising entity can compare the epoch ID in received
Evidence or Attestation Results against the latest epoch ID it received from
the epoch ID distributor to determine if it is within the current epoch.
An actual solution also needs to take into account race conditions
when transitioning to a new epoch, such as by using a counter signed
by the epoch ID distributor as the epoch ID, by including both the current and
previous epoch IDs in messages and/or checks by requiring retries
in case of mismatching epoch IDs, or by buffering incoming messages
that might be associated with an epoch ID that the receiver has not yet
obtained.</t>
        <t>More generally, in order to prevent an appraising entity from generating false
negatives (e.g., discarding Evidence that is deemed stale even if it is
not), the appraising entity should keep an "epoch window" consisting of the
most recently received epoch IDs.  The depth of such epoch window is directly
proportional to the maximum network propagation delay between the first to receive the epoch ID and the last to receive the epoch ID and it is inversely proportional to the epoch duration.
The appraising entity shall compare the
epoch ID carried in the received Evidence or Attestation Result with the epoch IDs
in its epoch window to find a suitable match.</t>
        <t>Whereas the nonce approach typically requires the appraising entity
to keep state for each nonce generated, the epoch ID approach minimizes
the state kept to be independent of the number of Attesters or Verifiers
from which it expects to receive Evidence or Attestation Results as long
as all use the same epoch ID distributor.</t>
      </section>
      <section anchor="discussion">
        <name>Discussion</name>
        <t>Implicit and explicit timekeeping can be combined into hybrid mechanisms.
For example, if clocks exist within the Attesting Environment and are considered trustworthy (tamper-proof) but are not synchronized, a nonce-based exchange may be used to determine the (relative) time offset between the involved peers followed by any number of timestamp
based exchanges.</t>
        <t>It is important to note that the actual values in Claims might have been
generated long before the Claims are signed.  If so, it is the signer's
responsibility to ensure that the values are still fresh when they are
signed.  For example, values generated at boot time might have been saved to
secure storage until network connectivity is established to the remote Verifier
and a nonce is obtained.</t>
        <t>A more detailed discussion with examples appears in <xref target="time-considerations"/>.</t>
        <t>For a discussion on the security of epoch IDs see <xref target="epochids-sec"/>.</t>
      </section>
    </section>
    <section anchor="privacy-considerations">
      <name>Privacy Considerations</name>
      <t>The conveyance of Evidence and the resulting Attestation Results
reveal a great deal of information about the internal state of a
device as well as potentially any users of the device.</t>
      <t>In many cases, the whole point of attestation procedures is
to provide reliable information about the type of the device and the
firmware/software that the device is running.</t>
      <t>This information might be particularly interesting to many attackers.
For example, knowing that a device is
running a weak version of firmware provides a way to aim attacks better.</t>
      <t>In some circumstances, if an attacker can become aware of Endorsements, Reference Values, or appraisal policies, it could potentially provide an attacker with insight into defensive mitigations.
It is recommended that attention be paid to confidentiality of such information.</t>
      <t>Additionally, many Evidence, Attestation Results, and appraisal policies potentially contain Personally Identifying Information (PII) depending on the end-to-end use case of
the remote attestation procedure.
Remote attestation that includes containers and applications, e.g., a blood pressure monitor, may further
reveal details about specific systems or users.</t>
      <t>In some cases, an attacker may be able to make inferences about the contents of Evidence
from the resulting effects or timing of the processing.
For example, an attacker might be able to infer the value of specific Claims if it knew that only certain values were accepted by the Relying Party.</t>
      <t>Conceptual messages (see <xref target="messages"/>) carrying sensitive or confidential information are expected to be integrity protected (i.e., either via signing or a secure channel) and optionally might be confidentiality protected via encryption.
If there isn't confidentiality protection of conceptual messages themselves, the underlying conveyance protocol should provide these protections.</t>
      <t>As Evidence might contain sensitive or confidential information,
Attesters are responsible for only sending such Evidence to trusted
Verifiers.
Some Attesters might want a stronger level of assurance of
the trustworthiness of a Verifier before sending Evidence to it.
In such cases,
an Attester can first act as a Relying Party and ask for the Verifier's own
Attestation Result. Appraising it just as a Relying Party would appraise
an Attestation Result for any other purpose.</t>
      <t>Another approach to deal with Evidence is to remove PII from the Evidence
while still being able to verify that the Attester is one of a large set.
This approach is often called "Direct Anonymous Attestation".  See
Section 6.2 of <xref target="CCC-DeepDive"/> and <xref target="I-D.ietf-rats-daa"/> for more discussion.</t>
    </section>
    <section anchor="security-considerations">
      <name>Security Considerations</name>
      <t>This document provides an architecture for doing remote attestation.
No specific wire protocol is documented here.
Without a specific proposal to compare against, it is impossible to know if the security threats listed below have been mitigated well.</t>
      <t>The security considerations below should be read as being, essentially, requirements against realizations of the RATS architecture.
Some threats apply to protocols and some are against implementations (code) and physical infrastructure (such as factories).</t>
      <t>The fundamental purpose of the RATS architecture is to allow a Relying Party to establish a basis for trusting the Attester.</t>
      <section anchor="attester-and-attestation-key-protection">
        <name>Attester and Attestation Key Protection</name>
        <t>Implementers need to pay close attention to the protection of the Attester and the manufacturing processes for provisioning attestation key material. If either of these are compromised, intended levels of assurance for  remote attestation procedures are compromised because attackers can forge Evidence or manipulate the Attesting Environment.
For example, a Target Environment should not be able to tamper with the
Attesting Environment that measures it by isolating the two environments
from each other in some way.</t>
        <t>Remote attestation applies to use cases with a range of security requirements. The protections discussed here range from low to high security: low security may be limited to application or process isolation by the device's operating system and high security may involve specialized hardware to defend against physical attacks on a chip.</t>
        <section anchor="on-device-attester-and-key-protection">
          <name>On-Device Attester and Key Protection</name>
          <t>It is assumed that an Attesting Environment is sufficiently isolated from the
Target Environment it collects Claims about and that it signs the resulting Claims set with an attestation
key so that the Target Environment cannot forge Evidence about itself.  Such
an isolated environment might be provided by a process, a dedicated chip,
a TEE, a virtual machine, or another secure mode of operation.
The Attesting Environment must be protected from unauthorized modification to ensure it behaves correctly. Confidentiality protection of the Attesting Environment's signing key is vital so it cannot be misused to forge Evidence.</t>
          <t>In many cases, the user or owner of a device that includes the role of Attester must not be able to modify or extract keys from the Attesting Environments to prevent creating forged Evidence.
Some common examples include the user of a mobile phone or FIDO authenticator.</t>
          <t>Measures for a minimally protected system might include process or application isolation provided by a high-level operating system and restricted access to root or system privileges. In contrast, for really simple single-use devices that don't use a protected mode operating system (like a Bluetooth speaker), the only factual isolation might be the sturdy housing of the device.</t>
          <t>Measures for a moderately protected system could include a special restricted operating environment, such as a TEE. In this case, only security-oriented software has access to the Attester and key material.</t>
          <t>Measures for a highly protected system could include specialized hardware that is used to provide protection against chip decapping attacks, power supply and clock glitching, faulting injection and RF, and power side channel attacks.</t>
        </section>
        <section anchor="attestation-key-provisioning-processes">
          <name>Attestation Key Provisioning Processes</name>
          <t>Attestation key provisioning is the process that occurs in the factory or elsewhere to establish signing key material on the device and the validation key material off the device.
Sometimes, this procedure is referred to as "personalization" or "customization".</t>
          <t>When generating keys off-device in the factory or in the device, the use of
a cryptographically strong sequence (<xref section="6.2" sectionFormat="comma" target="RFC4086"/>) needs consideration.</t>
          <section anchor="off-device-key-generation">
            <name>Off-Device Key Generation</name>
            <t>One way to provision key material is to first generate it external to the device and then copy the key onto the device.
In this case, confidentiality protection of the generator and the path over which the key is provisioned is necessary.
The manufacturer needs to take care to protect corresponding key material with measures appropriate for its value.</t>
            <t>The degree of protection afforded to this key material can vary by the intended
function of the device and the specific practices of the device manufacturer or integrator.
The confidentiality protection is fundamentally based upon some amount of physical protection. While encryption is often used to provide confidentiality when a key is conveyed across a factory where the attestation key is created or applied, it must be available in an unencrypted form.
The physical protection can therefore vary from situations where the key is unencrypted only within carefully controlled secure enclaves within silicon to situations where an entire facility is considered secure
by the simple means of locked doors and limited access.</t>
            <t>The cryptography that is used to enable confidentiality protection of the attestation key comes with its own requirements to be secured.
This results in recursive problems, as the key material used to provision attestation keys must again somehow have been provisioned securely beforehand (requiring an additional level of protection and so on).</t>
            <t>Commonly, a combination of some physical security measures and some cryptographic measures are used to establish confidentiality protection.</t>
          </section>
          <section anchor="on-device-key-generation">
            <name>On-Device Key Generation</name>
            <t>When key material is generated within a device and the secret part of it never leaves the device, the problem may lessen.  
 For public-key cryptography, it is not necessary to maintain confidentiality
 of the public key.  However, integrity of the chain of custody of the
 public key is necessary in order to avoid attacks where an attacker is able
 to get a key endorsed that the attacker controls.</t>
            <t>To summarize, attestation key provisioning must ensure that only valid attestation key material is established in Attesters.</t>
          </section>
        </section>
      </section>
      <section anchor="conceptual-message-protection">
        <name>Conceptual Message Protection</name>
        <t>Any solution that conveys information in any conceptual message (see <xref target="messages"/>)
must support end-to-end integrity protection
and replay attack prevention. It often also needs to support additional
security properties, including:</t>
        <ul spacing="normal">
          <li>end-to-end encryption,</li>
          <li>denial-of-service protection,</li>
          <li>authentication,</li>
          <li>auditing,</li>
          <li>fine-grained access controls, and</li>
          <li>logging.</li>
        </ul>
        <t><xref target="freshness"/> discusses ways in which freshness can be used in this
architecture to protect against replay attacks.</t>
        <t>To assess the security provided by a particular appraisal policy, it
is important to understand the strength of the root of trust, e.g.,
whether it is mutable software or firmware that is read-only after
boot or immutable hardware/ROM.</t>
        <t>It is also important that the appraisal policy was obtained securely itself.
If an attacker can configure or modify appraisal policies and Endorsements or Reference Values for a Relying Party or a Verifier, then integrity of the process is compromised.</t>
        <t>Security protections in the RATS architecture may be applied at different layers, whether by a conveyance protocol or an information encoding format.
This architecture expects conceptual messages to be end-to-end protected based on the role interaction context.
For example, if an Attester produces Evidence that is relayed through some other entity that doesn't implement the Attester or the intended Verifier roles, then the relaying entity should not expect to have access to the Evidence.</t>
        <t>The RATS architecture allows for an entity to function in multiple roles
(<xref target="rolesentities"/>) and for composite devices (<xref target="compositedevice"/>).
Implementers need to evaluate their designs to ensure that the assumed security properties of the individual components and roles still hold despite the lack of separation and that emergent risk is not introduced.  The specifics of this evaluation will depend on the implementation and the use case; hence, they are out of scope for this document.
Isolation mechanisms in software or hardware that separate Attesting Environments and Target Environments (<xref target="twotypes"/>) can support an implementer's evaluation and resulting design decisions.</t>
      </section>
      <section anchor="epochids-sec">
        <name>Attestation Based on Epoch ID</name>
        <t>Epoch IDs, described in <xref target="epochfreshness"/>, can be tampered with, replayed, dropped, delayed, and
reordered by an attacker.</t>
        <t>An attacker could either be external or belong to the distribution group (for
example, if one of the Attester entities have been compromised).</t>
        <t>An attacker who is able to tamper with epoch IDs can potentially lock all the
participants in a certain epoch of choice forever, effectively freezing time.
This is problematic since it destroys the ability to ascertain freshness of
Evidence and Attestation Results.</t>
        <t>To mitigate this threat, the transport should be at least integrity protected
and provide origin authentication.</t>
        <t>Selective dropping of epoch IDs is equivalent to pinning the victim node to a past epoch.
An attacker could drop epoch IDs to only some entities and not others, which will typically result in a denial of service due to the permanent staleness of the Attestation Result or Evidence.</t>
        <t>Delaying or reordering epoch IDs is equivalent to manipulating the victim's
timeline at will.  This ability could be used by a malicious actor (e.g., a
compromised router) to mount a confusion attack. For example, a Verifier
can be tricked into accepting Evidence coming from a past epoch as fresh, while, in
the meantime, the Attester has been compromised.</t>
        <t>Reordering and dropping attacks are mitigated if the transport provides the ability to detect reordering and drop.
However, the delay attack described above can't be thwarted in this manner.</t>
      </section>
      <section anchor="trust-anchor-protection">
        <name>Trust Anchor Protection</name>
        <t>As noted in <xref target="trustmodel"/>, Verifiers and Relying Parties have trust anchor stores
that must be secured.
<xref target="RFC6024"/> contains more discussion of trust anchor store requirements
for protecting public keys.
Section 6 of <xref target="NIST-800-57-p1"/> contains a comprehensive treatment of the
topic, including the protection of symmetric key material.
Specifically, a trust anchor store must resist modification against unauthorized insertion, deletion, and modification.
Additionally, if the trust anchor is a symmetric key, the trust anchor store must
not allow unauthorized read.</t>
        <t>If certificates are used as trust anchors, Verifiers and Relying Parties are also
responsible for validating the entire certificate path up to the trust anchor,
which includes checking for certificate revocation.
For an example of such a procedure, see <xref target="RFC5280" sectionFormat="of" section="6"/>.</t>
      </section>
    </section>
    <section anchor="iana-considerations">
      <name>IANA Considerations</name>
      <t>This document has no IANA actions.</t>
    </section>
  </middle>
  <back>

<displayreference target="I-D.birkholz-rats-tuda" to="RATS-TUDA"/>
<displayreference target="I-D.ietf-rats-uccs" to="RATS-UCCS"/>
<displayreference target="I-D.ietf-teep-architecture" to="TEEP-ARCH"/>
<displayreference target="I-D.ietf-rats-daa" to="RATS-DAA"/>
<displayreference target="I-D.tschofenig-rats-psa-token" to="RATS-PSA-TOKEN"/>
<displayreference target="I-D.tschofenig-tls-cwt" to="TLS-CWT"/>

    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>

<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7519.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8392.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5280.xml"/>

      </references>
      <references>
        <name>Informative References</name>

<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4949.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5209.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8322.xml"/>

        <reference anchor="OPCUA" target="https://opcfoundation.org/developer-tools/specifications-unified-architecture/part-2-security-model/">
          <front>
            <title>OPC Unified Architecture Specification, Part 2: Security Model, Release 1.03</title>
            <author>
              <organization>OPC Foundation</organization>
            </author>
            <date year="2015" month="November"/>
          </front>
          <seriesInfo name="OPC 10000-2" value=""/>
        </reference>

        <reference anchor="TCG-DICE" target="https://trustedcomputinggroup.org/wp-content/uploads/DICE-Attestation-Architecture-r23-final.pdf">
          <front>
            <title>DICE Attestation Architecture</title>
            <author>
              <organization>Trusted Computing Group</organization>
            </author>
            <date year="2021" month="March"/>
          </front>
	  <refcontent>Version 1.00</refcontent>
	  <refcontent>Revision 0.23</refcontent>
	  
        </reference>

<!-- [I-D.birkholz-rats-tuda] IESG state I-D Exists -->

<xi:include href="https://datatracker.ietf.org/doc/bibxml3/reference.I-D.birkholz-rats-tuda.xml"/>


<!-- [I-D.birkholz-rats-uccs] Replaced by [I-D.ietf-rats-uccs]; the latter is also referenced in this document.-->

<xi:include href="https://datatracker.ietf.org/doc/bibxml3/reference.I-D.ietf-rats-uccs.xml"/>

<!-- [I-D.ietf-teep-architecture] IESG state Approved-announcement to be sent::Revised I-D Needed -->
<reference anchor='I-D.ietf-teep-architecture'>
<front>
<title>Trusted Execution Environment Provisioning (TEEP) Architecture</title>
<author initials='M' surname='Pei' fullname='Mingliang Pei'>
<organization />
</author>
<author initials='H' surname='Tschofenig' fullname='Hannes Tschofenig'>
<organization />
</author>
<author initials='D' surname='Thaler' fullname='Dave Thaler'>
<organization />
</author>
<author initials='D' surname='Wheeler' fullname='David Wheeler'>
<organization />
</author>
<date year='2022' month='October' day='24' />
</front>
<seriesInfo name='Internet-Draft' value='draft-ietf-teep-architecture-19'/>
</reference>




<!-- [I-D.ietf-rats-daa] IESG state I-D Exists -->

<xi:include href="https://datatracker.ietf.org/doc/bibxml3/reference.I-D.ietf-rats-daa.xml"/>

        <reference anchor="TCGarch" target="https://trustedcomputinggroup.org/wp-content/uploads/TCG_TPM2_r1p59_Part1_Architecture_pub.pdf">
          <front>
            <title>Trusted Platform Module Library, Part 1: Architecture</title>
            <author>
              <organization>Trusted Computing Group</organization>
            </author>
            <date year="2019" month="November"/>
          </front>
        </reference>

        <reference anchor="WebAuthN" target="https://www.w3.org/TR/webauthn-1/">
          <front>
            <title>Web Authentication: An API for accessing Public Key Credentials Level 1</title>
            <author>
              <organization>W3C</organization>
            </author>
            <date year="2019" month="March"/>
          </front>
        </reference>

        <reference anchor="CTAP" target="https://fidoalliance.org/specs/fido-v2.0-id-20180227/fido-client-to-authenticator-protocol-v2.0-id-20180227.html">
          <front>
            <title>Client to Authenticator Protocol (CTAP)</title>
            <author>
              <organization>FIDO Alliance</organization>
            </author>
            <date year="2018" month="February"/>
          </front>
        </reference>

        <reference anchor="strengthoffunction" target="https://csrc.nist.gov/glossary/term/strength_of_function">
          <front>
            <title>Strength of Function</title>
            <author>
              <organization>NIST</organization>
            </author>
          </front>
        </reference>


<reference anchor="CCC-DeepDive" target="https://confidentialcomputing.io/white-papers-reports">
          <front>
            <title>A Technical Analysis of Confidential Computing</title>
            <author>
              <organization>Confidential Computing Consortium</organization>
            </author>
            <date year="2022" month="November"/>
          </front>
	  <refcontent>Version 1.3</refcontent>
        </reference>

        <reference anchor="TCG-DICE-SIBDA" target="https://trustedcomputinggroup.org/wp-content/uploads/TCG_DICE_SymIDAttest_v1_r0p95_pub-1.pdf">
          <front>
            <title>Symmetric Identity Based Device Attestation</title>
            <author>
              <organization>Trusted Computing Group</organization>
            </author>
            <date year="2020" month="January"/>
          </front>
	  <refcontent>Version 1.0</refcontent>
	  <refcontent>Revision 0.95</refcontent>
        </reference>

        <reference anchor="NIST-800-57-p1" target="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57pt1r5.pdf">
          <front>
            <title>Recommendation for Key Management: Part 1 - General</title>
	    <seriesInfo name="DOI" value="10.6028/NIST.SP.800-57pt1r5"/>
            <author initials="E." surname="Barker" fullname="Elaine Barker">
              <organization>NIST</organization>
            </author>
            <date year="2020" month="May"/>
          </front>
        </reference>

<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6024.xml"/>

<!-- [I-D.tschofenig-rats-psa-token] IESG state	I-D Exists -->
<reference anchor='I-D.tschofenig-rats-psa-token'>
<front>
<title>Arm's Platform Security Architecture (PSA) Attestation Token</title>
<author initials='H' surname='Tschofenig' fullname='Hannes Tschofenig'>
<organization />
</author>
<author initials='S' surname='Frost' fullname='Simon Frost'>
<organization />
</author>
<author initials='M' surname='Brossard' fullname='Mathias Brossard'>
<organization />
</author>
<author initials='A' surname='Shaw' fullname='Adrian Shaw'>
<organization />
</author>
<author initials='T' surname='Fossati' fullname='Thomas Fossati'>
<organization />
</author>
<date year='2022' month='September' day='6' />
</front>
<seriesInfo name='Internet-Draft' value='draft-tschofenig-rats-psa-token-10'/>
</reference>




<!-- [I-D.tschofenig-tls-cwt] IESG state Expired -->

<xi:include href="https://datatracker.ietf.org/doc/bibxml3/reference.I-D.tschofenig-tls-cwt.xml"/>

<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4086.xml"/>

      </references>
    </references>
    
    <section anchor="time-considerations">
      <name>Time Considerations</name>
      <t><xref target="freshness"/> discussed various issues and requirements around freshness of Evidence and
summarized three approaches that might be used by different solutions to address them.
This appendix provides more details with examples to help illustrate potential approaches and inform those creating specific solutions.</t>
      <t>The table below defines a number of relevant events with an ID that
is used in subsequent diagrams.  The times of said events might be
defined in terms of an absolute clock time, such as the Coordinated Universal Time timescale,
or might be defined relative to some other timestamp or timeticks counter, such as a clock resetting its epoch each time it is powered on.</t>

<table>
  <name>Relevant Events over Time</name>
        <thead>
          <tr>
            <th align="left">ID</th>
            <th align="left">Event</th>
            <th align="left">Explanation of event</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="left">VG</td>
            <td align="left">Value generated</td>
            <td align="left">A value to appear in a Claim was created.  In some cases, a value may have technically existed before an Attester became aware of it, but the Attester might have no idea how long it has had that value.  In such a case, the value created time is the time at which the Claim containing the copy of the value was created.</td>
          </tr>
          <tr>
            <td align="left">NS</td>
            <td align="left">Nonce sent</td>
            <td align="left">A nonce not predictable to an Attester (recentness &amp; uniqueness) is sent to an Attester.</td>
          </tr>
          <tr>
            <td align="left">NR</td>
            <td align="left">Nonce relayed</td>
            <td align="left">A nonce is relayed to an Attester by another entity.</td>
          </tr>
          <tr>
            <td align="left">IR</td>
            <td align="left">Epoch ID received</td>
            <td align="left">An epoch ID is successfully received and processed by an entity.</td>
          </tr>
          <tr>
            <td align="left">EG</td>
            <td align="left">Evidence generation</td>
            <td align="left">An Attester creates Evidence from collected Claims.</td>
          </tr>
          <tr>
            <td align="left">ER</td>
            <td align="left">Evidence relayed</td>
            <td align="left">A Relying Party relays Evidence to a Verifier.</td>
          </tr>
          <tr>
            <td align="left">RG</td>
            <td align="left">Result generation</td>
            <td align="left">A Verifier appraises Evidence and generates an Attestation Result.</td>
          </tr>
          <tr>
            <td align="left">RR</td>
            <td align="left">Result relayed</td>
            <td align="left">A Relying Party relays an Attestation Result to a Relying Party.</td>
          </tr>
          <tr>
            <td align="left">RA</td>
            <td align="left">Result appraised</td>
            <td align="left">The Relying Party appraises Attestation Results.</td>
          </tr>
          <tr>
            <td align="left">OP</td>
            <td align="left">Operation performed</td>
            <td align="left">The Relying Party performs some operation requested by the Attester via a resource access protocol as depicted in <xref target="clientserver"/>, e.g., across a session created earlier at time(RA).</td>
          </tr>
          <tr>
            <td align="left">RX</td>
            <td align="left">Result expiry</td>
            <td align="left">An Attestation Result should no longer be accepted, according to the Verifier that generated it.</td>
          </tr>
        </tbody>
      </table>
      <t>Using the table above, a number of hypothetical examples of how a solution might be built are illustrated below.
This list is not intended to be complete;
it is just representative enough to highlight various timing considerations.</t>
      <t>All times are relative to the local clocks, indicated by an "_a" (Attester),
"_v" (Verifier), or "_r" (Relying Party) suffix.</t>
      <t>Times with an appended Prime (') indicate a second instance of the same event.</t>
      <t>How and if clocks are synchronized depends upon the model.</t>
      <t>In the figures below, curly braces indicate containment.
For example, the notation Evidence{foo} indicates that 'foo' is contained in the Evidence; thus, it is covered by its signature.</t>
      <section anchor="example-1-timestamp-based-passport-model-example">
        <name>Example 1: Timestamp-Based Passport Model</name>
        <t><xref target="timestamp-based-passport-model"/>
illustrates a hypothetical Passport Model
solution that uses timestamps and requires roughly synchronized
clocks between the Attester, Verifier, and Relying Party, which
depends on using a secure clock synchronization mechanism.
As a result, the receiver of a conceptual message containing a
timestamp can directly compare it to its own clock and timestamps.</t>
      <figure anchor="timestamp-based-passport-model">
        <name>Timestamp-Based Passport Model</name>
        <artset>
          <artwork type="svg"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="416" width="520" viewBox="0 0 520 416" class="diagram" text-anchor="middle" font-family="monospace" font-size="13px">
              <path d="M 8,32 L 8,64" fill="none" stroke="black"/>
              <path d="M 48,64 L 48,80" fill="none" stroke="black"/>
              <path d="M 48,176 L 48,272" fill="none" stroke="black"/>
              <path d="M 48,304 L 48,336" fill="none" stroke="black"/>
              <path d="M 48,368 L 48,384" fill="none" stroke="black"/>
              <path d="M 96,32 L 96,64" fill="none" stroke="black"/>
              <path d="M 272,32 L 272,64" fill="none" stroke="black"/>
              <path d="M 320,64 L 320,112" fill="none" stroke="black"/>
              <path d="M 320,144 L 320,208" fill="none" stroke="black"/>
              <path d="M 320,240 L 320,272" fill="none" stroke="black"/>
              <path d="M 360,32 L 360,64" fill="none" stroke="black"/>
              <path d="M 384,32 L 384,64" fill="none" stroke="black"/>
              <path d="M 448,64 L 448,112" fill="none" stroke="black"/>
              <path d="M 448,144 L 448,272" fill="none" stroke="black"/>
              <path d="M 512,32 L 512,64" fill="none" stroke="black"/>
              <path d="M 8,32 L 96,32" fill="none" stroke="black"/>
              <path d="M 272,32 L 360,32" fill="none" stroke="black"/>
              <path d="M 384,32 L 512,32" fill="none" stroke="black"/>
              <path d="M 8,64 L 96,64" fill="none" stroke="black"/>
              <path d="M 272,64 L 360,64" fill="none" stroke="black"/>
              <path d="M 384,64 L 512,64" fill="none" stroke="black"/>
              <path d="M 48,192 L 96,192" fill="none" stroke="black"/>
              <path d="M 264,192 L 312,192" fill="none" stroke="black"/>
              <path d="M 56,256 L 96,256" fill="none" stroke="black"/>
              <path d="M 248,256 L 320,256" fill="none" stroke="black"/>
              <path d="M 48,320 L 64,320" fill="none" stroke="black"/>
              <path d="M 400,320 L 416,320" fill="none" stroke="black"/>
              <polygon class="arrowhead" points="424,320 412,314.4 412,325.6 " fill="black" transform="rotate(0,416,320)"/>
              <polygon class="arrowhead" points="320,192 308,186.4 308,197.6 " fill="black" transform="rotate(0,312,192)"/>
              <polygon class="arrowhead" points="64,256 52,250.4 52,261.6 " fill="black" transform="rotate(180,56,256)"/>
              <g class="text">
                <text x="52" y="52">Attester</text>
                <text x="316" y="52">Verifier</text>
                <text x="424" y="52">Relying</text>
                <text x="480" y="52">Party</text>
                <text x="60" y="100">time(VG_a)</text>
                <text x="48" y="116">|</text>
                <text x="48" y="132">~</text>
                <text x="320" y="132">~</text>
                <text x="448" y="132">~</text>
                <text x="48" y="148">|</text>
                <text x="60" y="164">time(EG_a)</text>
                <text x="180" y="196">Evidence{time(EG_a)}</text>
                <text x="332" y="228">time(RG_v)</text>
                <text x="144" y="260">Attestation</text>
                <text x="220" y="260">Result</text>
                <text x="192" y="276">{time(RG_v),time(RX_v)}</text>
                <text x="48" y="292">~</text>
                <text x="448" y="292">~</text>
                <text x="448" y="308">|</text>
                <text x="112" y="324">Attestation</text>
                <text x="280" y="324">Result{time(RG_v),time(RX_v)}</text>
                <text x="468" y="324">time(RA_r)</text>
                <text x="448" y="340">|</text>
                <text x="48" y="356">~</text>
                <text x="448" y="356">~</text>
                <text x="448" y="372">|</text>
                <text x="460" y="388">time(OP_r)</text>
              </g>
            </svg>
          </artwork>
          <artwork type="ascii-art"><![CDATA[
   .----------.                     .----------.  .---------------.
   | Attester |                     | Verifier |  | Relying Party |
   '----+-----'                     '-----+----'  '-------+-------'
        |                                 |               |
     time(VG_a)                           |               |
        |                                 |               |
        ~                                 ~               ~
        |                                 |               |
     time(EG_a)                           |               |
        |                                 |               |
        +------Evidence{time(EG_a)}------>|               |
        |                                 |               |
        |                              time(RG_v)         |
        |                                 |               |
        |<-----Attestation Result---------+               |
        |      {time(RG_v),time(RX_v)}    |               |
        ~                                                 ~
        |                                                 |
        +--Attestation Result{time(RG_v),time(RX_v)}--> time(RA_r)
        |                                                 |
        ~                                                 ~
        |                                                 |
        |                                              time(OP_r)]]></artwork>
        </artset>
      </figure>
        <t>The Verifier can check whether the Evidence is fresh when appraising
it at time(RG_v) by checking <tt>time(RG_v) - time(EG_a) &lt; Threshold</tt>, where the
Verifier's threshold is large enough to account for the maximum
permitted clock skew between the Verifier and the Attester.</t>
        <t>If time(VG_a) is included in the Evidence along with the Claim value
generated at that time, and the Verifier decides that it can trust the
time(VG_a) value, the Verifier can also determine whether the Claim value is
recent by checking <tt>time(RG_v) - time(VG_a) &lt; Threshold</tt>.
The threshold is decided by the Appraisal Policy for Evidence and, again,  needs to take
into account the maximum permitted clock skew between
the Verifier and the Attester.</t>
        <t>The Attester does not consume the Attestation Result but might cache it.</t>
        <t>The Relying Party can check whether the Attestation Result is fresh
when appraising it at time(RA_r) by checking the <tt>time(RA_r) - time(RG_v) &lt; Threshold</tt>,
where the Relying Party's threshold is large enough to account for the
maximum permitted clock skew between the Relying Party and the Verifier.
The result might then be used for some time (e.g., throughout the lifetime
of a connection established at time(RA_r)).  However, the Relying Party must be
careful not to allow continued use beyond the period for which
it deems the Attestation Result to remain fresh enough.  Thus,
it might allow use (at time(OP_r)) as long as <tt>time(OP_r) - time(RG_v) &lt; Threshold</tt>.
However, if the Attestation Result contains an expiry time time(RX_v), then
it could explicitly check <tt>time(OP_r) &lt; time(RX_v)</tt>.</t>
</section>
      <section anchor="example-2-nonce-based-passport-model-example">
        <name>Example 2: Nonce-Based Passport Model</name>
        <t><xref target="nonce-based-passport-model"/> illustrates a hypothetical Passport Model
solution that uses nonces instead of timestamps.  Compared to the
timestamp-based example, it requires an extra round trip
to retrieve a nonce and requires that the Verifier and Relying Party
track state to remember the nonce for some period of time.</t>
        <t>The advantage is that it does not require that any clocks
are synchronized.
As a result, the receiver of a conceptual message containing a
timestamp cannot directly compare it to its own clock or timestamps.
Thus, we use a suffix ("a" for Attester, "v" for Verifier, and "r" for Relying Party) on the IDs below indicating which clock generated them since times from different clocks cannot be compared.
Only the delta between two events from the sender can be used by the receiver.</t>
      <figure anchor="nonce-based-passport-model">
        <name>Nonce-Based Passport Model</name>
        <artset>
          <artwork type="svg"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="544" width="536" viewBox="0 0 536 544" class="diagram" text-anchor="middle" font-family="monospace" font-size="13px">
              <path d="M 8,32 L 8,64" fill="none" stroke="black"/>
              <path d="M 48,64 L 48,80" fill="none" stroke="black"/>
              <path d="M 48,144 L 48,176" fill="none" stroke="black"/>
              <path d="M 48,208 L 48,320" fill="none" stroke="black"/>
              <path d="M 48,352 L 48,384" fill="none" stroke="black"/>
              <path d="M 48,416 L 48,464" fill="none" stroke="black"/>
              <path d="M 48,496 L 48,512" fill="none" stroke="black"/>
              <path d="M 96,32 L 96,64" fill="none" stroke="black"/>
              <path d="M 272,32 L 272,64" fill="none" stroke="black"/>
              <path d="M 320,64 L 320,112" fill="none" stroke="black"/>
              <path d="M 320,176 L 320,256" fill="none" stroke="black"/>
              <path d="M 320,288 L 320,320" fill="none" stroke="black"/>
              <path d="M 360,32 L 360,64" fill="none" stroke="black"/>
              <path d="M 384,32 L 384,64" fill="none" stroke="black"/>
              <path d="M 448,64 L 448,112" fill="none" stroke="black"/>
              <path d="M 448,144 L 448,320" fill="none" stroke="black"/>
              <path d="M 448,384 L 448,464" fill="none" stroke="black"/>
              <path d="M 512,32 L 512,64" fill="none" stroke="black"/>
              <path d="M 8,32 L 96,32" fill="none" stroke="black"/>
              <path d="M 272,32 L 360,32" fill="none" stroke="black"/>
              <path d="M 384,32 L 512,32" fill="none" stroke="black"/>
              <path d="M 8,64 L 96,64" fill="none" stroke="black"/>
              <path d="M 272,64 L 360,64" fill="none" stroke="black"/>
              <path d="M 384,64 L 512,64" fill="none" stroke="black"/>
              <path d="M 56,160 L 72,160" fill="none" stroke="black"/>
              <path d="M 128,160 L 288,160" fill="none" stroke="black"/>
              <path d="M 48,224 L 72,224" fill="none" stroke="black"/>
              <path d="M 144,224 L 312,224" fill="none" stroke="black"/>
              <path d="M 56,304 L 72,304" fill="none" stroke="black"/>
              <path d="M 224,304 L 320,304" fill="none" stroke="black"/>
              <path d="M 56,368 L 72,368" fill="none" stroke="black"/>
              <path d="M 128,368 L 416,368" fill="none" stroke="black"/>
              <path d="M 48,432 L 64,432" fill="none" stroke="black"/>
              <path d="M 424,432 L 440,432" fill="none" stroke="black"/>
              <polygon class="arrowhead" points="448,432 436,426.4 436,437.6 " fill="black" transform="rotate(0,440,432)"/>
              <polygon class="arrowhead" points="320,224 308,218.4 308,229.6 " fill="black" transform="rotate(0,312,224)"/>
              <polygon class="arrowhead" points="64,368 52,362.4 52,373.6 " fill="black" transform="rotate(180,56,368)"/>
              <polygon class="arrowhead" points="64,304 52,298.4 52,309.6 " fill="black" transform="rotate(180,56,304)"/>
              <polygon class="arrowhead" points="64,160 52,154.4 52,165.6 " fill="black" transform="rotate(180,56,160)"/>
              <g class="text">
                <text x="52" y="52">Attester</text>
                <text x="316" y="52">Verifier</text>
                <text x="424" y="52">Relying</text>
                <text x="480" y="52">Party</text>
                <text x="60" y="100">time(VG_a)</text>
                <text x="48" y="116">|</text>
                <text x="48" y="132">~</text>
                <text x="320" y="132">~</text>
                <text x="448" y="132">~</text>
                <text x="320" y="148">|</text>
                <text x="100" y="164">Nonce1</text>
                <text x="332" y="164">time(NS_v)</text>
                <text x="60" y="196">time(EG_a)</text>
                <text x="108" y="228">Evidence</text>
                <text x="92" y="244">{Nonce1,</text>
                <text x="220" y="244">time(EG_a)-time(VG_a)}</text>
                <text x="332" y="276">time(RG_v)</text>
                <text x="120" y="308">Attestation</text>
                <text x="196" y="308">Result</text>
                <text x="168" y="324">{time(RX_v)-time(RG_v)}</text>
                <text x="48" y="340">~</text>
                <text x="448" y="340">~</text>
                <text x="448" y="356">|</text>
                <text x="100" y="372">Nonce2</text>
                <text x="460" y="372">time(NS_r)</text>
                <text x="60" y="404">time(RR_a)</text>
                <text x="116" y="436">[Attestation</text>
                <text x="292" y="436">Result{time(RX_v)-time(RG_v)},</text>
                <text x="492" y="436">time(RA_r)</text>
                <text x="144" y="452">Nonce2,</text>
                <text x="268" y="452">time(RR_a)-time(EG_a)]</text>
                <text x="48" y="484">~</text>
                <text x="448" y="484">~</text>
                <text x="448" y="500">|</text>
                <text x="460" y="516">time(OP_r)</text>
              </g>
            </svg>
          </artwork>
          <artwork type="ascii-art"><![CDATA[
   .----------.                     .----------.  .---------------.
   | Attester |                     | Verifier |  | Relying Party |
   '----+-----'                     '-----+----'  '-------+-------'
        |                                 |               |
     time(VG_a)                           |               |
        |                                 |               |
        ~                                 ~               ~
        |                                 |               |
        |<--Nonce1---------------------time(NS_v)         |
        |                                 |               |
     time(EG_a)                           |               |
        |                                 |               |
        +---Evidence--------------------->|               |
        | {Nonce1, time(EG_a)-time(VG_a)} |               |
        |                                 |               |
        |                              time(RG_v)         |
        |                                 |               |
        |<--Attestation Result------------+               |
        |   {time(RX_v)-time(RG_v)}       |               |
        ~                                                 ~
        |                                                 |
        |<--Nonce2-------------------------------------time(NS_r)
        |                                                 |
     time(RR_a)                                           |
        |                                                 |
        +--[Attestation Result{time(RX_v)-time(RG_v)}, -->|time(RA_r)
        |        Nonce2, time(RR_a)-time(EG_a)]           |
        |                                                 |
        ~                                                 ~
        |                                                 |
        |                                              time(OP_r)]]></artwork>
        </artset>
      </figure>
        <t>In this example solution, the Verifier can check whether the Evidence is
fresh at <tt>time(RG_v)</tt> by verifying that <tt>time(RG_v)-time(NS_v) &lt; Threshold</tt>.</t>
        <t>However, the Verifier cannot simply rely on a Nonce to
determine whether the value of a Claim is recent since the Claim value
might have been generated long before the nonce was sent by the Verifier.
Nevertheless, if the Verifier decides that the Attester can be trusted to
correctly provide the delta <tt>time(EG_a)-time(VG_a)</tt>, then it can determine recency
by checking <tt>time(RG_v)-time(NS_v) + time(EG_a)-time(VG_a) &lt; Threshold</tt>.</t>

<t>Similarly if, based on an Attestation Result from a Verifier it trusts, the
Relying Party decides that the Attester can be trusted to correctly provide
time deltas, then it can determine whether the Attestation Result is fresh by
checking <tt>time(OP_r)-time(NS_r) + time(RR_a)-time(EG_a) &lt;
Threshold</tt>.  Although the Nonce2 and <tt>time(RR_a)-time(EG_a)</tt> values
cannot be inside the Attestation Result, they might be signed by the Attester
such that the Attestation Result vouches for the Attester's signing
capability.</t>
        <t>However, the Relying Party must still be careful not to allow continued
use beyond the period for which it deems the Attestation Result to remain
valid.  Thus, if the Attestation Result sends a validity lifetime
in terms of <tt>time(RX_v)-time(RG_v)</tt>, then the Relying Party can check
<tt>time(OP_r)-time(NS_r) &lt; time(RX_v)-time(RG_v)</tt>.</t>
      </section>
      <section anchor="example-3-epoch-id-based-passport-model-example">
        <name>Example 3: Passport Model Based on Epoch ID</name>
        <t>The example in <xref target="fig-epochid-passport"/> illustrates a hypothetical Passport Model
solution that uses epoch IDs instead of nonces or timestamps.</t>
        <t>The epoch ID distributor broadcasts epoch ID <tt>I</tt>, which starts a new
epoch <tt>E</tt> for a protocol participant upon reception at <tt>time(IR)</tt>.</t>
        <t>The Attester generates Evidence incorporating epoch ID <tt>I</tt> and conveys it to the
	Verifier.</t>
	
        <t>The Verifier appraises that the received epoch ID <tt>I</tt> is "fresh" according to the
definition provided in <xref target="epochfreshness"/> whereby retries are required in the case of mismatching epoch IDs; then the Verifier generates an Attestation Result.  The
Attestation Result is conveyed to the Attester.</t>
        <t>After the transmission of epoch ID <tt>I'</tt> a new epoch <tt>E'</tt> is
established when <tt>I'</tt> is received by each protocol participant.  The Attester
relays the Attestation Result obtained during epoch <tt>E</tt> (associated with epoch ID
<tt>I</tt>) to the Relying Party using the epoch ID for the current epoch <tt>I'</tt>.
If the Relying Party had not yet received <tt>I'</tt>, then the Attestation Result would be rejected. The Attestation Result is received in this example.</t>
        <t>In <xref target ="fig-epochid-passport"/>, the epoch ID for relaying an Attestation Result to the Relying Party is current while a previous epoch ID was used to generate Verifier evaluated Evidence.
This indicates that at least one epoch transition has occurred and the Attestation Results may only be as fresh as the previous epoch.
If the Relying Party remembers the previous epoch ID <tt>I</tt> during an epoch window
as discussed in <xref target="epochfreshness"/>, and the message is received during
that window, the Attestation Result is accepted as fresh; otherwise, it is
rejected as stale.</t>
        <figure anchor="fig-epochid-passport">
          <name>Epoch ID-Based Passport Model</name>
          <artset>
            <artwork type="svg"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="512" width="520" viewBox="0 0 520 512" class="diagram" text-anchor="middle" font-family="monospace" font-size="13px">
                <path d="M 8,48 L 8,80" fill="none" stroke="black"/>
                <path d="M 48,80 L 48,96" fill="none" stroke="black"/>
                <path d="M 48,224 L 48,352" fill="none" stroke="black"/>
                <path d="M 48,384 L 48,432" fill="none" stroke="black"/>
                <path d="M 48,464 L 48,480" fill="none" stroke="black"/>
                <path d="M 96,48 L 96,80" fill="none" stroke="black"/>
                <path d="M 128,32 L 128,80" fill="none" stroke="black"/>
                <path d="M 184,80 L 184,232" fill="none" stroke="black"/>
                <path d="M 184,264 L 184,304" fill="none" stroke="black"/>
                <path d="M 184,344 L 184,368" fill="none" stroke="black"/>
                <path d="M 240,32 L 240,80" fill="none" stroke="black"/>
                <path d="M 272,48 L 272,80" fill="none" stroke="black"/>
                <path d="M 320,80 L 320,128" fill="none" stroke="black"/>
                <path d="M 320,192 L 320,272" fill="none" stroke="black"/>
                <path d="M 320,304 L 320,352" fill="none" stroke="black"/>
                <path d="M 320,408 L 320,432" fill="none" stroke="black"/>
                <path d="M 320,464 L 320,480" fill="none" stroke="black"/>
                <path d="M 360,48 L 360,80" fill="none" stroke="black"/>
                <path d="M 384,48 L 384,80" fill="none" stroke="black"/>
                <path d="M 448,80 L 448,128" fill="none" stroke="black"/>
                <path d="M 448,192 L 448,352" fill="none" stroke="black"/>
                <path d="M 448,416 L 448,432" fill="none" stroke="black"/>
                <path d="M 512,48 L 512,80" fill="none" stroke="black"/>
                <path d="M 128,32 L 240,32" fill="none" stroke="black"/>
                <path d="M 8,48 L 96,48" fill="none" stroke="black"/>
                <path d="M 272,48 L 360,48" fill="none" stroke="black"/>
                <path d="M 384,48 L 512,48" fill="none" stroke="black"/>
                <path d="M 8,80 L 96,80" fill="none" stroke="black"/>
                <path d="M 128,80 L 240,80" fill="none" stroke="black"/>
                <path d="M 272,80 L 360,80" fill="none" stroke="black"/>
                <path d="M 384,80 L 512,80" fill="none" stroke="black"/>
                <path d="M 112,176 L 152,176" fill="none" stroke="black"/>
                <path d="M 168,176 L 176,176" fill="none" stroke="black"/>
                <path d="M 192,176 L 200,176" fill="none" stroke="black"/>
                <path d="M 216,176 L 264,176" fill="none" stroke="black"/>
                <path d="M 368,176 L 392,176" fill="none" stroke="black"/>
                <path d="M 48,240 L 72,240" fill="none" stroke="black"/>
                <path d="M 144,240 L 312,240" fill="none" stroke="black"/>
                <path d="M 56,320 L 72,320" fill="none" stroke="black"/>
                <path d="M 224,320 L 320,320" fill="none" stroke="black"/>
                <path d="M 120,368 L 152,368" fill="none" stroke="black"/>
                <path d="M 192,368 L 200,368" fill="none" stroke="black"/>
                <path d="M 232,368 L 264,368" fill="none" stroke="black"/>
                <path d="M 376,368 L 392,368" fill="none" stroke="black"/>
                <path d="M 48,400 L 72,400" fill="none" stroke="black"/>
                <path d="M 232,400 L 392,400" fill="none" stroke="black"/>
                <polygon class="arrowhead" points="400,400 388,394.4 388,405.6 " fill="black" transform="rotate(0,392,400)"/>
                <polygon class="arrowhead" points="400,368 388,362.4 388,373.6 " fill="black" transform="rotate(0,392,368)"/>
                <polygon class="arrowhead" points="400,176 388,170.4 388,181.6 " fill="black" transform="rotate(0,392,176)"/>
                <polygon class="arrowhead" points="320,240 308,234.4 308,245.6 " fill="black" transform="rotate(0,312,240)"/>
                <polygon class="arrowhead" points="272,368 260,362.4 260,373.6 " fill="black" transform="rotate(0,264,368)"/>
                <polygon class="arrowhead" points="272,176 260,170.4 260,181.6 " fill="black" transform="rotate(0,264,176)"/>
                <polygon class="arrowhead" points="128,368 116,362.4 116,373.6 " fill="black" transform="rotate(180,120,368)"/>
                <polygon class="arrowhead" points="120,176 108,170.4 108,181.6 " fill="black" transform="rotate(180,112,176)"/>
                <polygon class="arrowhead" points="64,320 52,314.4 52,325.6 " fill="black" transform="rotate(180,56,320)"/>
                <circle cx="184" cy="176" r="6" class="opendot" fill="white" stroke="black"/>
                <circle cx="184" cy="368" r="6" class="opendot" fill="white" stroke="black"/>
                <g class="text">
                  <text x="160" y="52">Epoch</text>
                  <text x="196" y="52">ID</text>
                  <text x="52" y="68">Attester</text>
                  <text x="184" y="68">Distributor</text>
                  <text x="316" y="68">Verifier</text>
                  <text x="424" y="68">Relying</text>
                  <text x="480" y="68">Party</text>
                  <text x="60" y="116">time(VG_a)</text>
                  <text x="48" y="132">|</text>
                  <text x="48" y="148">~</text>
                  <text x="320" y="148">~</text>
                  <text x="448" y="148">~</text>
                  <text x="48" y="164">|</text>
                  <text x="320" y="164">|</text>
                  <text x="448" y="164">|</text>
                  <text x="60" y="180">time(IR_a)</text>
                  <text x="160" y="180">I</text>
                  <text x="208" y="180">I</text>
                  <text x="316" y="180">time(IR_v)</text>
                  <text x="444" y="180">time(IR_r)</text>
                  <text x="48" y="196">|</text>
                  <text x="60" y="212">time(EG_a)</text>
                  <text x="108" y="244">Evidence</text>
                  <text x="176" y="260">{I,time(EG_a)-time(VG_a)}</text>
                  <text x="316" y="292">time(RG_v)</text>
                  <text x="120" y="324">Attestation</text>
                  <text x="196" y="324">Result</text>
                  <text x="176" y="340">{I,time(RX_v)-time(RG_v)}</text>
                  <text x="64" y="372">time(IR'_a)</text>
                  <text x="168" y="372">I'-</text>
                  <text x="212" y="372">I'</text>
                  <text x="320" y="372">time(IR'_v)</text>
                  <text x="448" y="372">time(IR'_r)</text>
                  <text x="320" y="388">|</text>
                  <text x="448" y="388">|</text>
                  <text x="124" y="404">[Attestation</text>
                  <text x="204" y="404">Result</text>
                  <text x="444" y="404">time(RA_r)</text>
                  <text x="192" y="420">{I,time(RX_v)-time(RG_v)},I']</text>
                  <text x="48" y="452">~</text>
                  <text x="320" y="452">~</text>
                  <text x="448" y="452">~</text>
                  <text x="448" y="468">|</text>
                  <text x="444" y="484">time(OP_r)</text>
                </g>
              </svg>
            </artwork>
            <artwork type="ascii-art"><![CDATA[
                  .-------------.
   .----------.   | Epoch ID    |   .----------.  .---------------.
   | Attester |   | Distributor |   | Verifier |  | Relying Party |
   '----+-----'   '------+------'   '-----+----'  '-------+-------'
        |                |                |               |
     time(VG_a)          |                |               |
        |                |                |               |
        ~                |                ~               ~
        |                |                |               |
     time(IR_a) <-----I--o--I------> time(IR_v) ---> time(IR_r)
        |                |                |               |
     time(EG_a)          |                |               |
        |                |                |               |
        +---Evidence--------------------->|               |
        |   {I,time(EG_a)-time(VG_a)}     |               |
        |                |                |               |
        |                |           time(RG_v)           |
        |                |                |               |
        |<--Attestation Result------------+               |
        |   {I,time(RX_v)-time(RG_v)}     |               |
        |                |                |               |
     time(IR'_a) <----I'-o--I' ----> time(IR'_v) --> time(IR'_r)
        |                                 |               |
        +---[Attestation Result--------------------> time(RA_r)
        |   {I,time(RX_v)-time(RG_v)},I'] |               |
        |                                 |               |
        ~                                 ~               ~
        |                                 |               |
        |                                 |          time(OP_r)]]></artwork>
          </artset>
        </figure>
      </section>
      <section anchor="example-4-timestamp-based-background-check-model-example">
        <name>Example 4: Timestamp-Based Background-Check Model</name>
        <t><xref target="timestamp-based-bg-check-model"/> illustrates a hypothetical Background-Check Model
solution that uses timestamps and requires roughly synchronized
clocks between the Attester, Verifier, and Relying Party.
The Attester conveys Evidence to the Relying Party, which treats it as opaque and simply forwards it on to the Verifier.</t>
      <figure anchor="timestamp-based-bg-check-model">
        <name>Timestamp-Based Background-Check Model</name>
        <artset>
          <artwork type="svg"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="368" width="568" viewBox="0 0 568 368" class="diagram" text-anchor="middle" font-family="monospace" font-size="13px">
              <path d="M 8,32 L 8,64" fill="none" stroke="black"/>
              <path d="M 72,64 L 72,80" fill="none" stroke="black"/>
              <path d="M 72,104 L 72,112" fill="none" stroke="black"/>
              <path d="M 72,168 L 72,304" fill="none" stroke="black"/>
              <path d="M 72,336 L 72,352" fill="none" stroke="black"/>
              <path d="M 96,32 L 96,64" fill="none" stroke="black"/>
              <path d="M 176,32 L 176,64" fill="none" stroke="black"/>
              <path d="M 240,64 L 240,112" fill="none" stroke="black"/>
              <path d="M 240,144 L 240,208" fill="none" stroke="black"/>
              <path d="M 240,240 L 240,272" fill="none" stroke="black"/>
              <path d="M 304,32 L 304,64" fill="none" stroke="black"/>
              <path d="M 472,32 L 472,64" fill="none" stroke="black"/>
              <path d="M 512,64 L 512,112" fill="none" stroke="black"/>
              <path d="M 512,144 L 512,240" fill="none" stroke="black"/>
              <path d="M 512,272 L 512,304" fill="none" stroke="black"/>
              <path d="M 512,336 L 512,352" fill="none" stroke="black"/>
              <path d="M 560,32 L 560,64" fill="none" stroke="black"/>
              <path d="M 8,32 L 96,32" fill="none" stroke="black"/>
              <path d="M 176,32 L 304,32" fill="none" stroke="black"/>
              <path d="M 472,32 L 560,32" fill="none" stroke="black"/>
              <path d="M 8,64 L 96,64" fill="none" stroke="black"/>
              <path d="M 176,64 L 304,64" fill="none" stroke="black"/>
              <path d="M 472,64 L 560,64" fill="none" stroke="black"/>
              <path d="M 72,192 L 104,192" fill="none" stroke="black"/>
              <path d="M 176,192 L 232,192" fill="none" stroke="black"/>
              <path d="M 288,224 L 304,224" fill="none" stroke="black"/>
              <path d="M 472,224 L 504,224" fill="none" stroke="black"/>
              <path d="M 288,288 L 312,288" fill="none" stroke="black"/>
              <path d="M 464,288 L 512,288" fill="none" stroke="black"/>
              <polygon class="arrowhead" points="512,224 500,218.4 500,229.6 " fill="black" transform="rotate(0,504,224)"/>
              <polygon class="arrowhead" points="296,288 284,282.4 284,293.6 " fill="black" transform="rotate(180,288,288)"/>
              <polygon class="arrowhead" points="240,192 228,186.4 228,197.6 " fill="black" transform="rotate(0,232,192)"/>
              <g class="text">
                <text x="52" y="52">Attester</text>
                <text x="216" y="52">Relying</text>
                <text x="272" y="52">Party</text>
                <text x="516" y="52">Verifier</text>
                <text x="60" y="100">time(VG_a)</text>
                <text x="72" y="132">~</text>
                <text x="240" y="132">~</text>
                <text x="512" y="132">~</text>
                <text x="72" y="148">|</text>
                <text x="60" y="164">time(EG_a)</text>
                <text x="140" y="196">Evidence</text>
                <text x="148" y="212">{time(EG_a)}</text>
                <text x="236" y="228">time(ER_r)</text>
                <text x="388" y="228">Evidence{time(EG_a)}</text>
                <text x="508" y="260">time(RG_v)</text>
                <text x="236" y="292">time(RA_r)</text>
                <text x="360" y="292">Attestation</text>
                <text x="436" y="292">Result</text>
                <text x="240" y="308">|</text>
                <text x="380" y="308">{time(RX_v)}</text>
                <text x="72" y="324">~</text>
                <text x="240" y="324">~</text>
                <text x="512" y="324">~</text>
                <text x="240" y="340">|</text>
                <text x="252" y="356">time(OP_r)</text>
              </g>
            </svg>
          </artwork>
          <artwork type="ascii-art"><![CDATA[
.----------.         .---------------.                    .----------.
| Attester |         | Relying Party |                    | Verifier |
'-------+--'         '-------+-------'                    '----+-----'
        |                    |                                 |
  time(VG_a)                 |                                 |
        |                    |                                 |
        ~                    ~                                 ~
        |                    |                                 |
  time(EG_a)                 |                                 |
        |                    |                                 |
        +----Evidence------->|                                 |
        |   {time(EG_a)}     |                                 |
        |               time(ER_r) ---Evidence{time(EG_a)}---->|
        |                    |                                 |
        |                    |                            time(RG_v)
        |                    |                                 |
        |               time(RA_r) <---Attestation Result------+
        |                    |           {time(RX_v)}          |
        ~                    ~                                 ~
        |                    |                                 |
        |                 time(OP_r)                           |]]></artwork>
        </artset>
      </figure>
        <t>The time considerations in this example are equivalent to those
discussed under <xref target="example-1-timestamp-based-passport-model-example" format="none">Example 1</xref>.</t>
      </section>
      <section anchor="example-5-nonce-based-background-check-model-example">
        <name>Example 5: Nonce-Based Background-Check Model</name>
        <t><xref target="nonce-based-bg-check-model"/> illustrates a hypothetical Background-Check Model
solution that uses nonces; thus, it does not require that any clocks
be synchronized.
In this example solution, a nonce is generated by a Verifier at the request of a Relying Party when the Relying Party needs to send one to an Attester.</t>
      <figure anchor="nonce-based-bg-check-model">
        <name>Nonce-Based Background-Check Model</name>
        <artset>
          <artwork type="svg"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="432" width="536" viewBox="0 0 536 432" class="diagram" text-anchor="middle" font-family="monospace" font-size="13px">
              <path d="M 8,32 L 8,64" fill="none" stroke="black"/>
              <path d="M 48,64 L 48,80" fill="none" stroke="black"/>
              <path d="M 48,144 L 48,208" fill="none" stroke="black"/>
              <path d="M 48,240 L 48,368" fill="none" stroke="black"/>
              <path d="M 48,400 L 48,416" fill="none" stroke="black"/>
              <path d="M 96,32 L 96,64" fill="none" stroke="black"/>
              <path d="M 176,32 L 176,64" fill="none" stroke="black"/>
              <path d="M 240,64 L 240,112" fill="none" stroke="black"/>
              <path d="M 240,144 L 240,176" fill="none" stroke="black"/>
              <path d="M 240,208 L 240,272" fill="none" stroke="black"/>
              <path d="M 240,304 L 240,336" fill="none" stroke="black"/>
              <path d="M 304,32 L 304,64" fill="none" stroke="black"/>
              <path d="M 440,32 L 440,64" fill="none" stroke="black"/>
              <path d="M 480,64 L 480,112" fill="none" stroke="black"/>
              <path d="M 480,176 L 480,304" fill="none" stroke="black"/>
              <path d="M 480,336 L 480,368" fill="none" stroke="black"/>
              <path d="M 480,400 L 480,416" fill="none" stroke="black"/>
              <path d="M 528,32 L 528,64" fill="none" stroke="black"/>
              <path d="M 8,32 L 96,32" fill="none" stroke="black"/>
              <path d="M 176,32 L 304,32" fill="none" stroke="black"/>
              <path d="M 440,32 L 528,32" fill="none" stroke="black"/>
              <path d="M 8,64 L 96,64" fill="none" stroke="black"/>
              <path d="M 176,64 L 304,64" fill="none" stroke="black"/>
              <path d="M 440,64 L 528,64" fill="none" stroke="black"/>
              <path d="M 248,160 L 304,160" fill="none" stroke="black"/>
              <path d="M 352,160 L 432,160" fill="none" stroke="black"/>
              <path d="M 56,192 L 80,192" fill="none" stroke="black"/>
              <path d="M 128,192 L 208,192" fill="none" stroke="black"/>
              <path d="M 48,256 L 80,256" fill="none" stroke="black"/>
              <path d="M 208,256 L 232,256" fill="none" stroke="black"/>
              <path d="M 304,288 L 320,288" fill="none" stroke="black"/>
              <path d="M 448,288 L 472,288" fill="none" stroke="black"/>
              <path d="M 288,352 L 312,352" fill="none" stroke="black"/>
              <path d="M 464,352 L 480,352" fill="none" stroke="black"/>
              <polygon class="arrowhead" points="480,288 468,282.4 468,293.6 " fill="black" transform="rotate(0,472,288)"/>
              <polygon class="arrowhead" points="296,352 284,346.4 284,357.6 " fill="black" transform="rotate(180,288,352)"/>
              <polygon class="arrowhead" points="256,160 244,154.4 244,165.6 " fill="black" transform="rotate(180,248,160)"/>
              <polygon class="arrowhead" points="240,256 228,250.4 228,261.6 " fill="black" transform="rotate(0,232,256)"/>
              <polygon class="arrowhead" points="64,192 52,186.4 52,197.6 " fill="black" transform="rotate(180,56,192)"/>
              <g class="text">
                <text x="52" y="52">Attester</text>
                <text x="216" y="52">Relying</text>
                <text x="272" y="52">Party</text>
                <text x="484" y="52">Verifier</text>
                <text x="60" y="100">time(VG_a)</text>
                <text x="48" y="116">|</text>
                <text x="48" y="132">~</text>
                <text x="240" y="132">~</text>
                <text x="480" y="132">~</text>
                <text x="480" y="148">|</text>
                <text x="328" y="164">Nonce</text>
                <text x="476" y="164">time(NS_v)</text>
                <text x="104" y="196">Nonce</text>
                <text x="252" y="196">time(NR_r)</text>
                <text x="60" y="228">time(EG_a)</text>
                <text x="144" y="260">Evidence{Nonce}</text>
                <text x="252" y="292">time(ER_r)</text>
                <text x="384" y="292">Evidence{Nonce}</text>
                <text x="492" y="324">time(RG_v)</text>
                <text x="240" y="356">time(RA_r)</text>
                <text x="360" y="356">Attestation</text>
                <text x="436" y="356">Result</text>
                <text x="240" y="372">|</text>
                <text x="368" y="372">{time(RX_v)-time(RG_v)}</text>
                <text x="48" y="388">~</text>
                <text x="240" y="388">~</text>
                <text x="480" y="388">~</text>
                <text x="240" y="404">|</text>
                <text x="252" y="420">time(OP_r)</text>
              </g>
            </svg>
          </artwork>
          <artwork type="ascii-art"><![CDATA[
.----------.         .---------------.                .----------.
| Attester |         | Relying Party |                | Verifier |
'----+-----'         '-------+-------'                '----+-----'
     |                       |                             |
  time(VG_a)                 |                             |
     |                       |                             |
     ~                       ~                             ~
     |                       |                             |
     |                       |<-------Nonce-----------time(NS_v)
     |                       |                             |
     |<---Nonce-----------time(NR_r)                       |
     |                       |                             |
  time(EG_a)                 |                             |
     |                       |                             |
     +----Evidence{Nonce}--->|                             |
     |                       |                             |
     |                    time(ER_r) ---Evidence{Nonce}--->|
     |                       |                             |
     |                       |                          time(RG_v)
     |                       |                             |
     |                  time(RA_r) <---Attestation Result--+
     |                       |    {time(RX_v)-time(RG_v)}  |
     ~                       ~                             ~
     |                       |                             |
     |                    time(OP_r)                       |]]></artwork>
        </artset>
      </figure>
        <t>The Verifier can check whether the Evidence is fresh and a Claim
value is recent, which is the same as <xref target="example-2-nonce-based-passport-model-example" format="none">Example 2</xref>.</t>
        <t>However, unlike in  <xref target="example-2-nonce-based-passport-model-example" format="none">Example 2</xref>, the Relying
        Party can use the Nonce to determine whether the Attestation Result is
        fresh by verifying that <tt>time(OP_r)-time(NR_r) &lt;
        Threshold</tt>.</t>
        <t>However, the Relying Party must still be careful not to allow continued
use beyond the period for which it deems the Attestation Result to remain
valid.  Thus, if the Attestation Result sends a validity lifetime
in terms of <tt>time(RX_v)-time(RG_v)</tt>, then the Relying Party can check
<tt>time(OP_r)-time(ER_r) &lt; time(RX_v)-time(RG_v)</tt>.</t>
      </section>
    </section>
 <section title="Acknowledgments" numbered="false" toc="include">
   <t>The authors would like to thank the following people for their input:</t>

 <t><contact fullname="Joerg Borchert"/>, <contact fullname="Carsten Bormann"/>, <contact fullname="Nancy Cam-Winget"/>, <contact fullname="Guy Fedorkow"/>, <contact fullname="Jessica Fitzgerald-McKay"/>, <contact fullname="Thomas Fossati"/>, <contact fullname="Simon Frost"/>, <contact fullname="Andrew Guinn"/>, <contact fullname="Thomas Hardjano"/>, <contact fullname="Eliot Lear"/>, <contact fullname="Diego Lopez"/>, <contact fullname="Peter Loscocco"/>, <contact fullname="Laurence Lundblade"/>, <contact fullname="Giri Mandyam"/>, <contact fullname="Daniel Migault"/>, <contact fullname="Kathleen Moriarty"/>, <contact fullname="Paul Rowe"/>, <contact fullname="Hannes Tschofenig"/>, <contact fullname="Eric Voit"/>, <contact fullname="Monty Wiseman"/>, <contact fullname="David Wooten"/>, and <contact fullname="Liang Xia"/>. </t>
   </section>

   <section anchor="contributors" numbered="false" toc="include" removeInRFC="false">
     <name>Contributors</name>
     <t><contact fullname="Thomas Hardjono"/> created initial versions of the
     terminology section in collaboration with <contact fullname="Ned
     Smith"/>. <contact fullname="Eric Voit"/> provided the conceptual
     separation between Attestation Provision Flows and Attestation Evidence
     Flows.
     <contact fullname="Monty Wisemen"/> was a key author of a document that was merged to create
     this document.
     <contact fullname="Carsten Bormann"/> provided many of the motivational building
     blocks with respect to the Internet Threat Model.</t>
     <t><contact fullname="Peter Loscocco"/> contributed critical review
     feedback as part of the weekly design team meetings that added precision
     and depth to several sections.</t>
</section>   
  </back>
</rfc>
