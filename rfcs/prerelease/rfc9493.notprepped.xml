<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>

<rfc xmlns:xi="http://www.w3.org/2001/XInclude" ipr="trust200902" docName="draft-ietf-secevent-subject-identifiers-18" number="9493" submissionType="IETF" category="std" consensus="true" tocInclude="true" sortRefs="true" symRefs="true" updates="" obsoletes="" xml:lang="en" version="3">

  <front>
    <title abbrev="Security Event Subject Identifiers">Subject Identifiers for
    Security Event Tokens</title>
    <seriesInfo name="RFC" value="9493"/>
    <author initials="A." surname="Backman" fullname="Annabelle Backman" role="editor">
      <organization>Amazon</organization>
      <address>
        <email>richanna@amazon.com</email>
      </address>
    </author>
    <author initials="M." surname="Scurtescu" fullname="Marius Scurtescu">
      <organization>Coinbase</organization>
      <address>
        <email>marius.scurtescu@coinbase.com</email>
      </address>
    </author>
    <author initials="P." surname="Jain" fullname="Prachi Jain">
      <organization>Fastly</organization>
      <address>
        <email>prachi.jain1288@gmail.com</email>
      </address>
    </author>
    <date year="2023" month="December"/>
    <area>Security</area>
    <workgroup>Security Events</workgroup>

    <keyword>jwt</keyword>

    <abstract>
      <t>Security events communicated within Security Event Tokens may support
      a variety of identifiers to identify subjects related to the event.
      This specification formalizes the notion of Subject Identifiers as
      structured information that describes a subject and named formats that
      define the syntax and semantics for encoding Subject Identifiers as JSON
      objects.  It also establishes a registry for defining and allocating
      names for such formats as well as the JSON Web Token (JWT) "sub_id"
      Claim.</t>
    </abstract>
  </front>
  <middle>
    <section anchor="intro">
      <name>Introduction</name>
      <t>As described in <xref target="RFC8417" sectionFormat="of"
      section="1.2"/> ("<xref target="RFC8417" format="title"/>"), subjects
      related to security events may take a variety of forms, including but
      not limited to a JWT <xref target="RFC7519"/> principal, an IP address,
      a URL, etc.  Different types of subjects may need to be identified in
      different ways (e.g., a user might be identified by an email address,
      a phone number, or an account number).  Furthermore, even in the case
      where the type of the subject is known, there may be multiple ways by
      which a given subject may be identified.  For example, an account may be
      identified by an opaque identifier, an email address, a phone number, a
      JWT "iss" Claim and "sub" Claim, etc., depending on the nature and needs
      of the transmitter and receiver. Even within the context of a given
      transmitter and receiver relationship, it may be appropriate to identify
      different accounts in different ways, for example, if some accounts only
      have email addresses associated with them while others only have phone
      numbers. Therefore, it can be necessary to indicate within a SET the
      mechanism by which a subject is being identified.</t>
      <t>To address this problem, this specification defines Subject
      Identifiers as JSON <xref target="RFC8259"/> objects containing
      information identifying a subject and defines Identifier Formats as named
      sets of rules describing how to encode different kinds of
      subject-identifying information (e.g., an email address or an issuer and
      subject pair) as a Subject Identifier.</t>
      <t>Below is a non-normative example of a Subject Identifier that
      identifies a subject by email address, using the Email Identifier
      Format.</t>

      <figure anchor="figexampleintro">
        <name>Example: Subject Identifier Using the Email Identifier Format</name>

        <sourcecode type="json"><![CDATA[{
  "format": "email",
  "email": "user@example.com"
}]]></sourcecode>
      </figure>

      <t>Subject Identifiers are intended to be a general-purpose mechanism for identifying subjects within JSON objects, and their usage need not be limited to SETs.  Below is a non-normative example of a JWT that uses a Subject Identifier in the JWT "sub_id" Claim (defined in this specification) to identify the JWT Subject.</t>
      <figure anchor="figexampleintro2">
        <name>Example: JWT Using a Subject Identifier with the JWT "sub_id" Claim</name>
        <sourcecode type="json"><![CDATA[{
  "iss": "issuer.example.com",
  "sub_id": {
    "format": "phone_number",
    "phone_number": "+12065550100"
  }
}]]></sourcecode>
      </figure>
      <t>Usage of Subject Identifiers also need not be limited to identifying JWT Subjects.  They are intended as a general-purpose means of expressing identifying information in an unambiguous manner.  Below is a non-normative example of a SET containing a hypothetical security event describing the interception of a message, using Subject Identifiers to identify the sender, intended recipient, and interceptor.</t>
      <figure anchor="figexampleintro3">
        <name>Example: SET with an Event Payload Containing Multiple Subject Identifiers</name>
        <sourcecode type="json"><![CDATA[{
  "iss": "issuer.example.com",
  "iat": 1508184845,
  "aud": "aud.example.com",
  "events": {
    "https://secevent.example.com/events/message-interception": {
      "from": {
        "format": "email",
        "email": "alice@example.com"
      },
      "to": {
        "format": "email",
        "email": "bob@example.com"
      },
      "interceptor": {
        "format": "email",
        "email": "eve@example.com"
      }
    }
  }
}]]></sourcecode>
      </figure>
    </section>
    <section anchor="conv">
      <name>Notational Conventions</name>
        <t>
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>",
    "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL
    NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>",
    "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are
    to be interpreted as described in BCP&nbsp;14 <xref target="RFC2119"/>
    <xref target="RFC8174"/> when, and only when, they appear in all capitals,
    as shown here.
        </t>

      <section anchor="defn">
        <name>Definitions</name>
        <t>This specification utilizes terminology defined in <xref target="RFC8259"/> and <xref target="RFC8417"/>.</t>
        <t>Within this specification, the terms "Subject" and "subject" refer generically to anything being identified via one or more pieces of information.  The term "JWT Subject" refers specifically to the subject of a JWT (i.e., the subject that the JWT asserts claims about).</t>
      </section>
    </section>
    <section anchor="sub-ids">
      <name>Subject Identifiers</name>
      <t>A Subject Identifier is a JSON object <xref target="RFC8259"/> whose
      contents may be used to identify a subject within some context.  An
      Identifier Format is a named definition of a set of information that may
      be used to identify a subject and the rules for encoding that
      information as a Subject Identifier; these rules define the syntax and
      semantics of Subject Identifiers.  A Subject Identifier
      <bcp14>MUST</bcp14> conform to a specific Identifier Format and
      <bcp14>MUST</bcp14> contain a "format" member whose value is the name of
      that Identifier Format.</t>
      <t>Every Identifier Format <bcp14>MUST</bcp14> have a unique name
      registered in the IANA "Security Event Identifier Formats" registry
      established in <xref target="iana-formats"/> or a Collision-Resistant
      Name as defined in <xref target="RFC7519"/>.  Identifier Formats that
      are expected to be used broadly by a variety of parties
      <bcp14>SHOULD</bcp14> be registered in the "Security Event Identifier
      Formats" registry.</t>
      <t>An Identifier Format <bcp14>MAY</bcp14> describe more members than
      are strictly necessary to identify a subject and <bcp14>MAY</bcp14>
      describe conditions under which those members are required, optional, or
      prohibited.  The "format" member is reserved for use as described in
      this specification; Identifier Formats <bcp14>MUST NOT</bcp14> declare
      any rules regarding the "format" member.</t>
      <t>Every member within a Subject Identifier <bcp14>MUST</bcp14> match
      the rules specified for that member by this specification or by a Subject
      Identifier's Identifier Format.  A Subject Identifier <bcp14>MUST
      NOT</bcp14> contain any members prohibited or not described by its
      Identifier Format and <bcp14>MUST</bcp14> contain all members required
      by its Identifier Format.</t>
      <section anchor="identifier-formats-versus-principal-types">
        <name>Identifier Formats versus Principal Types</name>
        <t>Identifier Formats define how to encode identifying information for
        a subject.  Unlike Principal Types, they do not define the type or
        nature of the subject itself.  For example, while the Email
        Identifier Format declares that the value of the "email" member is an
        email address, a subject in a security event that is identified by an
        Email Subject Identifier could be an end user who controls that
        email address, the mailbox itself, or anything else that the
        transmitter and receiver both understand to be associated with that
        email address.  Consequently, Subject Identifiers remove ambiguity
        around how a subject is being identified and how to parse an
        identifying structure, but they do not remove ambiguity
        around how to resolve that identifier for a subject.  For example,
        consider a directory management API that allows callers to identify
        users and groups through both opaque unique identifiers and email
        addresses.  Such an API could use Subject Identifiers to disambiguate
        between which of these two types of identifiers is in use.  However,
        the API would have to determine whether the subject is a user or group
        via some other means, such as by querying a database, interpreting
        other parameters in the request, or inferring the type from the API
        contract.</t>
      </section>
      <section anchor="identifier-format-definitions">
        <name>Identifier Format Definitions</name>
        <t>The following Identifier Formats are registered in the IANA
        "Security Event Identifier Formats" registry established in <xref
        target="iana-formats"/>.</t>
        <t>Since the Subject Identifier Format conveys semantic information,
        applications <bcp14>SHOULD</bcp14> choose the most specific possible
        format for the identifier in question. For example, an email address
        can be conveyed using a "mailto:" URI and the URI Identifier
        Format, but since the value is known to be an email address, the
        application should prefer to use the Email Identifier Format
        instead.</t>
        <section anchor="sub-id-acct">
          <name>Account Identifier Format</name>
          <t>The Account Identifier Format identifies a subject using an account at a service provider, identified with an "acct" URI as defined in <xref target="RFC7565"/>. An account is an arrangement or agreement through which a user gets access to a service and gets a unique identity with the service provider. Subject Identifiers in this format <bcp14>MUST</bcp14> contain a "uri" member whose value is the "acct" URI for the subject.  The "uri" member is <bcp14>REQUIRED</bcp14> and <bcp14>MUST NOT</bcp14> be null or empty.  The Account Identifier Format is identified by a value of "account" in the "format" member.</t>
          <t>Below is a non-normative example Subject Identifier for the Account Identifier Format:</t>
          <figure anchor="figexamplesubidaccount">
            <name>Example: Subject Identifier for the Account Identifier Format</name>
            <sourcecode type="json"><![CDATA[{
  "format": "account",
  "uri": "acct:example.user@service.example.com"
}]]></sourcecode>
          </figure>
        </section>
        <section anchor="sub-id-email">
          <name>Email Identifier Format</name>
          <t>The Email Identifier Format identifies a subject using an email address.  Subject Identifiers in this format <bcp14>MUST</bcp14> contain an "email" member whose value is a string containing the email address of the subject, formatted as an "addr-spec" as defined in <xref target="RFC5322" sectionFormat="of" section="3.4.1"/>. The "email" member is <bcp14>REQUIRED</bcp14> and <bcp14>MUST NOT</bcp14> be null or empty. The value of the "email" member <bcp14>MUST</bcp14> identify a mailbox to which email may be delivered, in accordance with <xref target="RFC5321"/>. The Email Identifier Format is identified by the name "email".</t>
          <t>Below is a non-normative example Subject Identifier in the Email Identifier Format:</t>
          <figure anchor="figexamplesubidemail">
            <name>Example: Subject Identifier in the Email Identifier Format</name>
            <sourcecode type="json"><![CDATA[{
  "format": "email",
  "email": "user@example.com"
}]]></sourcecode>
          </figure>
          <section anchor="email-canon">
            <name>Email Canonicalization</name>
            <t>Many email providers will treat multiple email addresses as
            equivalent. While the domain portion of an email address <xref
            target="RFC5322"/> is consistently treated as case-insensitive per
            <xref target="RFC1034"/>, most providers treat the local part of
            the email address as case-insensitive as well and consider
            "user@example.com", "User@example.com", and "USER@example.com" as
            the same email address. Some providers also treat dots (".") as
            optional; for example, "user.name@example.com",
            "username@example.com", "u.s.e.r.name@example.com", and
            "u.s.e.r.n.a.m.e@example.com" might all be treated as
            equivalent. This has led users to view these strings as
            equivalent, driving service providers to implement proprietary
            email canonicalization algorithms to ensure that email addresses
            entered by users resolve to the same canonical string. Email
            canonicalization is not standardized, and there is no way for the
            event recipient to determine the mail provider's canonicalization
            method. Therefore, the recipient <bcp14>SHOULD</bcp14> apply its
            own canonicalization algorithm to incoming events in order to
            reproduce the translation done by the local email system.</t>
          </section>
        </section>
        <section anchor="sub-id-iss-sub">
          <name>Issuer and Subject Identifier Format</name>
          <t>The Issuer and Subject Identifier Format identifies a subject
          using a pair of "iss" and "sub" members, analogous to how subjects
          are identified using the JWT "iss" and "sub" Claims in <xref
          target="OpenID.Core">OpenID Connect</xref> ID Tokens.  These members
          <bcp14>MUST</bcp14> follow the formats of the "iss" member and "sub"
          member defined by <xref target="RFC7519"/>, respectively.  Both the
          "iss" member and the "sub" member are <bcp14>REQUIRED</bcp14> and
          <bcp14>MUST NOT</bcp14> be null or empty. The Issuer and Subject
          Identifier Format is identified by the name "iss_sub".</t>
          <t>Below is a non-normative example Subject Identifier in the Issuer
          and Subject Identifier Format:</t>
          <figure anchor="figexamplesubidisssub">
            <name>Example: Subject Identifier in the Issuer and Subject Identifier Format</name>
            <sourcecode type="json"><![CDATA[{
  "format": "iss_sub",
  "iss": "https://issuer.example.com/",
  "sub": "145234573"
}]]></sourcecode>
          </figure>
        </section>
        <section anchor="sub-id-opaque">
          <name>Opaque Identifier Format</name>
          <t>The Opaque Identifier Format describes a subject that is identified with a string with no semantics asserted beyond its usage as an identifier for the subject, such as a Universally Unique Identifier (UUID) or hash used as a surrogate identifier for a record in a database.  Subject Identifiers in this format <bcp14>MUST</bcp14> contain an "id" member whose value is a JSON string containing the opaque string identifier for the subject.  The "id" member is <bcp14>REQUIRED</bcp14> and <bcp14>MUST NOT</bcp14> be null or empty.  The Opaque Identifier Format is identified by the name "opaque".</t>
          <t>Below is a non-normative example Subject Identifier in the Opaque Identifier Format:</t>
          <figure anchor="figexamplesubidopaque">
            <name>Example: Subject Identifier in the Opaque Identifier Format</name>
            <sourcecode type="json"><![CDATA[{
  "format": "opaque",
  "id": "11112222333344445555"
}]]></sourcecode>
          </figure>
        </section>
        <section anchor="sub-id-phone">
          <name>Phone Number Identifier Format</name>
          <t>The Phone Number Identifier Format identifies a subject using a telephone number.  Subject Identifiers in this format <bcp14>MUST</bcp14> contain a "phone_number" member whose value is a string containing the full telephone number of the subject, including an international dialing prefix, formatted according to <xref target="E164">E.164</xref>. The "phone_number" member is <bcp14>REQUIRED</bcp14> and <bcp14>MUST NOT</bcp14> be null or empty. The Phone Number Identifier Format is identified by the name "phone_number".</t>
          <t>Below is a non-normative example Subject Identifier in the Phone Number Identifier Format:</t>
          <figure anchor="figexamplesubidphone">
            <name>Example: Subject Identifier in the Phone Number Identifier Format</name>
            <sourcecode type="json"><![CDATA[{
  "format": "phone_number",
  "phone_number": "+12065550100"
}]]></sourcecode>
          </figure>
        </section>
        <section anchor="sub-id-did">
          <name>Decentralized Identifier (DID) Format</name>
          <t>The Decentralized Identifier (DID) Format identifies a subject
          using a DID URL as defined in <xref target="DID"/>.  Subject
          Identifiers in this format <bcp14>MUST</bcp14> contain a "url"
          member whose value is a DID URL for the DID Subject being
          identified. The value of the "url" member <bcp14>MUST</bcp14> be a
          valid DID URL and <bcp14>MAY</bcp14> be a bare DID. The "url" member
          is <bcp14>REQUIRED</bcp14> and <bcp14>MUST NOT</bcp14> be null or
          empty. The Decentralized Identifier Format is identified by the name
          "did".</t>
          <t>Below are non-normative example Subject Identifiers for the Decentralized Identifier Format:</t>
          <figure anchor="figexamplesubiddidbare">
            <name>Example: Subject Identifier for the Decentralized Identifier Format, Identifying a Subject with a Bare DID</name>
            <sourcecode type="json"><![CDATA[{
  "format": "did",
  "url": "did:example:123456"
}]]></sourcecode>
          </figure>
          <figure anchor="figexamplesubiddidcomplex">
            <name>Example: Subject Identifier for the Decentralized Identifier Format, Identifying a Subject with a DID URL with Non-empty Path and Query Components</name>
            <sourcecode type="json"><![CDATA[{
  "format": "did",
  "url": "did:example:123456/did/url/path?versionId=1"
}]]></sourcecode>
          </figure>
        </section>
        <section anchor="sub-id-uri">
          <name>Uniform Resource Identifier (URI) Format</name>
          <t>The Uniform Resource Identifier (URI) Format identifies a subject using a URI as defined in <xref target="RFC3986"/>. This Identifier Format makes no assumptions or guarantees with regard to the content, scheme, or reachability of the URI within the field. Subject Identifiers in this format <bcp14>MUST</bcp14> contain a "uri" member whose value is a URI for the subject being identified. The "uri" member is <bcp14>REQUIRED</bcp14> and <bcp14>MUST NOT</bcp14> be null or empty. The URI Format is identified by the name "uri".</t>
          <t>Below are non-normative example Subject Identifiers for the URI Format:</t>
          <figure anchor="figexamplesubiduidbare">
            <name>Example: Subject Identifier for the URI Format, Identifying a Subject with a Website URI</name>
            <sourcecode type="json"><![CDATA[{
  "format": "uri",
  "uri": "https://user.example.com/"
}]]></sourcecode>
          </figure>
          <figure anchor="figexamplesubidurnbare">
            <name>Example: Subject Identifier for the URI Format, Identifying a Subject with a Random URN</name>
            <sourcecode type="json"><![CDATA[{
  "format": "uri",
  "uri": "urn:uuid:4e851e98-83c4-4743-a5da-150ecb53042f"
}]]></sourcecode>
          </figure>
        </section>
        <section anchor="sub-id-aliases">
          <name>Aliases Identifier Format</name>
          <t>The Aliases Identifier Format describes a subject that is
          identified with a list of different Subject Identifiers. It is
          intended for use when a variety of identifiers have been shared with
          the party that will be interpreting the Subject Identifier, and it
          is unknown which of those identifiers they will recognize or
          support.  Subject Identifiers in this format <bcp14>MUST</bcp14>
          contain an "identifiers" member whose value is a JSON array
          containing one or more Subject Identifiers.  Each Subject Identifier
          in the array <bcp14>MUST</bcp14> identify the same entity.  The
          "identifiers" member is <bcp14>REQUIRED</bcp14> and <bcp14>MUST
          NOT</bcp14> be null or empty.  It <bcp14>MAY</bcp14> contain
          multiple instances of the same Identifier Format (e.g., multiple
          Email Subject Identifiers) but <bcp14>SHOULD NOT</bcp14> contain
          exact duplicates.  This format is identified by the name
          "aliases".</t>
          <t>"aliases" Subject Identifiers <bcp14>MUST NOT</bcp14> be nested,
          i.e., the "identifiers" member of an "aliases" Subject Identifier
          <bcp14>MUST NOT</bcp14> contain a Subject Identifier in the Aliases
          Identifier Format.</t>
          <t>Below is a non-normative example Subject Identifier in the
          Aliases Identifier Format:</t>
          <figure anchor="figexamplesubididtoken">
            <name>Example: Subject Identifier in the Aliases Identifier Format</name>
            <sourcecode type="json"><![CDATA[{
  "format": "aliases",
  "identifiers": [
    {
      "format": "email",
      "email": "user@example.com"
    },
    {
      "format": "phone_number",
      "phone_number": "+12065550100"
    },
    {
      "format": "email",
      "email": "user+qualifier@example.com"
    }
  ]
}]]></sourcecode>
          </figure>
        </section>
      </section>
    </section>
    <section anchor="jwt-claims">
      <name>Subject Identifiers in JWTs</name>
      <section anchor="jwt-claims-sub_id">
        <name>JWT "sub_id" Claim</name>
        <t>The JWT "sub" Claim is defined in <xref target="RFC7519"
        sectionFormat="of" section="4.1.2"/> as containing a string value;
        therefore, it cannot contain a Subject Identifier (which is a JSON
        object) as its value.  This document defines the JWT "sub_id" Claim,
        in accordance with <xref target="RFC7519" sectionFormat="of"
        section="4.2"/>, as a common claim that identifies the JWT Subject
        using a Subject Identifier.  When present, the value of this claim
        <bcp14>MUST</bcp14> be a Subject Identifier that identifies the
        subject of the JWT.  The JWT "sub_id" Claim <bcp14>MAY</bcp14> be included
        in a JWT, whether or not the JWT "sub" Claim is present.  When both the JWT
        "sub" and "sub_id" Claims are present in a JWT, they
        <bcp14>MUST</bcp14> identify the same subject, as a JWT has one and
        only one JWT Subject.</t>
        <t>When processing a JWT with both JWT "sub" and "sub_id" Claims,
        implementations <bcp14>MUST NOT</bcp14> rely on both claims to
        determine the JWT Subject.  An implementation <bcp14>MAY</bcp14>
        attempt to determine the JWT Subject from one claim and fall back to
        using the other if it determines it does not understand the format of
        the first claim.  For example, an implementation may attempt to use
        "sub_id" and fall back to using "sub" upon finding that "sub_id"
        contains a Subject Identifier with a format that is not recognized by
        the implementation.</t>
        <t>Below are non-normative examples of JWTs containing the JWT "sub_id"
        Claim:</t>
        <figure anchor="figexamplejwtsubidemail">
          <name>Example: JWT Containing a JWT "sub_id" Claim and No "sub" Claim</name>
          <sourcecode type="json"><![CDATA[{
  "iss": "issuer.example.com",
  "sub_id": {
    "format": "email",
    "email": "user@example.com"
  }
}]]></sourcecode>
        </figure>
        <figure anchor="figexamplejwtsamesubid">
          <name>Example: JWT Where the JWT "sub" and "sub_id" Claims Identify the JWT Subject Using the Same Identifier</name>
          <sourcecode type="json"><![CDATA[{
  "iss": "issuer.example.com",
  "sub": "user@example.com",
  "sub_id": {
    "format": "email",
    "email": "user@example.com"
  }
}]]></sourcecode>
        </figure>
        <figure anchor="figexamplejwtdiffsubvalues">
          <name>Example: JWT Where the JWT "sub" and "sub_id" Claims Identify the JWT Subject Using Different Values of the Same Identifier Type</name>
          <sourcecode type="json"><![CDATA[{
  "iss": "issuer.example.com",
  "sub": "liz@example.com",
  "sub_id": {
    "format": "email",
    "email": "elizabeth@example.com"
  }
}]]></sourcecode>
        </figure>
        <figure anchor="figexamplejwtdiffsubtype">
          <name>Example: JWT Where the JWT "sub" and "sub_id" Claims Identify the JWT Subject via Different Types of Identifiers</name>
          <sourcecode type="json"><![CDATA[{
  "iss": "issuer.example.com",
  "sub": "user@example.com",
  "sub_id": {
    "format": "account",
    "uri": "acct:example.user@service.example.com"
  }
}]]></sourcecode>
        </figure>
      </section>
      <section anchor="subid-and-isssub-subject-identifiers">
        <name>JWT "sub_id" Claim and "iss_sub" Subject Identifier</name>
        <t>The JWT "sub_id" Claim <bcp14>MAY</bcp14> contain an "iss_sub" Subject Identifier.  In this case, the JWT's "iss" Claim and the Subject Identifier's "iss" member <bcp14>MAY</bcp14> be different. For example, an <xref target="OpenID.Core">OpenID Connect</xref> client may construct such a JWT when sending JWTs back to its OpenID Connect Identity Provider in order to identify the JWT Subject using an identifier known to be understood by both parties.  Similarly, the JWT's "sub" Claim and the Subject Identifier's "sub" member <bcp14>MAY</bcp14> be different.  For example, this may be used by an OpenID Connect client to communicate the JWT Subject's local identifier at the client back to its Identity Provider.</t>
        <t>Below are non-normative examples of a JWT where the JWT "iss" Claim and "iss" member within the JWT "sub_id" Claim are the same and a JWT where they are different.</t>
        <figure anchor="figexamplejwtsameiss">
          <name>Example: JWT with an "iss_sub" Subject Identifier Where the JWT Issuer and JWT Subject Issuer Are the Same</name>
          <sourcecode type="json"><![CDATA[{
  "iss": "issuer.example.com",
  "sub_id": {
    "format": "iss_sub",
    "iss": "issuer.example.com",
    "sub": "example_user"
  }
}]]></sourcecode>
        </figure>
        <figure anchor="figexamplejwtdiffiss">
          <name>Example: JWT with an "iss_sub" Subject Identifier Where the JWT Issuer and JWT Subject Issuer Are Different</name>
          <sourcecode type="json"><![CDATA[{
  "iss": "client.example.com",
  "sub_id": {
    "format": "iss_sub",
    "iss": "issuer.example.com",
    "sub": "example_user"
  }
}]]></sourcecode>
        </figure>
        <figure anchor="figexamplejwtdiffisssub">
          <name>Example: JWT with an "iss_sub" Subject Identifier Where the JWT "iss" and "sub" Claims Differ from the JWT Subject's "iss" and "sub" Members</name>
          <sourcecode type="json"><![CDATA[{
  "iss": "client.example.com",
  "sub": "client_user",
  "sub_id": {
    "format": "iss_sub",
    "iss": "issuer.example.com",
    "sub": "example_user"
  }
}]]></sourcecode>
        </figure>
      </section>
    </section>
    <section anchor="implementer">
      <name>Considerations for Specifications that Define Identifier Formats</name>
      <t>Identifier Format definitions <bcp14>MUST NOT</bcp14> make assertions or declarations regarding the subject being identified by the Subject Identifier (e.g., an Identifier Format cannot be defined as specifically identifying human end users). Such statements are outside the scope of Identifier Formats and Subject Identifiers. Expanding that scope for some Identifier Formats but not others would harm interoperability because applications that depend on this expanded scope to disambiguate the subject type would be unable to use Identifier Formats that do not provide such rules.</t>
    </section>
    <section anchor="privacy">
      <name>Privacy Considerations</name>
      <section anchor="identifier-correlation">
        <name>Identifier Correlation</name>
        <t>The act of presenting two or more identifiers for a single subject
        together (e.g., within an "aliases" Subject Identifier or via the
        JWT "sub" and "sub_id" Claims) may communicate more information about
        the subject than was intended.  For example, the entity to which the
        identifiers are presented now knows that both identifiers relate to
        the same subject and may be able to correlate additional data based on
        that.  When transmitting Subject Identifiers, the transmitter
        <bcp14>SHOULD</bcp14> take care that they are only transmitting
        multiple identifiers together when it is known that the recipient
        already knows that the identifiers are related (e.g., because they
        were previously sent to the recipient as claims in an OpenID Connect
        ID Token) or when correlation is essential to the use case.
        Implementers must consider such risks, and specifications that use
        Subject Identifiers must provide appropriate privacy considerations of
        their own.</t>
        <t>The considerations described in <xref target="RFC8417"
        sectionFormat="of" section="6"/> also apply when Subject Identifiers
        are used within SETs.  The considerations described in <xref
        target="RFC7519" sectionFormat="of" section="12"/> also apply when
        Subject Identifiers are used within JWTs.</t>
      </section>
    </section>
    <section anchor="security">
      <name>Security Considerations</name>
      <t>This specification does not define any mechanism for ensuring the
      confidentiality or integrity of a Subject Identifier.  Where such
      properties are required, implementations <bcp14>MUST</bcp14> use
      mechanisms provided by the containing format (e.g., integrity protecting
      SETs or JWTs using JSON Web Signature (JWS) <xref target="RFC7515"/>) or
      at the transport layer or other layer in the application stack (e.g.,
      using TLS <xref target="RFC8446"/>).</t>
      <t>Further considerations regarding confidentiality and integrity of
      SETs can be found in <xref target="RFC8417" sectionFormat="of"
      section="5.1"/>.</t>
    </section>
    <section anchor="iana">
      <name>IANA Considerations</name>
      <section anchor="iana-formats">
        <name>Security Event Identifier Formats Registry</name>
        <t>This document defines Identifier Formats, for which IANA has created and maintains a new registry titled "Security Event Identifier Formats".  Initial values for the "Security Event Identifier Formats" registry are given in <xref target="sub-ids"/>.  Future assignments are to be made through the Specification Required registration policy <xref target="BCP26"/> and shall follow the template presented in <xref target="iana-formats-template"/>.</t>
        <t>It is suggested that multiple designated experts be appointed who are able to represent the perspectives of different applications using this specification in order to enable broadly informed review of registration decisions.</t>

        <section anchor="iana-formats-template">
          <name>Registration Template</name>
          <dl newline="true">
            <dt>Format Name:</dt>
            <dd>
              <t>The name of the Identifier Format, as described in <xref
              target="sub-ids"/>. The name <bcp14>MUST</bcp14> be an ASCII
              string consisting only of lowercase characters ("a" - "z"),
              digits ("0" - "9"), underscores ("_"), and hyphens ("-") and
              <bcp14>SHOULD NOT</bcp14> exceed 20 characters in length.</t>
            </dd>
            <dt>Format Description:</dt>
            <dd>
              <t>A brief description of the Identifier Format.</t>
            </dd>
            <dt>Change Controller:</dt>
            <dd>
              <t>For formats defined in documents published by the IETF or its
              working groups, list "IETF".  For all other formats, list the
              name of the party responsible for the registration.  Contact
              information, such as mailing address, email address, or phone
              number, must also be provided.</t>
            </dd>
            <dt>Reference:</dt>
            <dd>
              <t>A reference to the document or documents that define the
              Identifier Format.  The reference document(s)
              <bcp14>MUST</bcp14> specify the name, format, and meaning of each
              member that may occur within a Subject Identifier of the defined
              format as well as whether each member is optional, required, or
              conditional and the circumstances under which these optional or
              conditional fields would be used. URIs that can be used to
              retrieve copies of each document <bcp14>SHOULD</bcp14> be
              included.</t>
            </dd>
          </dl>
        </section>
        <section anchor="iana-formats-init">
          <name>Initial Registry Contents</name>
          <section anchor="account-identifier-format">
            <name>Account Identifier Format</name>
            <dl spacing="compact" newline="false">
              <dt>Format Name:</dt> <dd>account</dd>
              <dt>Format Description:</dt> <dd>Subject Identifier based on
              "acct" URI</dd>
              <dt>Change Controller:</dt> <dd>IETF</dd>
              <dt>Reference:</dt> <dd><xref target="sub-ids"/> of
              RFC 9493</dd>
            </dl>
          </section>
          <section anchor="email-identifier-format">
            <name>Email Identifier Format</name>
            <dl spacing="compact" newline="false">
              <dt>Format Name:</dt> <dd>email</dd>
              <dt>Format Description:</dt> <dd>Subject Identifier based on
              an email address</dd>
              <dt>Change Controller:</dt> <dd>IETF</dd>
              <dt>Reference:</dt> <dd><xref target="sub-ids"/> of
              RFC 9493</dd>
            </dl>
          </section>
          <section anchor="issuer-and-subject-identifier-format">
            <name>Issuer and Subject Identifier Format</name>
            <dl spacing="compact" newline="false">
              <dt>Format Name:</dt> <dd>iss_sub</dd>
              <dt>Format Description:</dt> <dd>Subject Identifier based on an
              issuer and subject</dd>
              <dt>Change Controller:</dt> <dd>IETF</dd>
              <dt>Reference:</dt> <dd><xref target="sub-ids"/> of
              RFC 9493</dd>
            </dl>
          </section>
          <section anchor="opaque-identifier-format">
            <name>Opaque Identifier Format</name>
            <dl spacing="compact" newline="false">
              <dt>Format Name:</dt> <dd>opaque</dd>
              <dt>Format Description:</dt> <dd>Subject Identifier based on an
              opaque string</dd>
              <dt>Change Controller:</dt> <dd>IETF</dd>
              <dt>Reference:</dt> <dd><xref target="sub-ids"/> of
              RFC 9493</dd>
            </dl>
          </section>
          <section anchor="phone-number-identifier-format">
            <name>Phone Number Identifier Format</name>
            <dl spacing="compact" newline="false">
              <dt>Format Name:</dt> <dd>phone_number</dd>
              <dt>Format Description:</dt> <dd>Subject Identifier based on a
              phone number</dd>
              <dt>Change Controller:</dt> <dd>IETF</dd>
              <dt>Reference:</dt> <dd><xref target="sub-ids"/> of
              RFC 9493</dd>
            </dl>
          </section>
          <section anchor="decentralized-identifier-format">
            <name>Decentralized Identifier Format</name>
            <dl spacing="compact" newline="false">
              <dt>Format Name:</dt> <dd>did</dd>
              <dt>Format Description:</dt> <dd>Subject Identifier based on a
              decentralized identifier (DID)</dd>
              <dt>Change Controller:</dt> <dd>IETF</dd>
              <dt>Reference:</dt> <dd><xref target="sub-ids"/> of
              RFC 9493</dd>
            </dl>
          </section>
          <section anchor="uniform-resource-identifier-format">
            <name>Uniform Resource Identifier Format</name>
            <dl spacing="compact" newline="false">
              <dt>Format Name:</dt> <dd>uri</dd>
              <dt>Format Description:</dt> <dd>Subject Identifier based on a
              Uniform Resource Identifier (URI)</dd>
              <dt>Change Controller:</dt> <dd>IETF</dd>
              <dt>Reference:</dt> <dd><xref target="sub-ids"/> of
              RFC 9493</dd>
            </dl>
          </section>
          <section anchor="aliases-identifier-format">
            <name>Aliases Identifier Format</name>
            <dl spacing="compact" newline="false">
              <dt>Format Name:</dt> <dd>aliases</dd>
              <dt>Format Description:</dt> <dd>Subject Identifier that groups
              together multiple different Subject Identifiers for the same
              subject</dd>
              <dt>Change Controller:</dt> <dd>IETF</dd>
              <dt>Reference:</dt> <dd><xref target="sub-ids"/> of
              RFC 9493</dd>
            </dl>
          </section>
        </section>
        <section anchor="iana-formats-expert">
          <name>Guidance for Expert Reviewers</name>
          <t>The Expert Reviewer is expected to review the documentation referenced in a registration request to verify its completeness. The Expert Reviewer must base their decision to accept or reject the request on a fair and impartial assessment of the request. If the Expert Reviewer has a conflict of interest, such as being an author of a defining document referenced by the request, they must recuse themselves from the approval process for that request.</t>
          <t>Identifier Formats need not be generally applicable and may be highly specific to a particular domain; it is expected that formats may be registered for niche or industry-specific use cases. The Expert Reviewer should focus on whether the format is thoroughly documented and whether its registration will promote or harm interoperability.  In most cases, the Expert Reviewer should not approve a request if the registration would contribute to confusion or amount to a synonym for an existing format.</t>
        </section>
      </section>
      <section anchor="json-web-token-claims-registration">
        <name>JSON Web Token Claims Registration</name>
        <t>This document defines the JWT "sub_id" Claim, which IANA has registered in the "JSON Web Token Claims" registry <xref target="IANA.JWT.Claims"/> established by <xref target="RFC7519"/>.</t>
        <section anchor="registry-contents">
          <name>Registry Contents</name>
          <dl spacing="compact" newline="false">
            <dt>Claim Name:</dt> <dd>sub_id</dd>
            <dt>Claim Description:</dt> <dd>Subject Identifier</dd>
            <dt>Change Controller:</dt> <dd>IETF</dd>
            <dt>Reference:</dt> <dd><xref
            target="jwt-claims-sub_id"/> of RFC 9493</dd>
          </dl>
        </section>
      </section>
    </section>
  </middle>
  <back>


    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>


<referencegroup anchor="BCP26" target="https://www.rfc-editor.org/info/bcp26">
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8126.xml"/>
</referencegroup>

        <reference anchor="E164" target="https://www.itu.int/rec/T-REC-E.164-201011-I/en">
          <front>
            <title>E.164: The international public telecommunication numbering plan</title>
            <author>
              <organization>ITU-T</organization>
            </author>
            <date month="November" year="2010"/>
          </front>
	  <seriesInfo name="ITU-T Recommendation" value="E.164"/>
        </reference>

        <reference anchor="IANA.JWT.Claims" target="https://www.iana.org/assignments/jwt">
          <front>
            <title>JSON Web Token Claims</title>
            <author>
              <organization>IANA</organization>
            </author>
          </front>
        </reference>

        <reference anchor="DID" target="https://www.w3.org/TR/did-core/">
          <front>
            <title>Decentralized Identifiers (DIDs) v1.0</title>
	    <author fullname="Manu Sporny" role="editor">
	      <organization>Digital Bazaar</organization>
	    </author>
	    <author fullname="Amy Guy" role="editor">
	      <organization>Digital Bazaar</organization>
	    </author>
	    <author fullname="Markus Sabadello" role="editor">
	      <organization>Danube Tech</organization>
	    </author>
	    <author fullname="Drummond Reed" role="editor">
	      <organization>Evernym/Avast</organization>
	    </author>
	    <author fullname="Dave Longley">
	      <organization>Digital Bazaar</organization>
	      </author>
	      <author fullname="Orie Steele">
		<organization>Transmute</organization>
	      </author>
	      <author fullname="Christopher Allen">
		<organization>Blockchain Commons</organization>
	      </author>
            <date month="July" year="2022"/>
          </front>
        </reference>

        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8417.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7519.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8259.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7565.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.5322.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.5321.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.3986.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
      </references>
      <references>
        <name>Informative References</name>

        <reference anchor="OpenID.Core" target="https://openid.net/specs/openid-connect-core-1_0.html">
          <front>
            <title>OpenID Connect Core 1.0 incorporating errata set 1</title>
            <author initials="N." surname="Sakimura" fullname="Nat Sakimura">
              <organization>Nomura Research Institute, Ltd.</organization>
            </author>
            <author initials="J." surname="Bradley" fullname="John Bradley">
              <organization>Ping Identity</organization>
            </author>
            <author initials="M." surname="Jones" fullname="Michael B. Jones">
              <organization>Microsoft</organization>
            </author>
            <author initials="B." surname="de Medeiros" fullname="Breno de Medeiros">
              <organization>Google</organization>
            </author>
            <author initials="C." surname="Mortimore" fullname="Chuck Mortimore">
              <organization>Salesforce</organization>
            </author>
            <date year="2014" month="November"/>
          </front>
        </reference>

        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.1034.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7515.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8446.xml"/>
      </references>
    </references>
    <section numbered="false" anchor="acknowledgements">
      <name>Acknowledgements</name>
      <t>The authors would like to thank the members of the IETF Security
      Events Working Group, as well as those of the OpenID Shared Signals and
      Events Working Group, whose work provided the original basis for this
      document.  We would also like to acknowledge <contact fullname="Aaron
      Parecki"/>, <contact fullname="Denis Pinkas"/>, <contact
      fullname="Justin Richer"/>, <contact fullname="Mike Jones"/>, and other
      members of the working group for reviewing this document.</t>
    </section>
  </back>
</rfc>
