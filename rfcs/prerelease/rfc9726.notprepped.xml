<?xml version='1.0' encoding='UTF-8'?>

<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>

<rfc xmlns:xi="http://www.w3.org/2001/XInclude" ipr="trust200902" docName="draft-ietf-opsawg-mud-iot-dns-considerations-19" number="9726" category="bcp" consensus="true" tocInclude="true" sortRefs="true" symRefs="true" version="3" xml:lang="en" updates="" obsoletes="" submissionType="IETF">

  <front>
    <title abbrev="DNS in IoT Devices">Operational Considerations for Use of DNS in Internet of Things (IoT) Devices</title>
    <seriesInfo name="RFC" value="9726"/>
    <seriesInfo name="BCP" value="241"/>
    <author initials="M." surname="Richardson" fullname="Michael Richardson">
      <organization>Sandelman Software Works</organization>
      <address>
        <email>mcr+ietf@sandelman.ca</email>
      </address>
    </author>
    <author initials="W." surname="Pan" fullname="Wei Pan">
      <organization>Huawei Technologies</organization>
      <address>
        <email>william.panwei@huawei.com</email>
      </address>
    </author>
    <date year="2025" month="March"/>
    <area>OPS</area>
    <workgroup>opsawg</workgroup>

<keyword>DNS</keyword>
<keyword>MUD</keyword>
<keyword>round-robin</keyword>
<keyword>tailored response</keyword>
<keyword>DNSSEC</keyword>
<keyword>IoT security</keyword>
<keyword>Device Identity</keyword>

    <abstract>
      <t>This document details considerations about how Internet of Things
      (IoT) devices use IP addresses and DNS names.  These concerns become
      acute as network operators begin deploying Manufacturer Usage
      Descriptions (MUD), as specified in RFC 8520, to control device access.</t>
      <t>Also, this document makes recommendations on when and how to use DNS
      names in MUD files.</t>
    </abstract>
  </front>
  <middle>

<section anchor="introduction">
      <name>Introduction</name>
      <t><xref target="RFC8520"/> provides a standardized way to describe how
      a device with a specific purpose makes use of Internet resources.  Access
      Control Lists (ACLs) can be defined in a Manufacturer Usage Description
      (MUD) file <xref target="RFC8520" format="default"/> that permits a
      device to access Internet resources by their DNS names or IP
      addresses.</t>
      <t>The use of a DNS name rather than an IP address in an ACL has many
      advantages: Not only does the layer of indirection permit the mapping of
      a name to IP addresses to be changed over time, but it also generalizes
      automatically to IPv4 and IPv6 addresses as well as permits a
      variety of load-balancing strategies, including multi-CDN deployments
      wherein load-balancing can account for geography and load.</t>
      <t>However, the use of DNS names has implications on how ACLs are
      executed at the MUD policy enforcement point (typically, a firewall).
      Concretely, the firewall has access only to the Layer 3 headers of the
      packet.  This includes the source and destination IP addresses and, if not
      encrypted by IPsec, the destination UDP or TCP port number present in
      the transport header.  The DNS name is not present!</t>
      <t>So, in order to implement these name-based ACLs, there must be a
      mapping between the names in the ACLs and IP addresses.</t>
      <t>In order for manufacturers to understand how to configure DNS
      associated with name-based ACLs, a model of how the DNS resolution will
      be done by MUD controllers is necessary.  <xref target="mapping"/>
      models some good strategies that could be used.</t>
      <t>This model is non-normative but is included so that IoT device
      manufacturers can understand how the DNS will be used to resolve the
      names they use.</t>
      <t>There are some ways of using DNS that will present problems for MUD
      controllers, which <xref target="dns-anti-p"/> explains.</t>
      <t><xref target="sec-priv-out"/> details how current trends in DNS
      resolution such as public DNS servers, DNS over TLS (DoT) <xref
      target="RFC7858"/>, DNS over HTTPS (DoH) <xref target="RFC8484"/>, or
      DNS over QUIC (DoQ) <xref target="RFC9250"/> can cause problems with the
      strategies employed.</t>
      <t>The core of this document is <xref target="sec-reco"/>, which makes a
      series of recommendations ("best current practices") for manufacturers
      on how to use DNS and IP addresses with IoT devices described by MUD.</t>
      <t><xref target="sec-privacy"/> discusses a set of privacy issues that
      encrypted DNS (for example, DoT and DoH) are frequently used to deal
      with.  How these concerns apply to IoT devices located within a
      residence or enterprise is a key concern.</t>
      <t><xref target="sec-security"/> also covers some of the negative outcomes should MUD/firewall managers and IoT manufacturers choose not to cooperate.</t>
    </section>
    <section anchor="Terminology">
      <name>Terminology</name>
      <t>This document makes use of terms defined in <xref target="RFC8520"/>
      and <xref target="RFC9499"/>.</t>
      <t>The term "anti-pattern" comes from agile software design literature,
      as per <xref target="antipattern"/>.</t>
      <t>"CDNs" refers to Content Distribution Networks, such as those described in
      <xref section="1.1" sectionFormat="comma" target="RFC6707"/>.</t>
    </section>
    <section anchor="mapping">
      <name>A Model for MUD Controller Mapping of DNS Names to Addresses</name>
      <t>This section details a strategy that a MUD controller could take.
      Within the limits of the DNS use detailed in <xref target="sec-reco"/>,
      this process could work.  The methods detailed in <xref
      target="failingstrategy"/> just will not work.</t>
      <t>The simplest successful strategy for a MUD controller to translate
      DNS names is to do a DNS lookup on the name (a forward lookup) and then
      use the resulting IP addresses to populate the actual ACLs.</t>
      <t>There are a number of possible failures, and the goal of this section is
      to explain how some common DNS usages may fail.</t>
      <section anchor="non-deterministic-mappings">
        <name>Non-Deterministic Mappings</name>
        <t>Most importantly, the mapping of the DNS names to IP addresses
        could be non-deterministic.</t>
        <t><xref target="RFC1794"/> describes the very common mechanism that
        returns DNS A (or reasonably AAAA) records in a permuted order.  This
        is known as "round-robin DNS" and has been used for many decades.  The
        historical intent is that the requestor will tend to use the first IP
        address that is returned.  As each query results in addresses being in a
        different order, the effect is to split the load among many
        servers.</t>
        <t>This situation does not result in failures as long as all possible
        A/AAAA records are returned.  The MUD controller and the device get a
        matching set, and the ACLs that are set up cover all
        possibilities.</t>
        <t>There are a number of circumstances in which the list is not
        exhaustive.  The simplest is when the round-robin DNS does not return
        all addresses.  This is routinely done by geographical DNS
        load-balancing systems: Only the addresses that the balancing system
        wishes to be used are returned.</t>
        <t>Failure can also occur if there are more addresses than what will
        conveniently fit into a DNS reply.  The reply will be marked as
        truncated.  (If DNSSEC resolution will be done, then the entire RR
        must be retrieved over TCP (or using a larger EDNS(0) size) before
        being validated.)</t>
        <t>However, in a geographical DNS load-balancing system, different
        answers are given based upon the locality of the system asking.  There
        may also be further layers of round-robin indirection.</t>
        <t>Aside from the list of records being incomplete, the list may have
        changed between the time that the MUD controller did the lookup and
        the time that the IoT device did the lookup, and this change can
        result in a failure for the ACL to match.  If the IoT device did not
        use the same recursive servers as the MUD controller, then tailored
        DNS replies and/or truncated round-robin results could return a
        different and non-overlapping set of addresses.</t>
        <t>In order to compensate for this, the MUD controller performs
        regular DNS lookups in order to never have stale data.  These lookups
        must be rate-limited to avoid excessive load on the DNS servers, and
        it may be necessary to avoid local recursive resolvers.  A MUD
        controller that incorporates its own recursive caching DNS client will
        be able to observe the TTL on the entries and cause them to expire
        appropriately.  This cache will last for at least some number of
        minutes and up to some number of days (respecting the TTL), while the
        underlying DNS data can change at a higher frequency, providing
        different answers to different queries!</t>
        <t>A MUD controller that is aware of which recursive DNS server the
        IoT device will use can instead query that server on a periodic basis.
        Doing so provides three advantages:</t>
        <ol spacing="normal" type="1">
	  <li>
            <t>Any geographic load-balancing will base the decision on the
            geolocation of the recursive DNS server, and the recursive name
            server will provide the same answer to the MUD controller as to
            the IoT device.</t>
          </li>
          <li>
            <t>The resulting mapping (of name to IP address) in the recursive
            name server will be cached and will remain the same for the entire
            advertised TTL reported in the DNS query return.  This
            also allows the MUD controller to avoid doing unnecessary
            queries.</t>
          </li>
          <li>
            <t>If any addresses have been omitted in a round-robin DNS
            process, the cache will have the same set of addresses that were
            returned.</t>
          </li>
        </ol>
        <t>The solution of using the same caching recursive resolver as the
        target device is very simple when the MUD controller is located in a
        residential Customer Premises Equipment (CPE) device.  The device is usually also the
        policy-enforcement point for the ACLs, and a caching resolver is
        typically located on the same device.  In addition to convenience,
        there is a shared fate advantage: As all three components are running
        on the same device, if the device is rebooted (which clears the cache),
        then all three components will get restarted when the device is
        restarted.</t>
        <t>The solution is more complex and sometimes more fragile when the
        MUD controller is located elsewhere in an enterprise or remotely in a
        cloud, such as when a Software-Defined Network (SDN) is used to manage
        the ACLs.  The DNS servers for a particular device may not be known to
        the MUD controller, and the MUD controller may not even be permitted
        to make recursive queries to that server if it is known.  In this
        case, additional installation-specific mechanisms are probably needed
        to get the right view of the DNS.</t>
        <t>A critical failure can occur when the device makes a new DNS
        request and receives a new set of IP addresses, but the MUD
        controller's copy of the addresses has not yet reached their TTL.  In that case, the MUD controller still has the old addresses
        implemented in the ACLs, but the IoT device has a new address not
        previously returned to the MUD controller.  This can result in a
        connectivity failure.</t>
      </section>
    </section>
    <section anchor="dns-anti-p">
      <name>DNS and IP Anti-Patterns for IoT Device Manufacturers</name>
      <t>In many design fields, there are good patterns that should be
      emulated, and often there are patterns that should not be emulated.  The
      latter are called anti-patterns, as per <xref
      target="antipattern"/>.</t>
      <t>This section describes a number of things that IoT manufacturers have
      been observed to do in the field, each of which presents difficulties for
      MUD enforcement points.</t>
      <section anchor="inprotocol">
        <name>Use of IP Address Literals</name>
        <t>A common pattern for a number of devices is to look for firmware
        updates in a two-step process.  An initial query is made (often over
        HTTPS, sometimes with a POST, but the method is immaterial) to a
        vendor system that knows whether an update is required.</t>
        <t>The current firmware model of the device is sometimes provided, and
        then the vendor's authoritative server provides a determination if a
        new version is required and, if so, what version.  In simpler cases,
        an HTTPS endpoint is queried, which provides the name and URL of the
        most recent firmware.</t>
        <t>The authoritative upgrade server then responds with a URL of a
        firmware blob that the device should download and install.  Best
        practice is that either firmware is signed internally <xref
        target="RFC9019"/> so that it can be verified, or a hash of the blob
        is provided.</t>
        <t>An authoritative server might be tempted to provide an IP address
        literal inside the protocol.  An argument for doing this is that it
        eliminates problems with firmware updates that might be caused by a
        lack of DNS or by incompatibilities with DNS.  For instance, a bug
        that causes interoperability issues with some recursive servers would
        become unpatchable for devices that were forced to use that recursive
        resolver type.</t>
        <t>But, there are several problems with the use of IP address literals
        for the location of the firmware.</t>
        <t>The first is that the update service server must decide whether to
        provide an IPv4 or an IPv6 literal, assuming that only one URL can be
        provided.  A DNS name can contain both kinds of addresses and can
        also contain many different IP addresses of each kind.  An update
        server might believe that if the connection were on IPv4, then an IPv4
        literal would be acceptable. However, due to NAT64 <xref
        target="RFC6146"/>, a device with only IPv6 connectivity will often be
        able to reach an IPv4 firmware update server by name (through DNS64
        <xref target="RFC6147"/>) but not be able to reach an arbitrary IPv4
        address.</t>
        <t>A MUD file for this access would need to resolve to the
        set of IP addresses that might be returned by the update server.  This
        can be done with IP address literals in the MUD file, but this may
        require continuing updates to the MUD file if the addresses change
        frequently.  A DNS name in the MUD could resolve to the set of all
        possible IPv4 and IPv6 addresses that would be used, with DNS
        providing a level of indirection that obviates the need to update the
        MUD file itself.</t>
        <t>A third problem involves the use of HTTPS.  It is often more
        difficult to get TLS certificates for an IP address, and so it is less
        likely that the firmware download will be protected by TLS.  Even if an IP address literal was placed in the TLS ServerNameIndicator
   <xref target="RFC6066"/>, against the advice of that document, it still would not provide enough
   context for a web server to distinguish which of the (potentially
   many) tenants the client wishes to reach.
   This drives the use of an IP address per tenant, and for
        IPv4 (at least), this is no longer a sustainable use of IP
        addresses.</t>
        <t>Finally, it is common in some CDNs
        to use multiple layers of DNS CNAMEs in order to isolate the content
        owner's naming system from changes in how the distribution network is
        organized.</t>
        <t>When a name or address is returned within an update protocol for
        which a MUD rule cannot be written, then the MUD controller is unable
        to authorize the connection.  In order for the connection to be
        authorized, the set of names returned within the update protocol needs
        to be known ahead of time and must be from a finite set of
        possibilities.  Such a set of names or addresses can be placed into
        the MUD file as an ACL in advance, and the connections can be
        authorized.</t>
      </section>
      <section anchor="use-of-non-deterministic-dns-names-in-protocols">
        <name>Use of Non-Deterministic DNS Names in Protocols</name>
        <t>A second pattern is for a control protocol to connect to a known
        HTTP endpoint.  This is easily described in MUD.  References within
        that control protocol are made to additional content at other URLs.
        The values of those URLs do not fit any easily described pattern and
        may point to arbitrary DNS names.</t>
        <t>Those DNS names are often within some third-party CDN system or may
        be arbitrary DNS names in a cloud-provider storage system (e.g., <xref
        target="AmazonS3"/> or <xref target="Akamai"/>).  Some of the name
        components may be specified by the third-party CDN provider.</t>
        <t>Such DNS names may be unpredictably chosen by the CDN and not the
        device manufacturer and therefore impossible to insert into a MUD
        file.  Implementation of the CDN system may also involve HTTP
        redirections to downstream CDN systems.</t>
        <t>Even if the CDN provider's chosen DNS names are deterministic, they
        may change at a rate much faster than MUD files can be updated.</t>
        <t>This situation applies to firmware updates but also applies to many
        other kinds of content: video content, in-game content, etc.</t>
        <t>A solution may be to use a deterministic DNS name within the
        control of the device manufacturer.  The device manufacturer is asked
        to point a CNAME to the CDN, to a name that might look like
        "g7.a.example", with the expectation that the CDN provider's DNS will do
        all the appropriate work to geolocate the transfer.  This can be fine
        for a MUD file, as the MUD controller, if located in the same
        geography as the IoT device, can follow the CNAME and collect the set
        of resulting IP addresses along with the TTL for each.  Then, the MUD
        controller can take charge of refreshing that mapping at intervals
        driven by the TTL.</t>
        <t>In some cases, a complete set of geographically distributed servers
        may be known ahead of time (or that it changes very slowly), and the
        device manufacturer can list all those IP addresses in the DNS for the
        name that it lists in the MUD file.  As long as the active set of
        addresses used by the CDN is a strict subset of that list, then the
        geolocated name can be used for the content download itself.</t>
      </section>
      <section anchor="use-of-a-too-generic-dns-name">
        <name>Use of a Too Generic DNS Name</name>
        <t>Some CDNs make all customer content available at a single URL (such
        as "s3.example.com").  This seems to be ideal from a MUD point of
        view: a completely predictable URL.</t>
        <t>The problem is that a compromised device could then connect to the
        contents of any bucket, potentially attacking the data from other
        customers.</t>
        <t>Exactly what the risk is depends upon what the other customers are
        doing: It could be limited to simply causing a distributed
        denial-of-service attack resulting in high costs to those customers,
        or such an attack could potentially include writing
        content.</t>
        <t>Amazon has recognized the problems associated with this practice
        and aims to change it to a virtual hosting model, as per <xref
        target="awss3virtualhosting"/>.</t>
        <t>The MUD ACLs provide only for permitting endpoints (hostnames and
        ports) but do not filter URLs (nor could filtering be enforced within
        HTTPS).</t>
      </section>
    </section>
    <section anchor="sec-priv-out">
      <name>DNS Privacy and Outsourcing versus MUD Controllers</name>
      <t><xref target="RFC7858"/> and <xref target="RFC8094"/> provide for DoT
      and DoH.  <xref target="RFC9499"/> details the terms.  But, even with
      the unencrypted DNS (a.k.a. Do53), it is possible to outsource DNS
      queries to other public services, such as those operated by Google,
      CloudFlare, Verisign, etc.</t>
      <t>For some users and classes of devices, revealing the DNS queries to
      those outside entities may constitute a privacy concern.  For other
      users, the use of an insecure local resolver may constitute a privacy
      concern.</t>
      <t>As described in <xref target="mapping"/>, the MUD controller
      needs to have access to the same resolver or resolvers as the IoT device.  If the
      IoT device does not use the DNS servers provided to it via DHCP or
      Router Advertisements, then the MUD controller will need to be told
      which servers will in fact be used.  As yet, there is no protocol to do
      this, but future work could provide this as an extension to MUD.</t>
      <t>Until such time as such a protocol exists, the best practice is for
      the IoT device to always use the DNS servers provided by DHCP or Router
      Advertisements.</t>
    </section>
    <section anchor="sec-reco">
      <name>Recommendations to IoT Device Manufacturers on MUD and DNS Usage</name>
      <t>Inclusion of a MUD file with IoT devices is operationally quite
      simple.  It requires only a few small changes to the DHCP client code to
      express the MUD URL.  It can even be done without code changes via the
      use of a QR code affixed to the packaging (see <xref
      target="RFC9238"/>).</t>
      <t>The difficult part is determining what to put into the MUD file
      itself.  There are currently tools that help with the definition and
      analysis of MUD files; see <xref target="mudmaker"/>.  The remaining
      difficulty is the actual list of expected connections to put in the
      MUD file.  An IoT manufacturer must spend some time reviewing the
      network communications by their device.</t>
      <t>This document discusses a number of challenges that occur relating to
      how DNS requests are made and resolved, and the goal of this section is
      to make recommendations on how to modify IoT systems to work well with
      MUD.</t>
      <section anchor="consistently-use-dns">
        <name>Consistently Use DNS</name>
        <t>For the reasons explained in <xref target="inprotocol"/>, the most
        important recommendation is to avoid using IP address literals in any
        protocol.  DNS names should always be used.</t>
      </section>
      <section anchor="use-primary-dns-names-controlled-by-the-manufacturer">
        <name>Use Primary DNS Names Controlled by the Manufacturer</name>
        <t>The second recommendation is to allocate and use DNS names within
        zones controlled by the manufacturer.  These DNS names can be
        populated with an alias (see <xref target="RFC9499" section="2"
        sectionFormat="comma"/>) that points to the production system.
        Ideally, a different name is used for each logical function, allowing
        different rules in the MUD file to be enabled and disabled.</t>
        <t>While it used to be costly to have a large number of aliases in a
        web server certificate, this is no longer the case.  Wildcard
        certificates are also commonly available; they allow for an infinite
        number of possible DNS names.</t>
      </section>
      <section anchor="use-content-distribution-network-with-stable-dns-names">
        <name>Use a Content Distribution Network with Stable DNS Names</name>
        <t>When aliases point to a CDN, give preference to stable DNS names
        that point to appropriately load-balanced targets.  CDNs that employ
        very low TTL values for DNS make it harder for the MUD
        controller to get the same answer as the IoT device.  A CDN that
        always returns the same set of A and AAAA records, but permutes them to
        provide the best one first, provides a more reliable answer.</t>
      </section>
      <section anchor="tailorednames">
        <name>Do Not Use Tailored Responses to Answer DNS Names</name>
        <t><xref target="RFC7871"/> defines the edns-client-subnet (ECS) EDNS0
        option and explains how authoritative servers sometimes answer queries
        differently based upon the IP address of the end system making the
        request.  Ultimately, the decision is based upon some topological
        notion of closeness.  This is often used to provide tailored responses
        to clients, providing them with a geographically advantageous
        answer.</t>
        <t>When the MUD controller makes its DNS query, it is critical that it
        receives an answer that is based upon the same topological decision as
        when the IoT device makes its query.</t>
        <t>There are probably ways in which the MUD controller could use the
        edns-client-subnet option to make a query that would get the same
        treatment as when the IoT device makes its query.  If this worked,
        then it would receive the same answer as the IoT device.</t>
        <t>In practice it could be quite difficult if the IoT device uses a
        different Internet connection, a different firewall, or a different
        recursive DNS server.  The edns-client-subnet option might be ignored or
        overridden by any of the DNS infrastructure.</t>
        <t>Some tailored responses might only reorder the replies so that the
        most preferred address is first.  Such a system would be acceptable if
        the MUD controller had a way to know that the list was complete.</t>
        <t>But, due to the above problems, a strong recommendation is to avoid
        using tailored responses as part of the DNS names in the MUD file.</t>
      </section>
      <section anchor="prefer-dns-servers-learned-from-dhcprouter-advertisements">
        <name>Prefer DNS Servers Learned from DHCP/Router Advertisements</name>
        <t>The best practice is for IoT devices to do DNS with the
        DHCP-provided DNS servers or with DNS servers learned from Router
        Advertisements <xref target="RFC8106"/>.</t>
        <t>The Adaptive DNS Discovery (ADD) Working Group has written <xref target="RFC9462"/> and <xref
        target="RFC9463"/> to provide information to end devices on how to
        find locally provisioned secure/private DNS servers.</t>
        <t>Use of public resolvers instead of the locally provided DNS
        resolver, whether Do53, DoQ, DoT, or DoH, is discouraged.</t>
        <t>Some manufacturers would like to have a fallback to using a public
        resolver to mitigate against local misconfiguration.  There are a
        number of reasons to avoid this, detailed in <xref
        target="tailorednames"/>.  The public resolver might not return the
        same tailored names that the MUD controller would get.</t>
        <t>It is recommended that non-local resolvers are only used when
        the locally provided resolvers provide no answers to any queries at
        all and do so repeatedly.  The status of the operator-provided
        resolvers needs to be re-evaluated on a periodic basis.</t>
        <t>Finally, if a device will ever attempt to use non-local resolvers,
        then the addresses of those resolvers need to be listed in the MUD
        file as destinations that are to be permitted. This needs to include
        the port numbers (i.e., 53, 853 for DoT, 443 for DoH) that will be
        used as well.</t>
      </section>
    </section>
    <section anchor="interactions-with-mdns-and-dnssd">
      <name>Interactions with mDNS and DNS-SD</name>
      <t>Unicast DNS requests are not the only way to map names to IP
      addresses.  IoT devices might also use Multicast DNS (mDNS) <xref target="RFC6762"/>,
      both to be discovered by other devices and also to discover other
      devices.</t>
      <t>mDNS replies include A and AAAA records, and it is conceivable that
      these replies contain addresses that are not local to the link on which
      they are made.  This could be the result of another device that contains
      malware.  An unsuspecting IoT device could be led to contact some
      external host as a result.  Protecting against such things is one of the
      benefits of MUD.</t>
      <t>In the unlikely case that the external host has been listed as a
      legitimate destination in a MUD file, communication will
      continue as expected.  As an example, an IoT device might look
      for a name like "update.local" in order to find a source of firmware
      updates.  It could be led to connect to some external host that was
      listed as "update.example" in the MUD file.  This should work fine if
      the name "update.example" does not require any kind of tailored
      reply.</t>
      <t>In residential networks, there has typically not been more than one
      network (although this is changing through work like <xref
      target="I-D.ietf-snac-simple"/>), but on campus or enterprise networks,
      having more than one network is not unusual.  In such networks, mDNS is
      being replaced with DNS-based Service Discovery (DNS-SD) <xref target="RFC8882"/>, and in such a
      situation, connections could be initiated to other parts of the network.
      Such connections might traverse the MUD policy enforcement point (an
      intra-department firewall) and could very well be rejected because the
      MUD controller did not know about that interaction.</t>
      <t><xref target="RFC8250"/> includes a number of provisions for
      controlling internal communications, including complex communications
      like same manufacturer ACLs.  To date, this aspect of MUD has been
      difficult to describe.  This document does not consider internal
      communications to be in scope.</t>
    </section>
    <section anchor="iana">
      <name>IANA Considerations</name>
<t>This document has no IANA actions.</t>
    </section>


    <section anchor="sec-privacy">
      <name>Privacy Considerations</name>
      <t>The use of non-local DNS servers exposes the list of DNS names
      resolved to a third party, including passive eavesdroppers.</t>
      <t>The use of DoT and DoH eliminates the threat from passive
      eavesdropping but still exposes the list to the operator of the DoT or
      DoH server.  There are additional methods to help preserve privacy, such
      as that described by <xref target="RFC9230"/>.</t>
      <t>The use of unencrypted (Do53) requests to a local DNS server exposes
      the list to any internal passive eavesdroppers. For some situations,
      that may be significant, particularly if unencrypted WiFi is used.</t>
      <t>Use of an encrypted DNS connection to a local DNS recursive resolver
      is the preferred choice.</t>
      <t>IoT devices that reach out to the manufacturer at regular intervals
      to check for firmware updates are informing passive eavesdroppers of the
      existence of a specific manufacturer's device being present at the
      origin location.</t>
      <t>Identifying the IoT device type empowers the attacker to launch
      targeted attacks to the IoT device (e.g., the attacker can take
      advantage of any known vulnerability on the device).</t>
      <t>While possession of a "large kitchen appliance" at a residence may be
      uninteresting to most, possession of intimate personal devices (e.g.,
      "sex toys") may be a cause for embarrassment.</t>
      <t>IoT device manufacturers are encouraged to find ways to anonymize
      their update queries.  For instance, contracting out the update
      notification service to a third party that deals with a large variety of
      devices would provide a level of defense against passive eavesdropping.
      Other update mechanisms should be investigated, including use of
      DNSSEC-signed TXT records with current version information.  This would
      permit DoT or DoH to convey the update notification in a private
      fashion.  This is particularly powerful if a local recursive DoT server
      is used, which then communicates using DoT over the Internet.</t>
      <t>The more complex case of <xref target="inprotocol"/> postulates that
      the version number needs to be provided to an intelligent agent that can
      decide the correct route to do upgrades.  <xref target="RFC9019"/>
      provides a wide variety of ways to accomplish the same thing without
      having to divulge the current version number.</t>
    </section>
    <section anchor="sec-security">
      <name>Security Considerations</name>
      <t>This document deals with conflicting security requirements:</t>
      <ul spacing="normal">
	<li>
          <t>devices that an operator wants to manage using <xref target="RFC8520"/></t>
        </li>
        <li>
          <t>requirements for the devices to get access to network resources
          that may be critical to their continued safe operation</t>
        </li>
      </ul>
      <t>This document takes the view that the two requirements do not need to
      be in conflict, but resolving the conflict requires careful planning on
      how the DNS can be safely and effectively be used by MUD controllers and
      IoT devices.</t>
      <t>When an IoT device with an inaccurate MUD file is deployed into a
      network that uses MUD, there is a significant possibility that the
      device will cause a spurious security exception to be raised.  There is
      significant evidence that such spurious exceptions can cause significant
      overhead to personnel.  In particular, repeated spurious exceptions are
      likely to cause the entire exception process to be turned off.  When MUD
      alerts are turned off, then even legitimate exceptions are ignored.
      This is very much a Boy Who Calls Wolf <xref target="boywhocriedwolf"/>
      situation.</t>
      <t>In order to avoid this situation, and for MUD alerts to be given
      appropriate attention, it is key that IoT device manufacturers create
      accurate MUD files.  This may require some significant thought and even
      rework of key systems so that all network access required by the IoT
      device can be described by a MUD file.  This level of informed
      cooperation within the IoT device vendor and with MUD controller
      manufacturers is key to getting significant return on investment from
      MUD.</t>
      <t>Manufacturers are encouraged to write MUD files that are good enough
      rather than perfect.  If in doubt, they should write MUD files that are
      somewhat more permissive if the files result in no spurious alerts.</t>
    </section>
  </middle>
  <back>
    <displayreference target="I-D.ietf-snac-simple" to="AUTO-STUB-NETWORKS"/>
    <references anchor="sec-combined-references">
      <name>References</name>
      <references anchor="sec-normative-references">
        <name>Normative References</name>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8520.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.1794.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9499.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9019.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8094.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8250.xml"/>
      </references>
      <references anchor="sec-informative-references">
        <name>Informative References</name>

        <reference anchor="AmazonS3" target="https://en.wikipedia.org/w/index.php?title=Amazon_S3&amp;oldid=1280379498">
          <front>
            <title>Amazon S3</title>
            <author>
              <organization>Wikipedia</organization>
            </author>
            <date day="14" month="March" year="2025"/>
          </front>
        </reference>

        <reference anchor="Akamai" target="https://en.wikipedia.org/w/index.php?title=Akamai_Technologies&amp;oldid=1277665363">
          <front>
            <title>Akamai Technologies</title>
            <author>
              <organization>Wikipedia</organization>
            </author>
            <date day="26" month="February" year="2025"/>
          </front>
        </reference>

        <reference anchor="mudmaker" target="https://mudmaker.org">
          <front>
            <title>MUD Maker</title>
            <author>
              <organization/>
            </author>
            <date/>
          </front>
        </reference>

        <reference anchor="antipattern" target="https://www.agilealliance.org/glossary/antipattern">
          <front>
            <title>AntiPattern</title>
            <author>
              <organization>Agile Alliance</organization>
            </author>
            <date/>
          </front>
        </reference>

        <reference anchor="boywhocriedwolf" target="https://en.wikipedia.org/w/index.php?title=The_Boy_Who_Cried_Wolf&amp;oldid=1274257821">
          <front>
            <title>The Boy Who Cried Wolf</title>
            <author>
              <organization>Wikipedia</organization>
            </author>
            <date year="2025" month="February" day="6"/>
          </front>
        </reference>

        <reference anchor="awss3virtualhosting" target="https://techmonitor.ai/techonology/cloud/aws-s3-path-deprecation">
          <front>
            <title>Down to the Wire: AWS Delays 'Path-Style' S3 Deprecation at Last Minute</title>
            <author>
              <organization>Tech Monitor</organization>
            </author>
            <date year="2020" month="September" day="24"/>
          </front>
        </reference>

        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7858.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8484.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9250.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6707.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6146.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6147.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6066.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9238.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7871.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8106.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9463.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9462.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6762.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-snac-simple.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8882.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9230.xml"/>
      </references>
    </references>

<section anchor="failingstrategy">
      <name>A Failing Strategy: Anti-Patterns</name>
      <t>Attempts to map IP addresses to DNS names in real time often fail for a number of reasons:</t>
      <ol spacing="normal" type="1">
	<li>
          <t>It can not be done fast enough.</t>
        </li>
        <li>
          <t>It reveals usage patterns of the devices.</t>
        </li>
        <li>
          <t>The mappings are often incomplete.</t>
        </li>
        <li>
          <t>Even if the mapping is present, due to virtual hosting, it may
          not map back to the name used in the ACL.</t>
        </li>
      </ol>

      <t>This is not a successful strategy for the reasons explained below.</t>
      <section anchor="too-slow">
        <name>Too Slow</name>
        <t>Mappings of IP addresses to DNS names require a DNS lookup in the
        in-addr.arpa or ip6.arpa space.  For a cold DNS cache, this will
        typically require 2 to 3 NS record lookups to locate the DNS server
        that holds the information required.  At 20 to 100 ms per round trip,
        this easily adds up to a significant amount of time before the packet
        that caused the lookup can be released.</t>
        <t>While subsequent connections to the same site (and subsequent
        packets in the same flow) will not be affected if the results are
        cached, the effects will be felt.  The ACL results can be cached for a
        period of time given by the TTL of the DNS results, but the DNS lookup
        must be repeated, e.g., in a few hours or days, when the cached binding (of IP
        address to name) expires.</t>
      </section>
      <section anchor="reveals-patterns-of-usage">
        <name>Reveals Patterns of Usage</name>
        <t>By doing the DNS lookups when the traffic occurs, then a passive
        attacker can see when the device is active and may be able to derive
        usage patterns.  They could determine when a home was occupied or not.
        This does not require access to all on-path data, just to the DNS
        requests to the bottom level of the DNS tree.</t>
      </section>
      <section anchor="mappings-are-often-incomplete">
        <name>Mappings Are Often Incomplete</name>
        <t>An IoT manufacturer with a cloud service provider that fails to
        include an A or AAAA record as part of their forward name publication
        will find that the new server is simply not used.  The operational
        feedback for that mistake is immediate.  The same is not true for
        reverse DNS mappings: They can often be incomplete or incorrect for
        months or even years without a visible effect on operations.</t>
        <t>IoT manufacturer cloud service providers often find it difficult to
        update reverse DNS maps in a timely fashion, assuming that they can do
        it at all.  Many cloud-based solutions dynamically assign IP addresses
        to services, often as the service grows and shrinks, reassigning those
        IP addresses to other services quickly.  The use of HTTP 1.1 Virtual
        Hosting may allow addresses and entire front-end systems to be reused
        dynamically without even reassigning the IP addresses.</t>
        <t>In some cases, there are multiple layers of CNAME between the
        original name and the target service name.  This is often due to a
        load-balancing layer in the DNS followed by a load-balancing layer at
        the HTTP level.</t>
        <t>The reverse DNS mapping for the IP address of the load balancer
        usually does not change.  If hundreds of web services are funneled
        through the load balancer, it would require hundreds of PTR records to
        be deployed.  This would easily exceed the UDP/DNS and EDNS0 limits
        and require all queries to use TCP, which would further slow
        down loading of the records.</t>
        <t>The enumeration of all services/sites that have been at that
        load balancer might also constitute a security concern.  To limit
        the churn of DNS PTR records and reduce failures of the MUD ACLs,
        operators would want to add all possible DNS names for each reverse
        DNS mapping, whether or not the DNS load-balancing in the forward DNS
        space lists that endpoint at that moment.</t>
      </section>
      <section anchor="forward-dns-names-can-have-wildcards">
        <name>Forward DNS Names Can Have Wildcards</name>
        <t>In some large hosting providers, content is hosted through a domain
        name that is published as a DNS wildcard (and uses a wildcard
        certificate).  For instance, github.io, which is used for hosting
        content, including the Editors' copy of Internet-Drafts stored on
        GitHub, does not actually publish any DNS names.  Instead, a wildcard
        exists to answer all potential DNS names: Requests are routed
        appropriately once they are received.</t>
        <t>This kind of system works well for self-managed hosted content.
        However, while it is possible to insert up to a few dozen PTR records,
        many thousands of entries are not possible, nor is it possible to deal
        with the unlimited (infinite) number of possibilities that a wildcard
        supports.</t>
        <t>Therefore, it would be impossible for the PTR reverse lookup to
        ever work with these wildcard DNS names.</t>
      </section>
    </section>
    <section anchor="contributors" numbered="false" toc="include">
      <name>Contributors</name>
      <contact initials="T." surname="Reddy.K" fullname="Tirumaleswar Reddy.K">
        <organization>Nokia</organization>
        <address>
      </address>
      </contact>
    </section>
  </back>
</rfc>
