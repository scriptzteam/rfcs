<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>

<rfc xmlns:xi="http://www.w3.org/2001/XInclude" submissionType="IETF" category="std" consensus="true" docName="draft-ietf-ace-mqtt-tls-profile-17" number="9431" ipr="trust200902" obsoletes="" updates="" xml:lang="en" tocInclude="true" tocDepth="4" symRefs="true" sortRefs="true" version="3">

  <!-- xml2rfc v2v3 conversion 3.12.2 -->
  <front>
        <title abbrev="MQTT-TLS Profile of ACE">Message Queuing Telemetry Transport (MQTT) and Transport Layer Security (TLS) Profile of Authentication
and Authorization for Constrained Environments (ACE) Framework</title>
	<seriesInfo name="RFC" value="9431"/>
        <author fullname="Cigdem Sengul" initials="C." surname="Sengul">
      <organization>Brunel University</organization>
      <address>
        <postal>
          <street>Dept. of Computer Science</street>
          <city>Uxbridge</city>
          <code>UB8 3PH</code>
          <country>United Kingdom</country>
        </postal>
        <email>csengul@acm.org</email>
      </address>
    </author>
    <author fullname="Anthony Kirby" initials="A." surname="Kirby">
      <organization>Oxbotica</organization>
      <address>
        <postal>
          <extaddr>1a Milford House</extaddr>
	    <street>Mayfield Road, Summertown</street>
            <city>Oxford</city>
          <code>OX2 7EL</code>
          <country>United Kingdom</country>
        </postal>
        <email>anthony@anthony.org</email>
      </address>
    </author>
    <date month="July" year="2023"/>
    <area>sec</area>
    <workgroup>ace</workgroup>

<keyword>publish-subscribe</keyword>
<keyword>authorization information format</keyword>
        <abstract>
      <t>
                This document specifies a profile for the Authentication and Authorization for Constrained
                Environments (ACE) framework to enable authorization in a publish-subscribe messaging system based on Message Queuing Telemetry Transport
                (MQTT).
                Proof-of-Possession keys, bound to OAuth 2.0 access tokens, are used to authenticate and authorize
                MQTT Clients. The protocol relies on TLS for confidentiality and MQTT server (Broker) authentication.
      </t>
    </abstract>
  </front>
  <middle>
    <section numbered="true" toc="default">
      <name>Introduction</name>
      <t>
                This document specifies a profile for the ACE framework <xref target="RFC9200" format="default"/>.
                In this profile, Clients and Servers (Brokers) use MQTT to exchange Application Messages.
                The protocol relies on TLS for communication security between entities. The MQTT protocol interactions
                are described based on the <xref target="MQTT-OASIS-Standard-v5" format="default">MQTT v5.0 OASIS Standard</xref>.
                Since it is expected that MQTT deployments will continue to support MQTT v3.1.1 Clients,
		        this document also describes a reduced set of protocol interactions for the
                <xref target="MQTT-OASIS-Standard-v3.1.1" format="default">MQTT v3.1.1 OASIS Standard</xref>.
		        However, MQTT v5.0 is the <bcp14>RECOMMENDED</bcp14> version, as it works more naturally
                with ACE-style authentication and authorization.
      </t>
      <t>
                MQTT is a publish-subscribe protocol, and
                after connecting to the MQTT Server (Broker), a Client can publish and subscribe to multiple topics.
                The Broker, which acts as the Resource Server (RS), is responsible for distributing messages published 
                by the publishers to their subscribers. In the rest of the
                document, the terms "RS", "MQTT Server", and "Broker" are used interchangeably.
      </t>
      <t>
                Messages are published under a Topic Name,
                and subscribers subscribe to the Topic Names to receive the corresponding messages.
                The Broker uses the Topic Name in a published message to determine which
                subscribers to relay the messages to.
                In this document, topics (more specifically, Topic Names) are treated as resources.
                The Clients are assumed to have identified the publish/subscribe topics of interest out of band
                (topic discovery is not a feature of the MQTT protocol).
                A Resource Owner can preconfigure policies at the Authorization Server (AS) 
                that give Clients publish or subscribe permissions to different topics.
      </t>
      <t>
                Clients prove their permission to publish and subscribe to topics hosted on an MQTT Broker
                using an access token that is bound to a Proof-of-Possession (PoP) key.
                This document describes how to authorize the following exchanges between the
                Clients and the Broker.
      </t>
      <ul spacing="normal">
        <li>connection requests from the Clients to the Broker</li>
        <li>publish requests from the Clients to the Broker and from the Broker to the Clients</li>
        <li>subscribe requests from the Clients to the Broker</li>
      </ul>
      <t>
                Clients use the MQTT PUBLISH packet to publish to a topic.
                The mechanisms specified in this document do not protect the Payload of the PUBLISH packet from the Broker. Hence,
                the Payload is not signed or encrypted specifically for the subscribers. This functionality may 
                be implemented using the proposal outlined in the 
                <xref target="I-D.ietf-ace-pubsub-profile" format="default">ACE Pub-Sub Profile</xref>.
      </t>
      <t>
                To provide communication confidentiality and Broker authentication to the MQTT Clients, TLS is used, and
                TLS 1.3 <xref target="RFC8446" format="default"/> is <bcp14>RECOMMENDED</bcp14>.
		This document makes the same assumptions as
		        <xref target="RFC9200" format="default" sectionFormat="of" section="4">the ACE framework</xref> regarding Client and RS
                registration with the AS for setting up the keying material.
                While the Client-Broker exchanges are only over MQTT, the required Client-AS and
                RS-AS interactions are described for HTTPS-based communication <xref target="RFC9110" format="default"/>, 
                using the "application/ace+json"
                content type and, unless otherwise specified, JSON encoding. The token <bcp14>MAY</bcp14> be an
                opaque reference to authorization information  or a JSON Web Token (JWT) <xref target="RFC7519" format="default"/>.
                For JWTs, this document follows <xref target="RFC7800" format="default"/>
                for PoP semantics for JWTs, and the mechanisms for providing and verifying PoP
                are detailed in  <xref target="connect_v5" format="default"/>. The Client-AS and RS-AS exchanges <bcp14>MAY</bcp14> also use protocols other than HTTP,
                e.g., Constrained Application Protocol (CoAP) <xref target="RFC7252" format="default"/> or MQTT. It is recommended
                that TLS is used to secure these communication channels between Client-AS and RS-AS.
                To reduce the protocol memory and bandwidth
                requirements, implementations <bcp14>MAY</bcp14> also use the "application/ace+cbor" content type, Concise Binary Object Representation (CBOR) encoding <xref target="RFC8949" format="default"/>,
                CBOR Web Tokens (CWTs) <xref target="RFC8392" format="default"/>, and associated PoP semantics.  For more information, see <xref target="RFC8747" format="default">"Proof-of-Possession Key
                Semantics for CBOR Web Tokens (CWTs)"</xref>.
                A JWT uses JSON Object Signing and Encryption (JOSE), while a CWT uses CBOR Object Signing and Encryption (COSE) <xref target="RFC9052" format="default"/> for security protection.
      </t>
      <section numbered="true" toc="default">
        <name>Requirements Language</name>
        <t>
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL
    NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as
    described in BCP&nbsp;14 <xref target="RFC2119"/> <xref target="RFC8174"/> 
    when, and only when, they appear in all capitals, as shown here.
        </t>
      </section>
      <section numbered="true" toc="default">
        <name>ACE-Related Terminology</name>
<t>
     Certain security-related terms, such as "authentication",
   "authorization", "data confidentiality", "(data) integrity", "message
   authentication code" (MAC), and "verify", are taken from <xref target="RFC4949" format="default"/>.
        </t>
        <t>
                    The terminology for entities in the architecture is defined in OAuth 2.0 <xref target="RFC6749" format="default"/>, such as "Client" (C),
                     "Resource Server" (RS), and "Authorization Server" (AS).
        </t>
        <t>
                    The term "resource" is used to refer to an MQTT Topic Name, which is defined in <xref target="mqtt-defs" format="default"/>.
                    Hence, the "Resource Owner" is any entity that can authoritatively speak for the topic.
                    This document also defines a Client Authorization Server for Clients that are not 
                    able to support HTTP.
        </t>
        <dl newline="true" spacing="normal" indent="8">
          <dt>Client Authorization Server (CAS)</dt>
          <dd>
                  An entity that prepares and endorses authentication and authorization data for a Client 
                  and communicates to the AS using HTTPS.
                  </dd>
        </dl>
      </section>
      <section anchor="mqtt-defs" numbered="true" toc="default">
        <name>MQTT-Related Terminology</name>
        <t>
                    The document describes message exchanges as MQTT protocol interactions.    The Clients are MQTT Clients, which connect to the
   Broker to publish and subscribe to Application Messages (which are
   labeled with their topics). For additional information,
                    please refer to the <xref target="MQTT-OASIS-Standard-v5" format="default">MQTT v5.0 OASIS Standard
                     </xref> or <xref target="MQTT-OASIS-Standard-v3.1.1" format="default">MQTT v3.1.1 OASIS Standard
                      </xref>.
        </t>
        <dl newline="true" spacing="normal" indent="8">
          <dt>Broker</dt>
          <dd>
                            The Server in MQTT. It acts as an intermediary between the Clients that publish Application Messages
                            and the Clients that made Subscriptions. The Broker acts as the Resource Server for the Clients.
                        </dd>
          <dt>Client</dt>
          <dd>
                            A device or program that uses MQTT.
                        </dd>
          <dt>Network Connection</dt>
          <dd>
                            A construct provided by the underlying transport protocol that is being used by MQTT. 
                            It connects the Client to the Server. It provides the means to send an ordered, lossless 
                            stream of bytes in both directions. This document uses TLS as the transport protocol.
                        </dd>
          <dt>Session</dt>
          <dd>
                            A stateful interaction between a Client and a Broker.
                            Some Sessions last only as long as the Network Connection;
                            others can span multiple Network Connections.
                        </dd>
          <dt>Application Message</dt>
          <dd>
                            The data carried by the MQTT protocol. The data has an associated Quality-of-Service (QoS) level and Topic
                            Name.
                        </dd>
          <dt>MQTT Control Packet</dt>
          <dd>
                           The MQTT protocol operates by exchanging a series of MQTT Control Packets.
                           Each packet is composed of a Fixed Header, a Variable Header (depending
                           on the Control Packet type), and a Payload.
                        </dd>
          <dt>UTF-8-encoded string</dt>
          <dd>
                            A string prefixed with a two-byte-length field that gives the number of bytes in a UTF-8-encoded string itself.
                            Unless stated otherwise, all UTF-8-encoded strings can have any length in the range 0 to 65535 bytes.
                        </dd>
          <dt>Binary Data</dt>
          <dd>
                            Binary Data is represented by a two-byte-length field, which indicates the number of data bytes, followed by that number of bytes. 
                            Thus, the length of Binary Data is limited to the range of 0 to 65535 bytes.
                        </dd>
          <dt>Variable Byte Integer</dt>
          <dd>
                            A Variable Byte Integer is encoded using an encoding scheme that uses a single byte for values up to 127. 
                            For larger values, the least significant seven bits of each byte encode the data, 
                            and the most significant bit is used to indicate whether there are bytes following in
                            the representation. Thus, each byte encodes 128 values and a "continuation bit". 
                            The maximum number of bytes in the Variable Byte Integer field is four.
                        </dd>
          <dt>QoS level</dt>
          <dd>
                            The level of assurance for the delivery of an Application Message. The QoS level can be 0-2,
                            where 0 indicates "At most once delivery", 1 indicates "At least once delivery", and 2 indicates "Exactly once delivery".
                        </dd>
          <dt>Property</dt>
          <dd>
                            The last field of the Variable Header is a set of properties
                            for several MQTT Control Packets (e.g., CONNECT and CONNACK).
                            A property consists of an Identifier that defines its usage and data type, followed by a value.
                            The Identifier is encoded as a Variable Byte Integer. For example, the "Authentication Data" property
                            uses the identifier 22.
                        </dd>
          <dt>Topic Name</dt>
          <dd>
                            The label attached to an Application Message, which is matched to a Subscription.
                        </dd>
          <dt>Subscription</dt>
          <dd>
                            A Subscription comprises a Topic Filter and a maximum QoS. A Subscription is associated with a single Session.
                        </dd>
          <dt>Topic Filter</dt>
          <dd>
                            An expression that indicates interest in one or more Topic Names. Topic Filters may include
                            wildcards.
                        </dd>
        </dl>
        <t>
                    MQTT sends various Control Packets across a Network Connection.
                    The following is not an exhaustive list, and the Control Packets that are not relevant for
                    authorization are not explained.
                    For instance, these include the PUBREL and PUBCOMP packets used in the 4-step handshake required
                    for QoS level 2.
        </t>
        <dl newline="true" spacing="normal" indent="8">
          <dt>CONNECT</dt>
          <dd>
                            The Client requests to connect to the Broker. This is
                            the first packet sent by a Client.
                        </dd>
          <dt>CONNACK</dt>
          <dd>
                            The Broker connection acknowledgment. CONNACK packets
                            contain return codes that indicate either a success or an error state
                            in response to a Client's CONNECT packet.
                        </dd>
          <dt>AUTH</dt>
          <dd>
                            An AUTH Control Packet is sent from the Client to the Broker or
                            from the Broker to the Client as part of an extended authentication exchange.
                            AUTH properties include the Authentication Method and Authentication Data.
                            The Authentication Method is set in the CONNECT packet, and consequent
                            AUTH packets follow the same Authentication Method.
                            The contents of the Authentication Data are defined by the Authentication Method.
                        </dd>
          <dt>PUBLISH</dt>
          <dd>
                            Publish request sent from a publishing Client to the Broker or from the Broker to a
                            subscribing Client.
                        </dd>
          <dt>PUBACK</dt>
          <dd>
                            Response to a PUBLISH request with QoS level 1. PUBACK can be sent from the Broker to a
                            Client or from a Client to the Broker.
                        </dd>
          <dt>PUBREC</dt>
          <dd>
                            Response to a PUBLISH request with QoS level 2. PUBREC can be sent from the Broker to a
                            Client or from a Client to the Broker.
                        </dd>
          <dt>SUBSCRIBE</dt>
          <dd>
                            Subscribe request sent from a Client.
                        </dd>
          <dt>SUBACK</dt>
          <dd>
                            Subscribe acknowledgment from the Broker to the Client.
                        </dd>
          <dt>PINGREQ</dt>
          <dd>
			                A ping request sent from a Client to the Broker.  It signals to the Broker that the Client is alive and
			                is used to confirm that the Broker is also alive. The "Keep Alive" period is set in the CONNECT packet.
			            </dd>
          <dt>PINGRESP</dt>
          <dd>
			                Response sent by the Broker to the Client in response to PINGREQ. It indicates the Broker is alive.
			            </dd>
          <dt>DISCONNECT</dt>
          <dd>
                            The DISCONNECT packet is the final MQTT Control Packet 
                            sent from the Client or the Broker. 
                            It indicates the reason why the Network Connection is being closed.
                            If the Network Connection is closed without the Client first sending a 
                            DISCONNECT packet with reason code 0x00 (Normal disconnection) and 
                            the MQTT Connection has a Will Message, the Will Message is published. 
                        </dd>
          <dt>Will</dt>
          <dd>
            <t>
                            If the Network Connection is not closed normally, the Broker sends a last Will Message
                            for the Client if the Client provided one in its CONNECT packet.
                            Situations in which the Will Message is published include, but are not limited to, the following:
            </t>
            <ul spacing="normal">
              <li>an I/O error or network failure detected by the Broker,</li>
              <li>the Client fails to communicate within the Keep Alive period,</li>
              <li>the Client closes the Network Connection without first sending a DISCONNECT packet with reason code 0x00 (Normal disconnection), and</li>
              <li>the Broker closes the Network Connection without first receiving a DISCONNECT packet with reason code 0x00 (Normal disconnection).</li>
            </ul>
            <t>
                            If the Will Flag is set in the CONNECT flags, then the Payload of the CONNECT packet includes information
                            about the Will. The information consists of the Will Properties, Will Topic,
                            and Will Payload fields.
            </t>
          </dd>
        </dl>
      </section>
    </section>
    <section anchor="token_acquisition" numbered="true" toc="default">
      <name>Authorizing Connection Requests</name>
      <t>
            This section specifies how Client connections are authorized by the AS 
            and verified by the MQTT Broker. <xref target="protocol_flow" format="default"/> shows the basic protocol flows 
            during connection setup. The token request and response use the token endpoint 
            at the AS, specified for HTTP-based interactions in <xref target="RFC9200" format="default" sectionFormat="of" section="5.8">the ACE framework</xref>. 
            Steps (D) and (E) are optional and use the introspection endpoint specified in <xref target="RFC9200" format="default" sectionFormat="of" section="5.9"> the ACE framework</xref>.
            The discussion in this document assumes that the Client and the Broker use HTTPS to communicate 
            with the AS via these endpoints. The Client and the Broker use MQTT to communicate between them.
            The C-AS and Broker-AS communications <bcp14>MAY</bcp14> be implemented using protocols other than HTTPS,
            e.g., CoAP or MQTT.  Whatever protocol is used for the C-AS and Broker-AS communications <bcp14>MUST</bcp14> provide mutual
            authentication, confidentiality protection, and integrity protection.
      </t>
      <t>
            If the Client is resource constrained or does not support HTTPS, a separate Client Authorization Server
            may carry out the token request on behalf of the Client (<xref target="protocol_flow"/>, steps (A) and (B)) and, later, onboard the Client with the token.
            The interactions between a Client and its Client Authorization Server for token
            onboarding and support for MQTT-based token requests at the AS are out of the scope of this document.
      </t>
      <figure anchor="protocol_flow">
        <name>Connection Setup</name>
        <artwork align="left" name="" type="" alt=""><![CDATA[
                              +---------------------+
                              | Client              |
                              |                     |
   +---(A) Token request------| Client -            |
   |                          | Authorization       |
   |   +-(B) Access token-----> Server Interface    |
   |   |                      |       (HTTPS)       |
   |   |                      |_____________________|
   |   |                      |                     |
+--v-------------+            |  Pub/Sub Interface  |
|  Authorization |            |   (MQTT over TLS)   |
|  Server        |            +----------------^----+
|________________|                 |           |
   |    ^                 (C) Connection   (F) Connection
   |    |                     request +        response
   |    |                     access token     |
   |    |                          |           |
   |    |                      +---v--------------+
   |    |                      |     Broker       |
   |    |                      |  (MQTT over TLS) |
   |    |                      |__________________|
   |    +(D) Introspection-----|                  |
   |         request (optional)| RS-AS interface  |
   |                           |     (HTTPS)      |
   +-(E) Introspection-------->|__________________|
         response (optional)
           ]]></artwork>
      </figure>
      <section numbered="true" toc="default">
        <name>Client Token Request to the Authorization Server (AS)</name>
        <t>
                The first step in the protocol flow (<xref target="protocol_flow"/>, step (A)) is the token acquisition by the Client
                from the AS. The Client and the AS <bcp14>MUST</bcp14> perform mutual authentication.
                The Client requests an access token from the AS, as
                described in <xref target="RFC9200" format="default" sectionFormat="of" section="5.8.1">the ACE framework</xref>. 
                The document follows the procedures defined in <xref target="RFC9202" format="default" sectionFormat="of" section="3.2.1">the DTLS profile</xref>
                for raw public keys (RPKs) <xref target="RFC7250" format="default"/>) and in <xref target="RFC7250" section="3.3.1" sectionFormat="of" format="default"/> for pre-shared keys (PSKs).
                However, the content type of the request is set to "application/ace+json", 
                and the AS uses JSON in the Payload of its responses to the Client and the RS.
                As explained earlier, implementations <bcp14>MAY</bcp14> also use the  "application/ace+cbor" content type.
        </t>
        <t> On receipt of the token request, the AS verifies the request. 
                If the AS successfully verifies the access token request and authorizes the Client for the
                indicated audience (i.e., RS) and scopes (i.e., publish/subscribe permissions over topics, as described
                in <xref target="scope" format="default"/>),
                the AS issues an access token (<xref target="protocol_flow"/>, step (B)). 
        </t>
        <t>The response includes the parameters described
                in <xref target="RFC9200" section="5.8.2" sectionFormat="of" format="default">the ACE framework</xref>.
                For RPKs, the parameters are as described 
                in <xref target="RFC9202" section="3.2.1" sectionFormat="of" format="default">the DTLS profile</xref>. 
                For PSKs, the document follows <xref target="RFC9202" format="default" sectionFormat="of" section="3.3.1">the DTLS profile</xref>.
                In both cases,  if the response contains an "ace_profile" parameter, this parameter is set
                to "mqtt_tls".
                The returned token is a Proof-of-Possession (PoP) token by default.
        </t>
        <t>
                This document follows <xref target="RFC7800" format="default"/> for PoP semantics for JWTs 
                (CWTs <bcp14>MAY</bcp14> also be used). The AS includes a "cnf" (confirmation) parameter in the PoP token 
                to declare that the Client 
                possesses a particular key and the RS can cryptographically confirm that 
                the Client has possession of that key, as described in <xref target="RFC9201" format="default"/>.
        </t>
        <t>
                Note that the contents of the web tokens (including the "cnf" parameter) are to be consumed by the RS 
                and not the Client (the Client obtains the key information in a different manner).
                The RPK case is handled as described in <xref target="RFC9202" format="default" sectionFormat="of" section="3.2.1">the DTLS profile</xref>.
                For the PSK case, the referenced procedures apply, with the following exceptions to accommodate 
                JWT and JOSE use. 
                In this case, the AS adds a "cnf" parameter to the Access Information 
                carrying  <xref target="RFC7517" format="default">a JSON Web Key (JWK)</xref> object that contains 
                 either the symmetric key itself or a key identifier that can be used by the RS to 
                 determine the secret key it shares with the Client. 
                The JWT is created as explained in <xref target="RFC7519" section="7" sectionFormat="of" format="default"/>, 
                 and the JWT <bcp14>MUST</bcp14> include <xref target="RFC7516" format="default"> a JSON Web Encryption (JWE)</xref>.
                If a CWT/COSE is used, this information <bcp14>MUST</bcp14> be inside the "COSE_Key" object 
                and <bcp14>MUST</bcp14> be encrypted using a "COSE_Encrypt0" structure.
        </t>
        <t> The AS returns error responses for JSON-based interactions
                following <xref target="RFC6749" section="5.2" sectionFormat="of" format="default"/>.
                When CBOR is used, the interactions <bcp14>MUST</bcp14> implement the procedure described in 
                <xref target="RFC9200" format="default" section="5.8.3" sectionFormat="of">the ACE framework</xref>.
        </t>
      </section>
      <section anchor="connect_v5" numbered="true" toc="default">
        <name>Client Connection Request to the Broker (C)</name>
        <section anchor="auth_options" numbered="true" toc="default">
          <name>Overview of Client-RS Authentication Methods over TLS and MQTT</name>
          <t>
                    Unless the Client publishes and subscribes to only public topics, the Client and the Broker <bcp14>MUST</bcp14> perform mutual authentication.
                    The Client <bcp14>MUST</bcp14> authenticate to the Broker either over MQTT or TLS before performing any other action.
                    For MQTT, the options are "None" and "ace".
                    For TLS, the options are "Anon" for an anonymous client,
                    and "Known(RPK/PSK)" for RPKs and PSKs, respectively.
                    The "None" and "Anon" options do not provide client authentication but can be used either
                    during authentication or in combination with authentication at the other layer.
                    When the Client uses TLS:Anon,MQTT:None, the Client can only publish or subscribe to public topics.
                    Thus, the client authentication procedures involve the following possible combinations:
          </t>
          <dl newline="true" spacing="normal" indent="8">
            <dt>TLS:Anon,MQTT:None:</dt> <dd>This option is used only for the topics that do not require authorization,
                            including the "authz-info" topic. Publishing to the "authz-info" topic is described in <xref target="app-authzinfo" format="default"/>.</dd>
            <dt>TLS:Anon,MQTT:ace:</dt> <dd>The token is transported inside the CONNECT packet and <bcp14>MUST</bcp14> be
                            validated using one of the methods described in <xref target="app-authzinfo" format="default"/>. This option also supports
                            a tokenless connection request for AS discovery.  As per the <xref target="RFC9200" format="default">ACE framework</xref>, 
                            a separate step is needed to determine whether the discovered AS URI is authorized to act as an AS.</dd>
            <dt>TLS:Known(RPK/PSK),MQTT:none:</dt> <dd>This specification supports client authentication with TLS with RPKs and PSKs, following the procedures 
                            described in the <xref target="RFC9202" format="default">DTLS profile</xref>. 
                             For the RPK, the Client
                            <bcp14>MUST</bcp14> have published the token to the "authz-info" topic. For the PSK, the token <bcp14>MAY</bcp14> be published to the "authz-info" topic 
                            or <bcp14>MAY</bcp14> be, alternatively, 
                            provided as a  "PSK identity" (e.g., an "identity" in the "identities" field in the Client's "pre_shared_key" extension in TLS 1.3).
                        </dd>
            <dt>TLS:Known(RPK/PSK),MQTT:ace:</dt> <dd>This option <bcp14>SHOULD NOT</bcp14> be chosen as the token transported in the CONNECT packet and
                            overwrites any permissions passed during the TLS authentication.</dd>
          </dl>
          <t>
                     It is <bcp14>RECOMMENDED</bcp14> that the Client implements TLS:Anon,MQTT:ace as the first choice when working with protected topics.
                     However, MQTT v3.1.1 Clients that do not prefer to overload the User Name and Password fields 
                     for ACE (as described in <xref target="MQTTv311" format="default"/>) <bcp14>MAY</bcp14> implement TLS:Known(RPK/PSK),MQTT:none and,
                     consequently, TLS:Anon,MQTT:None to submit their token to "authz-info".
          </t>
          <t>
                     The Broker <bcp14>MUST</bcp14> support TLS:Anon,MQTT:ace.
                     To support Clients with different capabilities, the Broker <bcp14>MAY</bcp14> provide multiple client authentication options,
                     e.g., support TLS:Known(RPK),MQTT:none and TLS:Anon,MQTT:None,
                     to enable RPK-based client authentication.
          </t>
          <t>
                    The Client <bcp14>MUST</bcp14> authenticate the Broker during the TLS handshake.
                    If the Client authentication uses TLS:Known(RPK/PSK),
                    then the Broker is authenticated using the respective method.
                    Otherwise, to authenticate the Broker, the Client <bcp14>MUST</bcp14> validate a
                    public key from an X.509 certificate or an RPK from the Broker against the
                    "rs_cnf" parameter in the token response, which contains information
                    about the public key used by the RS to authenticate if the token type is "pop" 
                    and asymmetric keys are used as defined in <xref target="RFC9201" format="default"/>.
                    The AS <bcp14>MAY</bcp14> include the thumbprint of the RS's X.509 certificate in the "rs_cnf"
                    (thumbprint, as defined in <xref target="RFC9360" format="default"/>). In this case,
                    the Client <bcp14>MUST</bcp14> validate the RS certificate against this thumbprint.
          </t>
        </section>
        <section anchor="app-authzinfo" numbered="true" toc="default">
          <name>authz-info: The Authorization Information Topic</name>
          <t>
                    In the cases when the Client must transport the token to the Broker first,
                    the Client connects to the Broker to publish its token to the "authz-info" topic.
                    The "authz-info" topic <bcp14>MUST</bcp14> only be published (i.e., the Clients are not allowed to subscribe to it).
                    "authz-info" is not protected, and hence, the Client uses the TLS:Anon,MQTT:None option over a TLS connection.
                    After publishing the token, the Client disconnects from the Broker and is expected to reconnect
                    using client authentication over TLS (i.e., TLS:Known(RPK/PSK),MQTT:none).
          </t>
          <t>
                    The Broker stores and indexes all tokens received to the "authz-info" topic in its key store
                    (similar to the <xref target="RFC9202" format="default">DTLS profile for ACE</xref>).
                    This profile follows the recommendation of
                    <xref target="RFC9200" format="default" sectionFormat="of" section="5.10.1">the ACE framework</xref>
                    and expects that the Broker stores only one token per PoP key, and any other
                    token linked to the same key overwrites an existing token.
          </t>
          <t>
                    The Broker <bcp14>MUST</bcp14> verify the validity of the token
                    (i.e., through local validation or introspection if the token is a reference),
                    as described in <xref target="token_validation" format="default"/>.
                    If the token is not valid, the Broker <bcp14>MUST</bcp14> discard the token.
          </t>
          <t>
                    Depending on the QoS level of the PUBLISH packet, the Broker returns
                    the error response as a PUBACK, PUBREC, or DISCONNECT packet.
                    If the QoS level is equal to 0, and the token is not valid, or if the claims
                    cannot be obtained in the case of an introspected token, the Broker <bcp14>MUST</bcp14>
                    send a DISCONNECT packet with reason code 0x87 (Not authorized).
                    If the PUBLISH Payload does not parse to a token, the Broker <bcp14>MUST</bcp14> send a DISCONNECT with
                    reason code 0x99 (Payload format invalid).
          </t>
          <t>
                    If the QoS level of the PUBLISH packet is greater than or equal to 1, and the token is not valid, or
                    the claims cannot be obtained in the case of an introspected token,
                    the Broker <bcp14>MUST</bcp14> send reason code 0x87 (Not authorized) in the PUBACK or PUBREC.  If the PUBLISH Payload does not parse to a token,
                    the PUBACK/PUBREC reason code is 0x99 (Payload format invalid).
          </t>
          <t>
                    When the Broker sends the "Not authorized" response, it must be noted that this corresponds
                    to the token being not valid and not that the actual PUBLISH packet was not authorized.
                    Given that the "authz-info" is a public topic, this response is not
                    expected to cause confusion.
          </t>
        </section>
        <section anchor="auth-TLS" numbered="true" toc="default">
          <name>Client Authentication over TLS</name>
          <t>
                 This document supports TLS with raw public keys (RPKs) 
                <xref target="RFC7250" format="default"/> and with pre-shared keys (PSKs).
                The TLS session setup follows the
                <xref target="RFC9202" format="default">DTLS profile for ACE</xref>, 
                  as the profile applies to TLS equally well 
                  <xref target="RFC9430" format="default"/>. 
                When there are exceptions to the DTLS profile, these are explicitly 
                stated in the document.
                If TLS 1.2 is used, <xref target="RFC7925" format="default"/> describes 
                how TLS can be used for constrained devices, alongside recommended cipher suites. 
                Additionally, TLS 1.2 implementations <bcp14>MUST</bcp14> use the "Extended Main Secret" extension (terminology adopted 
                from <xref target="I-D.ietf-tls-rfc8446bis" format="default"/>)
                to incorporate the handshake transcript into the main secret  <xref target="RFC7627" format="default"/>.  TLS implementations <bcp14>SHOULD</bcp14> use the

                Server Name Indication (SNI) <xref target="RFC6066" format="default"/> and Application-Layer Protocol Negotiation (ALPN) 
                <xref target="RFC7301" format="default"/> extensions so the TLS handshake authenticates as much of the protocol context as possible.
          </t>
          <section anchor="TLS-RPK" numbered="true" toc="default">
            <name>Raw Public Key Mode</name>
            <t>
                 This document follows the procedures defined in
                 <xref target="RFC9202" format="default" sectionFormat="of" section="3.2.2">the DTLS profile for ACE</xref> with 
                 the following exceptions. 
                 The Client <bcp14>MUST</bcp14> upload the access token to the Broker using the method specified in 
                 <xref target="app-authzinfo" format="default"/> before initiating the handshake.
            </t>
          </section>
          <section anchor="TLS-PSK" numbered="true" toc="default">
            <name>Pre-Shared Key Mode</name>
            <t>
                 This document follows the procedures defined in <xref target="RFC9202" section="3.3.2" sectionFormat="of" format="default">the DTLS profile for ACE</xref> with 
                 the following exceptions. 
            </t>
            <t>
	         To use TLS 1.3 with pre-shared keys, the Client utilizes the PSK
   extension specified in <xref target="RFC8446" format="default"/> using the key conveyed in the "cnf"
   parameter of the AS response.
 The same key is bound to the access token 
                in the "cnf" claim. The Client can upload the token, as specified in 
                 <xref target="app-authzinfo" format="default"/>, before initiating the handshake.
                 When using a previously uploaded token, the Client <bcp14>MUST</bcp14> indicate during the handshake which previously uploaded access token 
                 it intends to use.  To do so, it <bcp14>MUST</bcp14> create a "COSE_Key" or "JWK" structure with the "kid"
                 that was conveyed in the "rs_cnf" claim in the token response from
                 the AS and the key type "symmetric". This structure is then included as the only element 
                 in the "cnf" structure and the encoded value of that "cnf" structure used as a PSK identity in TLS.
                 As an alternative to the access token upload, the Client can provide the most recent access token, 
                 JWT or CWT, as a PSK identity. 
            </t>
            <t>
                In contrast to the <xref target="RFC9202" format="default">DTLS profile for ACE</xref>, 
                a Client <bcp14>MAY</bcp14> omit support for the cipher suites TLS_PSK_WITH_AES_128_CCM_8 and TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8. 
                For TLS 1.2, however, a client <bcp14>MUST</bcp14> support TLS_ECDHE_PSK_WITH_AES_128_GCM_SHA256 for PSKs <xref target="RFC8442" format="default"/> and TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 for RPKs <xref target="RFC8422" format="default"/>, 
                as recommended in <xref target="RFC9325" format="default"/> (and adjusted to be a PSK cipher suite as appropriate). 
            </t>
          </section>
        </section>
        <section anchor="auth-ACE" numbered="true" toc="default">
          <name>Client Authentication over MQTT</name>
          <section anchor="token-CONNECT" numbered="true" toc="default">
            <name>Transporting the Access Token inside the MQTT CONNECT</name>
            <t>
                    This section describes how the Client transports the token to the Broker
                    inside the CONNECT packet. If this method is used,
                    the Client TLS connection is expected to be anonymous, and the Broker is
                    authenticated during the TLS connection setup.
                    The approach described in this section is similar to an earlier proposal
                     by Fremantle, et al. <xref target="Fremantle14" format="default"/>.
            </t>
            <t>
                    After sending the CONNECT packet, the Client <bcp14>MUST</bcp14> wait to receive the CONNACK packet from
                    the Broker. The only packets it is allowed to send are DISCONNECT
                    or AUTH that are in response to the Broker AUTH.
                    Similarly, except for a DISCONNECT and AUTH response from the Client,
                    the Broker <bcp14>MUST NOT</bcp14> process any packets before sending a CONNACK packet.
            </t>
            <t>
		            <xref target="mqtt5_connect_message" format="default"/> shows the structure of the
                    MQTT CONNECT packet used in MQTT v5.0.
                    A CONNECT packet is composed of a Fixed Header, a Variable Header, and a Payload
                    The Fixed Header contains the Control Packet Type (CPT), Reserved, and Remaining Length fields.
                    The Remaining Length is a Variable Byte Integer that represents the number of bytes 
                    remaining within the current Control Packet, including data in the Variable Header and the Payload.
                    The Variable Header contains the Protocol Name, Protocol Level,
                    Connect flags, Keep Alive, and Properties fields.
                    The Connect flags in the Variable Header specify the properties of the MQTT Session.
                    It also indicates the presence or absence of some fields in the Payload.
                    The Payload contains one or more encoded fields, namely a unique Client
                    Identifier for the Client, a Will Topic, Will Payload, User Name, and Password.
                    All but the Client Identifier can be omitted depending on the flags in the Variable Header.
                    The Client Identifier identifies the Client to the Broker and, therefore, 
                    is unique for each Client. It must be noted that the Client Identifier is an unauthenticated identifier
                    used within the MQTT protocol and so is not bound to the access token.
            </t>
            <figure anchor="mqtt5_connect_message">
              <name>MQTT v5 CONNECT Variable Header with Authentication Method Property for ACE</name>
              <artwork align="center" name="" type="" alt=""><![CDATA[    
0             8             16
+---------------------------+
|Protocol name length = 4   |
+---------------------------+
|     'M'            'Q'    |
+---------------------------+
|     'T'            'T'    |
+---------------------------+
|Proto.level=5|Connect flags|          
+---------------------------+
|        Keep alive         |
+---------------------------+
| CONNECT Properties Length |
|      (up to 4 bytes)      |
+---------------------------+ 
| ( ..Other properties..)   |
+---------------------------+
|  Authentication Method    |
|      (0x15)  |   Len      |
|      Len     |   'a'      | 
|      'c'     |   'e'      |
+---------------------------+
|  Authentication Data      |   
|     (0x16)   |    Len     |
|      Len     |   token    | 
|  or token + PoP data      |
+---------------------------+
]]></artwork>
            </figure>
            <t>
                The CONNECT flags are User Name, Password, Will Retain, Will QoS, Will Flag,
                Clean Start, and Reserved.
                <xref target="mqttv5_connect_flags" format="default"/> shows how the
                flags <bcp14>MUST</bcp14> be set to use AUTH packets for authentication and authorization,
                i.e., the User Name Flag and Password Flag <bcp14>MUST</bcp14> be set to 0.
                An MQTT v5.0 Broker <bcp14>MAY</bcp14> also support token transport using the User Name and Password to provide
                a security option for MQTT v3.1.1 Clients, as
                described in  <xref target="MQTTv311" format="default"/>.
            </t>
            <table anchor="mqttv5_connect_flags" align="center">
              <name>CONNECT Flags for AUTH</name>
              <thead>
		<tr>
		  <th>User Name Flag</th>
		  <th>Password Flag</th>
		  <th>Will Retain</th>
		  <th>Will QoS</th>
		  <th>Will Flag</th>
		  <th>Clean Start</th>
		  <th>Reserved</th>
		</tr>
	      </thead>
	      <tbody>
		<tr>
		  <td align="center">0</td>
		  <td align="center">0</td>
		  <td align="center">X</td>
		  <td align="center">X X</td>
		  <td align="center">X</td>
		  <td align="center">X</td>
		  <td align="center">0</td>
		</tr>
	      </tbody>
	    </table>
            <t>
                The Will Flag indicates that a Will Message needs to be sent. 
                The Client <bcp14>MAY</bcp14> set the Will Flag as desired (marked as "X" in <xref target="mqttv5_connect_flags" format="default"/>).
                If the Will Flag is set to 1,  the Broker <bcp14>MUST</bcp14> check that the token
                allows the publication of the Will Message (i.e., the Will Topic Filter is in the scope array). 
                The check is performed against the token scope
                described in <xref target="scope" format="default"/>. If the Will authorization fails, the connection 
                is refused, as described in  <xref target="as_discovery" format="default"/>.
                If the Broker accepts the connection request, the Broker
                stores the Will Message and  publishes it when the Network Connection is closed according to Will QoS,
	            Will Retain parameters, and MQTT Will management rules.  To avoid publishing the Will Messages
                in the case of temporary network disconnections,
                the Client specifies a Will Delay Interval in the Will Properties.
                <xref target="disconnections" format="default"/> explains how the Broker deals with the retained messages in further detail.
            </t>
            <t>
	      In MQTT v5.0, the Client signals a new Session (i.e., that the Session does not continue an existing Session) by setting the Clean Start flag to 1 in the CONNECT packet. In this profile, the Client <bcp14>SHOULD</bcp14> always start with a new Session. The Broker <bcp14>MAY</bcp14> also signal that it does not support the continuation of an existing Session by setting the Session Expiry Interval to 0 in the CONNACK. If the Broker starts a new Session, the Broker <bcp14>MUST</bcp14> set the Session Present flag to 0 in the CONNACK packet to signal this to the Client.
            </t>
            <t>
	       The Broker <bcp14>MAY</bcp14> support continuing an existing Session, e.g., if the Broker requires it for QoS reasons. In this case, if a CONNECT packet is received with Clean Start set to 0, and there is a Session associated with the Client Identifier, the Broker <bcp14>MUST</bcp14> resume communications with the Client based on the state from the existing Session. In its response, the Broker <bcp14>MUST</bcp14> set the Session Present flag to 1 in the CONNACK packet to signal the continuation of an existing Session to the Client. The Session State stored by the Client and the Broker is described in <xref target="disconnections" format="default"/>.
            </t>
            <t>
	      When reconnecting to a Broker that supports continuing existing Sessions, the Client <bcp14>MUST</bcp14> still provide a token in addition to using the same Client Identifier and setting the Clean Start to 0. The Broker <bcp14>MUST</bcp14> still perform PoP validation on the provided token. If the token matches the stored state, the Broker <bcp14>MAY</bcp14> skip introspecting a token-by-reference and use the stored introspection result. The Broker <bcp14>MUST</bcp14> also verify the Client is authorized to receive or send MQTT packets that are pending transmission. When a Client connects with a long Session Expiry Interval, the Broker may need to maintain the Client's MQTT Session State after it disconnects for an extended period. Brokers <bcp14>SHOULD</bcp14> implement administrative policies to limit misuse.
            </t>
            <t>
	      Note that, according to the MQTT standard, the Broker uses the Client Identifier to identify the Session State. In the case of a Client Identifier collision, a Client may take over another Client's Session.
	      Given that the Broker <bcp14>MUST</bcp14> associate the Client with a valid token, a Client will only send or receive messages to its authorized topics.
                Therefore, while this issue is not expected to affect security,
                it may affect QoS (i.e., PUBLISH or QoS messages saved for Client A may be delivered to a Client B).
                In addition, if this Client Identifier represents a Client already connected to the Broker,
                the Broker sends a DISCONNECT packet to the existing Client with reason code 0x8E (Session taken over)
                and closes the connection to the Client.
            </t>
          </section>
          <section anchor="AUTH-method" numbered="true" toc="default">
            <name>Authentication Using the AUTH Property</name>
            <t><xref target="mqtt5_connect_message"/> shows the Authentication Method and Authentication Data fields when the client authenticates using the AUTH property. The Client <bcp14>MUST</bcp14> set the Authentication Method as a property of a CONNECT packet by using the property identifier 21 (0x15). This is followed by a UTF-8-encoded string containing the name of the Authentication Method, which <bcp14>MUST</bcp14> be set to "ace". If the Broker does not support this profile, it sends a CONNACK packet with reason code 0x8C (Bad authentication method).
            </t>
            <t>
                The Authentication Method is followed by the Authentication Data,
                which has a property identifier 22 (0x16) and is Binary Data.
                Based on the Authentication Data, the Broker <bcp14>MUST</bcp14> support both options below:
            </t>
            <ul spacing="normal">
              <li>proof of possession using a challenge from the TLS session</li>
              <li>proof of possession via a Broker-generated challenge/response</li>
            </ul>
            <section anchor="pop_nonce" numbered="true" toc="default">
              <name>Proof of Possession Using a Challenge from the TLS Session</name>
              <figure anchor="authdata_tlsexporter">
                <name>Authentication Data for PoP Based on TLS Exporter Content</name>
                <artwork align="left" name="" type="" alt=""><![CDATA[
+-----------------------------------------------------------------+
|Authentication|Token Length|Token   |MAC or Signature            |
|Data Length   |            |        |(over TLS exporter content) |
+-----------------------------------------------------------------+
         ]]></artwork>
              </figure>
              <t>
                For this option, the Authentication Data inside the Client's CONNECT packet <bcp14>MUST</bcp14> contain the two-byte integer token length,
                the token, and the keyed message digest (MAC) or the Client signature (as shown in 
                <xref target="authdata_tlsexporter" format="default"/>).
                The Proof-of-Possession key in the token is used to calculate
                 the keyed message digest (MAC) or the Client signature
                based on the content obtained from the TLS exporter (<xref target="RFC5705" format="default"/>
                for TLS 1.2 and <xref target="RFC8446" section="7.5" sectionFormat="of" format="default"/> for TLS 1.3).
                This content is exported from the TLS session using the exporter label "EXPORTER-ACE-MQTT-Sign-Challenge",
                an empty context, and a length of 32 bytes.
                The token is also validated, as described in  <xref target="token_validation" format="default"/>,
                and the Broker responds with a CONNACK packet with the appropriate response code.
                The Client cannot reauthenticate using this method during the same TLS session (see <xref target="reauthentication" format="default"/>).
              </t>
            </section>
            <section anchor="pop_challenge" numbered="true" toc="default">
              <name>Proof of Possession via Broker-generated Challenge/Response</name>
              <figure anchor="authdata_challenge_client">
                <name>Authentication Data to Initiate PoP Based on Challenge/Response</name>
                <artwork align="left" name="" type="" alt=""><![CDATA[
+------------------------------------+
|Authentication|Token Length|Token   |
|Data Length   |            |        |
+------------------------------------+
         ]]></artwork>
              </figure>
              <figure anchor="authdata_challenge_broker_challenge">
                <name>Authentication Data for Broker Challenge</name>
                <artwork align="left" name="" type="" alt=""><![CDATA[
+--------------------------+
|Authentication|RS Nonce   |
|Data Length   |(8 bytes)  |
+--------------------------+
         ]]></artwork>
              </figure>
              <t>
	            For this option, the Broker follows a Broker-generated challenge/response protocol.
                If the Authentication Data inside the Client's CONNECT contains only the two-byte integer token length and
                the token (as shown in <xref target="authdata_challenge_client" format="default"/>),
                the Broker <bcp14>MUST</bcp14> respond with an AUTH packet
                with the authenticated reason code set to 0x18 (Continue Authentication).
                The Broker also uses this method if the Authentication Data does not 
                contain a token, but the Broker has a token stored for the connecting Client.
              </t>
              <t>
                The Broker continues authentication using an AUTH packet that contains the Authentication Method 
                and the Authentication Data. The Authentication Method <bcp14>MUST</bcp14> be set to "ace", and the Authentication Data <bcp14>MUST NOT</bcp14> be empty and 
                <bcp14>MUST</bcp14> contain an 8-byte RS nonce as a challenge for the Client (<xref target="authdata_challenge_broker_challenge" format="default"/>).
              </t>
              <figure anchor="authdata_challenge_client_response">
                <name>Authentication Data for the Client Challenge Response</name>
                <artwork align="left" name="" type="" alt=""><![CDATA[
+---------------------------------------------------------+
|Authentication|Client Nonce |MAC or Signature            |
|Data Length   |(8 bytes)    |(over RS nonce+Client nonce)|
+---------------------------------------------------------+
         ]]></artwork>
              </figure>
              <t>
                The Client responds to this with an AUTH packet
                with reason code 0x18 (Continue Authentication).
                Similarly, the Client packet sets the Authentication Method to "ace".
                The Authentication Data in the Client's response is formatted as shown
                in <xref target="authdata_challenge_client_response" format="default"/> and includes the 8-byte Client nonce and
                the signature or MAC computed over the RS nonce concatenated with the Client nonce
                using PoP key in the token.
              </t>
              <t>
                Next, the token is validated as described in  <xref target="token_validation" format="default"/>.
                The success case is illustrated in <xref target="pop_challenge_response" format="default"/>.
                The Client <bcp14>MAY</bcp14> also reauthenticate using this challenge-response flow,
                as described in <xref target="reauthentication" format="default"/>.
              </t>
              <figure anchor="pop_challenge_response">
                <name>PoP Challenge/Response Flow - Success</name>
                <artwork align="center" name="" type="" alt=""><![CDATA[
Client      Broker
 |             |
 |<===========>| TLS connection setup
 |             |
 |             |
 +------------>| CONNECT with Authentication Data
 |             | contains only token
 |             |
 <-------------+ AUTH 0x18 (Cont. Authentication)
 |             | 8-byte RS nonce as challenge
 |             |
 |------------>| AUTH 0x18 (Cont. Authentication)
 |             | 8-byte Client nonce + signature/MAC
 |             |
 |             |---+ Token validation
 |             |   | (may involve introspection)
 |             |<--+
 |             |
 |<------------+ CONNACK 0x00 (Success)
                     ]]></artwork>
              </figure>
            </section>
          </section>
        </section>
        <section anchor="token_validation" numbered="true" toc="default">
          <name>Broker Token Validation</name>
          <t>
                    The Broker <bcp14>MUST</bcp14> verify the validity of the token either locally
                    (e.g., in the case of a self-contained token) or <bcp14>MAY</bcp14> send a request to the
                    introspection endpoint of the AS (as described for HTTP-based interactions in
                    <xref target="RFC9200" format="default" sectionFormat="of" section="5.9">the ACE framework</xref>).
                    The Broker <bcp14>MUST</bcp14> verify the claims in the access token according to the rules set in
                    <xref target="RFC9200" format="default" sectionFormat="of" section="5.10.1.1">the ACE framework</xref>.
          </t>
          <t>
                    To authenticate the Client, the Broker validates the signature or the MAC, depending on how the PoP protocol is implemented.
                    For self-contained tokens, the Broker <bcp14>MUST</bcp14> process the security protection of the token first, as specified by the respective token format, 
                    i.e., a CWT uses COSE, while a JWT uses JOSE.  For a token-by-reference, the 
                    Broker uses the "cnf" structure returned as a result of token introspection, as specified in <xref target="RFC7519" format="default"/>. 
                    HMAC-SHA-256 (HS256) <xref target="RFC6234" format="default"/> and Ed25519 <xref target="RFC8032" format="default"/> are mandatory to implement
                    for the Broker. The Client <bcp14>MUST</bcp14> implement at least one of them depending on the choice of symmetric or asymmetric validation.
                    Validation of the signature or MAC <bcp14>MUST</bcp14> fail if the signature algorithm is set to "none"
                    when the key used for the signature algorithm cannot be determined or
                    the computed and received signature/MAC do not match.
          </t>
          <t>
                The  Broker <bcp14>MUST</bcp14> check if the access token is still valid, 
                if it is the intended destination (i.e., the audience)
                of the token, and if the token was issued by an authorized
                 Authorization Server.  If the Client is using TLS RPK mode
                 to authenticate to the Broker,  the AS constructs the access token 
                 so that the Broker can associate the access token with the 
                 Client's public key.  The "cnf" claim <bcp14>MUST</bcp14> contain either the Client's RPK or, 
                 if the key is already known by the Broker (e.g., from previous communication), 
                 a reference to it.
          </t>
        </section>
      </section>
      <section anchor="scope" numbered="true" toc="default">
        <name>Token Scope and Authorization</name>
        <t>  
            The scope field contains the publish and subscribe permissions for the Client.
            Therefore, the token or its introspection result <bcp14>MUST</bcp14> be cached 
                to allow a Client's future PUBLISH and SUBSCRIBE messages.
                 During the CONNECT, if the Will Flag is set to 1, the Broker <bcp14>MUST</bcp14> also authorize
                the publication of the Will Topic and Will Message using the token's scope field.
            The Broker uses the scope to match against the Topic Name in a PUBLISH packet
            (including Will Topic in the CONNECT) or a Topic Filter in a SUBSCRIBE packet.
        </t>
        <t>
            The scope in the token is a single value. For a JWT, the single scope 
            is a base64url-encoded string with any padding characters removed, which has an internal structure of a JSON array. 

            For a CWT, this information is represented in CBOR.  
            The internal structure follows the <xref target="RFC9237" format="default">Authorization Information 
            Format (AIF) for ACE</xref>.
            Using the Concise Data Definition Language (CDDL) <xref target="RFC8610" format="default"/>,
            the specific data model for MQTT is:
        </t>
        <figure anchor="MQTTaif">
          <name>AIF-MQTT Data Model</name>
          <sourcecode type="cddl"><![CDATA[
 AIF-MQTT = AIF-Generic<mqtt-topic-filter, mqtt-permissions>
 AIF-Generic<Toid, Tperm> = [* [Toid, Tperm]]
 mqtt-topic-filter = tstr ; as per Section 4.7 of MQTT v5.0
 mqtt-permissions = [+permission]
 permission = "pub"/"sub"
            ]]></sourcecode>
        </figure>
        <t>
            Topic Filters are implemented according to Section 4.7 of the
            <xref target="MQTT-OASIS-Standard-v5" format="default">MQTT v5.0 OASIS Standard</xref>.
            By default, Wildcard Subscriptions are supported, and so, 
            the Topic Filter may include special wildcard characters.
            The multi-level wildcard, "#", matches any number of levels within a topic, and the single-level wildcard, "+",
            matches one topic level.
            The Broker <bcp14>MAY</bcp14> signal in the CONNACK explicitly whether Wildcard Subscriptions are supported
            by returning a CONNACK property "Wildcard Subscription Available". 
            A value of 0 means that Wildcard Subscriptions are not supported. 
            A value of 1 means Wildcard Subscriptions are supported.
        </t>
        <t> Following this model, an example scope may contain:
        </t>
        <figure anchor="MQTTaifex">
          <name>Example Scope</name>
          <sourcecode type="json"><![CDATA[
 [["topic1",["pub","sub"]],["topic2/#",["pub"]],["+/topic3",["sub"]]]
            ]]></sourcecode>
        </figure>
        <t>
            This access token gives publish ("pub") and subscribe ("sub") permissions to the "topic1",
            publish permission to all the subtopics of "topic2",
            and subscribe permission to all "topic3", skipping one level.
        </t>
        <t>
            If the scope is empty, the Broker records
            no permissions for the Client for any topic. In this case, the Client
            is not able to publish or subscribe to any protected topics.
            The non-empty scope is used to authorize the Will Topic, if provided, in the CONNECT packet, 
            during connection setup and, if the connection request 
            succeeds, the Topic Names or Topic Filters requested in the future PUBLISH and SUBSCRIBE packets. 
            For the authorization to succeed, the Broker <bcp14>MUST</bcp14> verify that the Topic Name or Topic Filter in question is either 
            an exact match to or a subset of at least one "topic_filter" in the scope.
        </t>
      </section>
      <section numbered="true" toc="default">
        <name>Broker Response to Client Connection Request</name>
        <t>
                 Based on the validation result (obtained either via local inspection or using the introspection
                interface of the AS), the Broker <bcp14>MUST</bcp14> send a CONNACK packet to the Client.
        </t>
        <section anchor="as_discovery" numbered="true" toc="default">
          <name>Unauthorized Request and the Optional Authorization Server Discovery</name>
          <t> Authentication can fail for the following reasons:
          </t>
          <ul spacing="normal">
            <li>if the Client does not provide a valid token,</li>
            <li>the Client omits the Authentication Data field and the Broker
                        has no token stored for the Client,</li>
            <li>the token or Authentication data are malformed, or </li>
            <li>if the Will Flag is set, the authorization checks for 
                        the Will Topic fails.</li>
          </ul>
          <t> 
                    The Broker responds with the CONNACK reason code 0x87 (Not Authorized) or any other applicable
                    reason code.
          </t>
          <t>
                        The Broker <bcp14>MAY</bcp14> also trigger AS discovery and include a User Property (identified as property type 38 (0x26)) 
                        in the CONNACK for the AS Request Creation Hints.
                        The User Property is a UTF-8 string pair, composed of a name and a value. The name
                        of the User Property <bcp14>MUST</bcp14> be set to "ace_as_hint". The value of the User Property
                        is a UTF-8-encoded JSON object containing the mandatory "AS" parameter
                         and the optional parameters "audience", "kid", "cnonce", and "scope", as defined
                         in <xref target="RFC9200" format="default" sectionFormat="of" section="5.3">the ACE framework</xref>.
          </t>
        </section>
        <section anchor="auth_success" numbered="true" toc="default">
          <name>Authorization Success</name>
          <t>
            On success, the reason code of the CONNACK is 0x00 (Success).
	    If the Broker starts a new Session, it <bcp14>MUST</bcp14> also set Session Present to 0 in the CONNACK packet to signal a new Session to the Client. Otherwise, it <bcp14>MUST</bcp14> set Session Present to 1.
          </t>
          <t>
                    Having accepted the connection, the Broker <bcp14>MUST</bcp14> be prepared to store the token
                    during the connection and after disconnection for future use. 
                    If the token is not self-contained and the Broker uses token
                    introspection, it <bcp14>MAY</bcp14> cache the validation result to authorize
                    the subsequent PUBLISH and SUBSCRIBE packets.
                    PUBLISH and SUBSCRIBE packets, which are sent after a connection
                    setup, do not contain access tokens. If the introspection result
                    is not cached, the Broker needs to introspect the saved token for
                    each request. The Broker <bcp14>SHOULD</bcp14> also use a cache timeout to introspect
                    tokens regularly. The timeout value is specific to the application and should be chosen 
       to reduce the risk of using stale introspection responses.
          </t>
        </section>
      </section>
    </section>
    <section anchor="pubsub_authorization" numbered="true" toc="default">
      <name>Authorizing PUBLISH and SUBSCRIBE Packets</name>
      <t>
        Using the cached token or its introspection result, the Broker uses the scope field 
        to match against the Topic Name in a PUBLISH packet or a Topic Filter in a SUBSCRIBE packet.
      </t>
      <section anchor="publish-packets" numbered="true" toc="default">
        <name>PUBLISH Packets from the Publisher Client to the Broker</name>
        <t>
                On receiving the PUBLISH packet, the Broker <bcp14>MUST</bcp14> use the type of
                packet (i.e., PUBLISH) and the Topic Name in the packet header to match against the
                scope array items in the cached token or its introspection result.
                Following the example in <xref target="scope" format="default"/>, the Client sending a PUBLISH packet for "topic2/a" would be
                allowed, as the scope array includes the ["topic2/#",["pub"]].
        </t>
        <t>
                If the Client is allowed to publish to the topic,
                the Broker publishes the message to all valid subscribers of the topic.
		       In the case of an authorization failure, the Broker <bcp14>MUST</bcp14> return an error if
                the Client has set the QoS level of the PUBLISH packet to greater than or equal to 1.
                Depending on the QoS level, the Broker responds with either a PUBACK or PUBREC packet with reason code
             0x87 (Not authorized).
		        On receiving an acknowledgment with 0x87 (Not authorized),
                the Client <bcp14>MAY</bcp14> reauthenticate by providing a new token, as described in <xref target="reauthentication" format="default"/>.
        </t>
        <t>
                For QoS level 0, the Broker sends a DISCONNECT packet with reason code 0x87 (Not authorized)
                and closes the Network Connection.  Note that the server-side DISCONNECT is a new feature of MQTT v5.0 (in MQTT v3.1.1,
                the server needs to drop the connection).
        </t>
        <t> For all QoS levels, the Broker <bcp14>MAY</bcp14> return 0x80 (Unspecified error) if they do not want to leak the Topic Names to unauthorized clients.
        </t>
      </section>
      <section numbered="true" toc="default">
        <name>PUBLISH Packets from the Broker to the Subscriber Clients</name>
        <t>
	  To forward PUBLISH packets to the subscribing Clients, the Broker identifies all the subscribers that have valid matching Topic Subscriptions to the Topic Name of the PUBLISH packet (i.e., the tokens are valid, and token scopes allow a Subscription to this particular Topic Name). 
                The Broker forwards the PUBLISH packet to all the valid
                subscribers.
        </t>
        <t>
                The Broker <bcp14>MUST NOT</bcp14> forward messages to unauthorized subscribers.
                To avoid silently dropping messages, the Broker <bcp14>MUST</bcp14> close the Network Connection and 
                <bcp14>SHOULD</bcp14> inform the affected subscribers.
                In this case, the only way to inform a client would be sending a DISCONNECT packet.  
                Therefore, the Broker <bcp14>SHOULD</bcp14> send a DISCONNECT packet with reason code 0x87 (Not authorized)
                before closing the Network Connection to these clients.
        </t>
      </section>
      <section numbered="true" toc="default">
        <name>Authorizing SUBSCRIBE Packets</name>
        <t>
            In MQTT, a SUBSCRIBE packet is sent from a Client to the Broker
             to create one or more Subscriptions
            to one or more topics.
            The SUBSCRIBE packet may contain multiple Topic Filters.
            The Topic Filters may include wildcard characters.
        </t>
        <t>
            On receiving the SUBSCRIBE packet, the Broker <bcp14>MUST</bcp14> use the type of packet (i.e.,
            SUBSCRIBE) and the Topic Filter in the packet header to match
            against the scope field of the stored token or introspection result.
            The Topic Filters <bcp14>MUST</bcp14> be an exact match to or be a subset of at least one of the "topic_filter" fields
            in the scope array found in the Client's token. For example, if the Client sends a SUBSCRIBE request for topic "a/b/*" and has a token that permits "a/*", this is a valid SUBSCRIBE request, as "a/b/*" is a subset of "a/*". (The process is similar to a Broker matching the Topic Name in a PUBLISH packet against the Subscriptions known to the Server.)
        </t>
        <t>
            As a response to the SUBSCRIBE packet, the Broker issues a SUBACK packet.
             For each Topic Filter,
            the SUBACK packet includes a return code matching the QoS level
            for the corresponding Topic Filter. In the case of failure, the return code is 0x87,
            indicating that the Client is not authorized. The Broker <bcp14>MAY</bcp14> return 0x80 (Unspecified error)
            if they do not want to leak the Topic Names to unauthorized clients. 
            A reason code is returned for each Topic Filter.
		    Therefore, the Client may receive success codes for a subset of its Topic Filters while being
		    unauthorized for the rest.
        </t>
      </section>
    </section>
    <section anchor="reauthentication" numbered="true" toc="default">
      <name>Token Expiration, Update, and Reauthentication</name>
      <t>
            The Broker <bcp14>MUST</bcp14> check for token expiration whenever a CONNECT, PUBLISH, or SUBSCRIBE packet is received
            or sent.
	    The Broker <bcp14>SHOULD</bcp14> check for token expiration on receiving a PINGREQ packet.
            The Broker <bcp14>MAY</bcp14> also check for token expiration periodically, e.g., every hour. This may allow
		    for early detection of a token expiry.
      </t>
      <t>
            The token expiration is checked by checking the "exp" claim of a JWT or introspection response
             or via performing an
            introspection request with the AS, as described in <xref target="RFC9200" format="default" sectionFormat="of" section="5.9">the ACE framework</xref>.
            Token expirations may trigger the Broker to send PUBACK, SUBACK, and DISCONNECT packets with the return code
            set to "Not authorized". After sending a DISCONNECT packet, the Network Connection is closed, and
            no more messages can be sent.
      </t>
      <t>
		    The Client <bcp14>MAY</bcp14> reauthenticate a response to
            PUBACK and SUBACK, which signal loss of authorization.
            The Clients <bcp14>MAY</bcp14> also proactively update their tokens, i.e., before
            they receive a packet with a "Not authorized" return code.
            To start reauthentication, the Client <bcp14>MUST</bcp14> send an AUTH packet with reason code
            0x19 (Reauthentication). The Client <bcp14>MUST</bcp14>
		    set the Authentication Method as "ace" and transport the new token in the Authentication Data.
            If reauthenticating during the current TLS session, 
            the Client <bcp14>MUST NOT</bcp14> use the method described in <xref target="pop_nonce" format="default"/>, i.e.,
            proof of possession using a challenge from the TLS session, to avoid reusing the same challenge value from the TLS-Exporter.  
            Note that this means that servers will either need to record in the session ticket or database entry whether
             the TLS-Exporter-derived challenge was used or always deny use of the TLS-Exporter-derived challenge
              for resumed sessions.  In TLS 1.3, the resumed connection would have a new exporter value, 
              but the requirement is phrased this way for simplicity.
            For reauthentications in the same TLS-session,  the Client <bcp14>MUST</bcp14> use the challenge-response PoP, as defined
            in <xref target="pop_challenge" format="default"/>. 
            The Broker accepts reauthentication requests if the Client has already submitted
            a token (may be expired), for which it performed proof of possession.
            Otherwise, the Broker <bcp14>MUST</bcp14> deny the request.
		    If the reauthentication fails, the Broker
		    <bcp14>MUST</bcp14> send a DISCONNECT packet with reason code 0x87 (Not Authorized).
      </t>
    </section>
    <section anchor="disconnections" numbered="true" toc="default">
      <name>Handling Disconnections and Retained Messages</name>
      <t>
	In the case of a Client DISCONNECT, if the Session Expiry Interval is set to 0, the Broker doesn't store the Session State but <bcp14>MUST</bcp14> keep the retained messages. If the Broker stores the Session State, the state <bcp14>MAY</bcp14> include the token and its introspection result (for reference tokens) in addition to the MQTT Session State. The MQTT Session State is identified by the Client Identifier and includes the following:
      </t>
      <ul spacing="normal">
        <li>the Client Subscriptions, </li>
        <li>messages with QoS levels 1 and 2, which have
            not been completely acknowledged or are pending transmission to the Client, and </li>
        <li>if the Session is currently not connected, the time at which the Session will end and the Session State will be discarded.</li>
      </ul>
      <t>
	The token/introspection state is not part of the MQTT Session State, and PoP validation is required for each new connection, regardless of whether existing MQTT Sessions are continued.
      </t>
      <t>
            The messages to be retained are indicated to the Broker by setting a RETAIN flag in a PUBLISH packet.
            This way, the publisher signals to the Broker to store the most
            recent message for the associated topic.  Hence, the new subscribers can receive
            the last sent message from the publisher for that particular topic without waiting
            for the next PUBLISH packet.
            The Broker <bcp14>MUST</bcp14> continue publishing
            the retained messages as long as the associated tokens are valid.
            In the MQTT standard, if QoS is 0 for the PUBLISH packet, the Broker may discard the
            retained message any time. For QoS &gt; 1, the message expiry interval dictates how long the retained message is kept. 
            However, it is important that the Broker avoids sending messages indefinitely for the Clients that never update their tokens (i.e.,
            the Client connects briefly with a valid token, sends a PUBLISH packet with the RETAIN flag set to 1
            and QoS &gt; 1, disconnects, and never connects again). 
            Therefore, the Broker <bcp14>MUST</bcp14> use the minimum of the token expiry and message expiry interval to discard
            a retained message.  
      </t>
      <t>
            In case of disconnections due to network errors or server disconnection due to a protocol error
            (which includes authorization errors), the Will Message is sent if the Client supplied
            a Will in the CONNECT packet.  The Client's token scope array <bcp14>MUST</bcp14> include the Will Topic.
            The Will Message <bcp14>MUST</bcp14> be published to the Will Topic, regardless of whether the corresponding
		    token has expired (as it has been validated and accepted during CONNECT).
      </t>
    </section>
    <section anchor="MQTTv311" numbered="true" toc="default">
      <name>Reduced Protocol Interactions for MQTT v3.1.1</name>
      <t>
        This section describes a reduced set of protocol interactions for the MQTT v3.1.1 Clients.
        An MQTT v5.0 Broker <bcp14>MAY</bcp14> implement these interactions for the MQTT v3.1.1 Clients; 
        the flows described in this section are <bcp14>NOT RECOMMENDED</bcp14> for use by MQTT v5.0 Clients. 
        Brokers that do not support MQTT v3.1.1 Clients return a CONNACK packet
        with reason code 0x84 (Unsupported Protocol Version) in response to the connection requests.
      </t>
      <section anchor="token_311" numbered="true" toc="default">
        <name>Token Transport</name>
        <t> As in MQTT v5.0, the token <bcp14>MAY</bcp14> either be transported before, by publishing
             to the "authz-info" topic, or inside the CONNECT packet. If the Client provided
             the token via the "authz-info" topic and will not update the token in the CONNECT packet, 
             it <bcp14>MUST</bcp14> authenticate over TLS. The Broker <bcp14>SHOULD</bcp14> still be prepared to store the Client access
             token for future use (regardless of the method of transport).
        </t>
        <t>In MQTT v3.1.1, after the Client has published to the "authz-info" topic,
               the Broker cannot communicate
                the result of the token validation because PUBACK reason codes or server-side DISCONNECT
                packets are not supported.
                In any case, the subsequent TLS handshake would fail without a valid token,
                 which can prompt the Client to
                obtain a valid token.
        </t>
        <t>
                To transport the token to the Broker inside the CONNECT packet,
                the Client uses the User Name and Password fields.
                <xref target="mqtt_connect_message" format="default"/> shows the structure of the MQTT CONNECT packet.
        </t>
        <figure anchor="mqtt_connect_message">
          <name>MQTT CONNECT Variable Header Using a User Name and Password for ACE</name>
          <artwork align="center" name="" type="" alt=""><![CDATA[
0             8             16
+---------------------------+
|Protocol name length = 4   |
+---------------------------+
|     'M'            'Q'    |
+---------------------------+
|     'T'            'T'    |
+---------------------------+
|Proto.level=5|Connect flags|          
+---------------------------+
|        Keep alive         |
+---------------------------+
|        Payload            | 
|  Client Identifier        |
|  (UTF-8-encoded string)   |
| User Name as access token |
|   (UTF-8-encoded string)  |
| Password for signature/MAC|
|     (Binary Data)         |
+---------------------------+
]]></artwork>
        </figure>
        <t>
            <xref target="mqtt_connect_flags" format="default"/> shows how the MQTT connect flags <bcp14>MUST</bcp14> be set to initiate
             a connection with the Broker.
        </t>
        <table anchor="mqtt_connect_flags">
          <name>MQTT CONNECT Flags (Rsvd. = Reserved)</name>
	  <thead>
	    <tr>
	      <th>User Name Flag</th>
	      <th>Password Flag</th>
	      <th>Will Retain</th>
	      <th>Will QoS</th>
	      <th>Will Flag</th>
	      <th>Clean</th>
	      <th>Rsvd.</th>
	    </tr>
	  </thead>
	  <tbody>
	    <tr>
	      <td align="center">1</td>
	      <td align="center">1</td>
	      <td align="center">X</td>
	      <td align="center">X X</td>
	      <td align="center">X</td>
	      <td align="center">X</td>
	      <td align="center">0</td>
	    </tr>
	  </tbody>
	</table>
        <t>
	  The Client <bcp14>SHOULD</bcp14> set the Clean flag to 1 to always start a new Session. If the Clean flag is set to 0, the Broker <bcp14>MUST</bcp14> resume communications with the Client based on the state from the current Session (as identified by the Client Identifier). If there is no Session associated with the Client Identifier, the Broker <bcp14>MUST</bcp14> create a new Session. The Broker <bcp14>MUST</bcp14> set the Session Present flag in the CONNACK packet accordingly, i.e., 0 to indicate a new Session to the Client and 1 to indicate that the existing Session is continued. The Broker <bcp14>MUST</bcp14> still perform PoP validation on the provided Client token. MQTT v3.1.1 does not use a Session Expiry Interval, and the Client expects that the Broker maintains the Session State after it disconnects. However, the stored Session State can be discarded as a result of administrator action or policies (e.g., defining an automated response based on storage capabilities), and Brokers <bcp14>SHOULD</bcp14> implement administrative policies to limit misuse.
        </t>
        <t>
                    The Client <bcp14>MAY</bcp14> set the Will Flag as desired (marked as "X" in
                     <xref target="mqtt_connect_flags" format="default"/>). User Name and Password flags <bcp14>MUST</bcp14> be
                      set to 1 to  ensure that the Payload of the CONNECT packet includes both the User Name 
                      and Password fields. The MQTT User Name is a UTF-8-encoded string, and the MQTT Password is Binary Data.
        </t>
        <t>
                   The CONNECT in MQTT v3.1.1 does not have a field to indicate the Authentication
                    Method. To signal that the User Name field contains an ACE token,
                    this field <bcp14>MUST</bcp14> be prefixed with the keyword "ace", 
                    i.e., the User Name field is a concatenation of 'a', 'c', 'e', and the access token
                    represented as:
        </t>
        <figure anchor="v31username">
          <name>User Name in CONNECT</name>
          <artwork type="" name="" align="center" alt=""><![CDATA[
'U+0061'||'U+0063'||'U+0065'||UTF-8(access token)
                    ]]></artwork>
        </figure>
        <t>
                    To this end, the access token <bcp14>MUST</bcp14> be encoded with base64url,
                    omitting the "=" padding characters <xref target="RFC4648" format="default"/>.
        </t>
        <t>
                    The Password field <bcp14>MUST</bcp14> be set to the keyed message digest (MAC)
                    or signature associated with the access token for PoP.
                    The Client <bcp14>MUST</bcp14> apply the PoP key on the challenge derived from the TLS
                    session, as described in <xref target="pop_nonce" format="default"/>.
        </t>
      </section>
      <section anchor="errors_311" numbered="true" toc="default">
        <name>Handling Authorization Errors</name>
        <t>
                Error handling is more primitive in MQTT v3.1.1 due to not having appropriate error fields,
                error codes, and server-side DISCONNECTs.
		Therefore, the Broker will disconnect on almost any error and may not keep the Session State, necessitating that clients make a greater effort to ensure that tokens remain valid and do not attempt to publish to topics that they do not have permissions for.
                The following lists how the Broker responds to specific errors.
        </t>
        <dl newline="true" spacing="normal" indent="8">
          <dt>
                CONNECT without a token:</dt> <dd>The tokenless CONNECT attempt <bcp14>MUST</bcp14> fail. This is
                because the challenge-response-based PoP is not possible for MQTT v3.1.1. 
                It is also not possible to support AS discovery since a CONNACK packet in MQTT v3.1.1
                  does not include a means to provide additional information to the Client.
			    Therefore, AS discovery needs to take place out of band. 
		      </dd>
          <dt>
                Client-Broker PUBLISH authorization failure:</dt> <dd>In the case of a failure,
                  it is not possible to return an error in MQTT v3.1.1.
		       Acknowledgment messages only indicate success. In the case of an authorization error,
                the Broker <bcp14>MUST</bcp14> ignore the PUBLISH packet and disconnect the Client.
		         Also, as DISCONNECT packets are only sent
                from a Client to the Broker, the server disconnection needs to take place below the application layer.
		      </dd>
          <dt> SUBSCRIBE authorization failure:</dt>  <dd>In the  SUBACK packet, the return code is 0x80, indicating
                failure for the unauthorized topic(s). Note that, in both MQTT versions, a reason code is
                returned for each Topic Filter.
		      </dd>
          <dt>Broker-Client PUBLISH authorization failure:</dt>  <dd>When the Broker is forwarding PUBLISH packets to the subscribed Clients,
		      it may discover that some of the subscribers are no longer authorized due to expired tokens.
               These token expirations <bcp14>MUST</bcp14> lead to disconnecting the Client rather than silently dropping messages.
		      </dd>
        </dl>
      </section>
    </section>
        <section anchor="IANA" numbered="true" toc="default">
      <name>IANA Considerations</name>
      <section numbered="true" toc="default">
        <name>TLS Exporter Labels Registration</name>
        <t>
            This document registers "EXPORTER-ACE-MQTT-Sign-Challenge" (introduced in <xref target="pop_nonce" format="default"/>
           in this document) in the "TLS Exporter Labels" registry <xref target="RFC8447" format="default"/>.
        </t>
        <dl newline="false" spacing="normal">
          <dt>Recommended:</dt> <dd>N</dd>
          <dt>DTLS-OK:</dt> <dd>N</dd>
          <dt>Reference:</dt> <dd>RFC 9431</dd>
        </dl>
      </section>
      <section numbered="true" toc="default">
        <name>Media Type Registration</name>
        <t>This document registers the "application/ace+json" media type
            for messages of the protocols defined in this document carrying
            parameters encoded in JSON.</t>
        <dl newline="false" spacing="normal">
          <dt>Type name:</dt> <dd>application </dd>
          <dt>Subtype name:</dt> <dd>ace+json </dd>
          <dt>Required parameters:</dt> <dd>N/A </dd>
          <dt>Optional parameters:</dt> <dd>N/A </dd>
          <dt>Encoding considerations:</dt> <dd>Encoding considerations are identical to
those specified for the "application/json" media type.</dd>
          <dt>Security considerations:</dt> <dd><xref target="Security" format="default"/> of RFC 9431</dd>
          <dt>Interoperability considerations:</dt> <dd>none </dd>
          <dt>Published specification:</dt> <dd>RFC 9431</dd>
          <dt>Applications that use this media type:</dt> <dd>This media type is intended for
            Authorization-Server-Client and Authorization-Server-Resource-Server 
            communication as part of the ACE framework using JSON encoding, as specified in RFC 9431.</dd>
          <dt>Fragment identifier considerations:</dt> <dd>none </dd>
          <dt>Additional information:</dt>
	  <dd><t><br/></t>
	    <dl newline="false" spacing="normal">
              <dt>Deprecated alias names for this type:</dt> <dd>none</dd>
              <dt>Magic number(s):</dt> <dd>none</dd>
              <dt>File extension(s):</dt> <dd>none</dd>
              <dt>Macintosh file type code(s):</dt> <dd>none</dd>
            </dl>
          </dd>
          <dt>Person &amp; email address to contact for further information:</dt>
<dd><t><br/>Cigdem Sengul &lt;csengul@acm.org&gt;</t></dd>
          <dt>Intended usage:</dt> <dd>COMMON</dd>
          <dt>Restrictions on usage:</dt> <dd>none</dd>
          <dt>Author:</dt> <dd>Cigdem Sengul &lt;csengul@acm.org&gt;</dd>
          <dt>Change controller:</dt> <dd>IETF </dd>
        </dl>
      </section>
      <section numbered="true" toc="default">
        <name>ACE OAuth Profile Registration</name>
        <t>The following registrations have been made in the "ACE Profiles" registry, following the procedure specified in
	        <xref target="RFC9200" format="default"/>.
        </t>
        <dl newline="false" spacing="normal">
          <dt>Name:</dt> <dd>mqtt_tls</dd>
          <dt>Description:</dt> <dd>Profile for delegating Client authentication and authorization using MQTT for the 
            Client and Broker (RS) interactions and HTTP for the AS interactions. 
	        TLS is used for confidentiality and integrity protection and server authentication. 
            Client authentication can be provided either via TLS or using in-band PoP validation at the MQTT
            application layer.
            </dd>
          <dt>CBOR Value:</dt> <dd>3</dd>
          <dt>Reference:</dt> <dd>RFC 9431</dd>
        </dl>
      </section>
      <section numbered="true" toc="default">
        <name>AIF</name>
        <t>For the media types "application/aif+cbor" and "application/aif+json",
        defined in <xref target="RFC9237" section="5.1" sectionFormat="of" format="default"/>, IANA has
        registered the following entries for the two media type parameters Toid
        and Tperm in the respective subregistry defined in <xref target="RFC9237" section="5.2" sectionFormat="of" format="default"/> within the "Media Type Sub-Parameter Registries".
        </t>
	<dl newline="true" spacing="normal">
          <dt>For Toid:</dt>
	  <dd>
        <dl newline="false" spacing="normal">
          <dt>Name:</dt> <dd>mqtt-topic-filter</dd>
          <dt>Description/Specification:</dt> <dd>Topic Filter, as defined in <xref target="scope" format="default"/> of RFC 9431.</dd>
          <dt>Reference:</dt> <dd>RFC 9431, <xref target="scope" format="default"/></dd>
        </dl>
	  </dd>
        <dt> For Tperm:</dt>
        <dd>
        <dl newline="false" spacing="normal">
          <dt>Name:</dt> <dd>mqtt-permissions</dd>
          <dt>Description/Specification:</dt> <dd>Permissions for the MQTT
                Client, as defined in <xref target="scope" format="default"/> of RFC 9431.
                Tperm is an array of one or more text strings that each have
                a value of either "pub" or "sub".</dd>
          <dt>Reference:</dt> <dd>RFC 9431, <xref target="scope" format="default"/></dd>
        </dl>
	</dd></dl>
      </section>
    </section>
    <section anchor="Security" numbered="true" toc="default">
      <name>Security Considerations</name>
      <t> This document specifies a profile for the Authentication and Authorization for Constrained Environments (ACE) framework
	  <xref target="RFC9200" format="default"/>. Therefore, the security considerations outlined
	  in <xref target="RFC9200" format="default"/> apply to this work.
      </t>
      <t> In addition, the security considerations outlined in the <xref target="MQTT-OASIS-Standard-v5" format="default">MQTT v5.0 OASIS Standard</xref>
	  and <xref target="MQTT-OASIS-Standard-v3.1.1" format="default">MQTT v3.1.1 OASIS Standard</xref>
	   apply.  Mainly, this document provides an authorization solution for MQTT,
	   the responsibility of which is left to the specific implementation in the MQTT standards.
	 In the following, we comment on a few relevant issues based on the current MQTT specifications.
      </t>
      <t>After the Broker validates an access token and accepts a connection from a client, it caches the token to authorize a Client's publish and subscribe requests in an ongoing Session.
      The Broker does not cache any tokens that cannot be validated.
      If a Client's permissions get revoked, but the access token has not expired,
	  the Broker may still grant publish/subscribe to revoked topics.
      If the Broker caches the token introspection responses, then the Broker <bcp14>SHOULD</bcp14> use a reasonable cache timeout
       to introspect tokens regularly. The timeout value is application specific and should be chosen 
       to reduce the risk of using stale introspection responses.
	  When permissions change dynamically, it is expected that the AS also
       follows a reasonable expiration strategy for the access tokens.
      </t>
      <t> The Broker may monitor Client behavior to detect potential security problems, especially those affecting availability.
	  These include repeated token transfer attempts to the public "authz-info" topic, repeated connection attempts,
	  abnormal terminations, and Clients that connect but do not send any data.
   If the Broker supports the public
   "authz-info" topic, described in <xref target="app-authzinfo" format="default"/>, then this may be
   vulnerable to a DDoS attack, where many Clients use the "authz-info" 
   public topic to transport tokens that are not meant to be used 
   and that the Broker may need to store until they expire.</t>
   <t>For MQTT v5.0, when a Client connects with a long Session Expiry Interval, the Broker may need to maintain the Client's MQTT Session State after it disconnects for an extended period. For MQTT v3.1.1, the Session State may need to be stored indefinitely, as it does not have a Session Expiry Interval feature. The Broker <bcp14>SHOULD</bcp14> implement administrative policies to limit misuse by the Client resulting from continuing existing Sessions.
      </t>
    </section>
    <section anchor="Privacy" numbered="true" toc="default">
      <name>Privacy Considerations</name>
      <t>The privacy considerations outlined in <xref target="RFC9200" format="default"/> apply to this work.
      </t>
      <t>In MQTT, the Broker is a central trusted party and may forward potentially sensitive information
	        between Clients. The mechanisms defined in this document do not protect the contents of the PUBLISH packet from the Broker, and hence,
                the content of the PUBLISH packet is not signed or encrypted separately for the subscribers.
                This functionality may be implemented using the proposal outlined in <xref target="I-D.ietf-ace-pubsub-profile" format="default">
                the ACE Pub-Sub Profile</xref>.
	        However, this solution would still not provide privacy for other fields of the packet, such as Topic Name.
      </t>
    </section>
  </middle>

    <back>

<displayreference target="I-D.ietf-tls-rfc8446bis" to="TLS-bis"/>
<displayreference target="I-D.ietf-ace-pubsub-profile" to="ACE-PUBSUB-PROFILE"/>
        <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4648.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7250.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8422.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8442.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8446.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.5705.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6234.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6749.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7800.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8747.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8610.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7519.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7516.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7517.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9052.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7627.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6066.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7301.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8032.xml"/>

        <reference anchor="MQTT-OASIS-Standard-v3.1.1" target="https://docs.oasis-open.org/mqtt/mqtt/v3.1.1/mqtt-v3.1.1.html">
          <front>
            <title>MQTT Version 3.1.1 Plus Errata 01</title>
            <author initials="A." surname="Banks" role="editor">
              <organization>IBM</organization>
            </author>
            <author initials="R." surname="Gupta" role="editor">
              <organization>IBM</organization>
            </author>
            <date year="2015" month="December"/>
          </front>
	  <refcontent>OASIS Standard</refcontent>
        </reference>

        <reference anchor="MQTT-OASIS-Standard-v5" target="https://docs.oasis-open.org/mqtt/mqtt/v5.0/mqtt-v5.0.html">
          <front>
            <title>MQTT Version 5.0</title>
            <author initials="A." surname="Banks" role="editor">
              <organization>IBM</organization>
            </author>
            <author initials="E." surname="Briggs" role="editor">
              <organization>Microsoft</organization>
            </author>
            <author initials="K." surname="Borgendale" role="editor">
              <organization>IBM</organization>
            </author>
            <author initials="R." surname="Gupta" role="editor">
              <organization>IBM</organization>
            </author>
            <date year="2019" month="March"/>
          </front>
	  <refcontent>OASIS Standard</refcontent>
        </reference>

       <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9200.xml"/>	
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9201.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9360.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9237.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9202.xml"/>
	
<reference anchor="RFC9430" target="https://www.rfc-editor.org/info/rfc9430">
<front>
<title>
Extension of the Datagram Transport Layer Security (DTLS) Profile for Authentication and Authorization for Constrained Environments (ACE) to Transport Layer Security (TLS)
</title>
<author initials="O." surname="Bergmann" fullname="Olaf Bergmann">
<organization>Universität Bremen TZI</organization>
</author>
<author initials="J." surname="Preuß Mattsson" fullname="John Preuß Mattsson">
<organization>Ericsson AB</organization>
</author>
<author initials="G." surname="Selander" fullname="Göran Selander">
<organization>Ericsson AB</organization>
</author>
<date month="July" year="2023"/>
</front>
<seriesInfo name="RFC" value="9430"/>
<seriesInfo name="DOI" value="10.17487/RFC9430"/>
</reference>

	<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9110.xml"/>

      </references>
      <references>
        <name>Informative References</name>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4949.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7252.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8949.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8392.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8447.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7925.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9325.xml"/>

        <reference anchor="Fremantle14" target="https://dx.doi.org/10.1109/SIoT.2014.8">
          <front>
            <title>Federated Identity and Access Management for the Internet of Things</title>
            <author initials="P." surname="Fremantle"/>
            <author initials="B." surname="Aziz"/>
            <author initials="J." surname="Kopecky"/>
            <author initials="P." surname="Scott"/>
            <date month="September" year="2014"/>
          </front>
	  <seriesInfo name="DOI" value="10.1109/SIoT.2014.8"/>
	  <refcontent>International Workshop on Secure Internet of Things</refcontent>
        </reference>

        <xi:include href="https://bib.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-tls-rfc8446bis.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-ace-pubsub-profile.xml"/>
      </references>
    </references>
    <section anchor="app-profile-requirements" numbered="true" toc="default">
      <name>Checklist for Profile Requirements</name>
      <t>
             Based on the requirements on profiles for the ACE framework <xref target="RFC9200" format="default"/>, 
         this document fulfills the following:
      </t>
      <ul spacing="normal">
        <li>Optional AS discovery: AS discovery is supported with the MQTT v5.0 described in <xref target="connect_v5" format="default"/>.</li>
        <li>The communication protocol between the Client and Broker (RS): MQTT</li>
        <li>The security protocol between the Client and RS: TLS</li>
        <li>Client and RS mutual authentication: Several options are possible and described in <xref target="auth_options" format="default"/>.
                  </li>
        <li> Proof-of-possession protocols: Both symmetric and asymmetric keys are supported, as specified in <xref target="AUTH-method" format="default"/>.
        </li>
        <li>Content-Format: For the HTTPS interactions with AS, "application/ace+json".
                    </li>
        <li>Unique profile identifier: mqtt_tls</li>
        <li>Token introspection: The RS uses the HTTPS introspection interface of the AS.</li>
        <li>Token request: The Client or its Client AS uses the HTTPS token endpoint of the AS.</li>
        <li>authz-info endpoint: It <bcp14>MAY</bcp14> be supported using the method described in <xref target="app-authzinfo" format="default"/> but is
                        not protected other than by the TLS channel between the Client and RS.
                    </li>
        <li>Token transport: Via the "authz-info" topic, TLS with PSKs (provided as a PSK identity), or in the
                      MQTT CONNECT packet for both versions of MQTT.
                      The AUTH extensions can also be used for authentication and reauthentication for
		            MQTT v5.0, as described in Sections <xref target="connect_v5" format="counter"/> and <xref target="reauthentication" format="counter"/>.</li>
      </ul>
    </section>
    <section anchor="Acknowledgments" numbered="false" toc="default">
      <name>Acknowledgments</name>
      <t>
                The authors would like to thank <contact fullname="Ludwig Seitz"/> for his review and his input on the authorization information endpoint; 
                <contact fullname="Benjamin Kaduk"/> for his review, insightful comments, and contributions to resolving issues; and <contact fullname="Carsten Bormann"/> for his review and 
                revisions to the AIF-MQTT data model.
                The authors would like to thank <contact fullname="Paul Fremantle"/> for the initial discussions on MQTT v5.0 support.
      </t>
    </section>
  </back>
</rfc>
