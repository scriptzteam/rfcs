<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>

<rfc xmlns:xi="http://www.w3.org/2001/XInclude" ipr="trust200902" docName="draft-ietf-dnsop-svcb-https-12" number="9460" submissionType="IETF" category="std" consensus="true" tocInclude="true" sortRefs="true" symRefs="true" updates="" obsoletes="" xml:lang="en" version="3">

  <!-- xml2rfc v2v3 conversion 3.16.0 -->
  <front>
    <title abbrev="SVCB and HTTPS RRs for DNS">Service Binding and Parameter Specification via the DNS (SVCB and HTTPS Resource Records)</title>

<seriesInfo name="RFC" value="9460"/>
    <author initials="B." surname="Schwartz" fullname="Ben Schwartz">
      <organization>Meta Platforms, Inc.</organization>
      <address>
        <email>ietf@bemasc.net</email>
      </address>
    </author>
    <author initials="M." surname="Bishop" fullname="Mike Bishop">
      <organization>Akamai Technologies</organization>
      <address>
        <email>mbishop@evequefou.be</email>
      </address>
    </author>
    <author initials="E." surname="Nygren" fullname="Erik Nygren">
      <organization>Akamai Technologies</organization>
      <address>
        <email>erik+ietf@nygren.org</email>
      </address>
    </author>
    <date year="2023" month="November" />
    <area>ops</area>
    <workgroup>dnsop</workgroup>

    <keyword>multi-CDN</keyword>
    <keyword>HSTS</keyword>
    <keyword>ECH</keyword>
    <keyword>CNAME</keyword>
    <keyword>apex</keyword>
    <keyword>ALPN</keyword>
    <keyword>HTTP/3</keyword>
    <keyword>alias</keyword>
     <keyword>SvcParam</keyword>
     <keyword>AliasMode</keyword>
     <keyword>ServiceMode</keyword>

    <abstract>
      <t>This document specifies the "SVCB" ("Service Binding") and "HTTPS" DNS resource record (RR)
types to facilitate the lookup of information needed to make connections
to network services, such as for HTTP origins.  SVCB records
allow a service to be provided from multiple alternative endpoints,
each with associated parameters (such as transport protocol
configuration), and are extensible to support future uses
(such as keys for encrypting the TLS ClientHello).  They also
enable aliasing of apex domains, which is not possible with CNAME.
The HTTPS RR is a variation of SVCB for use with HTTP (see RFC 9110, "HTTP Semantics").
By providing more information to the client before it attempts to
establish a connection, these records offer potential benefits to
both performance and privacy.</t>
    </abstract>
  </front>
  <middle>
    <section anchor="introduction">
      <name>Introduction</name>
      <t>The SVCB ("Service Binding") and HTTPS resource records (RRs) provide clients with complete instructions
for access to a service.  This information enables improved
performance and privacy by avoiding transient connections to a suboptimal
default server, negotiating a preferred protocol, and providing relevant
public keys.</t>
      <t>For example, HTTP clients currently resolve only A and/or AAAA records for
the origin hostname, learning only its IP addresses.  If an HTTP client learns
more about the origin before connecting, it may be able to upgrade "http" URLs
to "https", enable HTTP/3 or Encrypted ClientHello <xref target="I-D.ietf-tls-esni"/>,
or switch to an
operationally preferable endpoint.  It is highly desirable to minimize the
number of round trips and lookups required to
learn this additional information.</t>
      <t>The SVCB and HTTPS RRs also help when the operator of a service
wishes to delegate operational control to one or more other domains, e.g.,
aliasing the origin "https://example.com" to a service
operator endpoint at "svc.example.net".  While this case can sometimes
be handled by a CNAME, that does not cover all use cases.  CNAME is also
inadequate when the service operator needs to provide a bound
collection of consistent configuration parameters through the DNS
(such as network location, protocol, and keying information).</t>
      <t>This document first describes the SVCB RR as a general-purpose RR that can be applied directly and efficiently to a wide range
of services (<xref target="svcb"/>).  It also describes the rules for defining other
SVCB-compatible RR types (<xref target="svcb-compatible"/>), starting with the HTTPS
RR type (<xref target="https"/>), which provides improved efficiency and convenience
with HTTP by avoiding the need for an Attrleaf label <xref target="RFC8552"/>
(<xref target="httpsnames"/>).</t>
      <t>The SVCB RR has two modes: 1) "AliasMode", which simply delegates operational
control for a resource and 2) "ServiceMode", which binds together
configuration information for a service endpoint.
ServiceMode provides additional key=value parameters
within each RDATA set.</t>
      <section anchor="goals">
        <name>Goals</name>
        <t>The goal of the SVCB RR is to allow clients to resolve a single
additional DNS RR in a way that:</t>
        <ul spacing="normal">
          <li>Provides alternative endpoints that are authoritative for the service,
along with parameters associated with each of these endpoints.</li>
          <li>Does not assume that all alternative endpoints have the same parameters
or capabilities, or are even
operated by the same entity.  This is important, as DNS does not
provide any way to tie together multiple RRsets for the same name.
For example, if "www.example.com" is a CNAME alias that switches
between one of three Content Delivery Networks (CDNs) or hosting environments, successive queries
for that name may return records that correspond to different environments.</li>
          <li>Enables CNAME-like functionality at a zone apex (such as
"example.com") for participating protocols and generally
enables extending operational authority for a service identified
by a domain name to other instances with alternate names.</li>
        </ul>
        <t>Additional goals specific to HTTPS RRs and the HTTP use cases include:</t>
        <ul spacing="normal">
          <li>Connecting directly to HTTP/3 (QUIC transport)
alternative endpoints <xref target="RFC9114"/>.</li>
          <li>Supporting non-default TCP and UDP ports.</li>
          <li>Enabling SRV-like benefits (e.g., apex aliasing, as mentioned above) for HTTP,
where SRV <xref target="RFC2782"/> has not been widely adopted.</li>
          <li>Providing an indication signaling that the "https" scheme should
          be used instead of "http" for all HTTP requests to this host and port,
          similar to HTTP Strict Transport Security <xref
          target="RFC6797"/> (see
<xref target="hsts"/>).</li>
          <li>Enabling the conveyance of Encrypted ClientHello keys <xref target="I-D.ietf-tls-esni"/> associated
with an alternative endpoint.</li>
        </ul>
      </section>
      <section anchor="overview-of-the-svcb-rr">
        <name>Overview of the SVCB RR</name>
        <t>This subsection briefly describes the SVCB RR with forward references to
the full exposition of each component.  (As discussed in <xref target="svcb-compatible"/>, this all
applies equally to the HTTPS RR, which shares
the same encoding, format, and high-level semantics.)</t>
        <t>The SVCB RR has two modes: 1) AliasMode (<xref target="alias-mode"/>), which aliases a name
to another name and 2) ServiceMode (<xref target="service-mode"/>), which provides connection
information bound to a service endpoint domain.  Placing both forms in a single
RR type allows clients to
fetch the relevant information with a single query (<xref target="svcb-names"/>).</t>
        <t>The SVCB RR has two required fields and one optional field.  The fields are:</t>
        <dl spacing="normal" newline="false"><dt>SvcPriority (<xref target="pri"/>):</dt><dd>The priority of this record (relative to others,
with lower values preferred).  A value of 0 indicates AliasMode.</dd>
          <dt>TargetName:</dt><dd>The domain name of either the alias target (for
AliasMode) or the alternative endpoint (for ServiceMode).</dd>
          <dt>SvcParams (optional):</dt><dd>A list of key=value pairs
describing the alternative endpoint at
TargetName (only used in ServiceMode and otherwise ignored).
SvcParams are described in <xref target="presentation"/>.</dd>
</dl>
        <t>Cooperating DNS recursive resolvers will perform subsequent record
resolution (for SVCB, A, and AAAA records) and return them in the
Additional section of the response (<xref target="recursive-behavior"/>).  Clients either use responses
included in the Additional section returned by the recursive resolver
or perform necessary SVCB, A, and AAAA record resolutions (<xref target="client-behavior"/>).  DNS
authoritative servers can attach in-bailiwick SVCB, A, AAAA, and CNAME
records in the Additional section to responses for a SVCB query (<xref target="authoritative-behavior"/>).</t>
        <t>In ServiceMode, the SvcParams of the SVCB RR
provide an extensible data model for describing alternative
endpoints that are authoritative for a service, along with
parameters associated with each of these alternative endpoints (<xref target="keys"/>).</t>
        <t>For HTTP use cases, the HTTPS RR (<xref target="https"/>) enables many of the benefits of Alt-Svc
<xref target="RFC7838"/>
without waiting for a full HTTP connection initiation (multiple round trips)
before learning of the preferred alternative,
and without necessarily revealing the user's
intended destination to all entities along the network path.</t>
      </section>
      <section anchor="terminology">
        <name>Terminology</name>
        <t>Terminology in this document is based on the common case where the SVCB record is used to
access a resource identified by a URI whose <tt>authority</tt> field contains a DNS
hostname as the <tt>host</tt>.</t>
        <ul spacing="normal">
          <li>The "service" is the information source identified by the <tt>authority</tt> and
<tt>scheme</tt> of the URI, capable of providing access to the resource.  For "https"
URIs, the "service" corresponds to an "origin" <xref target="RFC6454"/>.</li>
          <li>The "service name" is the <tt>host</tt> portion of the authority.</li>
          <li>The "authority endpoint" is the authority's hostname and a port number implied
by the scheme or specified in the URI.</li>
          <li>An "alternative endpoint" is a hostname, port number, and other associated
instructions to the client on how to reach an instance of a service.</li>
        </ul>
        <t>Additional DNS terminology intends to be consistent
with <xref target="RFC8499"/>.</t>
        <t>SVCB is a contraction of "service binding".  The SVCB RR, HTTPS RR,
and future RR types that share SVCB's formats and registry are
collectively known as SVCB-compatible RR types.  The contraction "SVCB" is also
used to refer to this system as a whole.</t>
       <t>The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>",
       "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>",
       "<bcp14>SHALL NOT</bcp14>", "<bcp14>SHOULD</bcp14>",
       "<bcp14>SHOULD NOT</bcp14>",
       "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
       "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document
       are to be interpreted as described in BCP&nbsp;14
       <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only
       when, they appear in all capitals, as shown here.</t>
      </section>
    </section>
    <section anchor="svcb">
      <name>The SVCB Record Type</name>

      <t>The SVCB DNS RR type (RR type 64)
is used to locate alternative endpoints for a service.</t>
      <t>The algorithm for resolving SVCB records and associated
address records is specified in <xref target="client-behavior"/>.</t>

      <t>Other SVCB-compatible RR types
can also be defined as needed (see <xref target="svcb-compatible"/>).  In particular, the
HTTPS RR (RR type 65) provides special handling
for the case of "https" origins as described in <xref target="https"/>.</t>
      <t>SVCB RRs are extensible by a list of SvcParams, which are pairs consisting of a
SvcParamKey and a SvcParamValue. Each SvcParamKey has a presentation name and a
registered number. Values are in a format specific to the SvcParamKey.  Each
SvcParam has a specified presentation format (used in zone files) and
wire encoding
(e.g., domain names, binary data, or numeric values). The initial SvcParamKeys
and their formats are defined in <xref target="keys"/>.</t>
      <section anchor="presentation">
        <name>Zone-File Presentation Format</name>
        <t>The presentation format <tt>&lt;RDATA&gt;</tt> of the record (<xref section="5.1" sectionFormat="comma" target="RFC1035"/>) has
the form:</t>
        <sourcecode type="pseudocode"><![CDATA[
SvcPriority TargetName SvcParams
]]></sourcecode>
        <t>The SVCB record is defined specifically within
the Internet ("IN") Class (<xref section="3.2.4" sectionFormat="comma" target="RFC1035"/>).</t>
        <t>SvcPriority is a number in the range 0-65535,
TargetName is a <tt>&lt;domain-name&gt;</tt> (<xref section="5.1" sectionFormat="comma" target="RFC1035"/>),
and the SvcParams are a whitespace-separated list with each SvcParam
consisting of a SvcParamKey=SvcParamValue pair or a standalone SvcParamKey.
SvcParamKeys are registered by IANA (<xref target="svcparamregistry"/>).</t>
        <t>Each SvcParamKey <bcp14>SHALL</bcp14> appear at most once in the SvcParams.
In presentation format, SvcParamKeys are lowercase alphanumeric strings.
Key names contain 1-63 characters from the ranges "a"-"z", "0"-"9", and "-".
In ABNF <xref target="RFC5234"/>,</t>
<sourcecode name="" type="abnf"><![CDATA[
alpha-lc      = %x61-7A   ; a-z
SvcParamKey   = 1*63(alpha-lc / DIGIT / "-")
SvcParam      = SvcParamKey ["=" SvcParamValue]
SvcParamValue = char-string ; See Appendix A.
value         = *OCTET ; Value before key-specific parsing
]]></sourcecode>
        <t>The SvcParamValue is parsed using the
character-string decoding algorithm (<xref target="decoding"/>), producing a <tt>value</tt>.
The <tt>value</tt> is then validated and converted into wire format in a manner
specific to each key.</t>
        <t>When the optional "=" and SvcParamValue are omitted, the <tt>value</tt> is
interpreted as empty.</t>
        <t>Arbitrary keys can be represented using the unknown-key presentation format
"keyNNNNN" where NNNNN is the numeric
value of the key type without leading zeros.
A SvcParam in this form <bcp14>SHALL</bcp14> be parsed as specified above, and
the decoded <tt>value</tt> <bcp14>SHALL</bcp14> be used as its wire-format encoding.</t>
        <t>For some SvcParamKeys, the <tt>value</tt> corresponds to a list or set of
items.  Presentation formats for such keys <bcp14>SHOULD</bcp14> use a comma-separated list
(<xref target="value-list"/>).</t>
        <t>SvcParams in presentation format <bcp14>MAY</bcp14> appear in any order, but keys <bcp14>MUST NOT</bcp14> be
repeated.</t>
      </section>
      <section anchor="rdata-wire-format">
        <name>RDATA Wire Format</name>
        <t>The RDATA for the SVCB RR consists of:</t>
        <ul spacing="normal">
          <li>a 2-octet field for SvcPriority as an integer in network
byte order.</li>
          <li>the uncompressed, fully qualified TargetName, represented as
a sequence of length-prefixed labels per <xref section="3.1" sectionFormat="of" target="RFC1035"/>.</li>
          <li>the SvcParams, consuming the remainder of the record
(so smaller than 65535 octets and constrained by the RDATA
and DNS message sizes).</li>
        </ul>
        <t>When the list of SvcParams is non-empty, it contains a series of
SvcParamKey=SvcParamValue pairs, represented as:</t>
        <ul spacing="normal">
          <li>a 2-octet field containing the SvcParamKey as an
integer in network byte order.  (See <xref target="iana-keys"/> for the defined values.)</li>
          <li>a 2-octet field containing the length of the SvcParamValue
as an integer between 0 and 65535 in network byte order.</li>
          <li>an octet string of this length whose contents are the SvcParamValue in a
format determined by the SvcParamKey.</li>
        </ul>
        <t>SvcParamKeys <bcp14>SHALL</bcp14> appear in increasing numeric order.</t>
        <t>Clients <bcp14>MUST</bcp14> consider an RR malformed if:</t>
        <ul spacing="normal">
          <li>the end of the RDATA occurs within a SvcParam.</li>
          <li>SvcParamKeys are not in strictly increasing numeric order.</li>
          <li>the SvcParamValue for a SvcParamKey does not have the expected format.</li>
        </ul>
        <t>Note that the second condition implies that there are no duplicate
SvcParamKeys.</t>
        <t>If any RRs are malformed, the client <bcp14>MUST</bcp14> reject the entire RRset and
fall back to non-SVCB connection establishment.</t>
      </section>
      <section anchor="svcb-names">
        <name>SVCB Query Names</name>
        <t>When querying the SVCB RR, a service is translated into a QNAME by prepending
the service name with a label indicating the scheme, prefixed with an underscore,
resulting in a domain name like "_examplescheme.api.example.com.".  This
follows the Attrleaf naming pattern <xref target="RFC8552"/>, so the scheme <bcp14>MUST</bcp14> be
registered appropriately with IANA (see <xref target="other-standards"/>).</t>
        <t>Protocol mapping documents <bcp14>MAY</bcp14> specify additional underscore-prefixed labels
to be prepended.  For schemes that specify a port (<xref section="3.2.3" sectionFormat="of" target="RFC3986"/>), one reasonable possibility is to prepend the indicated port
number if a non-default port number is specified.  This document terms this behavior
"Port Prefix Naming" and uses it in the examples throughout.</t>
        <t>See <xref target="httpsnames"/> for information regarding HTTPS RR behavior.</t>
        <t>When a prior CNAME or SVCB record has aliased to
a SVCB record, each RR <bcp14>SHALL</bcp14> be returned under its own owner name, as in
ordinary CNAME processing (<xref section="3.6.2" sectionFormat="comma" target="RFC1034"/>).  For details, see
the recommendations regarding aliases for clients (<xref target="client-behavior"/>),
servers (<xref target="server-behavior"/>), and zones (<xref target="zone-structures"/>).</t>
        <t>Note that none of these forms alter the origin or authority for validation
purposes.
For example, TLS clients <bcp14>MUST</bcp14> continue to validate TLS certificates
for the original service name.</t>
        <t>As an example, the owner of "example.com" could publish this record:</t>
        <sourcecode type="dns-rr"><![CDATA[
_8443._foo.api.example.com. 7200 IN SVCB 0 svc4.example.net.
]]></sourcecode>
        <t>This record would indicate that "foo://api.example.com:8443" is aliased to "svc4.example.net".
The owner of "example.net", in turn, could publish this record:</t>
        <sourcecode type="dns-rr"><![CDATA[
svc4.example.net.  7200  IN SVCB 3 svc4.example.net. (
    alpn="bar" port="8004" )
]]></sourcecode>
        <t>This record would indicate that these services are served on port number 8004,
which supports the protocol "bar" and its associated transport in
addition to the default transport protocol for "foo://".</t>
        <t>(Parentheses are used to ignore a line break in DNS zone-file presentation
format, per <xref section="5.1" sectionFormat="of" target="RFC1035"/>.)</t>
      </section>
      <section anchor="interpretation">
        <name>Interpretation</name>
        <section anchor="pri">
          <name>SvcPriority</name>
          <t>When SvcPriority is 0, the SVCB record is in AliasMode (<xref target="alias-mode"/>).
Otherwise, it is in ServiceMode (<xref target="service-mode"/>).</t>
          <t>Within a SVCB RRset,
all RRs <bcp14>SHOULD</bcp14> have the same mode.
If an RRset contains a record in AliasMode, the recipient <bcp14>MUST</bcp14> ignore
any ServiceMode records in the set.</t>
          <t>RRsets are explicitly unordered collections, so the
SvcPriority field is used to impose an ordering on SVCB RRs.
A smaller SvcPriority indicates that the domain owner recommends the use of this
record over ServiceMode RRs with a larger SvcPriority value.</t>
          <t>When receiving an RRset containing multiple SVCB records with the
same SvcPriority value, clients <bcp14>SHOULD</bcp14> apply a random shuffle within a
priority level to the records before using them, to ensure uniform
load balancing.</t>
        </section>
        <section anchor="alias-mode">
          <name>AliasMode</name>
          <t>In AliasMode, the SVCB record aliases a service to a
TargetName.  SVCB RRsets <bcp14>SHOULD</bcp14> only have a single RR in AliasMode.  If multiple AliasMode RRs are present, clients or recursive
resolvers <bcp14>SHOULD</bcp14> pick one at random.
</t>
          <t>The primary purpose of AliasMode is to allow aliasing at the zone
apex, where CNAME is not allowed (see, for example, <xref section="2.4" sectionFormat="comma" target="RFC1912"/>).
In AliasMode, the TargetName will
be the name of a domain that resolves to SVCB,
AAAA, and/or A records.  (See <xref target="svcb-compatible"/> for aliasing of SVCB-compatible RR types.)
Unlike CNAME, AliasMode records do not affect the resolution of other RR
types and apply only to a specific service, not an entire domain name.</t>
          <t>The AliasMode TargetName <bcp14>SHOULD NOT</bcp14> be equal
to the owner name, as this would result in a loop.
In AliasMode, recipients <bcp14>MUST</bcp14> ignore any SvcParams that are present.
Zone-file parsers <bcp14>MAY</bcp14> emit a warning if an AliasMode record has SvcParams.
The use of SvcParams in AliasMode records is currently not defined, but a
future specification could extend AliasMode records to include SvcParams.</t>
          <t>For example, the operator of "foo://example.com:8080" could
point requests to a service operating at "foosvc.example.net"
by publishing:</t>
          <sourcecode type="dns-rr"><![CDATA[
_8080._foo.example.com. 3600 IN SVCB 0 foosvc.example.net.
]]></sourcecode>
          <t>Using AliasMode maintains a separation of concerns: the owner of
"foosvc.example.net" can add or remove ServiceMode SVCB records without
requiring a corresponding change to "example.com".  Note that if
"foosvc.example.net" promises to always publish a SVCB record, this AliasMode
record can be replaced by a CNAME at the same owner name.</t>
          <t>AliasMode is especially useful for SVCB-compatible RR types that do not
require an underscore prefix, such as the HTTPS RR type.  For example,
the operator of "https://example.com" could point requests to a server
at "svc.example.net" by publishing this record at the zone apex:</t>
          <sourcecode type="dns-rr"><![CDATA[
example.com. 3600 IN HTTPS 0 svc.example.net.
]]></sourcecode>
          <t>Note that the SVCB record's owner name <bcp14>MAY</bcp14> be the canonical name
of a CNAME record, and the TargetName <bcp14>MAY</bcp14> be the owner of a CNAME
record. Clients and recursive resolvers <bcp14>MUST</bcp14> follow CNAMEs as normal.</t>
          <t>To avoid unbounded alias chains, clients and recursive resolvers <bcp14>MUST</bcp14> impose a
limit on the total number of SVCB aliases they will follow for each resolution
request.  This limit <bcp14>MUST NOT</bcp14> be zero, i.e., implementations <bcp14>MUST</bcp14> be able to
follow at least one AliasMode record.  The exact value of this limit
is left to implementations.</t>
          <t>Zones that require following multiple AliasMode records could encounter
compatibility and performance issues.</t>
          <t>As legacy clients will not know to use this record, service
operators will likely need to retain fallback AAAA and A records
alongside this SVCB record, although in a common case
the target of the SVCB record might offer better performance, and
therefore would be preferable for clients implementing this specification
to use.</t>
          <t>AliasMode records only apply to queries for the specific RR type.
For example, a SVCB record cannot alias to an HTTPS record or vice versa.</t>
        </section>
        <section anchor="service-mode">
          <name>ServiceMode</name>
          <t>In ServiceMode, the TargetName and SvcParams within each RR
associate an alternative endpoint for the service with its connection
parameters.</t>
          <t>Each protocol scheme that uses SVCB <bcp14>MUST</bcp14> define a protocol mapping that
explains how SvcParams are applied for connections of that scheme.
Unless specified otherwise by the
protocol mapping, clients <bcp14>MUST</bcp14> ignore any SvcParam that they do
not recognize.</t>
          <t>Some SvcParams impose requirements on other SvcParams in the RR.  A
ServiceMode RR is called "self-consistent" if its SvcParams all comply with
each other's requirements.  Clients <bcp14>MUST</bcp14> reject any RR whose recognized
SvcParams are not self-consistent and <bcp14>MAY</bcp14> reject the entire RRset.  To
help zone operators avoid this condition, zone-file implementations <bcp14>SHOULD</bcp14>
enforce self-consistency as well.</t>
        </section>
      </section>
      <section anchor="dot">
        <name>Special Handling of "." in TargetName</name>
        <t>If TargetName has the value "." (represented in the wire format as a
zero-length label), special rules apply.</t>
        <section anchor="aliasdot">
          <name>AliasMode</name>
          <t>For AliasMode SVCB RRs, a TargetName of "." indicates that the service
is not available or does not exist.  This indication is advisory:
clients encountering this indication <bcp14>MAY</bcp14> ignore it and attempt to connect
without the use of SVCB.</t>
        </section>
        <section anchor="servicemode">
          <name>ServiceMode</name>
          <t>For ServiceMode SVCB RRs, if TargetName has the value ".", then the
owner name of this record <bcp14>MUST</bcp14> be used as the effective TargetName.
If the record has a wildcard owner name in the zone file, the recipient
<bcp14>SHALL</bcp14> use the response's synthesized owner name as the effective TargetName.</t>
          <t>Here, for example, "svc2.example.net" is the effective TargetName:</t>
          <sourcecode type="dns-rr"><![CDATA[
example.com.      7200  IN HTTPS 0 svc.example.net.
svc.example.net.  7200  IN CNAME svc2.example.net.
svc2.example.net. 7200  IN HTTPS 1 . port=8002
svc2.example.net. 300   IN A     192.0.2.2
svc2.example.net. 300   IN AAAA  2001:db8::2
]]></sourcecode>
        </section>
      </section>
    </section>
    <section anchor="client-behavior">
      <name>Client Behavior</name>
      <t>"SVCB resolution" is the process of enumerating and ordering the available endpoints
for a service, as performed by the client.  SVCB resolution is implemented as follows:</t>
      <ol spacing="normal" type="1"><li>Let $QNAME be the service name plus appropriate prefixes for the
scheme (see <xref target="svcb-names"/>).</li>
        <li>Issue a SVCB query for $QNAME.</li>
        <li>If an AliasMode SVCB record is returned for $QNAME (after following CNAMEs
as normal), set $QNAME to its TargetName (without
additional prefixes) and loop back to Step 2,
subject to chain length limits and loop detection heuristics (see
<xref target="client-failures"/>).</li>
        <li>If one or more "compatible" (<xref target="mandatory"/>) ServiceMode records are returned,
these represent the alternative endpoints. Sort the records by ascending SvcPriority.</li>
        <li>Otherwise, SVCB resolution has failed, and the list of available endpoints is
empty.</li>
      </ol>
      <t>This procedure does not rely on any recursive or authoritative DNS server to
comply with this specification or have any awareness of SVCB.</t>
      <t>A client is called "SVCB-optional" if it can connect without the use of
ServiceMode records; otherwise, it is called "SVCB-reliant".  Clients for pre-existing
protocols (e.g., HTTP) <bcp14>SHALL</bcp14> implement SVCB-optional behavior (except as
noted in <xref target="client-failures"/> or when modified by future specifications).</t>
      <t>SVCB-optional clients <bcp14>SHOULD</bcp14> issue in parallel any other DNS queries that might
be needed for connection establishment if the SVCB record is absent, in order to minimize delay
in that case and enable the optimizations discussed in <xref target="optimizations"/>.</t>
      <t>Once SVCB resolution has concluded, whether successful or not,
if at least one AliasMode record was processed,
SVCB-optional clients <bcp14>SHALL</bcp14> append to the list of endpoints an
endpoint consisting of the final value of $QNAME, the authority
endpoint's port number, and no SvcParams.  (This endpoint will be
attempted before falling back to non-SVCB connection modes.  This ensures that
SVCB-optional clients will make use of an AliasMode record whose TargetName has
A and/or AAAA records but no SVCB records.)</t>
      <t>The client proceeds with connection establishment using this list of
endpoints.  Clients <bcp14>SHOULD</bcp14> try higher-priority alternatives first, with
fallback to lower-priority alternatives.  Clients resolve AAAA and/or A
records for the selected TargetName and <bcp14>MAY</bcp14> choose between them using an
approach such as Happy Eyeballs <xref target="RFC8305"/>.</t>
      <t>If the client is SVCB-optional and connecting using this list of endpoints has
failed, the client now attempts to use non-SVCB connection modes.</t>
      <t>Some important optimizations are discussed in <xref target="optimizations"/>
to avoid additional latency in comparison to ordinary AAAA/A lookups.</t>
      <section anchor="client-failures">
        <name>Handling Resolution Failures</name>
        <t>If DNS responses are cryptographically protected (e.g., using DNSSEC or
TLS <xref target="RFC7858"/> <xref target="RFC8484"/>) and SVCB resolution fails
due to an authentication error, SERVFAIL response, transport error, or
timeout, the client <bcp14>SHOULD</bcp14> abandon its attempt to reach the service, even
if the client is SVCB-optional.  Otherwise, an active attacker
could mount a downgrade attack by denying the user access to the SvcParams.</t>
        <t>A SERVFAIL error can occur if the domain is DNSSEC-signed, the recursive
resolver is DNSSEC-validating, and the attacker is between the recursive
resolver and the authoritative DNS server.  A transport error or timeout can
occur if an active attacker between the client and the recursive resolver is
selectively dropping SVCB queries or responses, based on their size or
other observable patterns.</t>
        <t>If the client enforces DNSSEC validation on A/AAAA responses, it <bcp14>SHOULD</bcp14>
apply the same validation policy to SVCB.  Otherwise, an attacker could
defeat the A/AAAA protection by forging SVCB responses that direct the
client to other IP addresses.</t>
        <t>If DNS responses are not cryptographically protected, clients <bcp14>MAY</bcp14> treat
SVCB resolution failure as fatal or nonfatal.</t>
        <t>If the client is unable to complete SVCB resolution due to its chain length
limit, the client <bcp14>MUST</bcp14> fall back to the authority endpoint, as if the
service's SVCB record did not exist.</t>
      </section>
      <section anchor="clients-using-a-proxy">
        <name>Clients Using a Proxy</name>
        <t>Clients using a domain-oriented transport proxy like HTTP CONNECT
(<xref section="4.3.6" sectionFormat="comma" target="RFC7231"/>) or SOCKS5 <xref target="RFC1928"/> have the option of
using named destinations, in which case the client does not perform
any A or AAAA queries for destination domains.  If the client is configured
to use named
destinations with a proxy that does not provide SVCB query capability
(e.g., through an affiliated DNS resolver), the client would have to perform
SVCB resolution separately, likely disclosing the destinations to additional parties and not just the proxy.
Clients in this configuration <bcp14>SHOULD</bcp14> arrange for a separate SVCB resolution
procedure with appropriate privacy properties.  If this is not possible,
SVCB-optional clients <bcp14>MUST</bcp14> disable SVCB resolution entirely, and SVCB-reliant
clients <bcp14>MUST</bcp14> treat the configuration as invalid.</t>
        <t>If the client does use SVCB and named destinations, the client <bcp14>SHOULD</bcp14> follow
the standard SVCB resolution process, selecting the smallest-SvcPriority
option that is compatible with the client and the proxy.  When connecting
using a SVCB record, clients <bcp14>MUST</bcp14> provide the final TargetName and port to the
proxy, which will perform any required A and AAAA lookups.</t>
        <t>This arrangement has several benefits:</t>
        <ul spacing="normal">
          <li>
            <t>Compared to disabling SVCB:
            </t>
            <ul spacing="normal">
              <li>It allows the client to use the SvcParams, if present, which are
only usable with a specific TargetName.  The SvcParams may
include information that enhances performance (e.g., supported protocols) and privacy.</li>
              <li>It allows a service on an apex domain to use aliasing.</li>
            </ul>
          </li>
          <li>
            <t>Compared to providing the proxy with an IP address:
            </t>
            <ul spacing="normal">
              <li>It allows the proxy to select between IPv4 and IPv6 addresses for the
server according to its configuration.</li>
              <li>It ensures that the proxy receives addresses based on its network
geolocation, not the client's.</li>
              <li>It enables faster fallback for TCP destinations with multiple addresses
of the same family.</li>
            </ul>
          </li>
        </ul>
      </section>
    </section>
    <section anchor="server-behavior">
      <name>DNS Server Behavior</name>
      <section anchor="authoritative-behavior">
        <name>Authoritative Servers</name>
        <t>When replying to a SVCB query, authoritative DNS servers <bcp14>SHOULD</bcp14> return
A, AAAA, and SVCB records in the Additional section for any TargetNames
that are in the zone.  If the zone is signed, the server <bcp14>SHOULD</bcp14> also
include DNSSEC records authenticating the existence or nonexistence of these records
in the Additional section.</t>
        <t>See <xref target="ecs"/> for exceptions.</t>
      </section>
      <section anchor="recursive-behavior">
        <name>Recursive Resolvers</name>
        <t>Whether the recursive resolver is aware of SVCB or not, the normal response
construction process used for unknown RR types <xref target="RFC3597"/>
generates the Answer section of the response.
Recursive resolvers that are aware of SVCB <bcp14>SHOULD</bcp14> help the client to
execute the procedure in <xref target="client-behavior"/> with minimum overall
latency by incorporating additional useful information into the
Additional section of the response as follows:
</t>
        <ol spacing="normal" type="1"><li>Incorporate the results of SVCB resolution.  If the recursive resolver's
local chain length limit (which may be different from the client's limit) has
been reached, terminate.</li>
          <li>
            <t>If any of the resolved SVCB records are in AliasMode, choose one of them
at random, and resolve SVCB, A, and AAAA records for its
TargetName.  </t>
            <ul spacing="normal">
              <li>If any SVCB records are resolved, go to Step 1.</li>
              <li>Otherwise, incorporate the results of A and AAAA resolution, and
terminate.</li>
            </ul>
          </li>
          <li>All the resolved SVCB records are in ServiceMode.  Resolve A and AAAA
queries for each TargetName (or for the owner name if TargetName
is "."), incorporate all the results, and terminate.</li>
        </ol>
        <t>In this procedure, "resolve" means the resolver's ordinary recursive
resolution procedure, as if processing a query for that RRset.
This includes following any aliases that the resolver would ordinarily
follow (e.g., CNAME, DNAME <xref target="RFC6672"/>).  Errors or anomalies in
obtaining additional records <bcp14>MAY</bcp14> cause this process to terminate but
<bcp14>MUST NOT</bcp14> themselves cause the resolver to send a failure response.</t>
        <t>See <xref target="alias-mode"/> for additional safeguards for recursive resolvers
to implement to mitigate loops.</t>
        <t>See <xref target="incomplete-response"/> for possible optimizations of this procedure.</t>
        <section anchor="dns64">
          <name>DNS64</name>
          <t>DNS64 resolvers synthesize responses to AAAA queries for names that only
have an A record (<xref section="5.1.7" sectionFormat="of" target="RFC6147"/>).  SVCB-aware DNS64
resolvers <bcp14>SHOULD</bcp14> apply the same synthesis logic when resolving AAAA
records for the TargetName for inclusion in the Additional section (Step 2 in
<xref target="recursive-behavior"/>) and <bcp14>MAY</bcp14> omit the A records from this section.</t>
          <t>DNS64 resolvers <bcp14>MUST NOT</bcp14> extrapolate the AAAA synthesis logic to the IP
hints in the SvcParams (<xref target="svcparamkeys-iphints"/>).  Modifying the IP hints
would break DNSSEC validation for the SVCB record and would not improve
performance when the above recommendation is implemented.</t>
        </section>
      </section>
      <section anchor="general-requirements">
        <name>General Requirements</name>
        <t>Recursive resolvers <bcp14>MUST</bcp14> be able to convey SVCB records with unrecognized
SvcParamKeys.  Resolvers <bcp14>MAY</bcp14> accomplish this by treating
the entire SvcParams portion of the record as opaque, even if the contents
are invalid.  If a recognized SvcParamKey is followed by a value that is
invalid according to the SvcParam's specification, a recursive resolver
<bcp14>MAY</bcp14> report an error such as SERVFAIL instead of returning
the record.
For complex value types whose interpretation might differ
between implementations or have additional future
allowed values added (e.g., URIs or "alpn"), resolvers
<bcp14>SHOULD</bcp14> limit validation to specified constraints.</t>
        <t>When responding to a query that includes the DNSSEC OK bit <xref target="RFC3225"/>,
DNSSEC-capable recursive and authoritative DNS servers <bcp14>MUST</bcp14> accompany
each RRset in the Additional section with the same DNSSEC-related records
that they would send when providing that RRset as an Answer (e.g., RRSIG, NSEC,
NSEC3).</t>
        <t>According to <xref section="5.4.1" sectionFormat="of" target="RFC2181"/>, "Unauthenticated RRs received
and cached from ... the additional data section ... should not be cached in
such a way that they would ever be returned as answers to a received query.
They may be returned as additional information where appropriate."
Recursive resolvers therefore <bcp14>MAY</bcp14> cache records from the Additional section
for use in populating Additional section responses and <bcp14>MAY</bcp14> cache them
for general use if they are authenticated by DNSSEC.</t>
      </section>
      <section anchor="ecs">
        <name>EDNS Client Subnet (ECS)</name>
        <t>The EDNS Client Subnet (ECS) option <xref target="RFC7871"/> allows recursive
resolvers to request IP addresses that are suitable for a particular client
IP range.  SVCB records may contain IP addresses (in ipv*hint SvcParams)
or direct users to a subnet-specific TargetName, so recursive resolvers
<bcp14>SHOULD</bcp14> include the same ECS option in SVCB queries as in A/AAAA queries.</t>
        <t>According to <xref section="7.3.1" sectionFormat="of" target="RFC7871"/>, "Any records from [the
Additional section] <bcp14>MUST NOT</bcp14> be tied to a network."  Accordingly,
when processing a response whose QTYPE is SVCB-compatible,
resolvers <bcp14>SHOULD</bcp14> treat any records in the Additional section as having
SOURCE PREFIX-LENGTH set to zero and SCOPE PREFIX-LENGTH as specified
in the ECS option.  Authoritative servers <bcp14>MUST</bcp14> omit such records if they are
not suitable for use by any stub resolvers that set SOURCE PREFIX-LENGTH to
zero.  This will cause the resolver to perform a follow-up query that can
receive a properly tailored ECS.  (This is similar to the usage of CNAME with
the ECS option as discussed in <xref section="7.2.1" sectionFormat="comma" target="RFC7871"/>.)</t>
        <t>Authoritative servers that omit Additional records can avoid the added
latency of a follow-up query by following the advice in <xref target="zone-performance"/>.</t>
      </section>
    </section>
    <section anchor="optimizations">
      <name>Performance Optimizations</name>
      <t>For optimal performance (i.e., minimum connection setup time), clients
<bcp14>SHOULD</bcp14> implement a client-side DNS cache.
Responses in the Additional section of a SVCB response <bcp14>SHOULD</bcp14> be placed
in cache before performing any follow-up queries.
With this behavior, and with conforming DNS servers,
using SVCB does not add network latency to connection setup.</t>
      <t>To improve performance when using a non-conforming recursive resolver, clients
<bcp14>SHOULD</bcp14> issue speculative A and/or AAAA queries in parallel with each SVCB
query, based on a predicted value of TargetName (see <xref target="zone-performance"/>).</t>
      <t>After a ServiceMode RRset is received, clients <bcp14>MAY</bcp14> try more than one option
in parallel and <bcp14>MAY</bcp14> prefetch A and AAAA records for multiple TargetNames.</t>
      <section anchor="optimistic-pre-connection-and-connection-reuse">
        <name>Optimistic Pre-connection and Connection Reuse</name>
        <t>If an address response arrives before the corresponding SVCB response, the
client <bcp14>MAY</bcp14> initiate a connection as if the SVCB query returned NODATA but
<bcp14>MUST NOT</bcp14> transmit any information that could be altered by the SVCB response
until it arrives.  For example, future SvcParamKeys could be defined that
alter the TLS ClientHello.</t>
        <t>Clients
implementing this optimization <bcp14>SHOULD</bcp14> wait for 50 milliseconds before
starting optimistic pre-connection, as per the guidance in
<xref target="RFC8305"/>.</t>
        <t>A SVCB record is consistent with a connection
if the client would attempt an equivalent connection when making use of
that record. If a SVCB record is consistent with an active or in-progress
connection C, the client <bcp14>MAY</bcp14> prefer that record and use C as its connection.
For example, suppose the client receives this SVCB RRset for a protocol
that uses TLS over TCP:</t>
        <sourcecode type="dns-rr"><![CDATA[
_1234._bar.example.com. 300 IN SVCB 1 svc1.example.net. (
    ipv6hint=2001:db8::1 port=1234 )
                               SVCB 2 svc2.example.net. (
    ipv6hint=2001:db8::2 port=1234 )
]]></sourcecode>
        <t>If the client has an in-progress TCP connection to <tt>[2001:db8::2]:1234</tt>,
it <bcp14>MAY</bcp14> proceed with TLS on that connection, even
though the other record in the RRset has higher priority.</t>
        <t>If none of the SVCB records are consistent
with any active or in-progress connection,
clients proceed with connection establishment as described in
<xref target="client-behavior"/>.</t>
      </section>
      <section anchor="incomplete-response">
        <name>Generating and Using Incomplete Responses</name>
        <t>When following the procedure in <xref target="recursive-behavior"/>, recursive
resolvers <bcp14>MAY</bcp14> terminate the procedure early and produce a reply that omits
some of the associated RRsets.  This is <bcp14>REQUIRED</bcp14> when the chain length limit
is reached (Step 1 in <xref target="recursive-behavior"/>) but might also be appropriate
when the maximum response size is reached or when responding before fully
chasing dependencies would improve performance.  When omitting certain
RRsets, recursive resolvers <bcp14>SHOULD</bcp14> prioritize information for
smaller-SvcPriority records.</t>
        <t>As discussed in <xref target="client-behavior"/>, clients <bcp14>MUST</bcp14> be able to fetch additional
information that is required to use a SVCB record, if it is not included
in the initial response.  As a performance optimization, if some of the SVCB
records in the response can be used without requiring additional DNS queries,
the client <bcp14>MAY</bcp14> prefer those records, regardless of their priorities.</t>
      </section>
    </section>
    <section anchor="svcb-compatible">
      <name>SVCB-Compatible RR Types</name>
      <t>An RR type is called "SVCB-compatible" if it permits an implementation that is
identical to SVCB in its:</t>
      <ul spacing="normal">
        <li>RDATA presentation format</li>
        <li>RDATA wire format</li>
        <li>IANA registry used for SvcParamKeys</li>
        <li>Authoritative server Additional section processing</li>
        <li>Recursive resolution process</li>
        <li>Relevant Class (i.e., Internet ("IN") <xref target="RFC1035"/>)</li>
      </ul>
      <t>This allows authoritative and recursive DNS servers to apply identical
processing to all SVCB-compatible RR types.</t>
      <t>All other behaviors described as applying to the SVCB RR also apply
to all SVCB-compatible RR types unless explicitly stated otherwise.
When following an AliasMode record (<xref target="alias-mode"/>) of RR type $T, the
follow-up query to the TargetName <bcp14>MUST</bcp14> also be for type $T.</t>
      <t>This document defines one SVCB-compatible RR type (other than SVCB itself):
the HTTPS RR type (<xref target="https"/>), which avoids Attrleaf label prefixes <xref target="RFC8552"/> in order to improve
compatibility with wildcards and CNAMEs, which are widely used with HTTP.</t>
      <t>Standards authors should consider carefully whether to use SVCB or define a
new SVCB-compatible RR type, as this choice cannot easily be reversed after
deployment.</t>
    </section>
    <section anchor="keys">
      <name>Initial SvcParamKeys</name>
      <t>A few initial SvcParamKeys are defined here.  These keys are useful for the
"https" scheme, and most are expected to be generally applicable to other
schemes as well.</t>
      <t>Each new protocol
mapping document <bcp14>MUST</bcp14> specify which keys are applicable and safe to use.
Protocol mappings <bcp14>MAY</bcp14> alter the interpretation of SvcParamKeys but <bcp14>MUST NOT</bcp14>
alter their presentation or wire formats.</t>
      <section anchor="alpn-key">
        <name>"alpn" and "no-default-alpn"</name>
        <t>The "alpn" and "no-default-alpn" SvcParamKeys together
indicate the set of Application-Layer Protocol Negotiation (ALPN)
protocol identifiers <xref target="RFC7301"/>
and associated transport protocols supported by this service endpoint (the
"SVCB ALPN set").</t>
        <t>As with Alt-Svc <xref target="RFC7838"/>, each ALPN protocol identifier is used to
identify the application protocol and associated suite
of protocols supported by the endpoint (the "protocol suite").
The presence of an ALPN protocol identifier in the SVCB ALPN set indicates that this
service endpoint, described by TargetName and the other parameters (e.g.,
"port"), offers service with the protocol suite associated with this ALPN identifier.</t>
        <t>Clients filter the set of ALPN identifiers to match the protocol suites they
support, and this informs the underlying transport protocol used (such
as QUIC over UDP or TLS over TCP).  ALPN protocol identifiers that do not uniquely
identify a protocol suite (e.g., an Identification Sequence that
can be used with both TLS and DTLS) are not compatible with this
SvcParamKey and <bcp14>MUST NOT</bcp14> be included in the SVCB ALPN set.</t>
        <section anchor="representation">
          <name>Representation</name>
          <t>ALPNs are identified by their registered "Identification Sequence"
(<tt>alpn-id</tt>), which is a sequence of 1-255 octets.</t>
<sourcecode name="" type="abnf"><![CDATA[
alpn-id = 1*255OCTET
]]></sourcecode>
          <t>For "alpn", the presentation <tt>value</tt> <bcp14>SHALL</bcp14> be
a comma-separated list (<xref target="value-list"/>)
of one or more <tt>alpn-id</tt>s.  Zone-file implementations <bcp14>MAY</bcp14> disallow the
"," and "\" characters in ALPN IDs instead of implementing the <tt>value-list</tt> escaping
procedure, relying on the opaque key format (e.g., <tt>key1=\002h2</tt>) in the
event that these characters are needed.</t>
          <t>The wire-format value for "alpn" consists of at least one
<tt>alpn-id</tt> prefixed by its length as a single octet, and these length-value
pairs are concatenated to form the SvcParamValue.  These pairs <bcp14>MUST</bcp14> exactly
fill the SvcParamValue; otherwise, the SvcParamValue is malformed.</t>
          <t>For "no-default-alpn", the presentation and wire-format values <bcp14>MUST</bcp14> be
empty.  When "no-default-alpn" is specified in an RR,
"alpn" must also be specified in order for the RR
to be "self-consistent" (<xref target="service-mode"/>).</t>
          <t>Each scheme that uses this SvcParamKey defines a "default set" of ALPN IDs
that are supported by nearly all clients and servers; this set <bcp14>MAY</bcp14>
be empty.  To determine the SVCB ALPN set, the client starts with the list of
<tt>alpn-id</tt>s from the "alpn" SvcParamKey, and it adds the default set unless the
"no-default-alpn" SvcParamKey is present.</t>
        </section>
        <section anchor="use">
          <name>Use</name>
          <t>To establish a connection to the endpoint, clients <bcp14>MUST</bcp14></t>
          <ol spacing="normal" type="1"><li>Let SVCB-ALPN-Intersection be the set of protocols in the SVCB ALPN set
that the client supports.</li>
            <li>Let Intersection-Transports be the set of transports (e.g., TLS, DTLS, QUIC)
implied by the protocols in SVCB-ALPN-Intersection.</li>
            <li>For each transport in Intersection-Transports, construct a ProtocolNameList
containing the Identification Sequences of all the client's supported ALPN
protocols for that transport, without regard to the SVCB ALPN set.</li>
          </ol>
          <t>For example, if the SVCB ALPN set is ["http/1.1", "h3"] and the client
supports HTTP/1.1, HTTP/2, and HTTP/3, the client could attempt to connect using
TLS over TCP with a ProtocolNameList of ["http/1.1", "h2"] and could also
attempt a connection using QUIC with a ProtocolNameList of ["h3"].</t>
          <t>Once the client has constructed a ClientHello, protocol negotiation in that
handshake proceeds as specified in <xref target="RFC7301"/>, without regard to the SVCB ALPN
set.</t>
          <t>Clients <bcp14>MAY</bcp14> implement a fallback procedure, using a less-preferred transport
if more-preferred transports fail to connect.  This fallback behavior is
vulnerable to manipulation by a network attacker who blocks the more-preferred
transports, but it may be necessary for compatibility with existing networks.</t>
          <t>With this procedure in place, an attacker who can modify DNS and network
traffic can prevent a successful transport connection but cannot otherwise
interfere with ALPN protocol selection.  This procedure also ensures that
each ProtocolNameList includes at least one protocol from the SVCB ALPN set.</t>
          <t>Clients <bcp14>SHOULD NOT</bcp14> attempt connection to a service endpoint whose SVCB
ALPN set does not contain any supported protocols.</t>
          <t>To ensure
consistency of behavior, clients <bcp14>MAY</bcp14> reject the entire SVCB RRset and fall
back to basic connection establishment if all of the compatible RRs indicate
"no-default-alpn", even if connection could have succeeded using a
non-default ALPN protocol.</t>
          <t>Zone operators <bcp14>SHOULD</bcp14> ensure that at least one RR in each RRset supports the
default transports.  This enables compatibility with the greatest number of
clients.</t>
        </section>
      </section>
      <section anchor="svcparamkeys-port">
        <name>"port"</name>
        <t>The "port" SvcParamKey defines the TCP or UDP port
that should be used to reach this alternative endpoint.
If this key is not present, clients <bcp14>SHALL</bcp14> use the authority endpoint's port
number.</t>
        <t>The presentation <tt>value</tt> of the SvcParamValue is a single decimal integer
between 0 and 65535 in ASCII.  Any other <tt>value</tt> (e.g., an empty value)
is a syntax error.  To enable simpler parsing, this SvcParamValue <bcp14>MUST NOT</bcp14> contain
escape sequences.</t>
        <t>The wire format of the SvcParamValue
is the corresponding 2-octet numeric value in network byte order.</t>
        <t>If a port-restricting firewall is in place between some client and the service
endpoint, changing the port number might cause that client to lose access to
the service, so operators should exercise caution when using this SvcParamKey
to specify a non-default port.</t>
      </section>
      <section anchor="svcparamkeys-iphints">
        <name>"ipv4hint" and "ipv6hint"</name>
        <t>The "ipv4hint" and "ipv6hint" keys convey IP addresses that clients <bcp14>MAY</bcp14> use to
reach the service.  If A and AAAA records for TargetName are locally
available, the client <bcp14>SHOULD</bcp14> ignore these hints.  Otherwise, clients
<bcp14>SHOULD</bcp14> perform A and/or AAAA queries for TargetName per
<xref target="client-behavior"/>, and clients <bcp14>SHOULD</bcp14> use the IP address in those
responses for future connections. Clients <bcp14>MAY</bcp14> opt to terminate any
connections using the addresses in hints and instead switch to the
addresses in response to the TargetName query. Failure to use A and/or
AAAA response addresses could negatively impact load balancing or other
geo-aware features and thereby degrade client performance.</t>
        <t>The presentation <tt>value</tt> <bcp14>SHALL</bcp14> be a comma-separated list (<xref target="value-list"/>)
of one or more IP addresses of the appropriate
family in standard textual format <xref target="RFC5952"/> <xref target="RFC4001"/>.  To enable simpler parsing,
this SvcParamValue <bcp14>MUST NOT</bcp14> contain escape sequences.</t>
        <t>The wire format for each parameter is a sequence of IP addresses in network
byte order (for the respective address family).
Like an A or AAAA RRset, the list of addresses represents an
unordered collection, and clients <bcp14>SHOULD</bcp14> pick addresses to use in a random order.
An empty list of addresses is invalid.</t>
        <t>When selecting between IPv4 and IPv6 addresses to use, clients may use an
approach such as Happy Eyeballs <xref target="RFC8305"/>.
When only "ipv4hint" is present, NAT64 clients may synthesize
IPv6 addresses as specified in <xref target="RFC7050"/> or ignore the "ipv4hint" key and
wait for AAAA resolution (<xref target="client-behavior"/>).
For best performance, server operators <bcp14>SHOULD</bcp14> include an "ipv6hint" parameter
whenever they include an "ipv4hint" parameter.</t>
        <t>These parameters are intended to minimize additional connection latency
when a recursive resolver is not compliant with the requirements in
<xref target="server-behavior"/> and <bcp14>SHOULD NOT</bcp14> be included if most clients are using
compliant recursive resolvers.  When TargetName is the service name
or the owner name (which can be written as "."), server operators
<bcp14>SHOULD NOT</bcp14> include these hints, because they are unlikely to convey any
performance benefit.</t>
      </section>
      <section anchor="svcparamkey-mandatory">
        <name>"mandatory"</name>
        <t>See <xref target="mandatory"/>.</t>
      </section>
    </section>
    <section anchor="mandatory">
      <name>ServiceMode RR Compatibility and Mandatory Keys</name>
      <t>In a ServiceMode RR, a SvcParamKey is considered "mandatory" if the RR will not
function correctly for clients that ignore this SvcParamKey.  Each SVCB
protocol mapping <bcp14>SHOULD</bcp14> specify a set of keys that are "automatically
mandatory", i.e., mandatory if they are present in an RR.  The SvcParamKey
"mandatory" is used to indicate any mandatory keys for this RR, in addition to
any automatically mandatory keys that are present.</t>
      <t>A ServiceMode RR is considered "compatible" by a client if the client
recognizes all the mandatory keys and their values indicate that successful
connection establishment is possible.  Incompatible RRs are ignored (see step 5 of the procedure defined in <xref target="client-behavior"/>).</t>
      <t>The presentation <tt>value</tt> <bcp14>SHALL</bcp14> be a comma-separated list
(<xref target="value-list"/>) of one or more valid
SvcParamKeys, either by their registered name or in the unknown-key format
(<xref target="presentation"/>).  Keys <bcp14>MAY</bcp14> appear in any order but <bcp14>MUST NOT</bcp14> appear more
than once.  For self-consistency (<xref target="service-mode"/>), listed keys <bcp14>MUST</bcp14> also
appear in the SvcParams.</t>
      <t>To enable simpler parsing, this
SvcParamValue <bcp14>MUST NOT</bcp14> contain escape sequences.</t>
      <t>For example, the following is a valid list of SvcParams:</t>
      <sourcecode><![CDATA[
ipv6hint=... key65333=ex1 key65444=ex2 mandatory=key65444,ipv6hint
]]></sourcecode>
      <t>In wire format, the keys are represented by their numeric values in
network byte order, concatenated in strictly increasing numeric order.</t>
      <t>This SvcParamKey is always automatically mandatory and <bcp14>MUST NOT</bcp14> appear in its
own value-list.  Other automatically mandatory keys <bcp14>SHOULD NOT</bcp14> appear in the
list either.  (Including them wastes space and otherwise has no effect.)</t>
    </section>
    <section anchor="https">
      <name>Using Service Bindings with HTTP</name>
      <t>The use of any protocol with SVCB requires a protocol-specific mapping
specification.  This section specifies the mapping for the "http" and "https"
URI schemes <xref target="RFC9110"/>.</t>
      <t>To enable special handling for HTTP use cases,
the HTTPS RR type is defined as a SVCB-compatible RR type,
specific to the "https" and "http" schemes.  Clients <bcp14>MUST NOT</bcp14>
perform SVCB queries or accept SVCB responses for "https"
or "http" schemes.</t>
      <t>The presentation format of the record is:</t>
      <sourcecode><![CDATA[
Name TTL IN HTTPS SvcPriority TargetName SvcParams
]]></sourcecode>
      <t>All the SvcParamKeys defined in <xref target="keys"/> are permitted for use in
HTTPS RRs.  The default set of ALPN IDs is the single value "http/1.1".
The "automatically mandatory" keys (<xref target="mandatory"/>) are "port"
and "no-default-alpn".  (As described in <xref target="mandatory"/>, clients must
either implement these keys or ignore any RR in which they appear.)
Clients that restrict the destination port in "https" URIs
(e.g., using the "bad ports" list from <xref target="FETCH"/>) <bcp14>SHOULD</bcp14> apply the
same restriction to the "port" SvcParam.</t>
      <t>The presence of an HTTPS RR for an origin also indicates
that clients should connect securely and use the "https" scheme, as
discussed in <xref target="hsts"/>.  This allows HTTPS RRs to apply to
pre-existing "http" scheme URLs, while ensuring that the client uses a
secure and authenticated connection.</t>
      <t>The HTTPS RR parallels the concepts
introduced in "HTTP Alternative Services" <xref target="RFC7838"/>.  Clients and servers that implement HTTPS RRs are
not required to implement Alt-Svc.</t>
      <section anchor="httpsnames">
        <name>Query Names for HTTPS RRs</name>
        <t>The HTTPS RR uses Port Prefix Naming (<xref target="svcb-names"/>),
with one modification: if the scheme is "https" and the port is 443,
then the client's original QNAME is
equal to the service name (i.e., the origin's hostname),
without any prefix labels.</t>
        <t>By removing the Attrleaf labels <xref target="RFC8552"/>
used in SVCB, this construction enables offline DNSSEC signing of
wildcard domains, which are commonly used with HTTP.  Using the
service name as the owner name of the HTTPS record, without prefixes,
also allows the targets of existing CNAME chains
(e.g., CDN hosts) to start returning HTTPS RR responses without
requiring origin domains to configure and maintain an additional
delegation.</t>
        <t>The procedure for following HTTPS AliasMode RRs and CNAME aliases is unchanged from SVCB (as described in Sections&nbsp;<xref target="alias-mode" format="counter"/> and <xref target="client-behavior" format="counter"/>).</t>
        <t>Clients always convert "http" URLs to "https" before performing an
HTTPS RR query using the process described in <xref target="hsts"/>, so domain owners
<bcp14>MUST NOT</bcp14> publish HTTPS RRs with a prefix of "_http".</t>
        <t>Note that none of these forms alter the HTTPS origin or authority.
For example, clients <bcp14>MUST</bcp14> continue to validate TLS certificate
hostnames based on the origin.</t>
      </section>
      <section anchor="comparison-with-alt-svc">
        <name>Comparison with Alt-Svc</name>
        <t>Publishing a ServiceMode HTTPS RR in DNS is intended
to be similar to transmitting an Alt-Svc field value over
HTTP, and receiving an HTTPS RR is intended to be similar to
receiving that field value over HTTP.  However, there are some
differences in the intended client and server behavior.</t>
        <section anchor="alpn-usage">
          <name>ALPN Usage</name>
          <t>Unlike Alt-Svc field values, HTTPS RRs can contain multiple ALPN IDs.  The
meaning and use of these IDs are discussed in <xref target="use"/>.</t>
        </section>
        <section anchor="untrusted-channel">
          <name>Untrusted Channels</name>
          <t>HTTPS records do not require or provide any assurance of authenticity.  (DNSSEC
signing and verification, which would provide such assurance, are <bcp14>OPTIONAL</bcp14>.)
The DNS resolution process is modeled as an untrusted channel that might be
controlled by an attacker, so
Alt-Svc parameters that cannot be safely received in this model <bcp14>MUST NOT</bcp14>
have a corresponding defined SvcParamKey.  For example, there is no
SvcParamKey corresponding to the Alt-Svc "persist" parameter, because
this parameter is not safe to accept over an untrusted channel.</t>
        </section>
        <section anchor="cache-lifetime">
          <name>Cache Lifetime</name>
          <t>There is no SvcParamKey corresponding to the Alt-Svc "ma" (max age) parameter.
Instead, server operators encode the expiration time in the DNS TTL.</t>
          <t>The appropriate TTL value might be different from the "ma" value
used for Alt-Svc, depending on the desired efficiency and
agility.  Some DNS caches incorrectly extend the lifetime of DNS
records beyond the stated TTL, so server operators cannot rely on
HTTPS RRs expiring on time.  Shortening the TTL to compensate
for incorrect caching is <bcp14>NOT RECOMMENDED</bcp14>, as this practice impairs the
performance of correctly functioning caches and does not guarantee
faster expiration from incorrect caches.  Instead, server operators
<bcp14>SHOULD</bcp14> maintain compatibility with expired records until they observe
that nearly all connections have migrated to the new configuration.</t>
        </section>
        <section anchor="granularity">
          <name>Granularity</name>
          <t>Sending Alt-Svc over HTTP allows the server to tailor the Alt-Svc
field value specifically to the client.  When using an HTTPS RR,
groups of clients will necessarily receive the same SvcParams.
Therefore, HTTPS RRs are not suitable for uses that require
single-client granularity.</t>
        </section>
      </section>
      <section anchor="interaction-with-alt-svc">
        <name>Interaction with Alt-Svc</name>
        <t>Clients that implement support for both Alt-Svc and HTTPS records and
are making a connection based on a cached Alt-Svc response <bcp14>SHOULD</bcp14>
retrieve any HTTPS records for the Alt-Svc alt-authority and ensure that
their connection attempts are consistent with both the Alt-Svc parameters
and any received HTTPS SvcParams.  If present, the HTTPS record's TargetName
and port are used for connection establishment (per <xref target="client-behavior"/>).
For example, suppose that
"https://example.com" sends an Alt-Svc field value of:</t>
        <sourcecode type="http-message"><![CDATA[
Alt-Svc: h2="alt.example:443", h2="alt2.example:443", h3=":8443"
]]></sourcecode>
        <t>The client would retrieve the following HTTPS records:</t>
        <sourcecode type="dns-rr"><![CDATA[
alt.example.              IN HTTPS 1 . alpn=h2,h3 foo=...
alt2.example.             IN HTTPS 1 alt2b.example. alpn=h3 foo=...
_8443._https.example.com. IN HTTPS 1 alt3.example. (
    port=9443 alpn=h2,h3 foo=... )
]]></sourcecode>
        <t>Based on these inputs, the following connection attempts would always be
allowed:</t>
        <ul spacing="normal">
          <li>HTTP/2 to <tt>alt.example:443</tt></li>
          <li>HTTP/3 to <tt>alt3.example:9443</tt></li>
          <li>Fallback to the client's non-Alt-Svc connection behavior</li>
        </ul>
        <t>The following connection attempts would not be allowed:</t>
        <ul spacing="normal">
          <li>HTTP/3 to <tt>alt.example:443</tt> (not consistent with Alt-Svc)</li>
          <li>Any connection to <tt>alt2b.example</tt> (no ALPN ID consistent with both the HTTPS
record and Alt-Svc)</li>
          <li>HTTPS over TCP to any port on <tt>alt3.example</tt> (not consistent with Alt-Svc)</li>
        </ul>
        <t>Suppose that "foo" is a SvcParamKey that renders the client SVCB-reliant.
The following Alt-Svc-only connection attempts would be allowed only if
the client does not support "foo", as they rely on SVCB-optional fallback
behavior:</t>
        <ul spacing="normal">
          <li>HTTP/2 to <tt>alt2.example:443</tt></li>
          <li>HTTP/3 to <tt>example.com:8443</tt></li>
        </ul>
        <t>Alt-authorities <bcp14>SHOULD</bcp14> carry the same SvcParams as the origin unless
a deviation is specifically known to be safe.
As noted in <xref section="2.4" sectionFormat="of" target="RFC7838"/>, clients <bcp14>MAY</bcp14> disallow any Alt-Svc
connection according to their own criteria, e.g., disallowing Alt-Svc
connections that lack support for privacy features that are available on
the authority endpoint.</t>
      </section>
      <section anchor="requiring-server-name-indication">
        <name>Requiring Server Name Indication</name>
        <t>Clients <bcp14>MUST NOT</bcp14> use an HTTPS RR response unless the
client supports the TLS Server Name Indication (SNI) extension and
indicates the origin name in the TLS ClientHello (which might be
encrypted via a future specification such as <xref target="I-D.ietf-tls-esni"/>).
This supports the conservation of IP addresses.</t>
        <t>Note that the TLS SNI (and also the HTTP "Host" or ":authority") will indicate
the origin, not the TargetName.</t>
      </section>
      <section anchor="hsts">
        <name>HTTP Strict Transport Security (HSTS)</name>
        <t>An HTTPS RR directs the client to communicate with this host only over a
secure transport, similar to HSTS <xref target="RFC6797"/>.
Prior to making an "http" scheme request, the client <bcp14>SHOULD</bcp14> perform a lookup
to determine if any HTTPS RRs exist for that origin.  To do so,
the client <bcp14>SHOULD</bcp14> construct a corresponding "https" URL as follows:</t>
        <ol spacing="normal" type="1"><li>Replace the "http" scheme with "https".</li>
          <li>If the "http" URL explicitly specifies port 80, specify port 443.</li>
          <li>Do not alter any other aspect of the URL.</li>
        </ol>
        <t>This construction is equivalent to <xref section="8.3" sectionFormat="of" target="RFC6797"/>, Step 5.</t>
        <t>If an HTTPS RR query for this "https" URL returns any AliasMode HTTPS RRs
or any compatible ServiceMode HTTPS RRs (see <xref target="mandatory"/>), the client
<bcp14>SHOULD</bcp14> behave as if it has received an HTTP 307 (Temporary Redirect) status code
with this "https" URL in the "Location" field.  (Receipt of an incompatible ServiceMode RR does not
trigger the redirect behavior.)
Because HTTPS RRs are received over an often-insecure channel (DNS),
clients <bcp14>MUST NOT</bcp14> place any more trust in this signal than if they
had received a 307 (Temporary Redirect) response over cleartext HTTP.</t>
        <t>Publishing an HTTPS RR can potentially lead to unexpected results
or a loss in functionality in cases where the "http" resource neither
redirects to the "https" resource nor references the same underlying resource.</t>
        <t>When an "https" connection fails due to an error in the underlying secure
transport, such as an error in certificate validation, some clients
currently offer a "user recourse" that allows the user to bypass the
security error and connect anyway.
When making an "https" scheme request to an origin with an HTTPS RR,
either directly or via the above redirect, such a client <bcp14>MAY</bcp14> remove the user
recourse option.  Origins that publish HTTPS RRs therefore <bcp14>MUST NOT</bcp14> rely
on user recourse for access.  For more information, see Sections <xref target="RFC6797" section="8.4" sectionFormat="bare"/> and <xref target="RFC6797" section="12.1" sectionFormat="bare"/> of <xref target="RFC6797"/>.</t>
      </section>
      <section anchor="use-of-https-rrs-in-other-protocols">
        <name>Use of HTTPS RRs in Other Protocols</name>
        <t>All HTTP connections to named origins are eligible to use HTTPS RRs, even
when HTTP is used as part of another protocol or without an explicit HTTP-related URI
scheme (<relref target="RFC9110" section="4.2"/>).  For example, clients that
support HTTPS RRs and implement <xref target="RFC6455"/> using the altered
opening handshake from <xref target="FETCH-WEBSOCKETS"/> <bcp14>SHOULD</bcp14> use HTTPS RRs
for the <tt>requestURL</tt>.</t>
        <t>When HTTP is used in a context where URLs or redirects are not applicable
(e.g., connections to an HTTP proxy), clients that find a corresponding HTTPS RR
<bcp14>SHOULD</bcp14> implement security upgrade behavior equivalent to that
specified in
<xref target="hsts"/>.</t>
        <t>Such protocols <bcp14>MAY</bcp14> define their own SVCB mappings, which <bcp14>MAY</bcp14>
be defined to take precedence over HTTPS RRs.</t>
      </section>
    </section>
    <section anchor="zone-structures">
      <name>Zone Structures</name>
      <section anchor="structuring-zones-for-flexibility">
        <name>Structuring Zones for Flexibility</name>
        <t>Each ServiceMode RRset can only serve a single scheme.  The scheme is indicated
by the owner name and the RR type.  For the generic SVCB RR type, this means that
each owner name can only be used for a single scheme.  The underscore prefixing
requirement (<xref target="svcb-names"/>) ensures that this is true for the initial query,
but it is the responsibility of zone owners to choose names that satisfy this
constraint when using aliases, including CNAME and AliasMode records.</t>
        <t>When using the generic SVCB RR type with aliasing, zone owners <bcp14>SHOULD</bcp14> choose alias
target names that indicate the scheme in use (e.g., "foosvc.example.net" for
"foo" schemes).  This will help to avoid confusion when another scheme needs to
be added to the configuration.  When multiple port numbers are in use, it may be
helpful to repeat the prefix labels in the alias target name (e.g.,
"_1234._foo.svc.example.net").</t>
      </section>
      <section anchor="zone-performance">
        <name>Structuring Zones for Performance</name>
        <t>To avoid a delay for clients using a non-conforming recursive resolver,
domain owners <bcp14>SHOULD</bcp14> minimize the use of AliasMode records and <bcp14>SHOULD</bcp14>
choose TargetName according to a predictable convention that is known
to the client, so that clients can issue A and/or AAAA queries for TargetName
in advance (see <xref target="optimizations"/>).  Unless otherwise specified, the
convention is to set TargetName to the service name for an initial
ServiceMode record, or to "." if it is reached via an alias.</t>
        <figure>
          <name>"foo://foo.example.com:8080" Is Available at "foosvc.example.net", but "bar://bar.example.com:9090" Is Served Locally</name>
          <sourcecode type="dns-rr"><![CDATA[
$ORIGIN example.com. ; Origin
foo                  3600 IN CNAME foosvc.example.net.
_8080._foo.foo       3600 IN CNAME foosvc.example.net.
bar                   300 IN AAAA 2001:db8::2
_9090._bar.bar       3600 IN SVCB 1 bar key65444=...

$ORIGIN example.net. ; Service provider zone
foosvc               3600 IN SVCB 1 . key65333=...
foosvc                300 IN AAAA 2001:db8::1
]]></sourcecode>
        </figure>
        <t>Domain owners <bcp14>SHOULD</bcp14> avoid using a TargetName that is below a DNAME, as
this is likely unnecessary and makes responses slower and larger.
Also, zone structures that require following more than eight aliases
(counting both AliasMode and CNAME records) are <bcp14>NOT RECOMMENDED</bcp14>.</t>
      </section>
      <section anchor="operational-considerations">
        <name>Operational Considerations</name>
        <t>Some authoritative DNS servers may not allow A or AAAA records on names
starting with an underscore (e.g., <xref target="BIND-CHECK-NAMES"/>).
This could create an operational issue when the TargetName contains an Attrleaf label,
or when using a TargetName of "." if the owner name contains an Attrleaf label.</t>
      </section>
      <section anchor="examples">
        <name>Examples</name>
        <section anchor="protocol-enhancements">
          <name>Protocol Enhancements</name>
          <t>Consider a simple zone of the form:</t>
          <sourcecode type="dns-rr"><![CDATA[
$ORIGIN simple.example. ; Simple example zone
@ 300 IN A    192.0.2.1
         AAAA 2001:db8::1
]]></sourcecode>
          <t>The domain owner could add this record:</t>
          <sourcecode type="dns-rr"><![CDATA[
@ 7200 IN HTTPS 1 . alpn=h3
]]></sourcecode>
          <t>This record would indicate that "https://simple.example" supports QUIC
in addition to HTTP/1.1 over TLS over TCP (the implicit default).
The record could also include other information (e.g., a non-standard port).
For "https://simple.example:8443", the record would be:</t>
          <sourcecode type="dns-rr"><![CDATA[
_8443._https 7200 IN HTTPS 1 . alpn=h3
]]></sourcecode>
          <t>These records also respectively tell clients to replace the scheme with "https" when
loading "http://simple.example" or "http://simple.example:8443".</t>
        </section>
        <section anchor="apex-aliasing">
          <name>Apex Aliasing</name>
          <t>Consider a zone that is using CNAME aliasing:</t>
          <sourcecode type="dns-rr"><![CDATA[
$ORIGIN aliased.example. ; A zone that is using a hosting service
; Subdomain aliased to a high-performance server pool
www             7200 IN CNAME pool.svc.example.
; Apex domain on fixed IPs because CNAME is not allowed at the apex
@                300 IN A     192.0.2.1
                     IN AAAA  2001:db8::1
]]></sourcecode>
          <t>With HTTPS RRs, the owner of aliased.example could alias the apex by
adding one additional record:</t>
          <sourcecode type="dns-rr"><![CDATA[
@               7200 IN HTTPS 0 pool.svc.example.
]]></sourcecode>
          <t>With this record in place, HTTPS-RR-aware clients will use the same
server pool for aliased.example and www.aliased.example.  (They will
also upgrade "http://aliased.example/..." to "https".)  Non-HTTPS-RR-aware
clients will just ignore the new record.</t>
          <t>Similar to CNAME, HTTPS RRs have no impact on the origin name.
When connecting, clients will continue to treat the authoritative
origins as "https://www.aliased.example" and "https://aliased.example",
respectively, and will validate TLS server certificates accordingly.</t>
        </section>
        <section anchor="parameter-binding">
          <name>Parameter Binding</name>
          <t>Suppose that svc.example's primary server pool supports HTTP/3 but its
backup server pool does not.  This can be expressed in the following form:</t>
          <sourcecode type="dns-rr"><![CDATA[
$ORIGIN svc.example. ; A hosting provider
pool  7200 IN HTTPS 1 . alpn=h2,h3
              HTTPS 2 backup alpn=h2 port=8443
pool   300 IN A        192.0.2.2
              AAAA     2001:db8::2
backup 300 IN A        192.0.2.3
              AAAA     2001:db8::3
]]></sourcecode>
          <t>This configuration is entirely compatible with the "apex aliasing" example,
whether the client supports HTTPS RRs or not.  If the client does support
HTTPS RRs, all connections will be upgraded to HTTPS, and clients will
use HTTP/3 if they can.  Parameters are "bound" to each server pool, so
each server pool can have its own protocol, port number, etc.</t>
        </section>
        <section anchor="multicdn">
          <name>Multi-CDN Configuration</name>
          <t>The HTTPS RR is intended to support HTTPS services operated by
multiple independent entities, such as different CDNs or different hosting providers.  This includes
the case where a service is migrated from one operator to another,
as well as the case where the service is multiplexed between
multiple operators for performance, redundancy, etc.</t>
          <t>This example shows such a configuration, with www.customer.example
having different DNS responses to different queries, either over time
or due to logic within the authoritative DNS server:</t>
          <sourcecode type="dns-rr"><![CDATA[
 ; This zone contains/returns different CNAME records
 ; at different points in time.  The RRset for "www" can
 ; only ever contain a single CNAME.

 ; Sometimes the zone has:
 $ORIGIN customer.example.  ; A multi-CDN customer domain
 www 900 IN CNAME cdn1.svc1.example.

 ; and other times it contains:
 $ORIGIN customer.example.
 www 900 IN CNAME customer.svc2.example.

 ; and yet other times it contains:
 $ORIGIN customer.example.
 www 900 IN CNAME cdn3.svc3.example.

 ; With the following remaining constant and always included:
 $ORIGIN customer.example.  ; A multi-CDN customer domain
 ; The apex is also aliased to www to match its configuration.
 @     7200 IN HTTPS 0 www
 ; Non-HTTPS-aware clients use non-CDN IPs.
               A    203.0.113.82
               AAAA 2001:db8:203::2

 ; Resolutions following the cdn1.svc1.example
 ; path use these records.
 ; This CDN uses a different alternative service for HTTP/3.
 $ORIGIN svc1.example.  ; domain for CDN 1
 cdn1     1800 IN HTTPS 1 h3pool alpn=h3
                  HTTPS 2 . alpn=h2
                  A    192.0.2.2
                  AAAA 2001:db8:192::4
 h3pool 300 IN A 192.0.2.3
            AAAA 2001:db8:192:7::3

 ; Resolutions following the customer.svc2.example
 ; path use these records.
 ; Note that this CDN only supports HTTP/2.
 $ORIGIN svc2.example. ; domain operated by CDN 2
 customer 300 IN HTTPS 1 . alpn=h2
           60 IN A    198.51.100.2
                 A    198.51.100.3
                 A    198.51.100.4
                 AAAA 2001:db8:198::7
                 AAAA 2001:db8:198::12

 ; Resolutions following the cdn3.svc3.example
 ; path use these records.
 ; Note that this CDN has no HTTPS records.
 $ORIGIN svc3.example. ; domain operated by CDN 3
 cdn3      60 IN A    203.0.113.8
                 AAAA 2001:db8:113::8
]]></sourcecode>
          <t>Note that in the above example, the different CDNs have different
configurations and different capabilities, but clients will use HTTPS RRs
as a bound-together unit.</t>
          <t>Domain owners should be cautious when using a multi-CDN configuration, as it
introduces a number of complexities highlighted by this example:</t>
          <ul spacing="normal">
            <li>If CDN 1 supports a desired protocol or feature and CDN 2 does not, the
client is vulnerable to
downgrade by a network adversary who forces clients to get CDN 2 records.</li>
            <li>Aliasing the apex to its subdomain simplifies the zone file but likely
increases resolution latency, especially when using a non-HTTPS-aware
recursive resolver.  An alternative would be to alias the zone
apex directly to a name managed by a CDN.</li>
            <li>The A, AAAA, and HTTPS resolutions are independent lookups, so resolvers may
observe and follow different CNAMEs to different CDNs.
Clients may thus find that the A and AAAA responses do not correspond to the
TargetName in the HTTPS response; these clients will need to perform additional
queries to retrieve the correct IP addresses.
Including ipv6hint and ipv4hint will reduce the performance
impact of this case.</li>
            <li>If not all CDNs publish HTTPS records, clients will sometimes
receive NODATA for HTTPS queries (as with cdn3.svc3.example above)
but could receive A/AAAA records from a different CDN.  Clients will
attempt to connect to this CDN without the benefit of its HTTPS
records.</li>
          </ul>
        </section>
        <section anchor="non-http-uses">
          <name>Non-HTTP Uses</name>
          <t>For protocols other than HTTP, the SVCB RR and an Attrleaf label <xref target="RFC8552"/>
will be used.  For example, to reach an example resource of
"baz://api.example.com:8765", the following SVCB
record would be used to alias it to "svc4-baz.example.net.",
which in turn could return AAAA/A records and/or SVCB
records in ServiceMode:</t>
          <sourcecode type="dns-rr"><![CDATA[
_8765._baz.api.example.com. 7200 IN SVCB 0 svc4-baz.example.net.
]]></sourcecode>
          <t>HTTPS RRs use similar Attrleaf labels if the origin contains
a non-default port.</t>
        </section>
      </section>
    </section>
    <section anchor="other-standards">
      <name>Interaction with Other Standards</name>
      <t>This standard is intended to reduce connection latency and
improve user privacy.  Server operators implementing this standard
<bcp14>SHOULD</bcp14> also implement TLS 1.3 <xref target="RFC8446"/> and
Online Certificate Status Protocol (OCSP) Stapling (i.e., Certificate Status
Request in <xref target="RFC6066" section="8" sectionFormat="of"/>),
both of which confer substantial performance and privacy
benefits when used in combination with SVCB records.</t>
      <t>To realize the greatest privacy benefits, this proposal is intended for
use over a privacy-preserving DNS transport (like DNS over TLS
<xref target="RFC7858"/> or DNS over HTTPS <xref target="RFC8484"/>).
However, performance improvements, and some modest privacy improvements,
are possible without the use of those standards.</t>
      <t>Any specification for the use of SVCB with a protocol <bcp14>MUST</bcp14> have an entry for its
scheme under the SVCB RR type in the IANA DNS "Underscored and Globally Scoped DNS Node Names" registry <xref target="RFC8552"/>.  The scheme <bcp14>MUST</bcp14> have an entry in the "Uniform Resource Identifier (URI) Schemes" registry <xref target="RFC7595"/> and <bcp14>MUST</bcp14> have a defined specification for use
with SVCB.</t>
    </section>
    <section anchor="security-considerations">
      <name>Security Considerations</name>
      <t>SVCB/HTTPS RRs permit distribution over untrusted
channels, and clients are <bcp14>REQUIRED</bcp14> to verify that the alternative endpoint
is authoritative for the service (similar to <xref section="2.1" sectionFormat="of" target="RFC7838"/>).
Therefore, DNSSEC signing and validation are <bcp14>OPTIONAL</bcp14> for publishing
and using SVCB and HTTPS RRs.</t>
      <t>Clients <bcp14>MUST</bcp14> ensure that their DNS cache is partitioned for each local
network, or flushed on network changes, to prevent a local adversary in one
network from implanting a forged DNS record that allows them to
track users or hinder their connections after they leave that network.</t>
      <t>An attacker who can prevent SVCB resolution can deny clients any associated
security benefits.  A hostile recursive resolver can always deny service to
SVCB queries, but network intermediaries can often prevent resolution as well,
even when the client and recursive resolver validate DNSSEC and use a secure
transport.  These downgrade attacks can prevent the "https" upgrade provided by
the HTTPS RR (<xref target="hsts"/>) and can disable any other protections coordinated via
SvcParams.  To prevent downgrades, <xref target="client-failures"/>
recommends that clients abandon the connection attempt when such an attack is
detected.</t>
      <t>A hostile DNS intermediary might forge AliasMode "." records (<xref target="aliasdot"/>) as
a way to block clients from accessing particular services.  Such an adversary
could already block entire domains by forging erroneous responses, but this
mechanism allows them to target particular protocols or ports within a domain.
Clients that might be subject to such attacks <bcp14>SHOULD</bcp14> ignore AliasMode "."
records.</t>
      <t>A hostile DNS intermediary or authoritative server can return SVCB records indicating any IP
address and port number, including IP addresses inside the local network and
port numbers assigned to internal services.  If the attacker can influence the
client's payload (e.g., TLS session ticket contents) and an internal service
has a sufficiently lax parser, the attacker could gain access to the
internal service.  (The same concerns apply to SRV records, HTTP Alt-Svc,
and HTTP redirects.)  As a mitigation, SVCB mapping documents <bcp14>SHOULD</bcp14> indicate
any port number restrictions that are appropriate for the supported transports.</t>
    </section>
    <section anchor="privacy-considerations">
      <name>Privacy Considerations</name>
      <t>Standard address queries reveal the user's intent to access a particular
domain.  This information is visible to the recursive resolver, and to
many other parties when plaintext DNS transport is used.  SVCB queries,
like queries for SRV records and other specific RR types, additionally
reveal the user's intent to use a particular protocol.  This is not
normally sensitive information, but it should be considered when adding
SVCB support in a new context.</t>
    </section>
    <section anchor="iana-considerations">
      <name>IANA Considerations</name>
      <section anchor="svcb-rrtype">
        <name>SVCB RR Type</name>

        <t>IANA has registered the following new DNS RR type in the "Resource Record (RR) TYPEs"
registry on the "Domain Name System (DNS) Parameters" page:</t>
        <dl spacing="compact">
          <dt>Type:</dt><dd>SVCB</dd>
          <dt>Value:</dt><dd>64</dd>
          <dt>Meaning:</dt><dd>General-purpose service binding</dd>
          <dt>Reference:</dt><dd>RFC 9460</dd>
	</dl>
      </section>
      <section anchor="https-rrtype">
        <name>HTTPS RR Type</name>

   <t>IANA has registered the following new DNS RR type
   in the "Resource Record (RR) TYPEs" registry
   on the "Domain Name System (DNS) Parameters" page:</t>

        <dl spacing="compact">
          <dt>Type:</dt><dd>HTTPS</dd>
          <dt>Value:</dt><dd>65</dd>
          <dt>Meaning:</dt><dd>SVCB-compatible type for use with HTTP</dd>
          <dt>Reference:</dt><dd>RFC 9460</dd>
	</dl>
      </section>
      <section anchor="svcparamregistry">
        <name>New Registry for Service Parameters</name>
        <t>IANA has created the "Service Parameter Keys (SvcParamKeys)"
registry in the "Domain Name System (DNS) Parameters" category
on a new page entitled "DNS Service Bindings (SVCB)".  This registry
defines the namespace
for parameters, including string representations and numeric
SvcParamKey values.  This registry is shared with other SVCB-compatible
RR types, such as the HTTPS RR.</t>
        <section anchor="procedure">
          <name>Procedure</name>
          <t>A registration <bcp14>MUST</bcp14> include the following fields:</t>
          <dl spacing="compact">
            <dt>Number:</dt><dd>Wire-format numeric identifier (range 0-65535)</dd>
            <dt>Name:</dt><dd>Unique presentation name</dd>
            <dt>Meaning:</dt><dd>A short description</dd>
            <dt>Reference:</dt><dd>Location of specification or registration source</dd>
            <dt>Change Controller:</dt><dd>Person or entity, with contact information if appropriate</dd>
	  </dl>
          <t>The characters in the registered Name field entry <bcp14>MUST</bcp14> be lowercase alphanumeric or "-"
(<xref target="presentation"/>).  The name <bcp14>MUST NOT</bcp14> start with "key" or "invalid".</t>
          <t>The registration policy for new entries is Expert Review (<xref section="4.5" sectionFormat="comma" target="RFC8126"/>).  The designated expert <bcp14>MUST</bcp14> ensure that
the reference is stable and publicly available and that it specifies
how to convert the SvcParamValue's presentation format to wire format.  The
reference <bcp14>MAY</bcp14> be any individual's Internet-Draft or a document from
any other source with similar assurances of stability and availability.
An entry <bcp14>MAY</bcp14> specify a reference of
the form "Same as (other key name)" if it uses the same presentation and wire
formats as an existing key.
</t>
          <t>This arrangement supports the development of new parameters while ensuring that
zone files can be made interoperable.</t>
        </section>
        <section anchor="iana-keys">
          <name>Initial Contents</name>
          <t>The "Service Parameter Keys (SvcParamKeys)" registry has been
populated with the following initial registrations:</t>


          <table>
            <thead>
              <tr>
                <th align="center">Number</th>
                <th align="left">Name</th>
                <th align="left">Meaning</th>
                <th align="left">Reference</th>
                <th align="left">Change Controller</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="center">0</td>
                <td align="left">mandatory</td>
                <td align="left">Mandatory keys in this RR</td>
                <td align="left">RFC 9460, <xref target="mandatory"/></td>
                <td align="left">IETF</td>
              </tr>
              <tr>
                <td align="center">1</td>
                <td align="left">alpn</td>
                <td align="left">Additional supported protocols</td>
                <td align="left">RFC 9460, <xref target="alpn-key"/></td>
                <td align="left">IETF</td>
              </tr>
              <tr>
                <td align="center">2</td>
                <td align="left">no-default-alpn</td>
                <td align="left">No support for default protocol</td>
                <td align="left">RFC 9460, <xref target="alpn-key"/></td>
                <td align="left">IETF</td>
              </tr>
              <tr>
                <td align="center">3</td>
                <td align="left">port</td>
                <td align="left">Port for alternative endpoint</td>
                <td align="left">RFC 9460, <xref target="svcparamkeys-port"/></td>
                <td align="left">IETF</td>
              </tr>
              <tr>
                <td align="center">4</td>
                <td align="left">ipv4hint</td>
                <td align="left">IPv4 address hints</td>
                <td align="left">RFC 9460, <xref target="svcparamkeys-iphints"/></td>
                <td align="left">IETF</td>
              </tr>
              <tr>
                <td align="center">5</td>
                <td align="left">ech</td>
                <td align="left">RESERVED (held for Encrypted ClientHello)</td>
                <td align="left">N/A</td>
                <td align="left">IETF</td>
              </tr>
              <tr>
                <td align="center">6</td>
                <td align="left">ipv6hint</td>
                <td align="left">IPv6 address hints</td>
                <td align="left">RFC 9460, <xref target="svcparamkeys-iphints"/></td>
                <td align="left">IETF</td>
              </tr>
              <tr>
                <td align="center">65280-65534</td>
                <td align="left">N/A</td>
                <td align="left">Reserved for Private Use</td>
                <td align="left">RFC 9460</td>
                <td align="left">IETF</td>
              </tr>
              <tr>
                <td align="center">65535</td>
                <td align="left">N/A</td>
                <td align="left">Reserved ("Invalid key")</td>
                <td align="left">RFC 9460</td>
                <td align="left">IETF</td>
              </tr>
            </tbody>
          </table>
        </section>
      </section>
      <section anchor="other-registry-updates">
        <name>Other Registry Updates</name>
        <t>Per <xref target="RFC8552"/>, the following entry has been added to the DNS "Underscored and Globally Scoped DNS Node Names" registry:</t>
        <table>
          <thead>
            <tr>
              <th align="left">RR Type</th>
              <th align="left">_NODE NAME</th>
              <th align="left">Reference</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">HTTPS</td>
              <td align="left">_https</td>
              <td align="left">RFC 9460</td>
            </tr>
          </tbody>
        </table>
      </section>
    </section>
  </middle>
  <back>

<displayreference target="RFC9110" to="HTTP"/>
<displayreference target="RFC8552" to="Attrleaf"/>
<displayreference target="RFC8305" to="HappyEyeballsV2"/>
<displayreference target="RFC7858" to="DoT"/>
<displayreference target="RFC8484" to="DoH"/>
<displayreference target="RFC7301" to="ALPN"/>
<displayreference target="RFC6455" to="WebSocket"/>
<displayreference target="I-D.ietf-tls-esni" to="ECH"/>
<displayreference target="RFC9114" to="HTTP/3"/>
<displayreference target="RFC2782" to="SRV"/>
<displayreference target="RFC6797" to="HSTS"/>
<displayreference target="RFC7838" to="AltSvc"/>
<displayreference target="RFC8499" to="DNSTerm"/>
<displayreference target="RFC3986" to="URI"/>
<displayreference target="RFC6672" to="DNAME"/>
<displayreference target="I-D.bellis-dnsop-http-record" to="HTTP-DNS-RR"/>
<displayreference target="I-D.ietf-dnsop-aname" to="ANAME-DNS-RR"/>

    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>

<!-- draft-ietf-httpbis-semantics (RFC 9110) -->
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9110.xml"/>

<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8552.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.1035.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.5234.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.1034.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8305.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7858.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8484.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7231.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.1928.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.3597.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6147.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.3225.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2181.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7871.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7301.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.5952.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4001.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7050.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6455.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8446.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6066.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7595.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8126.xml"/>

      </references>
      <references>
        <name>Informative References</name>

        <reference anchor="FETCH" target="https://fetch.spec.whatwg.org/">
          <front>
            <title>Fetch Living Standard</title>
            <author>
              <organization>WHATWG</organization>
            </author>
            <date year="2023" month="October"/>
          </front>
        </reference>

        <reference anchor="FETCH-WEBSOCKETS" target="https://websockets.spec.whatwg.org/">
          <front>
            <title>WebSockets Living Standard</title>
            <author>
              <organization>WHATWG</organization>
            </author>
            <date year="2023" month="September"/>
          </front>
        </reference>

        <reference anchor="BIND-CHECK-NAMES" target="https://bind9.readthedocs.io/en/v9.19.11/reference.html#namedconf-statement-check-names">
          <front>
            <title>BIND v9.19.11 Configuration Reference: "check-names"</title>
            <author>
              <organization>Internet Systems Consortium</organization>
            </author>
            <date year="2023" month="September"/>
          </front>
        </reference>

<!-- draft-ietf-tls-esni (I-D Exists) -->
<xi:include href="https://bib.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-tls-esni.xml"/>

<!-- draft-ietf-quic-http (RFC 9114) -->
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9114.xml"/>

<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2782.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6797.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7838.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6454.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8499.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.3986.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.1912.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6672.xml"/>

<!-- draft-bellis-dnsop-http-record (Expired) -->
<xi:include href="https://bib.ietf.org/public/rfc/bibxml3/reference.I-D.bellis-dnsop-http-record.xml"/>

<!-- draft-ietf-dnsop-aname (Expired) ("long way" to fix author initials) -->
<reference anchor="I-D.ietf-dnsop-aname">
   <front>
      <title>Address-specific DNS aliases (ANAME)</title>
      <author initials="T." surname="Finch" fullname="Tony Finch">
         <organization>University of Cambridge</organization>
      </author>
      <author initials="E." surname="Hunt" fullname="Evan Hunt">
         <organization>ISC</organization>
      </author>
      <author initials="P." surname="van Dijk" fullname="Peter van Dijk">
         <organization>PowerDNS</organization>
      </author>
      <author initials="A." surname="Eden" fullname="Anthony Eden">
         <organization>DNSimple</organization>
      </author>
      <author initials="W." surname="Mekking" fullname="Matthijs Mekking">
         <organization>ISC</organization>
      </author>
      <date month="July" day="8" year="2019" />
   </front>
   <seriesInfo name="Internet-Draft" value="draft-ietf-dnsop-aname-04" />
</reference>

      </references>
    </references>
    <section anchor="decoding">
      <name>Decoding Text in Zone Files</name>
      <t>DNS zone files are capable of representing arbitrary octet sequences in
basic ASCII text, using various delimiters and encodings, according to an algorithm
defined in <xref section="5.1" sectionFormat="of" target="RFC1035"/>.
The following summarizes some allowed inputs to that algorithm, using ABNF:</t>
<sourcecode name="" type="abnf"><![CDATA[
; non-special is VCHAR minus DQUOTE, ";", "(", ")", and "\".
non-special = %x21 / %x23-27 / %x2A-3A / %x3C-5B / %x5D-7E
; non-digit is VCHAR minus DIGIT.
non-digit   = %x21-2F / %x3A-7E
; dec-octet is a number 0-255 as a three-digit decimal number.
dec-octet   = ( "0" / "1" ) 2DIGIT /
              "2" ( ( %x30-34 DIGIT ) / ( "5" %x30-35 ) )
escaped     = "\" ( non-digit / dec-octet )
contiguous  = 1*( non-special / escaped )
quoted      = DQUOTE *( contiguous / ( ["\"] WSP ) ) DQUOTE
char-string = contiguous / quoted
]]></sourcecode>
      <t>The decoding algorithm allows <tt>char-string</tt> to represent any <tt>*OCTET</tt>,
using quoting to group values (e.g., those with internal whitespace), and
escaping to represent each non-printable octet as a single <tt>escaped</tt> sequence.
In this document, this algorithm is referred to as "character-string decoding", because
<xref target="RFC1035" sectionFormat="of" section="5.1"/> uses this
algorithm to produce a <tt>&lt;character-string&gt;</tt>.  Note that while
the length of a <tt>&lt;character-string&gt;</tt> is limited to 255 octets, the
character-string decoding algorithm can produce output of any length.</t>
      <section anchor="value-list">
        <name>Decoding a Comma-Separated List</name>
        <t>In order to represent lists of items in zone files, this specification uses
comma-separated lists.  When the allowed items in the list cannot contain ","
or "\", this is trivial.  (For simplicity, empty items are not allowed.)
A value-list parser that splits on "," and prohibits items containing "\"
is sufficient to comply with all requirements in this document.  This
corresponds to the <tt>simple-comma-separated</tt> syntax:</t>
<sourcecode name="" type="abnf"><![CDATA[
; item-allowed is OCTET minus "," and "\".
item-allowed           = %x00-2B / %x2D-5B / %x5D-FF
simple-item            = 1*item-allowed
simple-comma-separated = [simple-item *("," simple-item)]
]]></sourcecode>
        <t>For implementations that allow "," and "\" in item values, the following
escaping syntax applies:</t>
<sourcecode name="" type="abnf"><![CDATA[
item            = 1*OCTET
escaped-item    = 1*(item-allowed / "\," / "\\")
comma-separated = [escaped-item *("," escaped-item)]
]]></sourcecode>
        <t>Decoding of value-lists happens after character-string decoding.
For example, consider these <tt>char-string</tt> SvcParamValues:</t>
        <sourcecode type="test-vectors"><![CDATA[
"part1,part2,part3\\,part4\\\\"
part1\,\p\a\r\t2\044part3\092,part4\092\\
]]></sourcecode>
        <t>These inputs are equivalent: character-string decoding either of them would
produce the same <tt>value</tt>:</t>
        <sourcecode type="test-vectors"><![CDATA[
part1,part2,part3\,part4\\
]]></sourcecode>
        <t>Applying comma-separated list decoding to this <tt>value</tt> would produce a list
of three <tt>item</tt>s:</t>
        <sourcecode type="test-vectors"><![CDATA[
part1
part2
part3,part4\
]]></sourcecode>
      </section>
    </section>
    <section anchor="http-mapping-summary">
      <name>HTTP Mapping Summary</name>
      <t>This table serves as a non-normative summary of the HTTP mapping for SVCB
(<xref target="https"/>).  Future protocol mappings may provide a similar summary table.</t>

      <table>
        <tbody>
          <tr>
            <td align="left">
              <strong>Mapped scheme</strong></td>
            <td align="left">"https"</td>
          </tr>
          <tr>
            <td align="left">
              <strong>Other affected schemes</strong></td>
            <td align="left">"http", "wss", "ws", (other HTTP-based)</td>
          </tr>
          <tr>
            <td align="left">
              <strong>RR type</strong></td>
            <td align="left">HTTPS (65)</td>
          </tr>
          <tr>
            <td align="left">
              <strong>Name prefix</strong></td>
            <td align="left">None for port 443, else <tt>_$PORT._https</tt></td>
          </tr>
          <tr>
            <td align="left">
              <strong>Automatically mandatory keys</strong></td>
            <td align="left">
              <tt>port</tt>, <tt>no-default-alpn</tt></td>
          </tr>
          <tr>
            <td align="left">
              <strong>SvcParam defaults</strong></td>
            <td align="left">
              <tt>alpn</tt>: ["http/1.1"]</td>
          </tr>
          <tr>
            <td align="left">
              <strong>Special behaviors</strong></td>
            <td align="left">Upgrade from HTTP to HTTPS</td>
          </tr>
          <tr>
            <td align="left">
              <strong>Keys that records must include</strong></td>
            <td align="left">None</td>
          </tr>
        </tbody>
      </table>
    </section>
    <section anchor="comparison-with-alternatives">
      <name>Comparison with Alternatives</name>
      <t>The SVCB and HTTPS RR types closely resemble,
and are inspired by, some existing
record types and proposals.  One complaint regarding all of the alternatives
is that web clients have seemed unenthusiastic about implementing
them.  The hope here is that an extensible solution that
solves multiple problems will overcome this inertia and have a path
to achieve client implementation.</t>
      <section anchor="differences-from-the-srv-rr-type">
        <name>Differences from the SRV RR Type</name>
        <t>An SRV record <xref target="RFC2782"/> can perform a function similar
to that of the SVCB record,
informing a client to look in a different location for a service.
However, there are several differences:</t>
        <ul spacing="normal">
          <li>SRV records are typically mandatory, whereas SVCB is intended to be optional
when used with pre-existing protocols.</li>
          <li>SRV records cannot instruct the client to switch or upgrade
protocols, whereas SVCB can signal such an upgrade (e.g., to
HTTP/2).</li>
          <li>SRV records are not extensible, whereas SVCB and HTTPS RRs
can be extended with new parameters.</li>
          <li>SRV records specify a "weight" for unbalanced randomized load balancing.
SVCB only supports balanced randomized load balancing, although weights
could be added via a future SvcParam.</li>
        </ul>
      </section>
      <section anchor="differences-from-the-proposed-http-record">
        <name>Differences from the Proposed HTTP Record</name>
        <t>Unlike <xref target="I-D.bellis-dnsop-http-record"/>, this approach is
extensible to cover Alt-Svc and Encrypted ClientHello use cases.  Like that
proposal, this addresses the zone-apex CNAME challenge.</t>
        <t>Like that proposal, it remains necessary to continue to include
address records at the zone apex for legacy clients.</t>
      </section>
      <section anchor="differences-from-the-proposed-aname-record">
        <name>Differences from the Proposed ANAME Record</name>
        <t>Unlike <xref target="I-D.ietf-dnsop-aname"/>, this approach is extensible to
cover Alt-Svc and Encrypted ClientHello use cases.  This approach also does not
require any changes or special handling on either authoritative or
primary servers, beyond optionally returning in-bailiwick additional records.</t>
        <t>Like that proposal, this addresses the zone-apex CNAME challenge
for clients that implement this.</t>
        <t>However, with this SVCB proposal, it remains necessary to continue
to include address records at the zone apex for legacy clients.
If deployment of this standard is successful, the number of legacy clients
will fall over time.  As the number of legacy clients declines, the operational
effort required to serve these users without the benefit of SVCB indirection
should fall.  Server operators can easily observe how much traffic reaches this
legacy endpoint and may remove the apex's address records if the observed legacy
traffic has fallen to negligible levels.</t>
      </section>
      <section anchor="comparison-with-separate-rr-types-for-aliasmode-and-servicemode">
        <name>Comparison with Separate RR Types for AliasMode and ServiceMode</name>
        <t>Abstractly, functions of AliasMode and ServiceMode are independent,
so it might be tempting to specify them as separate RR types.  However,
this would result in serious performance impairment, because clients
cannot rely on their recursive resolver to follow SVCB aliases (unlike
CNAME).  Thus, clients would have to issue queries for both RR types
in parallel, potentially at each step of the alias chain.  Recursive
resolvers that implement the specification would, upon receipt of a
ServiceMode query, emit both a ServiceMode query and an AliasMode query to
the authoritative DNS server.  Thus, splitting the RR type would double, or in
some cases triple, the load on clients and servers, and would not
reduce implementation complexity.</t>
      </section>
    </section>
    <section anchor="test-vectors">
      <name>Test Vectors</name>
      <t>These test vectors only contain the RDATA portion of SVCB/HTTPS records in
presentation format, generic format <xref target="RFC3597"/>, and wire format. The wire
format uses hexadecimal (\xNN) for each non-ASCII byte. As the wire format is
long, it is broken into several lines.</t>
      <section anchor="aliasmode">
        <name>AliasMode</name>
        <figure>
          <name>AliasMode</name>
          <sourcecode type="test-vectors"><![CDATA[
example.com.   HTTPS   0 foo.example.com.

\# 19 (
00 00                                              ; priority
03 66 6f 6f 07 65 78 61 6d 70 6c 65 03 63 6f 6d 00 ; target
)

\x00\x00                                           # priority
\x03foo\x07example\x03com\x00                      # target
]]></sourcecode>
        </figure>
      </section>
      <section anchor="servicemode-1">
        <name>ServiceMode</name>
        <figure>
          <name>TargetName Is "."</name>
          <sourcecode type="test-vectors"><![CDATA[
example.com.   SVCB   1 .

\# 3 (
00 01      ; priority
00         ; target (root label)
)

\x00\x01   # priority
\x00       # target (root label)
]]></sourcecode>
        </figure>
        <figure>
          <name>Specifies a Port</name>
          <sourcecode type="test-vectors"><![CDATA[
example.com.   SVCB   16 foo.example.com. port=53

\# 25 (
00 10                                              ; priority
03 66 6f 6f 07 65 78 61 6d 70 6c 65 03 63 6f 6d 00 ; target
00 03                                              ; key 3
00 02                                              ; length 2
00 35                                              ; value
)

\x00\x10                                           # priority
\x03foo\x07example\x03com\x00                      # target
\x00\x03                                           # key 3
\x00\x02                                           # length 2
\x00\x35                                           # value
]]></sourcecode>
        </figure>
        <figure>
          <name>A Generic Key and Unquoted Value</name>
          <sourcecode type="test-vectors"><![CDATA[
example.com.   SVCB   1 foo.example.com. key667=hello

\# 28 (
00 01                                              ; priority
03 66 6f 6f 07 65 78 61 6d 70 6c 65 03 63 6f 6d 00 ; target
02 9b                                              ; key 667
00 05                                              ; length 5
68 65 6c 6c 6f                                     ; value
)

\x00\x01                                           # priority
\x03foo\x07example\x03com\x00                      # target
\x02\x9b                                           # key 667
\x00\x05                                           # length 5
hello                                              # value
]]></sourcecode>
        </figure>
        <figure>
          <name>A Generic Key and Quoted Value with a Decimal Escape</name>
          <sourcecode type="test-vectors"><![CDATA[
example.com.   SVCB   1 foo.example.com. key667="hello\210qoo"

\# 32 (
00 01                                              ; priority
03 66 6f 6f 07 65 78 61 6d 70 6c 65 03 63 6f 6d 00 ; target
02 9b                                              ; key 667
00 09                                              ; length 9
68 65 6c 6c 6f d2 71 6f 6f                         ; value
)

\x00\x01                                           # priority
\x03foo\x07example\x03com\x00                      # target
\x02\x9b                                           # key 667
\x00\x09                                           # length 9
hello\xd2qoo                                       # value
]]></sourcecode>
        </figure>
        <figure>
          <name>Two Quoted IPv6 Hints</name>
          <sourcecode type="test-vectors"><![CDATA[
example.com.   SVCB   1 foo.example.com. (
                      ipv6hint="2001:db8::1,2001:db8::53:1"
                      )

\# 55 (
00 01                                              ; priority
03 66 6f 6f 07 65 78 61 6d 70 6c 65 03 63 6f 6d 00 ; target
00 06                                              ; key 6
00 20                                              ; length 32
20 01 0d b8 00 00 00 00 00 00 00 00 00 00 00 01    ; first address
20 01 0d b8 00 00 00 00 00 00 00 00 00 53 00 01    ; second address
)

\x00\x01                                           # priority
\x03foo\x07example\x03com\x00                      # target
\x00\x06                                           # key 6
\x00\x20                                           # length 32
\x20\x01\x0d\xb8\x00\x00\x00\x00
     \x00\x00\x00\x00\x00\x00\x00\x01              # first address
\x20\x01\x0d\xb8\x00\x00\x00\x00
     \x00\x00\x00\x00\x00\x53\x00\x01              # second address
]]></sourcecode>
        </figure>
        <figure>
          <name>An IPv6 Hint Using the Embedded IPv4 Syntax</name>
          <sourcecode type="test-vectors"><![CDATA[
example.com.   SVCB   1 example.com. (
                        ipv6hint="2001:db8:122:344::192.0.2.33"
                        )
\# 35 (
00 01                                              ; priority
07 65 78 61 6d 70 6c 65 03 63 6f 6d 00             ; target
00 06                                              ; key 6
00 10                                              ; length 16
20 01 0d b8 01 22 03 44 00 00 00 00 c0 00 02 21    ; address
)

\x00\x01                                           # priority
\x07example\x03com\x00                             # target
\x00\x06                                           # key 6
\x00\x10                                           # length 16
\x20\x01\x0d\xb8\x01\x22\x03\x44
     \x00\x00\x00\x00\xc0\x00\x02\x21              # address
]]></sourcecode>
        </figure>
        <figure>
          <name>SvcParamKey Ordering Is Arbitrary in Presentation Format but Sorted in Wire Format</name>
          <sourcecode type="test-vectors"><![CDATA[
example.com.   SVCB   16 foo.example.org. (
                      alpn=h2,h3-19 mandatory=ipv4hint,alpn
                      ipv4hint=192.0.2.1
                      )

\# 48 (
00 10                                              ; priority
03 66 6f 6f 07 65 78 61 6d 70 6c 65 03 6f 72 67 00 ; target
00 00                                              ; key 0
00 04                                              ; param length 4
00 01                                              ; value: key 1
00 04                                              ; value: key 4
00 01                                              ; key 1
00 09                                              ; param length 9
02                                                 ; alpn length 2
68 32                                              ; alpn value
05                                                 ; alpn length 5
68 33 2d 31 39                                     ; alpn value
00 04                                              ; key 4
00 04                                              ; param length 4
c0 00 02 01                                        ; param value
)

\x00\x10                                           # priority
\x03foo\x07example\x03org\x00                      # target
\x00\x00                                           # key 0
\x00\x04                                           # param length 4
\x00\x01                                           # value: key 1
\x00\x04                                           # value: key 4
\x00\x01                                           # key 1
\x00\x09                                           # param length 9
\x02                                               # alpn length 2
h2                                                 # alpn value
\x05                                               # alpn length 5
h3-19                                              # alpn value
\x00\x04                                           # key 4
\x00\x04                                           # param length 4
\xc0\x00\x02\x01                                   # param value
]]></sourcecode>
        </figure>
        <figure>
          <name>An &quot;alpn&quot; Value with an Escaped Comma and an Escaped Backslash in Two Presentation Formats</name>
          <sourcecode type="test-vectors"><![CDATA[
example.com.   SVCB   16 foo.example.org. alpn="f\\\\oo\\,bar,h2"
example.com.   SVCB   16 foo.example.org. alpn=f\\\092oo\092,bar,h2

\# 35 (
00 10                                              ; priority
03 66 6f 6f 07 65 78 61 6d 70 6c 65 03 6f 72 67 00 ; target
00 01                                              ; key 1
00 0c                                              ; param length 12
08                                                 ; alpn length 8
66 5c 6f 6f 2c 62 61 72                            ; alpn value
02                                                 ; alpn length 2
68 32                                              ; alpn value
)

\x00\x10                                           # priority
\x03foo\x07example\x03org\x00                      # target
\x00\x01                                           # key 1
\x00\x0c                                           # param length 12
\x08                                               # alpn length 8
f\oo,bar                                           # alpn value
\x02                                               # alpn length 2
h2                                                 # alpn value
]]></sourcecode>
        </figure>
      </section>
      <section anchor="failure-cases">
        <name>Failure Cases</name>
        <t>This subsection contains test vectors that are not
compliant with this document. The various reasons for non-compliance
are explained with each example.</t>
        <figure>
          <name>Multiple Instances of the Same SvcParamKey</name>
          <sourcecode type="dns-rr"><![CDATA[
example.com.   SVCB   1 foo.example.com. (
                       key123=abc key123=def
                       )
]]></sourcecode>
        </figure>
        <figure>
          <name>Missing SvcParamValues That Must Be Non-Empty</name>
          <sourcecode type="dns-rr"><![CDATA[
example.com.   SVCB   1 foo.example.com. mandatory
example.com.   SVCB   1 foo.example.com. alpn
example.com.   SVCB   1 foo.example.com. port
example.com.   SVCB   1 foo.example.com. ipv4hint
example.com.   SVCB   1 foo.example.com. ipv6hint
]]></sourcecode>
        </figure>
        <figure>
          <name>The "no-default-alpn" SvcParamKey Value Must Be Empty</name>
          <sourcecode type="dns-rr"><![CDATA[
example.com.   SVCB   1 foo.example.com. no-default-alpn=abc
]]></sourcecode>
        </figure>
        <figure>
          <name>A Mandatory SvcParam Is Missing</name>
          <sourcecode type="dns-rr"><![CDATA[
example.com.   SVCB   1 foo.example.com. mandatory=key123
]]></sourcecode>
        </figure>
        <figure>
          <name>The "mandatory" SvcParamKey Must Not Be Included in the Mandatory List</name>
          <sourcecode type="dns-rr"><![CDATA[
example.com.   SVCB   1 foo.example.com. mandatory=mandatory
]]></sourcecode>
        </figure>
        <figure>
          <name>Multiple Instances of the Same SvcParamKey in the Mandatory List</name>
          <sourcecode type="dns-rr"><![CDATA[
example.com.   SVCB   1 foo.example.com. (
                      mandatory=key123,key123 key123=abc
                      )
]]></sourcecode>
        </figure>
      </section>
    </section>
    <section anchor="acknowledgments-and-related-proposals" numbered="false">
      <name>Acknowledgments and Related Proposals</name>
      <t>Over the years, IETF participants have proposed a wide range of solutions to
the "CNAME at the zone apex" challenge, including
<xref target="I-D.bellis-dnsop-http-record"/>,
<xref target="I-D.ietf-dnsop-aname"/>, and others.  The authors are grateful
for their work to elucidate the problem and identify promising strategies to
address it, some of which are reflected in this document.</t>
      <t>Thank you to <contact fullname="Ian Swett"/>, <contact fullname="Ralf Weber"/>, <contact fullname="Jon Reed"/>,
<contact fullname="Martin Thomson"/>, <contact fullname="Lucas Pardue"/>, <contact fullname="Ilari Liusvaara"/>,
<contact fullname="Tim Wicinski"/>, <contact fullname="Tommy Pauly"/>, <contact fullname="Chris Wood"/>, <contact fullname="David Benjamin"/>,
<contact fullname="Mark Andrews"/>, <contact fullname="Emily Stark"/>, <contact fullname="Eric Orth"/>, <contact fullname="Kyle Rose"/>,
<contact fullname="Craig Taylor"/>, <contact fullname="Dan McArdle"/>, <contact fullname="Brian Dickson"/>,
<contact fullname="Willem Toorop"/>, <contact fullname="Pieter Lexis"/>, <contact fullname="Puneet Sood"/>,
<contact fullname="Olivier Poitrey"/>, <contact fullname="Mashooq Muhaimen"/>,
<contact fullname="Tom Carpay"/>, and many others for their feedback
and suggestions on this document.</t>
    </section>
  </back>
</rfc>
