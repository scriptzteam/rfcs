<?xml version='1.0' encoding='UTF-8'?>

<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>

<rfc xmlns:xi="http://www.w3.org/2001/XInclude" 
ipr="trust200902" 
docName="draft-irtf-cfrg-frost-15" 
number="9591"
category="info" 
submissionType="IRTF" 
tocInclude="true" 
sortRefs="true" 
symRefs="true" 
consensus="true"
xml:lang="en"
updates=""
obsoletes="" 
version="3">  

  <front>
    <title abbrev="The FROST Protocol">The Flexible Round-Optimized Schnorr Threshold (FROST) Protocol for Two&nbhy;Round Schnorr Signatures</title>
    <seriesInfo name="RFC" value="9591"/>
    <author initials="D." surname="Connolly" fullname="Deirdre Connolly">
      <organization>Zcash Foundation</organization>
      <address>
        <email>durumcrustulum@gmail.com</email>
      </address>
    </author>
    <author initials="C." surname="Komlo" fullname="Chelsea Komlo">
      <organization>University of Waterloo, Zcash Foundation</organization>
      <address>
        <email>ckomlo@uwaterloo.ca</email>
      </address>
    </author>
    <author initials="I." surname="Goldberg" fullname="Ian Goldberg">
      <organization>University of Waterloo</organization>
      <address>
        <email>iang@uwaterloo.ca</email>
      </address>
    </author>
    <author initials="C. A." surname="Wood" fullname="Christopher A. Wood">
      <organization>Cloudflare</organization>
      <address>
        <email>caw@heapingbits.net</email>
      </address>
    </author>

    <date year="2024" month="June"/>

    <workgroup>Crypto Forum</workgroup>
    <abstract>
<t>This document specifies the Flexible Round-Optimized Schnorr Threshold
(FROST) signing protocol.  FROST signatures can be issued after a threshold
number of entities cooperate to compute a signature, allowing for improved
distribution of trust and redundancy with respect to a secret key. FROST
depends only on a prime-order group and cryptographic hash function. This
document specifies a number of ciphersuites to instantiate FROST using
different prime-order groups and hash functions. This document is a product
of the Crypto Forum Research Group (CFRG) in the IRTF.</t>
    </abstract>
  </front>
  <middle>


<section anchor="introduction">
      <name>Introduction</name>
      <t>Unlike signatures in a single-party setting, threshold signatures
require cooperation among a threshold number of signing participants, each holding a share
of a common private key. The security of threshold schemes in general assumes
that an adversary can corrupt strictly fewer than a threshold number of signer participants.</t>
      <t>This document specifies the Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol
based on the original work in <xref target="FROST20"/>. FROST reduces network overhead during
threshold signing operations while employing a novel technique to protect against forgery
attacks applicable to prior Schnorr-based threshold signature constructions. FROST requires
two rounds to compute a signature. Single-round signing variants based on <xref target="FROST20"/> are out of scope.</t>
      <t>FROST depends only on a prime-order group and cryptographic hash
      function. This document specifies a number of ciphersuites to
      instantiate FROST using different prime-order groups and hash functions.

Two ciphersuites can be used to produce signatures that are compatible
      with Edwards-Curve Digital Signature Algorithm (EdDSA) variants Ed25519
      and Ed448 as specified in <xref target="RFC8032"/>, i.e., the signatures
      can be verified with a verifier that is compliant with <xref target="RFC8032"/>.
      However, unlike EdDSA, the signatures produced by FROST are
      not deterministic, since deriving nonces deterministically allows for a
      complete key-recovery attack in multi-party, discrete logarithm-based
      signatures.</t>
      <t>Key generation for FROST signing is out of scope for this document. However, for completeness,
key generation with a trusted dealer is specified in <xref target="dep-dealer"/>.</t>
      <t>This document represents the consensus of the Crypto Forum Research
Group (CFRG). It is not an IETF product and is not a standard.</t>
    </section>
    <section anchor="conventions-and-definitions">
      <name>Conventions and Definitions</name>
        <t>
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL
    NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as
    described in BCP&nbsp;14 <xref target="RFC2119"/> <xref target="RFC8174"/> 
    when, and only when, they appear in all capitals, as shown here.
        </t>
      <t>The following notation is used throughout the document.</t>
      <dl spacing="normal">
        <dt>byte:</dt><dd>A sequence of eight bits.</dd>
        <dt>
          <tt>random_bytes(n)</tt>:</dt><dd>Outputs <tt>n</tt> bytes, sampled uniformly at random
using a cryptographically secure pseudorandom number generator (CSPRNG).</dd>
        <dt>
          <tt>count(i, L)</tt>:</dt><dd>Outputs the number of times the element <tt>i</tt> is represented in the list <tt>L</tt>.</dd>
        <dt>
          <tt>len(l)</tt>:</dt><dd>Outputs the length of list <tt>l</tt>, e.g., <tt>len([1,2,3]) = 3</tt>.</dd>
        <dt>
          <tt>reverse(l)</tt>:</dt><dd>Outputs the list <tt>l</tt> in reverse order, e.g., <tt>reverse([1,2,3]) = [3,2,1]</tt>.</dd>
        <dt>
          <tt>range(a, b)</tt>:</dt><dd>Outputs a list of integers from
          <tt>a</tt> to <tt>b-1</tt> in ascending order, e.g., <tt>range(1, 4)
          = [1,2,3]</tt>.</dd> <dt> <tt>pow(a, b)</tt>:</dt><dd>Outputs the
          result, a Scalar, of <tt>a</tt> to the power of <tt>b</tt>, e.g.,
          <tt>pow(2, 3) = 8</tt> modulo the relevant group order
          <tt>p</tt>.</dd>
        <dt>||:</dt><dd>Denotes concatenation of byte strings, i.e., <tt>x || y</tt> denotes the byte string <tt>x</tt>, immediately followed by
the byte string <tt>y</tt>, with no extra separator, yielding <tt>xy</tt>.</dd>
        <dt>nil:</dt><dd>Denotes an empty byte string.</dd>
      </dl>
      <t>Unless otherwise stated, we assume that secrets are sampled uniformly at random
using a CSPRNG; see <xref target="RFC4086"/> for additional guidance on the generation of random numbers.</t>
    </section>
    <section anchor="cryptographic-dependencies">
      <name>Cryptographic Dependencies</name>
<t>FROST signing depends on the following cryptographic constructs:</t>
      <ul spacing="normal">
        <li>Prime-order group (<xref target="dep-pog"/>)</li>
        <li>Cryptographic hash function (<xref target="dep-hash"/>)</li>
      </ul>
      <t>The following sections describe these constructs in more detail.</t>
      <section anchor="dep-pog">
        <name>Prime-Order Group</name>
        <t>FROST depends on an abelian group of prime order <tt>p</tt>. We represent this
group as the object <tt>G</tt> that additionally defines helper functions described below. The group operation
for <tt>G</tt> is addition <tt>+</tt> with identity element <tt>I</tt>. For any elements <tt>A</tt> and <tt>B</tt> of the group <tt>G</tt>,
<tt>A + B = B + A</tt> is also a member of <tt>G</tt>. Also, for any <tt>A</tt> in <tt>G</tt>, there exists an element
<tt>-A</tt> such that <tt>A + (-A) = (-A) + A = I</tt>. For convenience, we use <tt>-</tt> to denote
subtraction, e.g., <tt>A - B = A + (-B)</tt>. Integers, taken modulo the group order <tt>p</tt>, are called
"Scalars"; arithmetic operations on Scalars are implicitly performed modulo <tt>p</tt>. Since <tt>p</tt> is prime,
Scalars form a finite field. Scalar multiplication is equivalent to the repeated
application of the group operation on an element <tt>A</tt> with itself <tt>r-1</tt> times, denoted as
<tt>ScalarMult(A, r)</tt>. We denote the sum, difference, and product of two Scalars using the <tt>+</tt>, <tt>-</tt>,
and <tt>*</tt> operators, respectively. (Note that this means <tt>+</tt> may refer to group element addition or
Scalar addition, depending on the type of the operands.) For any element <tt>A</tt>, <tt>ScalarMult(A, p) = I</tt>.
We denote <tt>B</tt> as a fixed generator of the group. Scalar base multiplication is equivalent to the repeated application
of the group operation on <tt>B</tt> with itself <tt>r-1</tt> times, denoted as <tt>ScalarBaseMult(r)</tt>. The set of
Scalars corresponds to <tt>GF(p)</tt>, which we refer to as the Scalar field. It is assumed that
group element addition, negation, and equality comparison can be efficiently computed for
arbitrary group elements.</t>
        <t>This document uses types <tt>Element</tt> and <tt>Scalar</tt> to denote elements of the group <tt>G</tt> and
its set of Scalars, respectively. We denote Scalar(x) as the conversion of integer input <tt>x</tt>
to the corresponding Scalar value with the same numeric value. For example, Scalar(1) yields
a Scalar representing the value 1. Moreover, we use the type <tt>NonZeroScalar</tt> to denote a <tt>Scalar</tt>
value that is not equal to zero, i.e., Scalar(0). We denote equality comparison of these types
as <tt>==</tt> and assignment of values by <tt>=</tt>. When comparing Scalar values, e.g., for the purposes
of sorting lists of Scalar values, the least nonnegative representation mod <tt>p</tt> is used.</t>
        <t>We now detail a number of member functions that can be invoked on <tt>G</tt>.</t>
        <dl spacing="normal">
          <dt>Order():</dt><dd>Outputs the order of <tt>G</tt> (i.e., <tt>p</tt>).</dd>
          <dt>Identity():</dt><dd>Outputs the identity <tt>Element</tt> of the group (i.e., <tt>I</tt>).</dd>
          <dt>RandomScalar():</dt><dd>Outputs a random <tt>Scalar</tt> element in GF(p), i.e., a random Scalar in [0, p - 1].</dd>
          <dt>ScalarMult(A, k):</dt><dd>Outputs the Scalar multiplication between Element <tt>A</tt> and Scalar <tt>k</tt>.</dd>
          <dt>ScalarBaseMult(k):</dt><dd>Outputs the Scalar multiplication between Scalar <tt>k</tt> and the group generator <tt>B</tt>.</dd>
          <dt>SerializeElement(A):</dt><dd>Maps an <tt>Element</tt> <tt>A</tt> to a canonical byte array <tt>buf</tt> of fixed length <tt>Ne</tt>. This
function raises an error if <tt>A</tt> is the identity element of the group.</dd>
          <dt>DeserializeElement(buf):</dt><dd>Attempts to map a byte array <tt>buf</tt> to an <tt>Element</tt> <tt>A</tt>
and fails if the input is not the valid canonical byte representation of an element of
the group. This function raises an error if deserialization fails
or if <tt>A</tt> is the identity element of the group; see <xref target="ciphersuites"/> for group-specific
input validation steps.</dd>
          <dt>SerializeScalar(s):</dt><dd>Maps a Scalar <tt>s</tt> to a canonical byte array <tt>buf</tt> of fixed length <tt>Ns</tt>.</dd>
          <dt>DeserializeScalar(buf):</dt><dd>Attempts to map a byte array <tt>buf</tt> to a <tt>Scalar</tt> <tt>s</tt>.
This function raises an error if deserialization fails; see
<xref target="ciphersuites"/> for group-specific input validation steps.</dd>
        </dl>
      </section>
      <section anchor="dep-hash">
        <name>Cryptographic Hash Function</name> <t>FROST requires the use of
        a cryptographically secure hash function, generically written as H,
        which is modeled as a random oracle in security proofs for the
        protocol (see <xref target="FROST20"/> and <xref
        target="StrongerSec22"/>). For concrete recommendations on hash
        functions that <bcp14>SHOULD</bcp14> be used in practice, see <xref
        target="ciphersuites"/>. Using H, we introduce distinct
        domain-separated hashes H1, H2, H3, H4, and H5:</t>
        <ul spacing="normal">
          <li>H1, H2, and H3 map arbitrary byte strings to Scalar elements associated with the prime-order group.</li>
          <li>H4 and H5 are aliases for H with distinct domain separators.</li>
        </ul>
	
        <t>The details of H1, H2, H3, H4, and H5 vary based on the ciphersuite used. See <xref target="ciphersuites"/>
for more details about each.</t>
      </section>
    </section>
    <section anchor="helpers">
      <name>Helper Functions</name>
      <t>Beyond the core dependencies, the protocol in this document depends on the
following helper operations:</t>

      <ul spacing="normal">
        <li>Nonce generation (<xref target="dep-nonces"/>);</li>
        <li>Polynomials (<xref target="dep-polynomial"/>);</li>
        <li>List operations (<xref target="dep-encoding"/>);</li>
        <li>Binding factors computation (<xref target="dep-binding-factor"/>);</li>
        <li>Group commitment computation (<xref target="dep-group-commit"/>); and</li>
        <li>Signature challenge computation (<xref target="dep-sig-challenge"/>).</li>
      </ul>
      <t>The following sections describe these operations in more detail.</t>
      <section anchor="dep-nonces">
        <name>Nonce Generation</name>
        <t>To hedge against a bad random number generator (RNG) that outputs predictable values, nonces are
generated with the <tt>nonce_generate</tt> function by combining fresh randomness
with the secret key as input to a domain-separated hash function built
from the ciphersuite hash function <tt>H</tt>. This domain-separated hash function
is denoted as <tt>H3</tt>. This function always samples 32 bytes of fresh randomness
to ensure that the probability of nonce reuse is at most 2<sup>-128</sup>
as long as no more than 2<sup>64</sup> signatures are computed by a given
signing participant.</t>

        <sourcecode type="pseudocode"><![CDATA[
Inputs:
- secret, a Scalar.

Outputs:
- nonce, a Scalar.

def nonce_generate(secret):
  random_bytes = random_bytes(32)
  secret_enc = G.SerializeScalar(secret)
  return H3(random_bytes || secret_enc)
]]></sourcecode>
      </section>
      <section anchor="dep-polynomial">
        <name>Polynomials</name>
        <t>This section defines polynomials over Scalars that are used in the main protocol.
A polynomial of maximum degree t is represented as a list of t+1 coefficients,
where the constant term of the polynomial is in the first position and the
highest-degree coefficient is in the last position. For example, the polynomial
<tt>x<sup>2</sup> + 2x + 3</tt> has degree 2 and is represented as a list of three coefficients <tt>[3, 2, 1]</tt>.
A point on the polynomial <tt>f</tt> is a tuple (x, y), where <tt>y = f(x)</tt>.</t>
        <t>The function <tt>derive_interpolating_value</tt> derives a value that is used for polynomial
interpolation. 

It is provided a list of x-coordinates as input, each of which
cannot equal 0.</t>
        <sourcecode type="pseudocode"><![CDATA[
Inputs:
- L, the list of x-coordinates, each a NonZeroScalar.
- x_i, an x-coordinate contained in L, a NonZeroScalar.

Outputs:
- value, a Scalar.

Errors:
- "invalid parameters", if 1) x_i is not in L, or if 2) any
  x-coordinate is represented more than once in L.

def derive_interpolating_value(L, x_i):
  if x_i not in L:
    raise "invalid parameters"
  for x_j in L:
    if count(x_j, L) > 1:
      raise "invalid parameters"

  numerator = Scalar(1)
  denominator = Scalar(1)
  for x_j in L:
    if x_j == x_i: continue
    numerator *= x_j
    denominator *= x_j - x_i

  value = numerator / denominator
  return value
]]></sourcecode>
      </section>
      <section anchor="dep-encoding">
        <name>List Operations</name>
        <t>This section describes helper functions that work on lists of values produced
during the FROST protocol. The following function encodes a list of participant
commitments into a byte string for use in the FROST protocol.</t>
        <sourcecode type="pseudocode"><![CDATA[
Inputs:
- commitment_list = [(i, hiding_nonce_commitment_i,
  binding_nonce_commitment_i), ...], a list of commitments issued by
  each participant, where each element in the list indicates a
  NonZeroScalar identifier i and two commitment Element values
  (hiding_nonce_commitment_i, binding_nonce_commitment_i). This list
  MUST be sorted in ascending order by identifier.

Outputs:
- encoded_group_commitment, the serialized representation of
  commitment_list, a byte string.

def encode_group_commitment_list(commitment_list):
  encoded_group_commitment = nil
  for (identifier, hiding_nonce_commitment,
       binding_nonce_commitment) in commitment_list:
    encoded_commitment = (
        G.SerializeScalar(identifier) ||
        G.SerializeElement(hiding_nonce_commitment) ||
        G.SerializeElement(binding_nonce_commitment))
    encoded_group_commitment = (
        encoded_group_commitment ||
        encoded_commitment)
  return encoded_group_commitment
]]></sourcecode>
        <t>The following function is used to extract identifiers from a commitment list.</t>
        <sourcecode type="pseudocode"><![CDATA[
Inputs:
- commitment_list = [(i, hiding_nonce_commitment_i,
  binding_nonce_commitment_i), ...], a list of commitments issued by
  each participant, where each element in the list indicates a
  NonZeroScalar identifier i and two commitment Element values
  (hiding_nonce_commitment_i, binding_nonce_commitment_i). This list
  MUST be sorted in ascending order by identifier.

Outputs:
- identifiers, a list of NonZeroScalar values.

def participants_from_commitment_list(commitment_list):
  identifiers = []
  for (identifier, _, _) in commitment_list:
    identifiers.append(identifier)
  return identifiers
]]></sourcecode>
        <t keepWithNext="true">The following function is used to extract a binding factor from a list of binding factors.</t>
        <sourcecode type="pseudocode"><![CDATA[
Inputs:
- binding_factor_list = [(i, binding_factor), ...],
  a list of binding factors for each participant, where each element
  in the list indicates a NonZeroScalar identifier i and Scalar
  binding factor.
- identifier, participant identifier, a NonZeroScalar.

Outputs:
- binding_factor, a Scalar.

Errors:
- "invalid participant", when the designated participant is
  not known.

def binding_factor_for_participant(binding_factor_list, identifier):
  for (i, binding_factor) in binding_factor_list:
    if identifier == i:
      return binding_factor
  raise "invalid participant"
]]></sourcecode>
      </section>
      <section anchor="dep-binding-factor">
        <name>Binding Factors Computation</name>
        <t>This section describes the subroutine for computing binding factors based
	on the participant commitment list, message to be signed, and group public key.</t>
        <sourcecode type="pseudocode"><![CDATA[
Inputs:
- group_public_key, the public key corresponding to the group signing
  key, an Element.
- commitment_list = [(i, hiding_nonce_commitment_i,
  binding_nonce_commitment_i), ...], a list of commitments issued by
  each participant, where each element in the list indicates a
  NonZeroScalar identifier i and two commitment Element values
  (hiding_nonce_commitment_i, binding_nonce_commitment_i). This list
  MUST be sorted in ascending order by identifier.
- msg, the message to be signed.

Outputs:
- binding_factor_list, a list of (NonZeroScalar, Scalar) tuples
  representing the binding factors.

def compute_binding_factors(group_public_key, commitment_list, msg):
  group_public_key_enc = G.SerializeElement(group_public_key)
  // Hashed to a fixed length.
  msg_hash = H4(msg)
  // Hashed to a fixed length.
  encoded_commitment_hash =
      H5(encode_group_commitment_list(commitment_list))
  // The encoding of the group public key is a fixed length 
  // within a ciphersuite.
  rho_input_prefix = group_public_key_enc || msg_hash || 
   encoded_commitment_hash

  binding_factor_list = []
  for (identifier, hiding_nonce_commitment,
       binding_nonce_commitment) in commitment_list:
    rho_input = rho_input_prefix || G.SerializeScalar(identifier)
    binding_factor = H1(rho_input)
    binding_factor_list.append((identifier, binding_factor))
  return binding_factor_list
]]></sourcecode>
      </section>
      <section anchor="dep-group-commit">
        <name>Group Commitment Computation</name>
        <t>This section describes the subroutine for creating the group commitment
from a commitment list.</t>
        <sourcecode type="pseudocode"><![CDATA[
Inputs:
- commitment_list = [(i, hiding_nonce_commitment_i,
  binding_nonce_commitment_i), ...], a list of commitments issued by
  each participant, where each element in the list indicates a
  NonZeroScalar identifier i and two commitment Element values
  (hiding_nonce_commitment_i, binding_nonce_commitment_i). This list
  MUST be sorted in ascending order by identifier.
- binding_factor_list = [(i, binding_factor), ...],
  a list of (NonZeroScalar, Scalar) tuples representing the binding
  factor Scalar for the given identifier.

Outputs:
- group_commitment, an Element.

def compute_group_commitment(commitment_list, binding_factor_list):
  group_commitment = G.Identity()
  for (identifier, hiding_nonce_commitment,
       binding_nonce_commitment) in commitment_list:
    binding_factor = binding_factor_for_participant(
        binding_factor_list, identifier)
    binding_nonce = G.ScalarMult(
        binding_nonce_commitment,
        binding_factor)
    group_commitment = (
        group_commitment +
        hiding_nonce_commitment +
        binding_nonce)
  return group_commitment
]]></sourcecode>
<t>Note that the performance of this algorithm is defined
naively and scales linearly relative to the number of signers. For improved
performance, the group commitment can be computed using multi-exponentiation
techniques such as Pippinger's algorithm; see <xref target="MultExp"/> for more details.</t>
      </section>
      <section anchor="dep-sig-challenge">
        <name>Signature Challenge Computation</name>
        <t>This section describes the subroutine for creating the per-message challenge.</t>
        <sourcecode type="pseudocode"><![CDATA[
Inputs:
- group_commitment, the group commitment, an Element.
- group_public_key, the public key corresponding to the group signing
  key, an Element.
- msg, the message to be signed, a byte string.

Outputs:
- challenge, a Scalar.

def compute_challenge(group_commitment, group_public_key, msg):
  group_comm_enc = G.SerializeElement(group_commitment)
  group_public_key_enc = G.SerializeElement(group_public_key)
  challenge_input = group_comm_enc || group_public_key_enc || msg
  challenge = H2(challenge_input)
  return challenge
]]></sourcecode>
      </section>
    </section>
    <section anchor="frost-spec">
      <name>Two-Round FROST Signing Protocol</name>
      <t>This section describes the two-round FROST signing protocol for producing Schnorr signatures.
      The protocol is configured to run with a selection of <tt>NUM_PARTICIPANTS</tt> signer participants and a Coordinator.
      
<tt>NUM_PARTICIPANTS</tt> is a positive and
non-zero integer that <bcp14>MUST</bcp14> be at least
<tt>MIN_PARTICIPANTS</tt>, but <bcp14>MUST NOT</bcp14> be larger than
<tt>MAX_PARTICIPANTS</tt>, where <tt>MIN_PARTICIPANTS &lt;=
MAX_PARTICIPANTS</tt> and <tt>MIN_PARTICIPANTS</tt> is a positive and non-zero
integer. Additionally, <tt>MAX_PARTICIPANTS</tt> <bcp14>MUST</bcp14> be a positive
integer less than the group order. 
A signer participant, or simply
"participant", is an entity that is trusted to hold and use a signing key
      share. The Coordinator is an entity with the following responsibilities:</t>
      <ol spacing="normal" type="1"><li>Determining the participants that will participate (at least MIN_PARTICIPANTS in number);</li>
        <li>Coordinating rounds (receiving and forwarding inputs among participants);</li>
        <li>Aggregating signature shares output by each participant; and</li> 
        <li>Publishing the resulting signature.</li>
      </ol>
      <t>FROST assumes that the Coordinator and the set of signer participants are chosen
externally to the protocol. Note that it is possible to deploy the protocol without
designating a single Coordinator; see <xref target="no-coordinator"/> for more information.</t>
      <t>FROST produces signatures that can be verified as if they were produced from a single signer
using a signing key <tt>s</tt> with corresponding public key <tt>PK</tt>, where <tt>s</tt> is a Scalar
value and <tt>PK = G.ScalarBaseMult(s)</tt>. As a threshold signing protocol, the group signing
key <tt>s</tt> is Shamir secret-shared amongst each of the <tt>MAX_PARTICIPANTS</tt> participants
and is used to produce signatures; see <xref target="dep-shamir"/> for more information about Shamir secret sharing.
In particular, FROST assumes each participant is configured with the following information:</t>
      <ul spacing="normal">
        <li>An identifier, which is a NonZeroScalar value denoted as <tt>i</tt> in the range <tt>[1, MAX_PARTICIPANTS]</tt>
and <bcp14>MUST</bcp14> be distinct from the identifier of every other participant.</li>
        <li>A signing key <tt>sk_i</tt>, which is a Scalar value representing the i-th Shamir secret share
of the group signing key <tt>s</tt>. In particular, <tt>sk_i</tt> is the value <tt>f(i)</tt> on a secret
polynomial <tt>f</tt> of degree <tt>(MIN_PARTICIPANTS - 1)</tt>, where <tt>s</tt> is <tt>f(0)</tt>. The public key
corresponding to this signing key share is <tt>PK_i = G.ScalarBaseMult(sk_i)</tt>.</li>
      </ul>
      <t>Additionally, the Coordinator and each participant are configured with common group
information, denoted as "group info," which consists of the following:</t>
      <ul spacing="normal">
        <li>Group public key, which is an <tt>Element</tt> in <tt>G</tt> denoted as <tt>PK</tt>.</li>
        <li>Public keys <tt>PK_i</tt> for each participant, which are <tt>Element</tt> values in <tt>G</tt> denoted as <tt>PK_i</tt>
for each <tt>i</tt> in <tt>[1, MAX_PARTICIPANTS]</tt>.</li>
      </ul>
      <t>This document does not specify how this information, including the signing key shares,
are configured and distributed to participants. 
In general, two configuration
mechanisms are possible: one that requires a single trusted dealer and one
that requires performing a distributed key generation protocol. We highlight
the key generation mechanism by a trusted dealer in <xref target="dep-dealer"/> for reference.</t>
      <t>FROST requires two rounds to complete. In the first round,
      participants generate and publish one-time-use commitments to be used in
      the second round. In the second round, each participant produces a share
      of the signature over the Coordinator-chosen message and the other
      participant commitments. After the second round is completed, the
      Coordinator aggregates the signature shares to produce a final
      signature. The Coordinator <bcp14>SHOULD</bcp14> abort the protocol if
      the signature is invalid; see <xref target="abort"/> for more
      information about dealing with invalid signatures and misbehaving
      participants. This complete interaction (without being aborted) is shown
      in <xref target="fig-frost"/>.</t>
      <figure anchor="fig-frost">
        <name>FROST Protocol Overview</name>
        <artwork><![CDATA[
        (group info)            (group info,     (group info,
            |               signing key share)   signing key share)
            |                         |                |
            v                         v                v
        Coordinator               Signer-1   ...   Signer-n
    ------------------------------------------------------------
   signing request
------------>
            |
      == Round 1 (Commitment) ==
            | participant commitment |                 |
            |<-----------------------+                 |
            |          ...                             |
            | participant commitment            (commit state) ==\
            |<-----------------------------------------+         |
                                                                 |
      == Round 2 (Signature Share Generation) ==                 |
   message
------------>
            |                                                    |
            |   participant input    |                 |         |
            +------------------------>                 |         |
            |     signature share    |                 |         |
            |<-----------------------+                 |         |
            |          ...                             |         |
            |    participant input                     |         |
            +------------------------------------------>         /
            |     signature share                      |<=======/
            <------------------------------------------+
            |
      == Aggregation ==
            |
  signature |
<-----------+
]]></artwork>
      </figure>
      <t>Details for round one are described in <xref target="frost-round-one"/> and details for round two
are described in <xref target="frost-round-two"/>. 
Note that each participant persists some state between
the two rounds; this state is deleted as described in <xref target="frost-round-two"/>. The final
Aggregation step is described in <xref target="frost-aggregation"/>.</t>
      <t>FROST assumes that all inputs to each round, especially those that are received
over the network, are validated before use. 
In particular, this means that any value of type Element or Scalar received
over the network <bcp14>MUST</bcp14> be deserialized using DeserializeElement
and DeserializeScalar, respectively, as these functions perform the necessary
input validation steps. Additionally, all messages sent over the wire
<bcp14>MUST</bcp14> be encoded using their respective functions, e.g., Scalars
and Elements are encoded using SerializeScalar and SerializeElement.</t>
      <t>FROST assumes reliable message delivery between the Coordinator and participants in
order for the protocol to complete. An attacker masquerading as another participant
will result only in an invalid signature; see <xref target="sec-considerations"/>. However, in order
to identify misbehaving participants,
we assume that the network channel is additionally authenticated; confidentiality is
not required.</t>
      <section anchor="frost-round-one">
        <name>Round One - Commitment</name>
        <t>Round one involves each participant generating nonces and their corresponding public commitments.
A nonce is a pair of Scalar values, and a commitment is a pair of Element values. Each participant's behavior in this round is described by the <tt>commit</tt> function below. Note that this function invokes <tt>nonce_generate</tt> twice, once for each type of nonce produced. The output of this function is a pair of secret nonces <tt>(hiding_nonce, binding_nonce)</tt> and their corresponding public commitments
<tt>(hiding_nonce_commitment, binding_nonce_commitment)</tt>.</t>
        <sourcecode type="pseudocode"><![CDATA[
Inputs:
- sk_i, the secret key share, a Scalar.

Outputs:
- (nonce, comm), a tuple of nonce and nonce commitment pairs,
  where each value in the nonce pair is a Scalar and each value in
  the nonce commitment pair is an Element.

def commit(sk_i):
  hiding_nonce = nonce_generate(sk_i)
  binding_nonce = nonce_generate(sk_i)
  hiding_nonce_commitment = G.ScalarBaseMult(hiding_nonce)
  binding_nonce_commitment = G.ScalarBaseMult(binding_nonce)
  nonces = (hiding_nonce, binding_nonce)
  comms = (hiding_nonce_commitment, binding_nonce_commitment)
  return (nonces, comms)
]]></sourcecode>
        <t>The outputs <tt>nonce</tt> and <tt>comm</tt> from participant <tt>P_i</tt> are both stored locally and
kept for use in the second round. The <tt>nonce</tt> value is secret and <bcp14>MUST NOT</bcp14> be shared, whereas
the public output <tt>comm</tt> is sent to the Coordinator. The nonce values produced by this function <bcp14>MUST NOT</bcp14> be used in more than one invocation of <tt>sign</tt>, and the nonces <bcp14>MUST</bcp14> be generated
from a source of secure randomness.</t>
      </section>
      <section anchor="frost-round-two">
        <name>Round Two - Signature Share Generation</name>
        <t>In round two, the Coordinator is responsible for sending the message to be signed and choosing the participants that will participate (a number of at least MIN_PARTICIPANTS). Signers
additionally require locally held data, specifically their private key and the
nonces corresponding to their commitment issued in round one.</t>
        <t>The Coordinator begins by sending each participant the message to be signed along with the set of signing commitments for all participants in the participant list. Each participant
<bcp14>MUST</bcp14> validate the inputs before processing the Coordinator's request. In particular,
the signer <bcp14>MUST</bcp14> validate commitment_list, deserializing each group Element in the
list using DeserializeElement from <xref target="dep-pog"/>. If deserialization fails, the signer
<bcp14>MUST</bcp14> abort the protocol. Moreover, each participant <bcp14>MUST</bcp14> ensure that
its identifier and commitments (from the first round) appear in commitment_list.

Applications that restrict participants from processing arbitrary input
messages are also required to perform relevant application-layer input
validation checks; see <xref target="message-validation"/> for more
details.</t>
        <t>Upon receipt and successful input validation, each signer then runs the following
procedure to produce its own signature share.</t>
        <sourcecode type="pseudocode"><![CDATA[
Inputs:
- identifier, identifier i of the participant, a NonZeroScalar.
- sk_i, signer secret key share, a Scalar.
- group_public_key, public key corresponding to the group signing
  key, an Element.
- nonce_i, pair of Scalar values (hiding_nonce, binding_nonce)
  generated in round one.
- msg, the message to be signed, a byte string.
- commitment_list = [(i, hiding_nonce_commitment_i,
  binding_nonce_commitment_i), ...], a list of commitments issued by
  each participant, where each element in the list indicates a
  NonZeroScalar identifier i and two commitment Element values
  (hiding_nonce_commitment_i, binding_nonce_commitment_i). This list
  MUST be sorted in ascending order by identifier.


Outputs:
- sig_share, a signature share, a Scalar.

def sign(identifier, sk_i, group_public_key,
         nonce_i, msg, commitment_list):
  # Compute the binding factor(s)
  binding_factor_list = compute_binding_factors(group_public_key, 
   commitment_list, msg)
  binding_factor = binding_factor_for_participant(
      binding_factor_list, identifier)

  # Compute the group commitment
  group_commitment = compute_group_commitment(
      commitment_list, binding_factor_list)

  # Compute the interpolating value
  participant_list = participants_from_commitment_list(
      commitment_list)
  lambda_i = derive_interpolating_value(participant_list, identifier)

  # Compute the per-message challenge
  challenge = compute_challenge(
      group_commitment, group_public_key, msg)

  # Compute the signature share
  (hiding_nonce, binding_nonce) = nonce_i
  sig_share = hiding_nonce + (binding_nonce * binding_factor) +
      (lambda_i * sk_i * challenge)

  return sig_share
]]></sourcecode>
        <t>The output of this procedure is a signature share. Each participant sends
these shares back to the Coordinator. Each participant <bcp14>MUST</bcp14> delete the nonce and
corresponding commitment after completing <tt>sign</tt> and <bcp14>MUST NOT</bcp14> use the nonce
as input more than once to <tt>sign</tt>.</t>
        <t>Note that the <tt>lambda_i</tt> value derived during this procedure does not change
across FROST signing operations for the same signing group. As such, participants
can compute it once and store it for reuse across signing sessions.</t>
      </section>
      <section anchor="frost-aggregation">
        <name>Signature Share Aggregation</name>
        <t>After participants perform round two and send their signature shares to the Coordinator,
the Coordinator aggregates each share to produce a final signature. Before aggregating,
the Coordinator <bcp14>MUST</bcp14> validate each signature share using DeserializeScalar. If validation
fails, the Coordinator <bcp14>MUST</bcp14> abort the protocol, as the resulting signature will be invalid.
If all signature shares are valid, the Coordinator aggregates them to produce the final
signature using the following procedure.</t>
        <sourcecode type="pseudocode"><![CDATA[
Inputs:
- commitment_list = [(i, hiding_nonce_commitment_i,
  binding_nonce_commitment_i), ...], a list of commitments issued by
  each participant, where each element in the list indicates a
  NonZeroScalar identifier i and two commitment Element values
  (hiding_nonce_commitment_i, binding_nonce_commitment_i). This list
  MUST be sorted in ascending order by identifier.
- msg, the message to be signed, a byte string.
- group_public_key, public key corresponding to the group signing
  key, an Element.
- sig_shares, a set of signature shares z_i, Scalar values, for each
  participant, of length NUM_PARTICIPANTS, where
  MIN_PARTICIPANTS <= NUM_PARTICIPANTS <= MAX_PARTICIPANTS.

Outputs:
- (R, z), a Schnorr signature consisting of an Element R and
  Scalar z.

def aggregate(commitment_list, msg, group_public_key, sig_shares):
  # Compute the binding factors
  binding_factor_list = compute_binding_factors(group_public_key, 
   commitment_list, msg)

  # Compute the group commitment
  group_commitment = compute_group_commitment(
      commitment_list, binding_factor_list)

  # Compute aggregated signature
  z = Scalar(0)
  for z_i in sig_shares:
    z = z + z_i
  return (group_commitment, z)
]]></sourcecode>
        <t>The output from the aggregation step is the output signature (R, z). The canonical encoding
of this signature is specified in <xref target="ciphersuites"/>.</t>
        <t>The Coordinator <bcp14>SHOULD</bcp14> verify this signature using the group public key before publishing or
releasing the signature. Signature verification is as specified for the corresponding
ciphersuite; see <xref target="ciphersuites"/> for details. The aggregate signature will verify successfully
if all signature shares are valid. Moreover, subsets of valid signature shares will not yield
a valid aggregate signature themselves.</t>
        <t>If the aggregate signature verification fails, the Coordinator <bcp14>MAY</bcp14> verify each signature
share individually to identify and act on misbehaving participants. The mechanism for acting on
a misbehaving participant is out of scope for this specification; see <xref target="abort"/> for more information
about dealing with invalid signatures and misbehaving participants.</t>
        <t>The function for verifying a signature share, denoted as <tt>verify_signature_share</tt>, is described below.
Recall that the Coordinator is configured with "group info" that contains
the group public key <tt>PK</tt> and public keys <tt>PK_i</tt> for each participant. The <tt>group_public_key</tt> and
<tt>PK_i</tt> function arguments <bcp14>MUST</bcp14> come from that previously stored group info.</t>
        <sourcecode type="pseudocode"><![CDATA[
Inputs:
- identifier, identifier i of the participant, a NonZeroScalar.
- PK_i, the public key for the i-th participant, where
  PK_i = G.ScalarBaseMult(sk_i), an Element.
- comm_i, pair of Element values in G
  (hiding_nonce_commitment, binding_nonce_commitment) generated in
  round one from the i-th participant.
- sig_share_i, a Scalar value indicating the signature share as
  produced in round two from the i-th participant.
- commitment_list = [(i, hiding_nonce_commitment_i,
  binding_nonce_commitment_i), ...], a list of commitments issued by
  each participant, where each element in the list indicates a
  NonZeroScalar identifier i and two commitment Element values
  (hiding_nonce_commitment_i, binding_nonce_commitment_i). This list
  MUST be sorted in ascending order by identifier.
- group_public_key, public key corresponding to the group signing
  key, an Element.
- msg, the message to be signed, a byte string.

Outputs:
- True if the signature share is valid, and False otherwise.

def verify_signature_share(
        identifier, PK_i, comm_i, sig_share_i, commitment_list,
        group_public_key, msg):
  # Compute the binding factors
  binding_factor_list = compute_binding_factors(group_public_key, 
   commitment_list, msg)
  binding_factor = binding_factor_for_participant(
      binding_factor_list, identifier)

  # Compute the group commitment
  group_commitment = compute_group_commitment(
      commitment_list, binding_factor_list)

  # Compute the commitment share
  (hiding_nonce_commitment, binding_nonce_commitment) = comm_i
  comm_share = hiding_nonce_commitment + G.ScalarMult(
      binding_nonce_commitment, binding_factor)

  # Compute the challenge
  challenge = compute_challenge(
      group_commitment, group_public_key, msg)

  # Compute the interpolating value
  participant_list = participants_from_commitment_list(
      commitment_list)
  lambda_i = derive_interpolating_value(participant_list, identifier)

  # Compute relation values
  l = G.ScalarBaseMult(sig_share_i)
  r = comm_share + G.ScalarMult(PK_i, challenge * lambda_i)

  return l == r
]]></sourcecode>
<t>The Coordinator can verify each signature share before aggregating and
verifying the signature under the group public key. However, since the
aggregate signature is valid if all signature shares are valid, this order of
operations is more expensive if the signature is valid.</t>
      </section>
      <section anchor="abort">
        <name>Identifiable Abort</name>
        <t>FROST does not provide robustness; i.e, all participants are required to complete the
protocol honestly in order to generate a valid signature. When the signing protocol
does not produce a valid signature, the Coordinator <bcp14>SHOULD</bcp14> abort; see <xref target="sec-considerations"/>
for more information about FROST's security properties and the threat model.</t>
        <t>As a result of this property, a misbehaving participant can cause a denial of service (DoS) on
the signing protocol by contributing malformed signature shares or refusing to participate.
Identifying misbehaving participants that produce invalid shares can be done by checking
signature shares from each participant using <tt>verify_signature_share</tt> as described in <xref target="frost-aggregation"/>.
FROST assumes the network channel is authenticated to identify the signer that misbehaved.
FROST allows for identifying misbehaving participants that produce invalid signature shares
as described in <xref target="frost-aggregation"/>. FROST does not provide accommodations for identifying
participants that refuse to participate, though applications are assumed to detect when participants
fail to engage in the signing protocol.</t>
        <t>In both cases, preventing this type of attack requires the Coordinator to identify
misbehaving participants such that applications can take corrective action. The mechanism
for acting on misbehaving participants is out of scope for this specification. However,
one reasonable approach would be to remove the misbehaving participant from the set of allowed
participants in future runs of FROST.</t>
      </section>
    </section>
    <section anchor="ciphersuites">
      <name>Ciphersuites</name>
      <t>A FROST ciphersuite must specify the underlying prime-order group details
and cryptographic hash function. Each ciphersuite is denoted as (Group, Hash),
e.g., (ristretto255, SHA-512). This section contains some ciphersuites.
Each ciphersuite also includes a context string, denoted as <tt>contextString</tt>,
which is an ASCII string literal (with no terminating NUL character).</t>
      <t>The <bcp14>RECOMMENDED</bcp14> ciphersuite is (ristretto255, SHA-512) as described in <xref target="recommended-suite"/>.
The (Ed25519, SHA-512) and (Ed448, SHAKE256) ciphersuites are included
for compatibility with Ed25519 and Ed448 as defined in <xref target="RFC8032"/>.</t>
      <t>The DeserializeElement and DeserializeScalar functions instantiated for a
particular prime-order group corresponding to a ciphersuite <bcp14>MUST</bcp14> adhere
to the description in <xref target="dep-pog"/>. Validation steps for these functions
are described for each of the ciphersuites below. Future ciphersuites <bcp14>MUST</bcp14>
describe how input validation is done for DeserializeElement and DeserializeScalar.</t>
      <t>Each ciphersuite includes explicit instructions for verifying signatures produced
by FROST. Note that these instructions are equivalent to those produced by a single
participant.</t>
      <t>Each ciphersuite adheres to the requirements in <xref target="ciphersuite-reqs"/>. Future
ciphersuites <bcp14>MUST</bcp14> also adhere to these requirements.</t>
<section anchor="frosted25519-sha-512">
        <name>FROST(Ed25519, SHA-512)</name>
        <t>This ciphersuite uses edwards25519 for the Group and SHA-512 for the hash function <tt>H</tt>
meant to produce Ed25519-compliant signatures as specified in <xref section="5.1" sectionFormat="of" target="RFC8032"/>.
The value of the contextString parameter is "FROST-ED25519-SHA512-v1".</t>
        <dl newline="false" spacing="normal">
          <dt>Group:</dt> <dd><t>edwards25519 <xref target="RFC8032"/>, where Ne = 32 and Ns = 32.</t>
            <dl newline="false" spacing="normal">
              <dt>Order():</dt> <dd>Return 2<sup>252</sup> + 27742317777372353535851937790883648493 (see <xref target="RFC7748"/>).</dd>
              <dt>Identity():</dt> <dd>As defined in <xref target="RFC7748"/>.</dd>
              <dt>RandomScalar():</dt> <dd>Implemented by returning a uniformly random Scalar in the range
[0, <tt>G.Order()</tt> - 1]. Refer to <xref target="random-scalar"/> for implementation guidance.</dd>
              <dt>SerializeElement(A):</dt> <dd>Implemented as specified in <xref section="5.1.2" sectionFormat="comma" target="RFC8032"/>.
Additionally, this function validates that the input element is not the group
identity element.</dd>
              <dt>DeserializeElement(buf):</dt> <dd>Implemented as specified in <xref section="5.1.3" sectionFormat="comma" target="RFC8032"/>.
Additionally, this function validates that the resulting element is not the group
identity element and is in the prime-order subgroup. If any of these checks fail,
deserialization returns an error. The latter check can
be implemented by multiplying the resulting point by the order of the group and
checking that the result is the identity element. Note that optimizations for
this check exist; see <xref target="Pornin22"/>.</dd>
              <dt>SerializeScalar(s):</dt> <dd>Implemented by outputting the little-endian 32-byte encoding of
the Scalar value with the top three bits set to zero.</dd>
              <dt>DeserializeScalar(buf):</dt> <dd>Implemented by attempting to deserialize a Scalar from a
little-endian 32-byte string. This function can fail if the input does not
represent a Scalar in the range [0, <tt>G.Order()</tt> - 1]. Note that this means the
top three bits of the input <bcp14>MUST</bcp14> be zero.</dd>
            </dl>
	  </dd>
            <dt>Hash (<tt>H</tt>):</dt> <dd><t>SHA-512, which has an output of 64 bytes.</t>
	    <dl newline="false" spacing="normal">
              <dt>H1(m):</dt> <dd>Implemented by computing H(contextString || "rho" || m), interpreting the 64-byte digest
as a little-endian integer, and reducing the resulting integer modulo
2<sup>252</sup> + 27742317777372353535851937790883648493.</dd>
              <dt>H2(m):</dt> <dd>Implemented by computing H(m), interpreting the 64-byte digest
as a little-endian integer, and reducing the resulting integer modulo
2<sup>252</sup> + 27742317777372353535851937790883648493.</dd>
              <dt>H3(m):</dt> <dd>Implemented by computing H(contextString || "nonce" || m), interpreting the 64-byte digest
as a little-endian integer, and reducing the resulting integer modulo
2<sup>252</sup> + 27742317777372353535851937790883648493.</dd>
              <dt>H4(m):</dt> <dd>Implemented by computing H(contextString || "msg" || m).</dd>
              <dt>H5(m):</dt> <dd>Implemented by computing H(contextString || "com" || m).</dd>
	  </dl>
	</dd>
      </dl>

        <t>Normally, H2 would also include a domain separator; however, for compatibility with <xref target="RFC8032"/>, it is omitted.</t>
        <t>Signature verification is as specified in <xref section="5.1.7" sectionFormat="of" target="RFC8032"/> with the
constraint that implementations <bcp14>MUST</bcp14> check the group equation <tt>[8][z]B = [8]R + [8][c]PK</tt>
(changed to use the notation in this document).</t>
        <t>Canonical signature encoding is as specified in <xref target="sig-encoding"/>.</t>
      </section>
      <section anchor="recommended-suite">
        <name>FROST(ristretto255, SHA-512)</name>
        <t>This ciphersuite uses ristretto255 for the Group and SHA-512 for the hash function <tt>H</tt>.
The value of the contextString parameter is "FROST-RISTRETTO255-SHA512-v1".</t>
        <dl newline="false" spacing="normal">
          <dt>Group:</dt> <dd><t>ristretto255 <xref target="RFC9496"/>, where Ne = 32 and Ns = 32.</t>
        <dl newline="false" spacing="normal">
              <dt>Order():</dt> <dd>Return 2<sup>252</sup> + 27742317777372353535851937790883648493 (see <xref target="RFC9496"/>).</dd>
              <dt>Identity():</dt> <dd>As defined in <xref target="RFC9496"/>.</dd>
              <dt>RandomScalar():</dt> <dd>Implemented by returning a uniformly random Scalar in the range
[0, <tt>G.Order()</tt> - 1]. Refer to <xref target="random-scalar"/> for implementation guidance.</dd>
              <dt>SerializeElement(A):</dt> <dd>Implemented using the "Encode" function from <xref target="RFC9496"/>.
Additionally, this function validates that the input element is not the group
identity element.</dd>
              <dt>DeserializeElement(buf):</dt> <dd>Implemented using the "Decode" function from <xref target="RFC9496"/>.
Additionally, this function validates that the resulting element is not the group
identity element. If either the "Decode" function or the check fails, deserialization returns an error.</dd>
              <dt>SerializeScalar(s):</dt> <dd>Implemented by outputting the little-endian 32-byte encoding of
the Scalar value with the top three bits set to zero.</dd>
              <dt>DeserializeScalar(buf):</dt> <dd>Implemented by attempting to deserialize a Scalar from a
little-endian 32-byte string. This function can fail if the input does not
represent a Scalar in the range [0, <tt>G.Order()</tt> - 1]. Note that this means the
top three bits of the input <bcp14>MUST</bcp14> be zero.</dd>
            </dl>
          </dd>
          <dt>Hash (<tt>H</tt>):</dt> <dd><t>SHA-512, which has 64 bytes of output.</t>
	  <dl newline="false" spacing="normal">
            <dt>H1(m):</dt> <dd>Implemented by computing H(contextString || "rho" || m) and mapping the
output to a Scalar as described in <xref section="4.4" sectionFormat="comma" target="RFC9496"/>.</dd>
            <dt>H2(m):</dt> <dd>Implemented by computing H(contextString || "chal" || m) and mapping the
output to a Scalar as described in <xref section="4.4" sectionFormat="comma" target="RFC9496"/>.</dd>
              <dt>H3(m):</dt> <dd>Implemented by computing H(contextString || "nonce" || m) and mapping the
output to a Scalar as described in <xref section="4.4" sectionFormat="comma" target="RFC9496"/>.</dd>
              <dt>H4(m):</dt> <dd>Implemented by computing H(contextString || "msg" || m).</dd>
              <dt>H5(m):</dt> <dd>Implemented by computing H(contextString || "com" || m).</dd>
            </dl>
          </dd>
	</dl>
        <t>Signature verification is as specified in <xref target="prime-order-verify"/>.</t>
        <t>Canonical signature encoding is as specified in <xref target="sig-encoding"/>.</t>
      </section>
      <section anchor="frosted448-shake256">
        <name>FROST(Ed448, SHAKE256)</name>
        <t>This ciphersuite uses edwards448 for the Group and SHAKE256 for the hash function <tt>H</tt>
	meant to produce Ed448-compliant signatures as specified in <xref section="5.2" sectionFormat="of" target="RFC8032"/>.
   Unlike Ed448 in <xref target="RFC8032"/>, this ciphersuite does not allow applications to
   specify a context string and always sets the context of <xref target="RFC8032"/> to the empty string.
Note that this ciphersuite does not allow applications to specify a context
string as is allowed for Ed448 in <xref target="RFC8032"/>, and always sets
the <xref target="RFC8032"/> context string to the empty string.  The value of
the (internal to FROST) contextString parameter is
"FROST-ED448-SHAKE256-v1".</t>
  <dl newline="false" spacing="normal">
            <dt>Group:</dt> <dd><t>edwards448 <xref target="RFC8032"/>, where Ne = 57 and Ns = 57.</t>
	    <dl newline="false" spacing="normal">
              <dt>Order():</dt> <dd>Return 2<sup>446</sup> - 13818066809895115352007386748515426880336692474882178609894547503885.</dd>
              <dt>Identity():</dt> <dd>As defined in <xref target="RFC7748"/>.</dd>
              <dt>RandomScalar():</dt> <dd>Implemented by returning a uniformly random Scalar in the range
[0, <tt>G.Order()</tt> - 1]. Refer to <xref target="random-scalar"/> for implementation guidance.</dd>
              <dt>SerializeElement(A):</dt> <dd>Implemented as specified in <xref section="5.2.2" sectionFormat="comma" target="RFC8032"/>.
Additionally, this function validates that the input element is not the group
identity element.</dd>
              <dt>DeserializeElement(buf):</dt> <dd>Implemented as specified in <xref section="5.2.3" sectionFormat="comma" target="RFC8032"/>.
Additionally, this function validates that the resulting element is not the group
identity element and is in the prime-order subgroup. If any of these checks fail,
deserialization returns an error. The latter check can
be implemented by multiplying the resulting point by the order of the group and
checking that the result is the identity element. Note that optimizations for
this check exist; see <xref target="Pornin22"/>.</dd>
              <dt>SerializeScalar(s):</dt> <dd>Implemented by outputting the little-endian 57-byte encoding of
the Scalar value.</dd>
              <dt>DeserializeScalar(buf):</dt> <dd>Implemented by attempting to deserialize a Scalar from a
little-endian 57-byte string. This function can fail if the input does not
represent a Scalar in the range [0, <tt>G.Order()</tt> - 1].</dd>
            </dl>
          </dd>
            <dt>Hash (<tt>H</tt>):</dt> <dd><t>SHAKE256 with 114 bytes of output.</t>
	    <dl newline="false" spacing="normal">
              <dt>H1(m):</dt> <dd>Implemented by computing H(contextString || "rho" || m), interpreting the
114-byte digest as a little-endian integer, and reducing the resulting integer modulo
2<sup>446</sup> - 13818066809895115352007386748515426880336692474882178609894547503885.</dd>
              <dt>H2(m):</dt> <dd>Implemented by computing H("SigEd448" || 0 || 0 || m), interpreting
the 114-byte digest as a little-endian integer, and reducing the resulting integer
modulo 2<sup>446</sup> - 13818066809895115352007386748515426880336692474882178609894547503885.</dd>
              <dt>H3(m):</dt> <dd>Implemented by computing H(contextString || "nonce" || m), interpreting the
114-byte digest as a little-endian integer, and reducing the resulting integer modulo
2<sup>446</sup> - 13818066809895115352007386748515426880336692474882178609894547503885.</dd>
              <dt>H4(m):</dt> <dd>Implemented by computing H(contextString || "msg" || m).</dd>
              <dt>H5(m):</dt> <dd>Implemented by computing H(contextString || "com" || m).</dd>
	     </dl>
          </dd>
	</dl>
        <t>Normally, H2 would also include a domain separator. However, it is omitted for compatibility with <xref target="RFC8032"/>.</t>
        <t>Signature verification is as specified in <xref section="5.2.7" sectionFormat="of" target="RFC8032"/> with the
constraint that implementations <bcp14>MUST</bcp14> check the group equation <tt>[4][z]B = [4]R + [4][c]PK</tt>
(changed to use the notation in this document).</t>
        <t>Canonical signature encoding is as specified in <xref target="sig-encoding"/>.</t>
      </section>
      <section anchor="frostp-256-sha-256">
        <name>FROST(P-256, SHA-256)</name>
        <t>This ciphersuite uses P-256 for the Group and SHA-256 for the hash function <tt>H</tt>.
The value of the contextString parameter is "FROST-P256-SHA256-v1".</t>
       <dl newline="false" spacing="normal">
            <dt>Group:</dt> <dd><t>P-256 (secp256r1) <xref target="x9.62"/>, where Ne = 33 and Ns = 32.</t>
	    <dl newline="false" spacing="normal">
              <dt>Order():</dt> <dd>Return 0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551.</dd>
              <dt>Identity():</dt> <dd>As defined in <xref target="x9.62"/>.</dd>
              <dt>RandomScalar():</dt> <dd>Implemented by returning a uniformly random Scalar in the range
[0, <tt>G.Order()</tt> - 1]. Refer to <xref target="random-scalar"/> for implementation guidance.</dd>
              <dt>SerializeElement(A):</dt> <dd>Implemented using the compressed Elliptic-Curve-Point-to-Octet-String
method according to <xref target="SEC1"/>, yielding a 33-byte output. Additionally, this function validates
that the input element is not the group identity element.</dd>

              <dt>DeserializeElement(buf):</dt> <dd>Implemented by attempting to deserialize a 33-byte input string to
a public key using the compressed Octet-String-to-Elliptic-Curve-Point method according to <xref target="SEC1"/> and then performing public key validation as defined in Section 3.2.2.1 of <xref target="SEC1"/>.
This includes checking that the coordinates of the resulting point are
in the correct range, that the point is on the curve, and that the point is not
the point at infinity. (As noted in the specification, validation of the point
order is not required since the cofactor is 1.) If any of these checks fail,
deserialization returns an error.</dd>
              <dt>SerializeScalar(s):</dt> <dd>Implemented using the Field-Element-to-Octet-String conversion
according to <xref target="SEC1"/>.</dd>
              <dt>DeserializeScalar(buf):</dt> <dd>Implemented by attempting to deserialize a Scalar from a 32-byte
string using Octet-String-to-Field-Element from <xref target="SEC1"/>. This function can fail if the
input does not represent a Scalar in the range [0, <tt>G.Order()</tt> - 1].</dd>
	    </dl>
	  </dd>
          <dt>Hash (<tt>H</tt>):</dt> <dd><t>SHA-256, which has 32 bytes of output.</t>

	    <dl newline="false" spacing="normal">
               <dt>H1(m):</dt> <dd>Implemented as hash_to_field(m, 1) (see <xref section="5.2" sectionFormat="comma" target="RFC9380"/>)
using <tt>expand_message_xmd</tt> with SHA-256 with parameters DST = contextString || "rho",
F set to the Scalar field, p set to <tt>G.Order()</tt>, m = 1, and L = 48.</dd>
              <dt>H2(m):</dt> <dd>Implemented as hash_to_field(m, 1) (see <xref section="5.2" sectionFormat="comma" target="RFC9380"/>)
using <tt>expand_message_xmd</tt> with SHA-256 with parameters DST = contextString || "chal",
F set to the Scalar field, p set to <tt>G.Order()</tt>, m = 1, and L = 48.</dd>
              <dt>H3(m):</dt> <dd>Implemented as hash_to_field(m, 1) (see <xref section="5.2" sectionFormat="comma" target="RFC9380"/>)
using <tt>expand_message_xmd</tt> with SHA-256 with parameters DST = contextString || "nonce",
F set to the Scalar field, p set to <tt>G.Order()</tt>, m = 1, and L = 48.</dd>
              <dt>H4(m):</dt> <dd>Implemented by computing H(contextString || "msg" || m).</dd>
              <dt>H5(m):</dt> <dd>Implemented by computing H(contextString || "com" || m).</dd>
	    </dl>
	  </dd>
       </dl>
        <t>Signature verification is as specified in <xref target="prime-order-verify"/>.</t>
        <t>Canonical signature encoding is as specified in <xref target="sig-encoding"/>.</t>
      </section>
      <section anchor="frostsecp256k1-sha-256">
        <name>FROST(secp256k1, SHA-256)</name>
        <t>This ciphersuite uses secp256k1 for the Group and SHA-256 for the hash function <tt>H</tt>.
The value of the contextString parameter is "FROST-secp256k1-SHA256-v1".</t>
        <dl newline="false" spacing="normal">
            <dt>Group:</dt> <dd><t>secp256k1 <xref target="SEC2"/>, where Ne = 33 and Ns = 32.</t>
	    <dl newline="false" spacing="normal">
              <dt>Order():</dt> <dd>Return 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141.</dd>
              <dt>Identity():</dt> <dd>As defined in <xref target="SEC2"/>.</dd>
              <dt>RandomScalar():</dt> <dd>Implemented by returning a uniformly random Scalar in the range
[0, <tt>G.Order()</tt> - 1]. Refer to <xref target="random-scalar"/> for implementation guidance.</dd>
              <dt>SerializeElement(A):</dt> <dd>Implemented using the compressed Elliptic-Curve-Point-to-Octet-String
method according to <xref target="SEC1"/>, yielding a 33-byte output. Additionally, this function validates
that the input element is not the group identity element.</dd>
              <dt>DeserializeElement(buf):</dt> <dd>Implemented by attempting to deserialize a 33-byte input string to
a public key using the compressed Octet-String-to-Elliptic-Curve-Point method according to <xref target="SEC1"/> and then performing public key validation as defined in Section 3.2.2.1 of <xref target="SEC1"/>.
This includes checking that the coordinates of the resulting point are
in the correct range, the point is on the curve, and the point is not
the point at infinity. (As noted in the specification, validation of the point
order is not required since the cofactor is 1.) If any of these checks fail,
deserialization returns an error.</dd>
              <dt>SerializeScalar(s):</dt> <dd>Implemented using the Field-Element-to-Octet-String conversion
according to <xref target="SEC1"/>.</dd>
              <dt>DeserializeScalar(buf):</dt> <dd>Implemented by attempting to deserialize a Scalar from a 32-byte
string using Octet-String-to-Field-Element from <xref target="SEC1"/>. This function can fail if the
input does not represent a Scalar in the range [0, <tt>G.Order()</tt> - 1].</dd>
	    </dl>
	  </dd>
            <dt>Hash (<tt>H</tt>):</dt> <dd><t>SHA-256, which has 32 bytes of output.</t>
	    <dl newline="false" spacing="normal">
              <dt>H1(m):</dt> <dd>Implemented as hash_to_field(m, 1) (see <xref section="5.2" sectionFormat="comma" target="RFC9380"/>)
using <tt>expand_message_xmd</tt> with SHA-256 with parameters DST = contextString || "rho",
F set to the Scalar field, p set to <tt>G.Order()</tt>, m = 1, and L = 48.</dd>
              <dt>H2(m):</dt> <dd>Implemented as hash_to_field(m, 1) (see <xref section="5.2" sectionFormat="comma" target="RFC9380"/>)
using <tt>expand_message_xmd</tt> with SHA-256 with parameters DST = contextString || "chal",
F set to the Scalar field, p set to <tt>G.Order()</tt>, m = 1, and L = 48.</dd>
              <dt>H3(m):</dt> <dd>Implemented as hash_to_field(m, 1) (see <xref section="5.2" sectionFormat="comma" target="RFC9380"/>)
using <tt>expand_message_xmd</tt> with SHA-256 with parameters DST = contextString || "nonce",
F set to the Scalar field, p set to <tt>G.Order()</tt>, m = 1, and L = 48.</dd>
              <dt>H4(m):</dt> <dd>Implemented by computing H(contextString || "msg" || m).</dd>
              <dt>H5(m):</dt> <dd>Implemented by computing H(contextString || "com" || m).</dd>
	    </dl>
	  </dd>
	</dl>
        <t>Signature verification is as specified in <xref target="prime-order-verify"/>.</t>
        <t>Canonical signature encoding is as specified in <xref target="sig-encoding"/>.</t>
      </section>
      <section anchor="ciphersuite-reqs">
        <name>Ciphersuite Requirements</name>
        <t>Future documents that introduce new ciphersuites <bcp14>MUST</bcp14> adhere to
the following requirements.</t>
        <ol spacing="normal" type="1"><li>H1, H2, and H3 all have output distributions that are close to
  (indistinguishable from) the uniform distribution.</li>
          <li>All hash functions <bcp14>MUST</bcp14> be domain-separated with a per-suite context
  string. Note that the FROST(Ed25519, SHA-512) ciphersuite does not
  adhere to this requirement for H2 alone in order to maintain compatibility
	  with <xref target="RFC8032"/>.</li>
	  
          <li>The group <bcp14>MUST</bcp14> be of prime order and all deserialization functions <bcp14>MUST</bcp14>
  output elements that belong to their respective sets of Elements or Scalars, or else fail.</li>
          <li>The canonical signature encoding details are clearly specified.</li>
        </ol>
      </section>
    </section>
    <section anchor="sec-considerations">
      <name>Security Considerations</name>
      <t>A security analysis of FROST is documented in <xref target="FROST20"/> and <xref target="StrongerSec22"/>. At a high level, FROST provides security against Existential Unforgeability Under Chosen Message
      Attacks (EUF-CMA) as defined in <xref target="StrongerSec22"/>.
 To satisfy this requirement, the ciphersuite needs to adhere to the
 requirements in <xref target="ciphersuite-reqs"/> and the following
 assumptions must hold.</t>
      <ul spacing="normal">
        <li>The signer key shares are generated and distributed securely, e.g., via a trusted dealer
that performs key generation (see <xref target="dep-vss"/>) or through a distributed key generation protocol.</li>
        <li>The Coordinator and at most <tt>(MIN_PARTICIPANTS-1)</tt> participants may be corrupted.</li>
      </ul>
      <t>Note that the Coordinator is not trusted with any private information, and communication at the time of signing can be performed over a public channel as long as it is authenticated and reliable.</t>
      <t>FROST provides security against DoS attacks under the following assumptions:</t>
      <ul spacing="normal">
        <li>The Coordinator does not perform a DoS attack.</li>
        <li>The Coordinator identifies misbehaving participants such that they can be removed from
future invocations of FROST. The Coordinator may also abort upon detecting a misbehaving
participant to ensure that invalid signatures are not produced.</li>
      </ul>
      <t>FROST does not aim to achieve the following goals:</t>
      <ul spacing="normal">
        <li>Post-quantum security. FROST, like plain Schnorr signatures, requires the hardness of the Discrete Logarithm Problem.</li>
        <li>Robustness. Preventing DoS attacks against misbehaving participants requires the Coordinator
to identify and act on misbehaving participants; see <xref target="abort"/> for more information. 
While FROST
does not provide robustness, <xref target="ROAST"/> is a wrapper protocol around FROST that does.</li>
        <li>Downgrade prevention. All participants in the protocol are assumed to agree on which algorithms to use.</li>
        <li>Metadata protection. If protection for metadata is desired, a higher-level communication
channel can be used to facilitate key generation and signing.</li>
      </ul>
      <t>The rest of this section documents issues particular to implementations or deployments.</t>
      <section anchor="side-channel-mitigations">
        <name>Side-Channel Mitigations</name>
        <t>Several routines process secret values (nonces, signing keys / shares), and depending
on the implementation and deployment environment, mitigating side-channels may be
pertinent. Mitigating these side-channels requires implementing <tt>G.ScalarMult()</tt>, <tt>G.ScalarBaseMult()</tt>,
<tt>G.SerializeScalar()</tt>, and <tt>G.DeserializeScalar()</tt> in constant (value-independent) time.
The various ciphersuites lend themselves differently to specific implementation techniques
and ease of achieving side-channel resistance, though ultimately avoiding value-dependent
computation or branching is the goal.</t>
      </section>
      <section anchor="optimizations">
        <name>Optimizations</name>
        <t><xref target="StrongerSec22"/> presented an optimization to FROST that reduces the total number of Scalar multiplications
from linear in the number of signing participants to a constant. However, as described in <xref target="StrongerSec22"/>,
this optimization removes the guarantee that the set of signer participants that started round one of
the protocol is the same set of signing participants that produced the signature output by round two.
As such, the optimization is <bcp14>NOT RECOMMENDED</bcp14> and is not covered in this document.</t>
      </section>
      <section anchor="nonce-reuse-attacks">
        <name>Nonce Reuse Attacks</name>
        <t><xref target="dep-nonces"/> describes the procedure that participants use to produce nonces during
the first round of signing. The randomness produced in this procedure <bcp14>MUST</bcp14> be sampled
uniformly at random. The resulting nonces produced via <tt>nonce_generate</tt> are indistinguishable
from values sampled uniformly at random. This requirement is necessary to avoid
replay attacks initiated by other participants that allow for a complete key-recovery attack.
The Coordinator <bcp14>MAY</bcp14> further hedge against nonce reuse attacks by tracking participant nonce
commitments used for a given group key at the cost of additional state.</t>
      </section>
      <section anchor="protocol-failures">
        <name>Protocol Failures</name>
        <t>We do not specify what implementations should do when the protocol fails other than requiring
the protocol to abort. Examples of viable failures include when a verification check returns invalid or the underlying transport failed to deliver the required messages.</t>
      </section>
      <section anchor="no-coordinator">
        <name>Removing the Coordinator Role</name>
        <t>In some settings, it may be desirable to omit the role of the Coordinator entirely.
Doing so does not change the security implications of FROST; instead, it simply
requires each participant to communicate with all other participants. We loosely
describe how to perform FROST signing among participants without this coordinator role.
We assume that every participant receives a message to be signed from an external source as input prior to performing the protocol.</t>
        <t>Every participant begins by performing <tt>commit()</tt> as is done in the setting
where a Coordinator is used. However, instead of sending the commitment
to the Coordinator, every participant will publish this commitment to every other participant. In the second round, participants will already have sufficient information to perform signing, and they will directly perform <tt>sign()</tt>. All participants will then publish their signature shares to one another. After having received all signature shares from all other participants, each participant will then perform <tt>verify_signature_share</tt> and then <tt>aggregate</tt> directly.</t>
<t>The requirements for the underlying network channel remain the same in the
setting where all participants play the role of the Coordinator, in that all
exchanged messages are public and the channel must be reliable. However, in the setting
where a player attempts to split the view of all other players by sending
disjoint values to a subset of players, the signing operation will output an
invalid signature. To avoid this DoS, implementations may wish to define a
mechanism where messages are authenticated so that cheating players can be
identified and excluded.</t>
      </section>
      <section anchor="pre-hashing">
        <name>Input Message Hashing</name>
        <t>FROST signatures do not pre-hash message inputs. This means that
        the entire message must be known in advance of invoking the signing
        protocol. Applications can apply pre-hashing in settings where storing
        the full message is prohibitively expensive.  In such cases,
        pre-hashing <bcp14>MUST</bcp14> use a collision-resistant hash
        function with a security level commensurate with the security inherent
        to the ciphersuite chosen. For applications that choose to apply
        pre-hashing, it is <bcp14>RECOMMENDED</bcp14> that they use the hash
        function (<tt>H</tt>) associated with the chosen ciphersuite in a
        manner similar to how <tt>H4</tt> is defined.  In particular, a
        different prefix <bcp14>SHOULD</bcp14> be used to differentiate this
        pre-hash from <tt>H4</tt>. For example, if a fictional protocol Quux
        decided to pre-hash its input messages, one possible way to do so is
        via <tt>H(contextString || "Quux-pre-hash" || m)</tt>.</t>
      </section>
      <section anchor="message-validation">
        <name>Input Message Validation</name>
        <t>Message validation varies by application. For example, some applications may
require that participants only process messages of a certain structure. In digital
currency applications, wherein multiple participants may collectively sign a transaction,
it is reasonable to require each participant to check that the input message is a
syntactically valid transaction.</t>
        <t>As another example, some applications may require that participants only process
messages with permitted content according to some policy. In digital currency
applications, this might mean that a transaction being signed is allowed and
intended by the relevant stakeholders. Another instance of this type of message
validation is in the context of <xref target="RFC8446"/>, wherein implementations may
use threshold signing protocols to produce signatures of transcript hashes. In
this setting, signing participants might require the raw TLS handshake messages
to validate before computing the transcript hash that is signed.</t>
        <t>In general, input message validation is an application-specific consideration
that varies based on the use case and threat model. However, it is <bcp14>RECOMMENDED</bcp14>
that applications take additional precautions and validate inputs so that
participants do not operate as signing oracles for arbitrary messages.</t>
      </section>
    </section>
    <section anchor="iana-considerations">
      <name>IANA Considerations</name>
     <t>This document has no IANA actions.</t>
    </section>
  </middle>

  <back>

    <displayreference target="RFC9496" to="RISTRETTO"/>
    <displayreference target="RFC9380" to="HASH-TO-CURVE"/>
    <displayreference target="RFC8446" to="TLS"/>

    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>

        <reference anchor="x9.62">
          <front>
            <title>Public Key Cryptography for the Financial Services Industry: the Elliptic Curve Digital Signature Algorithm (ECDSA)</title>
            <author>
              <organization>American National Standards Institute</organization>
            </author>
            <date year="2005" month="November"/>
          </front>
          <seriesInfo name="ANSI" value="X9.62-2005"/>
        </reference>

        <reference anchor="SEC1" target="https://secg.org/sec1-v2.pdf">
          <front>
            <title>SEC 1: Elliptic Curve Cryptography</title>
            <author>
              <organization>Standards for Efficient Cryptography</organization>
            </author>
            <date year="2009" month="May"/>
          </front>
	  <refcontent>Version 2.0</refcontent>
        </reference>

        <reference anchor="SEC2" target="https://secg.org/sec2-v2.pdf">
          <front>
            <title>SEC 2: Recommended Elliptic Curve Domain Parameters</title>
            <author>
              <organization>Standards for Efficient Cryptography</organization>
            </author>
            <date year="2010" month="January"/>
          </front>
	     <refcontent>Version 2.0</refcontent>
        </reference>

        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8032.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>

        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9496.xml"/>

        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9380.xml"/>

      </references>
      <references>
        <name>Informative References</name>
        <reference anchor="FROST20" target="https://eprint.iacr.org/2020/852.pdf">
          <front>
            <title>FROST: Flexible Round-Optimized Schnorr Threshold Signatures</title>
            <author initials="C." surname="Komlo" fullname="Chelsea Komlo">
              <organization/>
            </author>
            <author initials="I." surname="Goldberg" fullname="Ian Goldberg">
              <organization/>
            </author>
            <date year="2020" month="December"/>
          </front>
        </reference>

        <reference anchor="StrongerSec22" target="https://crypto.iacr.org/2022/papers/538806_1_En_18_Chapter_OnlinePDF.pdf">
          <front>
            <title>Better than Advertised Security for Non-interactive Threshold Signatures</title>
            <author initials="M." surname="Bellare" fullname="Mihir Bellare">
              <organization/>
            </author>
            <author initials="E." surname="Crites" fullname="Elizabeth Crites">
              <organization/>
            </author>
            <author initials="C." surname="Komlo" fullname="Chelsea Komlo">
              <organization/>
            </author>
            <author initials="M." surname="Maller" fullname="Mary Maller">
              <organization/>
            </author>
            <author initials="S." surname="Tessaro" fullname="Stefano Tessaro">
              <organization/>
            </author>
            <author initials="C." surname="Zhu" fullname="Chenzhi Zhu">
              <organization/>
            </author>
            <date month="August" year="2022"/>
          </front>
	  <seriesInfo name="DOI" value="10.1007/978-3-031-15985-5_18"/>
        </reference>

        <reference anchor="Pornin22" target="https://eprint.iacr.org/2022/1164.pdf">
          <front>
            <title>Point-Halving and Subgroup Membership in Twisted Edwards Curves</title>
            <author initials="T." surname="Pornin" fullname="Thomas Pornin">
              <organization/>
            </author>
            <date year="2022" month="September"/>
          </front>
        </reference>

        <reference anchor="ROAST" target="https://eprint.iacr.org/2022/550">
          <front>
            <title>ROAST: Robust Asynchronous Schnorr Threshold Signatures</title>
            <author initials="T." surname="Ruffing" fullname="Tim Ruffing">
              <organization/>
            </author>
            <author initials="V." surname="Ronge" fullname="Viktoria Ronge">
              <organization/>
            </author>
            <author initials="E." surname="Jin" fullname="Elliott Jin">
              <organization/>
            </author>
            <author initials="J." surname="Schneider-Bensch" fullname="Jonas Schneider-Bensch">
              <organization/>
            </author>
            <author initials="D." surname="Schrder" fullname="Dominique Schrder">
              <organization/>
            </author>
            <date year="2022" month="November"/>
          </front>
	  <seriesInfo name="DOI" value="10.1145/3548606"/>
	  <refcontent>Paper 2022/550</refcontent>
        </reference>

        <reference anchor="MultExp" target="https://zfnd.org/speeding-up-frost-with-multi-scalar-multiplication/">
          <front>
            <title>Speeding up FROST with multi-scalar multiplication</title>
            <author initials="D." surname="Connolly" fullname="Deirdre Connolly">
              <organization/>
            </author>
            <author initials="C." surname="Gouvea" fullname="Conrado Gouvea">
              <organization/>
            </author>
            <date year="2023" month="June"/>
          </front>
        </reference>

        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4086.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7748.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8446.xml"/>

        <reference anchor="ShamirSecretSharing">
          <front>
            <title>How to share a secret</title>
            <author fullname="Adi Shamir" initials="A." surname="Shamir">
              <organization>Massachusetts Institute of Technology</organization>
            </author>
            <date month="November" year="1979"/>
          </front>
          <seriesInfo name="DOI" value="10.1145/359168.359176"/>
          <refcontent>Association for Computing Machinery (ACM)</refcontent>
          <refcontent>Communications of the ACM, Vol. 22, Issue 11, pp. 612-613</refcontent>
       </reference>

        <reference anchor="FeldmanSecretSharing">
          <front>
            <title>A practical scheme for non-interactive verifiable secret sharing</title>
            <author fullname="Paul Feldman" initials="P." surname="Feldman" >
              <organization/>
            </author>
            <date month="October" year="1987"/>
          </front>
          <seriesInfo name="DOI" value="10.1109/sfcs.1987.4"/>
	  <refcontent>IEEE</refcontent>
          <refcontent>28th Annual Symposium on Foundations of Computer Science (sfcs 1987)</refcontent>
        </reference>

      </references>
    </references>
    <section anchor="sig-encoding">
      <name>Schnorr Signature Encoding</name>
      <t>This section describes one possible canonical encoding of FROST signatures. Using notation
from <xref section="3" sectionFormat="of" target="RFC8446"/>, the encoding of a FROST signature (R, z) is as follows:</t>
      <sourcecode type=""><![CDATA[
  struct {
    opaque R_encoded[Ne];
    opaque z_encoded[Ns];
  } Signature;
]]></sourcecode>
      <t>Where Signature.R_encoded is <tt>G.SerializeElement(R)</tt>, Signature.z_encoded is
<tt>G.SerializeScalar(z)</tt>, and <tt>G</tt> is determined by ciphersuite.</t>
    </section>
    <section anchor="prime-order-verify">
      <name>Schnorr Signature Generation and Verification for Prime-Order Groups</name>
      <t>This section contains descriptions of functions for generating and verifying Schnorr signatures.
It is included to complement the routines present in <xref target="RFC8032"/> for prime-order groups, including
ristretto255, P-256, and secp256k1. The functions for generating and verifying signatures are
<tt>prime_order_sign</tt> and <tt>prime_order_verify</tt>, respectively.</t>
      <t>The function <tt>prime_order_sign</tt> produces a Schnorr signature over a message given a full secret signing
key as input (as opposed to a key share).</t>
      <sourcecode type="pseudocode"><![CDATA[
Inputs:
- msg, message to sign, a byte string.
- sk, secret key, a Scalar.

Outputs:
- (R, z), a Schnorr signature consisting of an Element R and
  Scalar z.

def prime_order_sign(msg, sk):
  r = G.RandomScalar()
  R = G.ScalarBaseMult(r)
  PK = G.ScalarBaseMult(sk)
  comm_enc = G.SerializeElement(R)
  pk_enc = G.SerializeElement(PK)
  challenge_input = comm_enc || pk_enc || msg
  c = H2(challenge_input)
  z = r + (c * sk) // Scalar addition and multiplication
  return (R, z)
]]></sourcecode>
      <t>The function <tt>prime_order_verify</tt> verifies Schnorr signatures with validated inputs.
Specifically, it assumes that the signature R component and public key belong to the prime-order group.</t>
      <sourcecode type="pseudocode"><![CDATA[
Inputs:
- msg, signed message, a byte string.
- sig, a tuple (R, z) output from signature generation.
- PK, public key, an Element.

Outputs:
- True if signature is valid, and False otherwise.

def prime_order_verify(msg, sig = (R, z), PK):
  comm_enc = G.SerializeElement(R)
  pk_enc = G.SerializeElement(PK)
  challenge_input = comm_enc || pk_enc || msg
  c = H2(challenge_input)

  l = G.ScalarBaseMult(z)
  r = R + G.ScalarMult(PK, c)
  return l == r
]]></sourcecode>
    </section>
    <section anchor="dep-dealer">
      <name>Trusted Dealer Key Generation</name>
      <t>One possible key generation mechanism is to depend on a trusted dealer, wherein the
dealer generates a group secret <tt>s</tt> uniformly at random and uses Shamir and Verifiable
Secret Sharing <xref target="ShamirSecretSharing"/> as described in Appendices <xref target="dep-shamir" format="counter"/> and <xref target="dep-vss" format="counter"/> to create secret
shares of s, denoted as <tt>s_i</tt> for <tt>i = 1, ..., MAX_PARTICIPANTS</tt>, to be sent to all <tt>MAX_PARTICIPANTS</tt> participants.
This operation is specified in the <tt>trusted_dealer_keygen</tt> algorithm. The mathematical relation
between the secret key <tt>s</tt> and the <tt>MAX_PARTICIPANTS</tt> secret shares is formalized in the <tt>secret_share_combine(shares)</tt>
algorithm, defined in <xref target="dep-shamir"/>.</t>
      <t>The dealer that performs <tt>trusted_dealer_keygen</tt> is trusted to 1) generate good randomness, 2) delete secret values after distributing shares to each participant, and 3) keep secret values confidential.</t>
      <sourcecode type="pseudocode"><![CDATA[
Inputs:
- secret_key, a group secret, a Scalar, that MUST be derived from at
  least Ns bytes of entropy.
- MAX_PARTICIPANTS, the number of shares to generate, an integer.
- MIN_PARTICIPANTS, the threshold of the secret sharing scheme,
  an integer.

Outputs:
- participant_private_keys, MAX_PARTICIPANTS shares of the secret
  key s, each a tuple consisting of the participant identifier
  (a NonZeroScalar) and the key share (a Scalar).
- group_public_key, public key corresponding to the group signing
  key, an Element.
- vss_commitment, a vector commitment of Elements in G, to each of
  the coefficients in the polynomial defined by secret_key_shares and
  whose first element is G.ScalarBaseMult(s).

def trusted_dealer_keygen(
        secret_key, MAX_PARTICIPANTS, MIN_PARTICIPANTS):
  # Generate random coefficients for the polynomial
  coefficients = []
  for i in range(0, MIN_PARTICIPANTS - 1):
    coefficients.append(G.RandomScalar())
  participant_private_keys, coefficients = secret_share_shard(
      secret_key, coefficients, MAX_PARTICIPANTS)
  vss_commitment = vss_commit(coefficients):
  return participant_private_keys, vss_commitment[0], vss_commitment
]]></sourcecode>
      <t>It is assumed that the dealer then sends one secret key share to each of the <tt>NUM_PARTICIPANTS</tt> participants, along with <tt>vss_commitment</tt>.
After receiving their secret key share and <tt>vss_commitment</tt>, participants <bcp14>MUST</bcp14> abort if they do not have the same view of <tt>vss_commitment</tt>.
The dealer can use a secure broadcast channel to ensure each participant has a consistent view of this commitment.
Furthermore, each participant <bcp14>MUST</bcp14> perform <tt>vss_verify(secret_key_share_i, vss_commitment)</tt> and abort if the check fails.
The trusted dealer <bcp14>MUST</bcp14> delete the secret_key and secret_key_shares upon completion.</t>
      <t>Use of this method for key generation requires a mutually authenticated secure channel
between the dealer and participants to send secret key shares, wherein the channel provides confidentiality and integrity. Mutually authenticated TLS is one possible deployment option.</t>
      <section anchor="dep-shamir">
        <name>Shamir Secret Sharing</name>
        <t>In Shamir secret sharing, a dealer distributes a secret <tt>Scalar</tt> <tt>s</tt> to <tt>n</tt> participants
in such a way that any cooperating subset of at least <tt>MIN_PARTICIPANTS</tt> participants can recover the
secret. There are two basic steps in this scheme: 1) splitting a secret into
multiple shares and 2) combining shares to reveal the resulting secret.</t>
        <t>This secret sharing scheme works over any field <tt>F</tt>. In this specification, <tt>F</tt> is
the Scalar field of the prime-order group <tt>G</tt>.</t>
        <t>The procedure for splitting a secret into shares is as follows.
The algorithm <tt>polynomial_evaluate</tt> is defined in <xref target="dep-extended-polynomial-operations"/>.</t>
        <sourcecode type="pseudocode"><![CDATA[
Inputs:
- s, secret value to be shared, a Scalar.
- coefficients, an array of size MIN_PARTICIPANTS - 1 with randomly
  generated Scalars, not including the 0th coefficient of the
  polynomial.
- MAX_PARTICIPANTS, the number of shares to generate, an integer less
  than the group order.

Outputs:
- secret_key_shares, A list of MAX_PARTICIPANTS number of secret
  shares, each a tuple consisting of the participant identifier
  (a NonZeroScalar) and the key share (a Scalar).
- coefficients, a vector of MIN_PARTICIPANTS coefficients which
  uniquely determine a polynomial f.

def secret_share_shard(s, coefficients, MAX_PARTICIPANTS):
  # Prepend the secret to the coefficients
  coefficients = [s] + coefficients

  # Evaluate the polynomial for each point x=1,...,n
  secret_key_shares = []
  for x_i in range(1, MAX_PARTICIPANTS + 1):
    y_i = polynomial_evaluate(Scalar(x_i), coefficients)
    secret_key_share_i = (x_i, y_i)
    secret_key_shares.append(secret_key_share_i)
  return secret_key_shares, coefficients
]]></sourcecode>
        <t>Let <tt>points</tt> be the output of this function. The i-th element in <tt>points</tt> is
the share for the i-th participant, which is the randomly generated polynomial
evaluated at coordinate <tt>i</tt>. We denote a secret share as the tuple <tt>(i, points[i])</tt>
and the list of these shares as <tt>shares</tt>. <tt>i</tt> <bcp14>MUST</bcp14> never equal <tt>0</tt>; recall that
<tt>f(0) = s</tt>, where <tt>f</tt> is the polynomial defined in a Shamir secret sharing operation.</t>
        <t>The procedure for combining a <tt>shares</tt> list of length <tt>MIN_PARTICIPANTS</tt> to recover the
secret <tt>s</tt> is as follows; the algorithm <tt>polynomial_interpolate_constant</tt> is defined in <xref target="dep-extended-polynomial-operations"/>.</t>
        <sourcecode type="pseudocode"><![CDATA[
Inputs:
- shares, a list of at minimum MIN_PARTICIPANTS secret shares, each a
  tuple (i, f(i)) where i and f(i) are Scalars.

Outputs:
- s, the resulting secret that was previously split into shares,
  a Scalar.

Errors:
- "invalid parameters", if fewer than MIN_PARTICIPANTS input shares
  are provided.

def secret_share_combine(shares):
  if len(shares) < MIN_PARTICIPANTS:
    raise "invalid parameters"
  s = polynomial_interpolate_constant(shares)
  return s
]]></sourcecode>
        <section anchor="dep-extended-polynomial-operations">
          <name>Additional Polynomial Operations</name>
          <t>This section describes two functions. One function, denoted as <tt>polynomial_evaluate</tt>,
is for evaluating a polynomial <tt>f(x)</tt> at a particular point <tt>x</tt> using Horner's method,
i.e., computing <tt>y = f(x)</tt>. The other function, <tt>polynomial_interpolate_constant</tt>, is for
recovering the constant term of an interpolating polynomial defined by a set of points.</t>
          <t>The function <tt>polynomial_evaluate</tt> is defined as follows.</t>
          <sourcecode type="pseudocode"><![CDATA[
Inputs:
- x, input at which to evaluate the polynomial, a Scalar
- coeffs, the polynomial coefficients, a list of Scalars

Outputs: Scalar result of the polynomial evaluated at input x

def polynomial_evaluate(x, coeffs):
  value = Scalar(0)
  for coeff in reverse(coeffs):
    value *= x
    value += coeff
  return value
]]></sourcecode>
          <t keepWithNext="true">The function <tt>polynomial_interpolate_constant</tt> is defined as follows.</t>
          <sourcecode type="pseudocode"><![CDATA[
Inputs:
- points, a set of t points with distinct x coordinates on
  a polynomial f, each a tuple of two Scalar values representing the
  x and y coordinates.

Outputs:
- f_zero, the constant term of f, i.e., f(0), a Scalar.

def polynomial_interpolate_constant(points):
  x_coords = []
  for (x, y) in points:
    x_coords.append(x)

  f_zero = Scalar(0)
  for (x, y) in points:
    delta = y * derive_interpolating_value(x_coords, x)
    f_zero += delta

  return f_zero
]]></sourcecode>
        </section>
      </section>
      <section anchor="dep-vss">
        <name>Verifiable Secret Sharing</name>
        <t>Feldman's Verifiable Secret Sharing (VSS) <xref target="FeldmanSecretSharing"/>
builds upon Shamir secret sharing, adding a verification step to demonstrate the consistency of a participant's
share with a public commitment to the polynomial <tt>f</tt> for which the secret <tt>s</tt>
is the constant term. This check ensures that all participants have a point
(their share) on the same polynomial, ensuring that they can reconstruct
the correct secret later.</t>
<t>The procedure for committing to a polynomial <tt>f</tt> of degree at most <tt>MIN_PARTICIPANTS-1</tt> is as follows.</t>
        <sourcecode type="pseudocode"><![CDATA[
Inputs:
- coeffs, a vector of the MIN_PARTICIPANTS coefficients that
  uniquely determine a polynomial f.

Outputs:
- vss_commitment, a vector commitment to each of the coefficients in
  coeffs, where each item of the vector commitment is an Element.

def vss_commit(coeffs):
  vss_commitment = []
  for coeff in coeffs:
    A_i = G.ScalarBaseMult(coeff)
    vss_commitment.append(A_i)
  return vss_commitment
]]></sourcecode>
        <t>The procedure for verification of a participant's share is as follows.
If <tt>vss_verify</tt> fails, the participant <bcp14>MUST</bcp14> abort the protocol, and the failure should be investigated out of band.</t>
        <sourcecode type="pseudocode"><![CDATA[
Inputs:
- share_i: A tuple of the form (i, sk_i), where i indicates the
  participant identifier (a NonZeroScalar), and sk_i the
  participant's secret key, a secret share of the constant term of f,
  where sk_i is a Scalar.
- vss_commitment, a VSS commitment to a secret polynomial f, a vector
  commitment to each of the coefficients in coeffs, where each
  element of the vector commitment is an Element.

Outputs:
- True if sk_i is valid, and False otherwise.

def vss_verify(share_i, vss_commitment)
  (i, sk_i) = share_i
  S_i = G.ScalarBaseMult(sk_i)
  S_i' = G.Identity()
  for j in range(0, MIN_PARTICIPANTS):
    S_i' += G.ScalarMult(vss_commitment[j], pow(i, j))
  return S_i == S_i'
]]></sourcecode>
        <t>We now define how the Coordinator and participants can derive group info,
which is an input into the FROST signing protocol.</t>
        <sourcecode type="pseudocode"><![CDATA[
Inputs:
- MAX_PARTICIPANTS, the number of shares to generate, an integer.
- MIN_PARTICIPANTS, the threshold of the secret sharing scheme,
  an integer.
- vss_commitment, a VSS commitment to a secret polynomial f, a vector
  commitment to each of the coefficients in coeffs, where each
  element of the vector commitment is an Element.

Outputs:
- PK, the public key representing the group, an Element.
- participant_public_keys, a list of MAX_PARTICIPANTS public keys
  PK_i for i=1,...,MAX_PARTICIPANTS, where each PK_i is the public
  key, an Element, for participant i.

def derive_group_info(MAX_PARTICIPANTS, MIN_PARTICIPANTS, 
 vss_commitment):
  PK = vss_commitment[0]
  participant_public_keys = []
  for i in range(1, MAX_PARTICIPANTS+1):
    PK_i = G.Identity()
    for j in range(0, MIN_PARTICIPANTS):
      PK_i += G.ScalarMult(vss_commitment[j], pow(i, j))
    participant_public_keys.append(PK_i)
  return PK, participant_public_keys
]]></sourcecode>
      </section>
    </section>
    <section anchor="random-scalar">
      <name>Random Scalar Generation</name>
      <t>Two popular algorithms for
      generating a random integer uniformly distributed in the range [0,
      G.Order() -1] are described in the sections that follow.</t>
      <section anchor="rejection-sampling">
        <name>Rejection Sampling</name>
        <t>Generate a random byte array with <tt>Ns</tt> bytes and attempt to map to a Scalar
by calling <tt>DeserializeScalar</tt> in constant time. If it succeeds, return the
result. If it fails, try again with another random byte array, until the
procedure succeeds. Failure to implement <tt>DeserializeScalar</tt> in constant time
can leak information about the underlying corresponding Scalar.</t>
        <t>As an optimization, if the group order is very close to a power of
2, it is acceptable to omit the rejection test completely.  In particular, if the group order is p and there is an integer b such that |p - 2<sup>b</sup>| is less than 2<sup>(b/2)</sup>, then
<tt>RandomScalar</tt> can simply return a uniformly random integer of at
most b bits.</t>
      </section>
      <section anchor="wide-reduction">
        <name>Wide Reduction</name>
        <t>Generate a random byte array with <tt>l = ceil(((3 * ceil(log2(G.Order()))) / 2) / 8)</tt>
bytes and interpret it as an integer; reduce the integer modulo <tt>G.Order()</tt> and return the
result. See <xref section="5" sectionFormat="of" target="RFC9380"/> for the underlying derivation of <tt>l</tt>.</t>
      </section>
    </section>
    <section anchor="test-vectors">
      <name>Test Vectors</name>
      <t>This section contains test vectors for all ciphersuites listed in <xref target="ciphersuites"/>.
All <tt>Element</tt> and <tt>Scalar</tt> values are represented in serialized form and encoded in
hexadecimal strings. Signatures are represented as the concatenation of their
constituent parts. The input message to be signed is also encoded as a hexadecimal
string.</t>
      <t>Each test vector consists of the following information.</t>
      <ul spacing="normal">
        <li>Configuration. This lists the fixed parameters for the particular instantiation
of FROST, including MAX_PARTICIPANTS, MIN_PARTICIPANTS, and NUM_PARTICIPANTS.</li>
        <li>Group input parameters. This lists the group secret key and shared public key,
generated by a trusted dealer as described in <xref target="dep-dealer"/>, as well as the
input message to be signed. The randomly generated coefficients produced by the
trusted dealer to share the group signing secret are also listed. Each coefficient
is identified by its index, e.g., <tt>share_polynomial_coefficients[1]</tt> is the coefficient
of the first term in the polynomial. Note that the 0-th coefficient is omitted, as this
is equal to the group secret key. All values are encoded as hexadecimal strings.</li>
        <li>Signer input parameters. This lists the signing key share for each of the
NUM_PARTICIPANTS participants.</li>
        <li>Round one parameters and outputs. This lists the NUM_PARTICIPANTS participants engaged
in the protocol, identified by their NonZeroScalar identifier, and the following for each participant: the hiding and binding commitment values produced in <xref target="frost-round-one"/>; the randomness
values used to derive the commitment nonces in <tt>nonce_generate</tt>; the resulting group
binding factor input computed in part from the group commitment list encoded as
described in <xref target="dep-encoding"/>; and the group binding factor as computed in <xref target="frost-round-two"/>.</li>
        <li>Round two parameters and outputs. This lists the NUM_PARTICIPANTS participants engaged
in the protocol, identified by their NonZeroScalar identifier, along with their corresponding
output signature share as produced in <xref target="frost-round-two"/>.</li>
        <li>Final output. This lists the aggregate signature as produced in <xref target="frost-aggregation"/>.</li>
      </ul>
      <section anchor="frosted25519-sha-512-1">
        <name>FROST(Ed25519, SHA-512)</name>

        <sourcecode type="test-vectors"><![CDATA[
// Configuration information
MAX_PARTICIPANTS: 3
MIN_PARTICIPANTS: 2
NUM_PARTICIPANTS: 2

// Group input parameters
participant_list: 1,3
group_secret_key: 7b1c33d3f5291d85de664833beb1ad469f7fb6025a0ec78b3a7
90c6e13a98304
group_public_key: 15d21ccd7ee42959562fc8aa63224c8851fb3ec85a3faf66040
d380fb9738673
message: 74657374
share_polynomial_coefficients[1]: 178199860edd8c62f5212ee91eff1295d0d
670ab4ed4506866bae57e7030b204

// Signer input parameters
P1 participant_share: 929dcc590407aae7d388761cddb0c0db6f5627aea8e217f
4a033f2ec83d93509
P2 participant_share: a91e66e012e4364ac9aaa405fcafd370402d9859f7b6685
c07eed76bf409e80d
P3 participant_share: d3cb090a075eb154e82fdb4b3cb507f110040905468bb9c
46da8bdea643a9a02

// Signer round one outputs
P1 hiding_nonce_randomness: 0fd2e39e111cdc266f6c0f4d0fd45c947761f1f5d
3cb583dfcb9bbaf8d4c9fec
P1 binding_nonce_randomness: 69cd85f631d5f7f2721ed5e40519b1366f340a87
c2f6856363dbdcda348a7501
P1 hiding_nonce: 812d6104142944d5a55924de6d49940956206909f2acaeedecda
2b726e630407
P1 binding_nonce: b1110165fc2334149750b28dd813a39244f315cff14d4e89e61
42f262ed83301
P1 hiding_nonce_commitment: b5aa8ab305882a6fc69cbee9327e5a45e54c08af6
1ae77cb8207be3d2ce13de3
P1 binding_nonce_commitment: 67e98ab55aa310c3120418e5050c9cf76cf387cb
20ac9e4b6fdb6f82a469f932
P1 binding_factor_input: 15d21ccd7ee42959562fc8aa63224c8851fb3ec85a3f
af66040d380fb9738673504df914fa965023fb75c25ded4bb260f417de6d32e5c442c
6ba313791cc9a4948d6273e8d3511f93348ea7a708a9b862bc73ba2a79cfdfe07729a
193751cbc973af46d8ac3440e518d4ce440a0e7d4ad5f62ca8940f32de6d8dc00fc12
c660b817d587d82f856d277ce6473cae6d2f5763f7da2e8b4d799a3f3e725d4522ec7
0100000000000000000000000000000000000000000000000000000000000000
P1 binding_factor: f2cb9d7dd9beff688da6fcc83fa89046b3479417f47f55600b
106760eb3b5603
P3 hiding_nonce_randomness: 86d64a260059e495d0fb4fcc17ea3da7452391baa
494d4b00321098ed2a0062f
P3 binding_nonce_randomness: 13e6b25afb2eba51716a9a7d44130c0dbae0004a
9ef8d7b5550c8a0e07c61775
P3 hiding_nonce: c256de65476204095ebdc01bd11dc10e57b36bc96284595b8215
222374f99c0e
P3 binding_nonce: 243d71944d929063bc51205714ae3c2218bd3451d0214dfb5ae
ec2a90c35180d
P3 hiding_nonce_commitment: cfbdb165bd8aad6eb79deb8d287bcc0ab6658ae57
fdcc98ed12c0669e90aec91
P3 binding_nonce_commitment: 7487bc41a6e712eea2f2af24681b58b1cf1da278
ea11fe4e8b78398965f13552
P3 binding_factor_input: 15d21ccd7ee42959562fc8aa63224c8851fb3ec85a3f
af66040d380fb9738673504df914fa965023fb75c25ded4bb260f417de6d32e5c442c
6ba313791cc9a4948d6273e8d3511f93348ea7a708a9b862bc73ba2a79cfdfe07729a
193751cbc973af46d8ac3440e518d4ce440a0e7d4ad5f62ca8940f32de6d8dc00fc12
c660b817d587d82f856d277ce6473cae6d2f5763f7da2e8b4d799a3f3e725d4522ec7
0300000000000000000000000000000000000000000000000000000000000000
P3 binding_factor: b087686bf35a13f3dc78e780a34b0fe8a77fef1b9938c563f5
573d71d8d7890f

// Signer round two outputs
P1 sig_share: 001719ab5a53ee1a12095cd088fd149702c0720ce5fd2f29dbecf24
b7281b603
P3 sig_share: bd86125de990acc5e1f13781d8e32c03a9bbd4c53539bbc106058bf
d14326007

sig: 36282629c383bb820a88b71cae937d41f2f2adfcc3d02e55507e2fb9e2dd3cbe
bd9d2b0844e49ae0f3fa935161e1419aab7b47d21a37ebeae1f17d4987b3160b
]]></sourcecode>
      </section>
      <section anchor="frosted448-shake256-1">
        <name>FROST(Ed448, SHAKE256)</name>
        <sourcecode type="test-vectors"><![CDATA[
// Configuration information
MAX_PARTICIPANTS: 3
MIN_PARTICIPANTS: 2
NUM_PARTICIPANTS: 2

// Group input parameters
participant_list: 1,3
group_secret_key: 6298e1eef3c379392caaed061ed8a31033c9e9e3420726f23b4
04158a401cd9df24632adfe6b418dc942d8a091817dd8bd70e1c72ba52f3c00
group_public_key: 3832f82fda00ff5365b0376df705675b63d2a93c24c6e81d408
01ba265632be10f443f95968fadb70d10786827f30dc001c8d0f9b7c1d1b000
message: 74657374
share_polynomial_coefficients[1]: dbd7a514f7a731976620f0436bd135fe8dd
dc3fadd6e0d13dbd58a1981e587d377d48e0b7ce4e0092967c5e85884d0275a7a740b
6abdcd0500

// Signer input parameters
P1 participant_share: 4a2b2f5858a932ad3d3b18bd16e76ced3070d72fd79ae44
02df201f525e754716a1bc1b87a502297f2a99d89ea054e0018eb55d39562fd0100
P2 participant_share: 2503d56c4f516444a45b080182b8a2ebbe4d9b2ab509f25
308c88c0ea7ccdc44e2ef4fc4f63403a11b116372438a1e287265cadeff1fcb0700
P3 participant_share: 00db7a8146f995db0a7cf844ed89d8e94c2b5f259378ff6
6e39d172828b264185ac4decf7219e4aa4478285b9c0eef4fccdf3eea69dd980d00

// Signer round one outputs
P1 hiding_nonce_randomness: 9cda90c98863ef3141b75f09375757286b4bc323d
d61aeb45c07de45e4937bbd
P1 binding_nonce_randomness: 781bf4881ffe1aa06f9341a747179f07a49745f8
cd37d4696f226aa065683c0a
P1 hiding_nonce: f922beb51a5ac88d1e862278d89e12c05263b945147db04b9566
acb2b5b0f7422ccea4f9286f4f80e6b646e72143eeaecc0e5988f8b2b93100
P1 binding_nonce: 1890f16a120cdeac092df29955a29c7cf29c13f6f7be60e63d6
3f3824f2d37e9c3a002dfefc232972dc08658a8c37c3ec06a0c5dc146150500
P1 hiding_nonce_commitment: 3518c2246c874569e54ab254cb1da666ca30f7879
605cc43b4d2c47a521f8b5716080ab723d3a0cd04b7e41f3cc1d3031c94ccf3829b23
fe80
P1 binding_nonce_commitment: 11b3d5220c57d02057497de3c4eebab384900206
592d877059b0a5f1d5250d002682f0e22dff096c46bb81b46d60fcfe7752ed47cea76
c3900
P1 binding_factor_input: 3832f82fda00ff5365b0376df705675b63d2a93c24c6
e81d40801ba265632be10f443f95968fadb70d10786827f30dc001c8d0f9b7c1d1b00
0e9a0f30b97fe77ef751b08d4e252a3719ae9135e7f7926f7e3b7dd6656b27089ca35
4997fe5a633aa0946c89f022462e7e9d50fd6ef313f72d956ea4571089427daa1862f
623a41625177d91e4a8f350ce9c8bd3bc7c766515dc1dd3a0eab93777526b616cccb1
48fe1e5992dc1ae705c8ba2f97ca8983328d41d375ed1e5fde5c9d672121c9e8f177f
4a1a9b2575961531b33f054451363c8f27618382cd66ce14ad93b68dac6a09f5edcbc
cc813906b3fc50b8fef1cc09757b06646f38ceed1674cd6ced28a59c93851b325c6a9
ef6a4b3b88860b7138ee246034561c7460db0b3fae501000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000
P1 binding_factor: 71966390dfdbed73cf9b79486f3b70e23b243e6c40638fb559
98642a60109daecbfcb879eed9fe7dbbed8d9e47317715a5740f772173342e00
P3 hiding_nonce_randomness: b3adf97ceea770e703ab295babf311d77e956a20d
3452b4b3344aa89a828e6df
P3 binding_nonce_randomness: 81dbe7742b0920930299197322b255734e52bbb9
1f50cfe8ce689f56fadbce31
P3 hiding_nonce: ccb5c1e82f23e0a4b966b824dbc7b0ef1cc5f56eeac2a4126e2b
2143c5f3a4d890c52d27803abcf94927faf3fc405c0b2123a57a93cefa3b00
P3 binding_nonce: e089df9bf311cf711e2a24ea27af53e07b846d09692fe11035a
1112f04d8b7462a62f34d8c01493a22b57a1cbf1f0a46c77d64d46449a90100
P3 hiding_nonce_commitment: 1254546d7d104c04e4fbcf29e05747e2edd392f67
87d05a6216f3713ef859efe573d180d291e48411e5e3006e9f90ee986ccc26b7a4249
0b80
P3 binding_nonce_commitment: 3ef0cec20be15e56b3ddcb6f7b956fca0c8f7199
0f45316b537b4f64c5e8763e6629d7262ff7cd0235d0781f23be97bf8fa8817643ea1
9cd00
P3 binding_factor_input: 3832f82fda00ff5365b0376df705675b63d2a93c24c6
e81d40801ba265632be10f443f95968fadb70d10786827f30dc001c8d0f9b7c1d1b00
0e9a0f30b97fe77ef751b08d4e252a3719ae9135e7f7926f7e3b7dd6656b27089ca35
4997fe5a633aa0946c89f022462e7e9d50fd6ef313f72d956ea4571089427daa1862f
623a41625177d91e4a8f350ce9c8bd3bc7c766515dc1dd3a0eab93777526b616cccb1
48fe1e5992dc1ae705c8ba2f97ca8983328d41d375ed1e5fde5c9d672121c9e8f177f
4a1a9b2575961531b33f054451363c8f27618382cd66ce14ad93b68dac6a09f5edcbc
cc813906b3fc50b8fef1cc09757b06646f38ceed1674cd6ced28a59c93851b325c6a9
ef6a4b3b88860b7138ee246034561c7460db0b3fae503000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000
P3 binding_factor: 236a6f7239ac2019334bad21323ec93bef2fead37bd5511435
6419f3fc1fb59f797f44079f28b1a64f51dd0a113f90f2c3a1c27d2faa4f1300

// Signer round two outputs
P1 sig_share: e1eb9bfbef792776b7103891032788406c070c5c315e3bf5d64acd4
6ea8855e85b53146150a09149665cbfec71626810b575e6f4dbe9ba3700
P3 sig_share: 815434eb0b9f9242d54b8baf2141fe28976cabe5f441ccfcd5ee7cd
b4b52185b02b99e6de28e2ab086c7764068c5a01b5300986b9f084f3e00

sig: cd642cba59c449dad8e896a78a60e8edfcbd9040df524370891ff8077d47ce72
1d683874483795f0d85efcbd642c4510614328605a19c6ed806ffb773b6956419537c
dfdb2b2a51948733de192dcc4b82dc31580a536db6d435e0cb3ce322fbcf9ec23362d
da27092c08767e607bf2093600
]]></sourcecode>
      </section>
      <section anchor="frostristretto255-sha-512">
        <name>FROST(ristretto255, SHA-512)</name>
        <sourcecode type="test-vectors"><![CDATA[
// Configuration information
MAX_PARTICIPANTS: 3
MIN_PARTICIPANTS: 2
NUM_PARTICIPANTS: 2

// Group input parameters
participant_list: 1,3
group_secret_key: 1b25a55e463cfd15cf14a5d3acc3d15053f08da49c8afcf3ab2
65f2ebc4f970b
group_public_key: e2a62f39eede11269e3bd5a7d97554f5ca384f9f6d3dd9c3c0d
05083c7254f57
message: 74657374
share_polynomial_coefficients[1]: 410f8b744b19325891d73736923525a4f59
6c805d060dfb9c98009d34e3fec02

// Signer input parameters
P1 participant_share: 5c3430d391552f6e60ecdc093ff9f6f4488756aa6cebdba
d75a768010b8f830e
P2 participant_share: b06fc5eac20b4f6e1b271d9df2343d843e1e1fb03c4cbb6
73f2872d459ce6f01
P3 participant_share: f17e505f0e2581c6acfe54d3846a622834b5e7b50cad9a2
109a97ba7a80d5c04

// Signer round one outputs
P1 hiding_nonce_randomness: f595a133b4d95c6e1f79887220c8b275ce6277e7f
68a6640e1e7140f9be2fb5c
P1 binding_nonce_randomness: 34dd1001360e3513cb37bebfabe7be4a32c5bb91
ba19fbd4360d039111f0fbdc
P1 hiding_nonce: 214f2cabb86ed71427ea7ad4283b0fae26b6746c801ce824b83c
eb2b99278c03
P1 binding_nonce: c9b8f5e16770d15603f744f8694c44e335e8faef00dad182b8d
7a34a62552f0c
P1 hiding_nonce_commitment: 965def4d0958398391fc06d8c2d72932608b1e625
5226de4fb8d972dac15fd57
P1 binding_nonce_commitment: ec5170920660820007ae9e1d363936659ef622f9
9879898db86e5bf1d5bf2a14
P1 binding_factor_input: e2a62f39eede11269e3bd5a7d97554f5ca384f9f6d3d
d9c3c0d05083c7254f572889dde2854e26377a16caf77dfee5f6be8fe5b4c80318da8
4698a4161021b033911db5ef8205362701bc9ecd983027814abee94f46d094943a2f4
b79a6e4d4603e52c435d8344554942a0a472d8ad84320585b8da3ae5b9ce31cd1903f
795c1af66de22af1a45f652cd05ee446b1b4091aaccc91e2471cd18a85a659cecd11f
0100000000000000000000000000000000000000000000000000000000000000
P1 binding_factor: 8967fd70fa06a58e5912603317fa94c77626395a695a0e4e4e
fc4476662eba0c
P3 hiding_nonce_randomness: daa0cf42a32617786d390e0c7edfbf2efbd428037
069357b5173ae61d6dd5d5e
P3 binding_nonce_randomness: b4387e72b2e4108ce4168931cc2c7fcce5f345a5
297368952c18b5fc8473f050
P3 hiding_nonce: 3f7927872b0f9051dd98dd73eb2b91494173bbe0feb65a3e7e58
d3e2318fa40f
P3 binding_nonce: ffd79445fb8030f0a3ddd3861aa4b42b618759282bfe24f1f93
04c7009728305
P3 hiding_nonce_commitment: 480e06e3de182bf83489c45d7441879932fd7b434
a26af41455756264fbd5d6e
P3 binding_nonce_commitment: 3064746dfd3c1862ef58fc68c706da287dd92506
6865ceacc816b3a28c7b363b
P3 binding_factor_input: e2a62f39eede11269e3bd5a7d97554f5ca384f9f6d3d
d9c3c0d05083c7254f572889dde2854e26377a16caf77dfee5f6be8fe5b4c80318da8
4698a4161021b033911db5ef8205362701bc9ecd983027814abee94f46d094943a2f4
b79a6e4d4603e52c435d8344554942a0a472d8ad84320585b8da3ae5b9ce31cd1903f
795c1af66de22af1a45f652cd05ee446b1b4091aaccc91e2471cd18a85a659cecd11f
0300000000000000000000000000000000000000000000000000000000000000
P3 binding_factor: f2c1bb7c33a10511158c2f1766a4a5fadf9f86f2a92692ed33
3128277cc31006

// Signer round two outputs
P1 sig_share: 9285f875923ce7e0c491a592e9ea1865ec1b823ead4854b48c8a462
87749ee09
P3 sig_share: 7cb211fe0e3d59d25db6e36b3fb32344794139602a7b24f1ae0dc4e
26ad7b908

sig: fc45655fbc66bbffad654ea4ce5fdae253a49a64ace25d9adb62010dd9fb2555
2164141787162e5b4cab915b4aa45d94655dbb9ed7c378a53b980a0be220a802
]]></sourcecode>
      </section>
      <section anchor="frostp-256-sha-256-1">
        <name>FROST(P-256, SHA-256)</name>
        <sourcecode type="test-vectors"><![CDATA[
// Configuration information
MAX_PARTICIPANTS: 3
MIN_PARTICIPANTS: 2
NUM_PARTICIPANTS: 2

// Group input parameters
participant_list: 1,3
group_secret_key: 8ba9bba2e0fd8c4767154d35a0b7562244a4aaf6f36c8fb8735
fa48b301bd8de
group_public_key: 023a309ad94e9fe8a7ba45dfc58f38bf091959d3c99cfbd02b4
dc00585ec45ab70
message: 74657374
share_polynomial_coefficients[1]: 80f25e6c0709353e46bfbe882a11bdbb1f8
097e46340eb8673b7e14556e6c3a4

// Signer input parameters
P1 participant_share: 0c9c1a0fe806c184add50bbdcac913dda73e482daf95dcb
9f35dbb0d8a9f7731
P2 participant_share: 8d8e787bef0ff6c2f494ca45f4dad198c6bee01212d6c84
067159c52e1863ad5
P3 participant_share: 0e80d6e8f6192c003b5488ce1eec8f5429587d48cf00154
1e713b2d53c09d928

// Signer round one outputs
P1 hiding_nonce_randomness: ec4c891c85fee802a9d757a67d1252e7f4e5efb8a
538991ac18fbd0e06fb6fd3
P1 binding_nonce_randomness: 9334e29d09061223f69a09421715a347e4e6deba
77444c8f42b0c833f80f4ef9
P1 hiding_nonce: 9f0542a5ba879a58f255c09f06da7102ef6a2dec6279700c656d
58394d8facd4
P1 binding_nonce: 6513dfe7429aa2fc972c69bb495b27118c45bbc6e654bb9dc9b
e55385b55c0d7
P1 hiding_nonce_commitment: 0213b3e6298bf8ad46fd5e9389519a8665d63d98f
4ec6a1fcca434e809d2d8070e
P1 binding_nonce_commitment: 02188ff1390bf69374d7b272e454b1878ef10a6b
6ea3ff36f114b300b4dbd5233b
P1 binding_factor_input: 023a309ad94e9fe8a7ba45dfc58f38bf091959d3c99c
fbd02b4dc00585ec45ab70825371853e974bc30ac5b947b216d70461919666584c70c
51f9f56f117736c5d178dd0b521ad9c1abe98048419cbdec81504c85e12eb40e3bcb6
ec73d3fc4afd000000000000000000000000000000000000000000000000000000000
0000001
P1 binding_factor: 7925f0d4693f204e6e59233e92227c7124664a99739d2c06b8
1cf64ddf90559e
P3 hiding_nonce_randomness: c0451c5a0a5480d6c1f860e5db7d655233dca2669
fd90ff048454b8ce983367b
P3 binding_nonce_randomness: 2ba5f7793ae700e40e78937a82f407dd35e847e3
3d1e607b5c7eb6ed2a8ed799
P3 hiding_nonce: f73444a8972bcda9e506bbca3d2b1c083c10facdf4bb5d47fef7
c2dc1d9f2a0d
P3 binding_nonce: 44c6a29075d6e7e4f8b97796205f9e22062e7835141470afe94
17fd317c1c303
P3 hiding_nonce_commitment: 033ac9a5fe4a8b57316ba1c34e8a6de453033b750
e8984924a984eb67a11e73a3f
P3 binding_nonce_commitment: 03a7a2480ee16199262e648aea3acab628a53e9b
8c1945078f2ddfbdc98b7df369
P3 binding_factor_input: 023a309ad94e9fe8a7ba45dfc58f38bf091959d3c99c
fbd02b4dc00585ec45ab70825371853e974bc30ac5b947b216d70461919666584c70c
51f9f56f117736c5d178dd0b521ad9c1abe98048419cbdec81504c85e12eb40e3bcb6
ec73d3fc4afd000000000000000000000000000000000000000000000000000000000
0000003
P3 binding_factor: e10d24a8a403723bcb6f9bb4c537f316593683b472f7a89f16
6630dde11822c4

// Signer round two outputs
P1 sig_share: 400308eaed7a2ddee02a265abe6a1cfe04d946ee8720768899619cf
abe7a3aeb
P3 sig_share: 561da3c179edbb0502d941bb3e3ace3c37d122aaa46fb54499f15f3
a3331de44

sig: 026d8d434874f87bdb7bc0dfd239b2c00639044f9dcb195e9a04426f70bfa4b7
0d9620acac6767e8e3e3036815fca4eb3a3caa69992b902bcd3352fc34f1ac192f
]]></sourcecode>
      </section>
      <section anchor="frostsecp256k1-sha-256-1">
        <name>FROST(secp256k1, SHA-256)</name>
        <sourcecode type="test-vectors"><![CDATA[
// Configuration information
MAX_PARTICIPANTS: 3
MIN_PARTICIPANTS: 2
NUM_PARTICIPANTS: 2

// Group input parameters
participant_list: 1,3
group_secret_key: 0d004150d27c3bf2a42f312683d35fac7394b1e9e318249c1bf
e7f0795a83114
group_public_key: 02f37c34b66ced1fb51c34a90bdae006901f10625cc06c4f646
63b0eae87d87b4f
message: 74657374
share_polynomial_coefficients[1]: fbf85eadae3058ea14f19148bb72b45e439
9c0b16028acaf0395c9b03c823579

// Signer input parameters
P1 participant_share: 08f89ffe80ac94dcb920c26f3f46140bfc7f95b493f8310
f5fc1ea2b01f4254c
P2 participant_share: 04f0feac2edcedc6ce1253b7fab8c86b856a797f44d83d8
2a385554e6e401984
P3 participant_share: 00e95d59dd0d46b0e303e500b62b7ccb0e555d49f5b849f
5e748c071da8c0dbc

// Signer round one outputs
P1 hiding_nonce_randomness: 7ea5ed09af19f6ff21040c07ec2d2adbd35b759da
5a401d4c99dd26b82391cb2
P1 binding_nonce_randomness: 47acab018f116020c10cb9b9abdc7ac10aae1b48
ca6e36dc15acb6ec9be5cdc5
P1 hiding_nonce: 841d3a6450d7580b4da83c8e618414d0f024391f2aeb511d7579
224420aa81f0
P1 binding_nonce: 8d2624f532af631377f33cf44b5ac5f849067cae2eacb88680a
31e77c79b5a80
P1 hiding_nonce_commitment: 03c699af97d26bb4d3f05232ec5e1938c12f1e6ae
97643c8f8f11c9820303f1904
P1 binding_nonce_commitment: 02fa2aaccd51b948c9dc1a325d77226e98a5a3fe
65fe9ba213761a60123040a45e
P1 binding_factor_input: 02f37c34b66ced1fb51c34a90bdae006901f10625cc0
6c4f64663b0eae87d87b4fff9b5210ffbb3c07a73a7c8935be4a8c62cf015f6cf7ade
6efac09a6513540fc3f5a816aaebc2114a811a415d7a55db7c5cbc1cf27183e79dd9d
ef941b5d4801000000000000000000000000000000000000000000000000000000000
0000001
P1 binding_factor: 3e08fe561e075c653cbfd46908a10e7637c70c74f0a77d5fd4
5d1a750c739ec6
P3 hiding_nonce_randomness: e6cc56ccbd0502b3f6f831d91e2ebd01c4de0479e
0191b66895a4ffd9b68d544
P3 binding_nonce_randomness: 7203d55eb82a5ca0d7d83674541ab55f6e76f1b8
5391d2c13706a89a064fd5b9
P3 hiding_nonce: 2b19b13f193f4ce83a399362a90cdc1e0ddcd83e57089a7af0bd
ca71d47869b2
P3 binding_nonce: 7a443bde83dc63ef52dda354005225ba0e553243402a4705ce2
8ffaafe0f5b98
P3 hiding_nonce_commitment: 03077507ba327fc074d2793955ef3410ee3f03b82
b4cdc2370f71d865beb926ef6
P3 binding_nonce_commitment: 02ad53031ddfbbacfc5fbda3d3b0c2445c8e3e99
cbc4ca2db2aa283fa68525b135
P3 binding_factor_input: 02f37c34b66ced1fb51c34a90bdae006901f10625cc0
6c4f64663b0eae87d87b4fff9b5210ffbb3c07a73a7c8935be4a8c62cf015f6cf7ade
6efac09a6513540fc3f5a816aaebc2114a811a415d7a55db7c5cbc1cf27183e79dd9d
ef941b5d4801000000000000000000000000000000000000000000000000000000000
0000003
P3 binding_factor: 93f79041bb3fd266105be251adaeb5fd7f8b104fb554a4ba9a
0becea48ddbfd7

// Signer round two outputs
P1 sig_share: c4fce1775a1e141fb579944166eab0d65eefe7b98d480a569bbbfcb
14f91c197
P3 sig_share: 0160fd0d388932f4826d2ebcd6b9eaba734f7c71cf25b4279a4ca25
81e47b18d

sig: 0205b6d04d3774c8929413e3c76024d54149c372d57aae62574ed74319b5ea14
d0c65dde8492a7471437e6c2fe3da49b90d23f642b5c6dbe7e36089f096dd97324
]]></sourcecode>
      </section>
    </section>
<section anchor="acknowledgments" numbered="false">
      <name>Acknowledgments</name>
      <t>This document was improved based on input and contributions by the
      Zcash Foundation engineering team.  In addition, the authors of this
      document would like to thank <contact fullname="Isis Lovecruft"/>,
      <contact fullname="Alden Torres"/>, <contact
      fullname="T. Wilson-Brown"/>, and <contact fullname="Conrado Gouvea"/>
      for their input and contributions.</t>
    </section>
  </back>
</rfc>
