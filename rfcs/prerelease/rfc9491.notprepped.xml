<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>

<rfc xmlns:xi="http://www.w3.org/2001/XInclude" submissionType="IETF" category="std" consensus="yes" docName="draft-ietf-spring-nsh-sr-15" number="9491" ipr="trust200902" obsoletes="" updates="" xml:lang="en" tocInclude="true" tocDepth="3" symRefs="true" sortRefs="true" version="3">

  <front>
    <title abbrev="NSH SR SFC">Integration of the Network Service Header (NSH)
    and Segment Routing for Service Function Chaining (SFC)</title>
<seriesInfo name="RFC" value="9491"/>
    <author fullname="James N Guichard" initials="J" surname="Guichard" role="editor">
      <organization>Futurewei Technologies</organization>
      <address>
        <postal>
          <street>2330 Central Expressway</street>
          <city>Santa Clara</city>
	  <region>CA</region>
          <country>United States of America</country>
        </postal>
        <email>james.n.guichard@futurewei.com</email>
      </address>
    </author>
    <author fullname="Jeff Tantsura" initials="J" surname="Tantsura" role="editor">
      <organization>Nvidia</organization>
      <address>
        <postal>
          <street/>
          <city/>
          <country>United States of America</country>
        </postal>
        <email>jefftant.ietf@gmail.com</email>
      </address>
    </author>
    <date month="November" year="2023"/>
    <area>RTG</area>
    <workgroup>SPRING</workgroup>
    <keyword>NSH</keyword>
    <keyword>SR</keyword>
    <keyword>MPLS-SR</keyword>
    <keyword>SRv6</keyword>
    <keyword>SFC</keyword>
    <abstract>
      <t> This document describes the integration of the Network Service
      Header (NSH) and Segment Routing (SR), as well as encapsulation details,
      to efficiently support Service Function Chaining (SFC) while maintaining
      separation of the service and transport planes as originally intended by
      the SFC architecture.
      </t>      
      <t> Combining these technologies allows SR to be used for steering
      packets between Service Function Forwarders (SFFs) along a given Service
      Function Path (SFP), whereas the NSH is responsible for maintaining the
      integrity of the service plane, the SFC instance context, and any
      associated metadata.
      </t>
      <t> This integration demonstrates that the NSH and SR can work cooperatively
      and provide a network operator with the flexibility to use whichever
      transport technology makes sense in specific areas of their network
      infrastructure while still maintaining an end-to-end service plane using
      the NSH.
      </t>
    </abstract>
  </front>
  <middle>
    <section numbered="true" toc="default">
      <name>Introduction</name>
      <t>

      </t>
      <section numbered="true" toc="default">
        <name>SFC Overview and Rationale</name>
        <t> The dynamic enforcement of a service-derived and adequate
        forwarding policy for packets entering a network that supports
        advanced Service Functions (SFs) has become a key challenge for
        network operators. For instance, cascading SFs at the Third
        Generation Partnership Project (3GPP) Gi interface (N6 interface in 5G
        architecture) has shown limitations such as 1) redundant
        classification features that must be supported by many SFs to execute
        their function; 2) some SFs that receive traffic that they are not supposed
        to process (e.g., TCP proxies receiving UDP traffic), which inevitably
        affects their dimensioning and performance; and 3) an increased design
        complexity related to the properly ordered invocation of several SFs.
        </t>
        <t> In order to solve those problems and to decouple the service's
        topology from the underlying physical network while allowing for
        simplified service delivery, SFC techniques have been introduced <xref
        target="RFC7665" format="default"/>.
        </t>
        <t> SFC techniques are meant to rationalize the service delivery logic
        and reduce the resulting complexity while optimizing service
        activation time cycles for operators that need more agile service
        delivery procedures to better accommodate ever-demanding customer
        requirements. SFC allows network operators to dynamically create
        service planes that can be used by specific traffic flows. Each
        service plane is realized by invoking and chaining the relevant
        service functions in the right sequence.  <xref target="RFC7498"
        format="default"/> provides an overview of the overall SFC problem
        space, and <xref target="RFC7665" format="default"/> specifies an SFC
        data plane architecture.  The SFC architecture does not make
        assumptions on how advanced features (e.g., load balancing, loose or strict
        service paths) could be enabled within a domain. Various
        deployment options are made available to operators with the SFC
        architecture; this approach is fundamental to accommodate various
        and heterogeneous deployment contexts.
        </t>
        <t>Many approaches can be considered for encoding the information
        required for SFC purposes (e.g., communicate a service chain pointer,
        encode a list of loose/explicit paths, or disseminate a service chain
        identifier together with a set of context information). Likewise, many
        approaches can also be considered for the channel to be used to carry
        SFC-specific information (e.g., define a new header, reuse existing
        packet header fields, or define an IPv6 extension header). Among all
        these approaches, the IETF created a transport-independent SFC
        encapsulation scheme: NSH <xref target="RFC8300"
        format="default"/>. This design is pragmatic, as it does not require
        replicating the same specification effort as a function of underlying
        transport encapsulation. Moreover, this design approach encourages
        consistent SFC-based service delivery in networks enabling distinct
        transport protocols in various network segments or even between SFFs
        vs. SF-SFF hops.
        </t>
      </section>
      <section numbered="true" toc="default">
        <name>Requirements Language</name>
        <t> The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>",
        "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL
        NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>",
        "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
        "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document
        are to be interpreted as described in BCP&nbsp;14 <xref
        target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they
        appear in all capitals, as shown here.
        </t>
      </section>
    </section>
    <section numbered="true" toc="default">
      <name>SFC within Segment Routing Networks</name>
      <t><xref target="RFC8300" format="default"/> specifies how to
      encapsulate the NSH directly within a link-layer header. In this
      document, IANA has assigned IP protocol number 145 for the NSH so that it
      can also be encapsulated directly within an IP header. The procedures
      that follow make use of this property.
      </t>
      <t>As described in <xref target="RFC8402" format="default"/>, SR
      leverages the source-routing technique. Concretely, a node steers a
      packet through an SR policy instantiated as an ordered list of
      instructions called segments. While initially designed for policy-based
      source routing, SR also finds its application in supporting SFC <xref
      target="I-D.ietf-spring-sr-service-programming" format="default"/>.
      </t>
      <t> The two SR data plane encapsulations, namely <xref target="RFC8660"
      format="default">SR-MPLS</xref> and <xref target="RFC8754"
      format="default">Segment Routing over IPv6 (SRv6)</xref>, can encode an
      SF as a segment so that a service function chain can be specified as a segment
      list. Nevertheless, and as discussed in <xref target="RFC7498"
      format="default"/>, traffic steering is only a subset of the issues that
      motivated the design of the SFC architecture. Further considerations,
      such as simplifying classification at intermediate SFs and allowing for
      coordinated behaviors among SFs by means of supplying context
      information (a.k.a. metadata), should be considered when designing an
      SFC data plane solution.
      </t>
      <t>While each scheme (i.e., NSH-based SFC and SR-based SFC) can work
      independently, this document describes how the two can be used together
      in concert and to complement each other through two representative
      application scenarios. Both application scenarios may be supported using
      either SR-MPLS or SRv6:
      </t>
      <dl spacing="normal" newline="true">
        <dt>NSH-based SFC with the SR-based transport plane:</dt>
	<dd>In this scenario, SR-MPLS or SRv6 provides the transport
	encapsulation between SFFs, while the NSH is used to convey and trigger SFC
	policies.</dd>
        <dt>SR-based SFC with the integrated NSH service plane:</dt>
	<dd>In this scenario, each service hop of the service function chain
	is represented as a segment of the SR segment list. SR is thus
	responsible for steering traffic through the necessary SFFs as part of
	the segment routing path, while the NSH is responsible for maintaining
	the service plane and holding the SFC instance context (including
	associated metadata).</dd>
      </dl>
      <t>Of course, it is possible to combine both of these two scenarios to
      support specific deployment requirements and use cases.		
      </t>      
      <t>A classifier <bcp14>MUST</bcp14> use one NSH Service Path Identifier
      (SPI) for each SR policy so that different traffic flows can use the
      same NSH Service Function Path (SFP) and different SR policies can
      coexist on the same SFP without conflict during SFF processing.</t>
    </section>
    <section numbered="true" toc="default">
      <name>NSH-Based SFC with SR-MPLS or the SRv6 Transport Tunnel</name>
      <t>Because of the transport-independent nature of NSH-based service
      function chains, it is expected that the NSH has broad applicability
      across different network domains (e.g., access, core).  By way of
      illustration, the various SFs involved in a service function chain may be
      available in a single data center or spread throughout multiple
      locations (e.g., data centers, different Points of Presence (POPs)),
      depending upon the network operator preference and/or availability of
      service resources. Regardless of where the SFs are deployed, it is
      necessary to provide traffic steering through a set of SFFs, and when
      NSH and SR are integrated, this is provided by SR-MPLS or SRv6.</t>
      <t>The following three figures provide an example of an SFC-established
      flow F that has SF instances located in different data centers, DC1 and
      DC2. For the purpose of illustration, let the SFC's NSH SPI be 100 and
      the initial Service Index (SI) be 255.
      </t>
      <t>Referring to <xref target="figure_1" format="default"/>, packets of
      flow F in DC1 are classified into an NSH-based service function chain,
      encapsulated after classification as &lt;Inner Pkt&gt;&lt;NSH: SPI 100,
      SI 255&gt;&lt;Outer-transport&gt;, and forwarded to SFF1 (which is the
      first SFF hop for this service function chain).</t>
      <t>After removing the outer transport encapsulation, SFF1 uses the SPI
      and SI carried within the NSH encapsulation to determine that it should
      forward the packet to SF1. SF1 applies its service, decrements the SI by
      1, and returns the packet to SFF1. Therefore, SFF1 has &lt;SPI 100, SI
      254&gt; when the packet comes back from SF1. SFF1 does a lookup on
      &lt;SPI 100, SI 254&gt;, which results in &lt;next-hop: DC1-GW1&gt; and
      forwards the packet to DC1-GW1.
      </t>
      <figure anchor="figure_1">
        <name>SR for Inter-DC SFC - Part 1</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
+--------------------------- DC1 ----------------------------+
|                          +-----+                           |
|                          | SF1 |                           |
|                          +--+--+                           |
|                             |                              |
|                             |                              |
|        +------------+       |    +------------+            |
|        | N(100,255) |       |    | N(100,254) |            |
|        +------------+       |    +------------+            |
|        | F:Inner Pkt|       |    | F:Inner Pkt|            |
|        +------------+  ^    |  | +------------+            |      
|                    (2) |    |  | (3)                       |
|                        |    |  v                           |
|                  (1)        |         (4)                  |
|+------------+   ---->    +--+---+    ---->     +---------+ |
||            |    NSH     |      |     NSH      |         | |
|| Classifier +------------+ SFF1 +--------------+ DC1-GW1 + |
||            |            |      |              |         | |
|+------------+            +------+              +---------+ |
|                                                            |
|             +------------+       +------------+            |
|             | N(100,255) |       | N(100,254) |            |
|             +------------+       +------------+            |
|             | F:Inner Pkt|       | F:Inner Pkt|            |
|             +------------+       +------------+            |
|                                                            |
+------------------------------------------------------------+
]]></artwork></figure>
      <t> Referring now to <xref target="figure_2" format="default"/>, DC1-GW1
      performs a lookup using the information conveyed in the NSH, which
      results in &lt;next-hop: DC2-GW1, encapsulation: SR&gt;.  The SR
      encapsulation, which may be SR-MPLS or SRv6, has the SR segment list to
      forward the packet across the inter-DC network to DC2.
      </t>
      <figure anchor="figure_2">
        <name>SR for Inter-DC SFC - Part 2</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
                  +----------- Inter DC ----------------+
           (4)    |                (5)                  |
+------+  ---->   | +---------+   ---->     +---------+ |
|      |   NSH    | |         |     SR      |         | |
+ SFF1 +----------|-+ DC1-GW1 +-------------+ DC2-GW1 + |
|      |          | |         |             |         | |
+------+          | +---------+             +---------+ |
                  |                                     |
                  |          +------------+             |
                  |          | S(DC2-GW1) |             |
                  |          +------------+             |
                  |          | N(100,254) |             |
                  |          +------------+             |
                  |          | F:Inner Pkt|             |
                  |          +------------+             |
                  +-------------------------------------+
]]></artwork>
      </figure>
      <t> When the packet arrives at DC2, as shown in <xref target="figure_3"
      format="default"/>, the SR encapsulation is removed, and DC2-GW1
      performs a lookup on the NSH, which results in next hop: SFF2. When SFF2
      receives the packet, it performs a lookup on &lt;NSH: SPI 100, SI
      254&gt; and determines to forward the packet to SF2. SF2 applies its
      service, decrements the SI by 1, and returns the packet to
      SFF2. Therefore, SFF2 has &lt;NSH: SPI 100, SI 253&gt; when the packet
      comes back from SF2.  SFF2 does a lookup on &lt;NSH: SPI 100, SI
      253&gt;, which results in the end of the service function chain.
      </t>
      <figure anchor="figure_3">
        <name>SR for Inter-DC SFC - Part 3</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
                   +------------------------ DC2 ----------------------+ 
                   |                         +-----+                   |
                   |                         | SF2 |                   |
                   |                         +--+--+                   |
                   |                            |                      |
                   |                            |                      |
                   |        +------------+      |    +------------+    |
                   |        | N(100,254) |      |    | N(100,253) |    |
                   |        +------------+      |    +------------+    |
                   |        | F:Inner Pkt|      |    | F:Inner Pkt|    |
                   |        +------------+  ^   |  | +------------+    |
                   |                    (7) |   |  | (8)               |
                   |                        |   |  v                   |
             (5)   |                 (6)        |     (9)              |
+---------+  --->  | +----------+   ---->    +--+---+ ---->            |
|         |   SR   | |          |    NSH     |      |  IP              |
+ DC1-GW1 +--------|-+ DC2-GW1  +------------+ SFF2 |                  |
|         |        | |          |            |      |                  |
+---------+        | +----------+            +------+                  |
                   |                                                   |
                   |           +------------+      +------------+      |
                   |           | N(100,254) |      | F:Inner Pkt|      |
                   |           +------------+      +------------+      |
                   |           | F:Inner Pkt|                          |
                   |           +------------+                          |
                   +---------------------------------------------------+
]]></artwork>
      </figure>
      <t>				
				
				
				The benefits of this scheme are listed hereafter:
      </t>
      <ul spacing="normal">
        <li>The network operator is able to take advantage of the
        transport-independent nature of the NSH encapsulation while the
        service is provisioned end-to-end.</li>
        <li>The network operator is able to take advantage of the
        traffic-steering (traffic-engineering) capability of SR where
        appropriate.</li>
        <li>Clear responsibility division and scope between the NSH and SR.</li>
      </ul>
      <t>Note that this scenario is applicable to any case where multiple
      segments of a service function chain are distributed across multiple
      domains or where traffic-engineered paths are necessary between SFFs
      (strict forwarding paths, for example). Further, note that the above
      example can also be implemented using end-to-end segment routing between
      SFF1 and SFF2. (As such, DC-GW1 and DC-GW2 are forwarding the packets
      based on segment routing instructions and are not looking at the NSH
      header for forwarding.)
      </t>
    </section>
    <section numbered="true" toc="default">
      <name>SR-Based SFC with the Integrated NSH Service Plane</name>
      <t>In this scenario, we assume that the SFs are NSH-aware; therefore,
      it should not be necessary to implement an SFC proxy to achieve SFC.
      The operation relies upon SR-MPLS or SRv6 to perform SFF-SFF transport
      and the NSH to provide the service plane between SFs, thereby maintaining SFC
      context (e.g., the service plane path referenced by the SPI) and any
      associated metadata.
      </t>
      <t>When a service function chain is established, a packet associated
      with that chain will first carry an NSH that will be used to maintain
      the end-to-end service plane through use of the SFC context.  The SFC
      context is used by an SFF to determine the SR segment list for
      forwarding the packet to the next-hop SFFs.  The packet is then
      encapsulated using the SR header and forwarded in the SR domain
      following normal SR operations.
      </t>
      <t>When a packet has to be forwarded to an SF attached to an SFF, the
      SFF performs a lookup on the segment identifier (SID) associated with
      the SF. In the case of SR-MPLS, this will be a Prefix-SID <xref
      target="RFC8402" format="default"/>. In the case of SRv6, the behavior
      described within this document is assigned the name END.NSH, and <xref
      target="NSHEPB"/> describes the allocation of the code point by IANA. The
      result of this lookup allows the SFF to retrieve the next-hop context
      between the SFF and SF (e.g., the destination Media Access Control (MAC)
      address in case Ethernet encapsulation is used between the SFF and SF). In
      addition, the SFF strips the SR information from the packet, updates the
      SR information, and saves it to a cache indexed by the NSH Service Path
      Identifier (SPI) and the Service Index (SI) decremented by 1. This saved
      SR information is used to encapsulate and forward the packet(s) coming
      back from the SF.
      </t>
      <t>The behavior of remembering the SR segment list occurs at the end of
      the regularly defined logic. The behavior of reattaching the
      segment list occurs before the SR process of forwarding the packet to
      the next entry in the segment list. Both behaviors are further detailed
      in <xref target="sec-5"/>.
      </t>
      <t>When the SF receives the packet, it processes it as usual. When the
      SF is co-resident with a classifier, the already-processed packet may be
      reclassified. The SF sends the packet back to the SFF. Once the SFF
      receives this packet, it extracts the SR information using the NSH SPI
      and SI as the index into the cache. The SFF then pushes the retrieved SR
      header on top of the NSH header and forwards the packet to the next
      segment in the segment list. The lookup in the SFF cache might fail if
      reclassification at the SF changed the NSH SPI and/or SI to values that
      do not exist in the SFF cache. In such a case, the SFF must generate an
      error and drop the packet.
      </t>
      <t> <xref target="figure_4" format="default"/> illustrates an example of
      this scenario.  </t>
      <figure anchor="figure_4">
        <name>NSH over SR for SFC</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
                        +-----+                       +-----+
                        | SF1 |                       | SF2 |
                        +--+--+                       +--+--+
                           |                             |
                           |                             |
             +-----------+ | +-----------+ +-----------+ | +-----------+
             |N(100,255) | | |N(100,254) | |N(100,254) | | |N(100,253) |
             +-----------+ | +-----------+ +-----------+ | +-----------+
             |F:Inner Pkt| | |F:Inner Pkt| |F:Inner Pkt| | |F:Inner Pkt|
             +-----------+ | +-----------+ +-----------+ | +-----------+
                     (2) ^ | (3) |                 (5) ^ | (6) |
                         | |     |                     | |     |
                         | |     |                     | |     |
                 (1)     | |     v      (4)            | |     v (7)
+------------+   --->    +-+----+      ---->          +---+--+   -->
|            | NSHoverSR |      |    NSHoverSR        |      |    IP
| Classifier +-----------+ SFF1 +---------------------+ SFF2 |
|            |           |      |                     |      |
+------------+           +------+                     +------+

             +------------+        +------------+        +------------+
             |   S(SF1)   |        |   S(SF2)   |        | F:Inner Pkt|
             +------------+        +------------+        +------------+
             |   S(SFF2)  |        | N(100,254) |
             +------------+        +------------+
             |   S(SF2)   |        | F:Inner Pkt|
             +------------+        +------------+
             | N(100,255) |
             +------------+
             | F:Inner Pkt|
             +------------+
]]></artwork>
      </figure>
      <t>The benefits of this scheme include the following:
      </t>
      <ul spacing="normal">
        <li>It is economically sound for SF vendors to only support one
        unified SFC solution. The SF is unaware of the SR.</li>
        <li>It simplifies the SFF (i.e., the SR router) by nullifying the
        needs for reclassification and SR proxy.</li>
        <li>SR is also used for forwarding purposes, including between SFFs.</li>
        <li>It takes advantage of SR to eliminate the NSH forwarding state in
        SFFs. This applies each time strict or loose SFPs are in use.</li>
        <li>It requires no interworking, as would be the case if SR-MPLS-based
        SFC and NSH-based SFC were deployed as independent mechanisms in
        different parts of the network.</li>
      </ul>
    </section>
    <section numbered="true" toc="default" anchor="sec-5">
      <name>Packet Processing for SR-Based SFC</name>
      <t> This section describes the End.NSH behavior (SRv6), Prefix-SID
      behavior (SR-MPLS), and NSH processing logic.</t>
      <section numbered="true" toc="default">
        <name>SR-Based SFC (SR-MPLS) Packet Processing</name>
        <t> When an SFF receives a packet destined to S and S is a local
        Prefix-SID associated with an SF, the SFF strips the SR segment list
        (label stack) from the packet, updates the SR information, and saves
        it to a cache indexed by the NSH Service Path Identifier (SPI) and the
        Service Index (SI) decremented by 1. This saved SR information is used
        to re-encapsulate and forward the packet(s) coming back from the
        SF.</t>
      </section>
      <section numbered="true" toc="default">
        <name>SR-Based SFC (SRv6) Packet Processing</name>
        <t> This section describes the End.NSH behavior and NSH processing
        logic for SRv6. The pseudocode is shown below.</t>
        <t> When N receives a packet destined to S and S is a local End.NSH
        SID, the processing is the same as that specified by <xref
        target="RFC8754" sectionFormat="comma" section="4.3.1.1"/>, up through
        line S15.</t>
        <t> After S15, if S is a local End.NSH SID, then:</t>

	<sourcecode type="pseudocode"><![CDATA[
S15.1.         Remove and store IPv6 and SRH headers in local cache
               indexed by <NSH: service-path-id, service-index -1>
S15.2.         Submit the packet to the NSH FIB lookup and transmit
               to the destination associated with <NSH:
               service-path-id, service-index>
	       ]]></sourcecode>

          <aside><t>Note: The End.NSH behavior interrupts the normal SRH packet
          processing, as described in <xref target="RFC8754"
          sectionFormat="comma" section="4.3.1.1"/>, which does not continue
          to S16 at this time.</t></aside>
          <t> When a packet is returned to the SFF from the SF, reattach the
          cached IPv6 and SRH headers based on the &lt;NSH: service-path-id,
          service-index&gt; from the NSH header.  Then, resume processing from
          <xref target="RFC8754" sectionFormat="comma" section="4.3.1.1"/>
          with line S16.</t>
      </section>
    </section>
    <section anchor="Encapsulation" numbered="true" toc="default">
      <name>Encapsulation</name>
      <t>
				
      </t>
      <section anchor="MPLS-SR" numbered="true" toc="default">
        <name>NSH Using SR-MPLS Transport</name>
        <t> SR-MPLS instantiates segment identifiers (SIDs) as MPLS labels;
        therefore, the segment routing header is a stack of MPLS labels.
        </t>
        <t> When carrying an NSH within an SR-MPLS transport, the full
        encapsulation headers are as illustrated in <xref target="figure_5"
        format="default"/>.
        </t>
        <figure anchor="figure_5">
          <name>NSH Using SR-MPLS Transport</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
		       +------------------+
		       ~   SR-MPLS Labels ~
		       +------------------+
		       |   NSH Base Hdr   |
		       +------------------+
		       | Service Path Hdr |
		       +------------------+
		       ~     Metadata     ~
		       +------------------+
]]></artwork>
        </figure>
        <t>As described in <xref target="RFC8402" format="default"/>,
        "[t]he IGP signaling extension for IGP-Prefix segment includes a flag to
        indicate whether directly connected neighbors of the node on which the
        prefix is attached should perform the NEXT operation or the CONTINUE
        operation when processing the SID." When an NSH is carried beneath
        SR-MPLS, it is necessary to terminate the NSH-based SFC at the tail-end
        node of the SR-MPLS label stack. This can be achieved using either the
        NEXT or CONTINUE operation.
        </t>
        <t> If the NEXT operation is to be used, then at the end of the
        SR-MPLS path, it is necessary to provide an indication to the tail end
        that the NSH follows the SR-MPLS label stack as described by <xref
        target="RFC8596" format="default"/>.
        </t>
        <t> If the CONTINUE operation is to be used, this is the equivalent of
        MPLS Ultimate Hop Popping (UHP); therefore, it is necessary to
        ensure that the penultimate hop node does not pop the top label of the
        SR-MPLS label stack and thereby expose the NSH to the wrong SFF. This is
        realized by setting the No Penultimate Hop Popping (No-PHP) flag in
        Prefix-SID Sub-TLV <xref target="RFC8667" format="default"/> <xref
        target="RFC8665" format="default"/>. It is <bcp14>RECOMMENDED</bcp14>
        that a specific Prefix-SID be allocated at each node for use by the
        SFC application for this purpose.
        </t>
      </section>
      <section anchor="SRv6" numbered="true" toc="default">
        <name>NSH Using SRv6 Transport</name>
        <t>When carrying a NSH within an SRv6 transport, the full encapsulation
        is as illustrated in <xref target="figure_6" format="default"/>.
        </t>
        <figure anchor="figure_6">
          <name>NSH Using SRv6 Transport</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Next Header   |  Hdr Ext Len  | Routing Type  | Segments Left |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Last Entry   |     Flags     |              Tag              | S
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ e
|                                                               | g
|            Segment List[0] (128-bit IPv6 address)             | m
|                                                               | e
|                                                               | n
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ t
|                                                               |
|                                                               | R
~                              ...                              ~ o
|                                                               | u
|                                                               | t
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ i
|                                                               | n
|            Segment List[n] (128-bit IPv6 address)             | g
|                                                               |
|                                                               | S
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ R
//                                                             // H
//         Optional Type Length Value objects (variable)       //
//                                                             //
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Ver|O|U|    TTL    |   Length  |U|U|U|U|MD Type| Next Protocol |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ N
|          Service Path Identifier              | Service Index | S
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ H
|                                                               |
~              Variable-Length Context Headers  (opt.)          ~
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
        </figure>
        <t>Encapsulation of the NSH following SRv6 is indicated by the IP protocol
        number for the NSH in the Next Header of the SRH.</t>
      </section>
    </section>
    <section anchor="Security" numbered="true" toc="default">
      <name>Security Considerations</name>
      <t>
				Generic SFC-related security considerations are discussed in <xref target="RFC7665" format="default"/>.</t>
      <t>
				NSH-specific security considerations are discussed in <xref target="RFC8300" format="default"/>.</t>
      <t> Generic security considerations related to segment routing are
      discussed in <xref target="RFC8754" sectionFormat="of" section="7"/> and
      <xref target="RFC8663" sectionFormat="of" section="5"/>.
 
      </t>
    </section>
    <section numbered="true" toc="default">
      <name>Backwards Compatibility</name>
      <t>For SRv6/IPv6, if a processing node does not recognize the NSH, it should
      follow the procedures described in <xref target="RFC8200"
      sectionFormat="of" section="4"/>. For SR-MPLS, if a processing node does
      not recognize the NSH, it should follow the procedures laid out in <xref
      target="RFC3031" sectionFormat="of" section="3.18"/>.
      </t>
    </section>
    <section numbered="true" toc="default">
      <name>Caching Considerations</name>
      <t>The cache mechanism must remove cached entries at an appropriate time
      determined by the implementation. Further, an implementation
      <bcp14>MAY</bcp14> allow network operators to set the said time value.
      In the case where a packet arriving from an SF does not have a matching
      cached entry, the SFF <bcp14>SHOULD</bcp14> log this event and
      <bcp14>MUST</bcp14> drop the packet. </t>
    </section>
    <section numbered="true" toc="default">
      <name>MTU Considerations</name>
      <t>Aligned with <xref target="RFC8300" sectionFormat="of" section="5"/>
      and <xref target="RFC8754" sectionFormat="of" section="5.3"/>, it is
      <bcp14>RECOMMENDED</bcp14> for network operators to increase the
      underlying MTU so that SR/NSH traffic is forwarded within an SR domain
      without fragmentation.

      </t>
    </section>
    <section anchor="IANA" numbered="true" toc="default">
      <name>IANA Considerations</name>
      <section anchor="NSHPROTO" numbered="true" toc="default">
        <name>Protocol Number for the NSH</name>
	<t>IANA has assigned  protocol number 145 for the NSH
	<xref target="RFC8300" format="default"/> in the "Assigned Internet
	Protocol Numbers" registry
	<eref target="https://www.iana.org/assignments/protocol-numbers/" brackets="angle"/>.</t>
<table anchor="iana-1" align="center">
<name>Assigned Internet Protocol Numbers Registry</name>
  <thead>
    <tr>
      <th>Decimal</th>
      <th>Keyword</th>
      <th>Protocol</th>
      <th>IPv6 Extension Header</th>
      <th>Reference</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>145</td>
      <td>NSH</td>
      <td>Network Service Header</td>
      <td>N</td>
      <td>RFC 9491</td>
    </tr>
    </tbody>
  </table>

      </section>
      <section anchor="NSHEPB" numbered="true" toc="default">
        <name>SRv6 Endpoint Behavior for the NSH</name>

        <t>IANA has allocated the following value in the "SRv6 Endpoint
        Behaviors" subregistry under the "Segment Routing" registry:</t>

<table anchor="iana-2" align="center">
<name>SRv6 Endpoint Behaviors Subregistry</name>
  <thead>
    <tr>
      <th>Value</th>
      <th>Hex</th>
      <th>Endpoint Behavior</th>
      <th>Reference</th>
      <th>Change Controller</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>84</td>
      <td>0x0054</td>
      <td>End.NSH - NSH Segment</td>
      <td>RFC 9491</td>
      <td>IETF</td>
    </tr>
  </tbody>
</table>

      </section>
    </section>

  </middle>
  <back>

<displayreference target="I-D.ietf-spring-sr-service-programming" to="SERVICE-PROGRAMMING"/>

    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8402.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8300.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8754.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8660.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8663.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8665.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8667.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.3031.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8200.xml"/>
      </references>
      <references>
        <name>Informative References</name>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7498.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7665.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8596.xml"/>

<reference anchor="I-D.ietf-spring-sr-service-programming"> 
<front>
<title>Service Programming with Segment Routing</title>
<author fullname="Francois Clad" initials="F." surname="Clad" role="editor">
<organization>Cisco Systems, Inc.</organization>
</author>
<author fullname="Xiaohu Xu" initials="X." surname="Xu" role="editor">
<organization>China Mobile</organization>
</author>
<author fullname="Clarence Filsfils" initials="C." surname="Filsfils">
<organization>Cisco Systems, Inc.</organization>
</author>
<author fullname="Daniel Bernier" initials="D." surname="Bernier">
<organization>Bell Canada</organization>
</author>
<author fullname="Cheng Li" initials="C." surname="Li">
<organization>Huawei</organization>
</author>
<author fullname="Bruno Decraene" initials="B." surname="Decraene">
<organization>Orange</organization>
</author>
<author fullname="Shaowen Ma" initials="S." surname="Ma">
<organization>Mellanox</organization>
</author>
<author fullname="Chaitanya Yadlapalli" initials="C." surname="Yadlapalli">
<organization>AT&amp;T</organization>
</author>
<author fullname="Wim Henderickx" initials="W." surname="Henderickx">
<organization>Nokia</organization>
</author>
<author fullname="Stefano Salsano" initials="S." surname="Salsano">
<organization>Universita di Roma "Tor Vergata"</organization>
</author>
<date day="21" month="August" year="2023"/>
</front>
<seriesInfo name="Internet-Draft" value="draft-ietf-spring-sr-service-programming-08"/>
</reference>
      </references>
    </references>

    <section anchor="Contributors" numbered="false" toc="default">
      <name>Contributors</name>
      <t>The following coauthors provided valuable inputs and text
      contributions to this document.</t>

      <contact fullname="Mohamed Boucadair">
        <organization>Orange</organization>
        <address>
          <email>mohamed.boucadair@orange.com</email>
        </address>
      </contact>

      <contact fullname="Joel Halpern">
        <organization>Ericsson</organization>
        <address>
          <email>joel.halpern@ericsson.com</email>
        </address>
      </contact>

      <contact fullname="Syed Hassan">
        <organization>Cisco System, inc.</organization>
        <address>
          <email>shassan@cisco.com</email>
        </address>
      </contact>

      <contact fullname="Wim Henderickx">
        <organization>Nokia</organization>
        <address>
          <email>wim.henderickx@nokia.com</email>
        </address>
      </contact>

      <contact fullname="Haoyu Song">
        <organization>Futurewei Technologies</organization>
        <address>
          <email>haoyu.song@futurewei.com</email>
        </address>
      </contact>

    </section>

  </back>
</rfc>
