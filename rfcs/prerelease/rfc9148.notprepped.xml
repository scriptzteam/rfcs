<?xml version='1.0' encoding='UTF-8'?>

<!DOCTYPE rfc [
 <!ENTITY nbsp    "&#160;">
 <!ENTITY zwsp   "&#8203;">
 <!ENTITY nbhy   "&#8209;">
 <!ENTITY wj     "&#8288;">
]>

<rfc xmlns:xi="http://www.w3.org/2001/XInclude" consensus="true"
     category="std" ipr="trust200902" docName="draft-ietf-ace-coap-est-18" number="9148"
     obsoletes="" updates="" submissionType="IETF" xml:lang="en"
     tocInclude="true" tocDepth="4" symRefs="true" sortRefs="true"
     version="3"> 


  <front>
    <title abbrev="EST-coaps">EST-coaps: Enrollment over Secure Transport with
    the Secure Constrained Application Protocol</title>
    <seriesInfo name="RFC" value="9148"/>
    <author fullname="Peter van der Stok" initials="P." surname="van der Stok">
      <organization>Consultant</organization>
      <address>
        <email>stokcons@bbhmail.nl</email>
      </address>
    </author>
    <author fullname="Panos Kampanakis" initials="P" surname="Kampanakis">
      <organization>Cisco Systems</organization>
      <address>
        <email>pkampana@cisco.com</email>
      </address>
    </author>
   
    <author fullname="Michael C. Richardson" initials="M." surname="Richardson">
      <organization abbrev="SSW">Sandelman Software Works
      </organization>
      <address>
        <email>mcr+ietf@sandelman.ca</email>
        <uri>https://www.sandelman.ca/</uri>
      </address>
    </author>
   
    <author fullname="Shahid Raza" initials="S" surname="Raza">
      <organization>RISE Research Institutes of Sweden</organization>
      <address>
        <postal>
          <street>Isafjordsgatan 22</street>
          <city>Kista, Stockholm</city>

          <code>16440</code>
          <country>SE</country>
        </postal>
        <email>shahid.raza@ri.se</email>
      </address>
    </author>
    <date month="April" year="2022"/>
    <area>Security</area>
    <workgroup>ACE</workgroup>

<keyword>EST</keyword>
<keyword>CoAPS</keyword>
<keyword>Constrained-Voucher</keyword>
<keyword>Constrained-Enrollment</keyword>
<keyword>BRSKI</keyword>


    <abstract>
      <t>Enrollment over Secure Transport (EST) is used as a certificate provisioning
	  protocol over HTTPS. Low-resource devices often use the lightweight Constrained
	  Application Protocol (CoAP) for message exchanges. This document defines how to
	  transport EST payloads over secure CoAP (EST-coaps), which allows
	  constrained devices to use existing EST functionality for provisioning certificates.

</t>
    </abstract>
  </front>
  <middle>

  <section anchor="intro" numbered="true" toc="default">
      <name>Introduction</name>
      <t>"Classical" Enrollment over Secure Transport (EST) <xref target="RFC7030" format="default"/>
	is used for authenticated/authorized endpoint certificate enrollment (and
	optionally key provisioning) through a Certification Authority (CA) or
	Registration Authority (RA). EST transports messages over HTTPS.</t>
      <t>This document defines a new transport for EST based on the Constrained
   Application Protocol (CoAP) since some Internet of Things (IoT) devices
   use CoAP instead of HTTP. Therefore, this specification utilizes DTLS
   <xref target="RFC6347" format="default"/> and CoAP <xref target="RFC7252" format="default"/> instead of
   TLS <xref target="RFC8446" format="default"/> and HTTP <xref target="RFC7230" format="default"/>. </t>
      <t>EST responses can be relatively large, and for this reason, this
   specification also uses CoAP Block-Wise Transfer <xref target="RFC7959" format="default"/> to
   offer a fragmentation mechanism of EST messages at the CoAP layer.
      </t>
      <t>This document also profiles the use of EST to support
      certificate-based client authentication only. Neither HTTP Basic nor Digest
      authentication (as described in <xref target="RFC7030"
      sectionFormat="of" section="3.2.3"/>) is supported. </t>
     
  </section>


  <section anchor="terminology" numbered="true" toc="default">
      <name>Terminology</name>

        <t>
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL
    NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as
    described in BCP&nbsp;14 <xref target="RFC2119"/> <xref target="RFC8174"/> 
    when, and only when, they appear in all capitals, as shown here.
        </t>

      <t>Many of the concepts in this document are taken from <xref target="RFC7030" format="default"/>. Consequently, much text is directly traceable to <xref target="RFC7030" format="default"/>. </t>
 
  </section>
 

  <section anchor="profile7925" numbered="true" toc="default">
      <name>DTLS and Conformance to RFC 7925 Profiles</name>
      <t>This section describes how EST-coaps conforms to the profiles of
      low-resource devices described in <xref target="RFC7925"
      format="default"/>.  EST-coaps can transport certificates and private
      keys. Certificates are responses to (re-)enrollment requests or requests
      for a trusted certificate list. Private keys can be transported as
      responses to a server-side key generation request as described in <xref
      target="RFC7030" sectionFormat="of" section="4.4"/> (and subsections)
      and discussed in <xref target="serverkey" format="default"/> of this
      document. </t>
      <t>EST-coaps depends on a secure transport mechanism that secures the exchanged CoAP messages. DTLS is one such secure protocol. No other changes are necessary regarding the secure transport of EST messages. </t>
 
        <figure align="center" anchor="est-coaps-layers">
<name>EST-coaps Protocol Layers</name>
<artwork align="center"><![CDATA[
+------------------------------------------------+
|    EST request/response messages               |
+------------------------------------------------+
|    CoAP for message transfer and signaling     |
+------------------------------------------------+
|    Secure Transport                            |
+------------------------------------------------+
]]></artwork>
</figure>

      <t>
    In accordance with Sections <xref target="RFC7925" section="3.3"
    sectionFormat="bare"/> and <xref target="RFC7925" section="4.4" sectionFormat="bare"/> of <xref target="RFC7925" format="default"/>, the
    mandatory cipher suite for DTLS in EST-coaps is
    TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 <xref target="RFC7251" format="default"/>.
    Curve secp256r1 <bcp14>MUST</bcp14>
    be supported <xref target="RFC8422" format="default"/>; this curve is equivalent to the
    NIST P-256 curve. After the publication of <xref target="RFC7748" format="default"/>, 
	support for Curve25519 will likely be required in the future by 
	(D)TLS profiles for the Internet of Things <xref target="RFC7925" format="default"/>.
      </t>
    
	<t>DTLS 1.2 implementations must use the Supported Elliptic Curves and Supported
    Point Formats Extensions in <xref target="RFC8422" format="default"/>. Uncompressed point
    format must also be supported. DTLS 1.3 <xref target="RFC9147" format="default"/>
	implementations differ from DTLS 1.2 
    because they do not support point format negotiation in favor of a single
    point format for each curve. Thus, support for DTLS 1.3 does not mandate
	point format extensions and negotiation. In addition, in DTLS 1.3, the 
    Supported Elliptic Curves extension has been renamed to Supported Groups.
      </t>

      <t>CoAP was designed to avoid IP fragmentation. DTLS is used to secure
      CoAP messages. However, fragmentation is still possible at the DTLS
      layer during the DTLS handshake even when using Elliptic Curve
      Cryptography (ECC) cipher suites. If fragmentation is necessary, "DTLS
      provides a mechanism for fragmenting a handshake message over a number
      of records, each of which can be transmitted separately, thus avoiding
      IP fragmentation" <xref target="RFC6347" format="default"/>.</t>
      <t>The authentication of the EST-coaps server by the EST-coaps client is
      based on certificate authentication in the DTLS handshake.  The
      EST-coaps client <bcp14>MUST</bcp14> be configured with at least an
      Implicit Trust Anchor database, which will enable the authentication
      of the server the first time before updating its trust anchor (Explicit
      TA) <xref target="RFC7030" format="default"/>.</t>
      <t>The authentication of the EST-coaps client <bcp14>MUST</bcp14> be with a client certificate
	in the DTLS handshake. This can either be:
      </t>
      <ul spacing="normal">
        <li>A previously issued client certificate (e.g., an existing
        certificate issued by the EST CA); this could be a common case for
        simple re-enrollment of clients. </li>
        <li>A previously installed certificate (e.g., manufacturer IDevID
        <xref target="IEEE802.1AR" format="default"/> or a certificate issued
        by some other party). IDevID's are expected to have a very long life,
        as long as the device, but under some conditions could expire. In that
        case, the server <bcp14>MAY</bcp14> authenticate a client certificate
        against its trust store though the certificate is expired (<xref
        target="sec" format="default"/>). </li>
      </ul>
      <t>EST-coaps supports the certificate types and TAs that
      are specified for EST in <xref target="RFC7030"
      sectionFormat="of" section="3"/>.
      </t>
      <t>As described in <xref target="RFC5272" sectionFormat="of"
      section="2.1"/>, proof-of-identity refers to a value that can be used to
      prove that an end entity or client is in the possession of and can use
      the private key corresponding to the certified public key. Additionally,
      channel-binding information can link proof-of-identity with an
      established connection.  Connection-based proof-of-possession is
      <bcp14>OPTIONAL</bcp14> for EST-coaps clients and servers. When
      proof-of-possession is desired, a set of actions are required regarding
      the use of tls-unique, described in <xref target="RFC7030"
      sectionFormat="of" section="3.5"/>. The tls-unique information consists
      of the contents of the first Finished message in the (D)TLS handshake
      between server and client <xref target="RFC5929" format="default"/>. The
      client adds the Finished message as a challengePassword in the
      attributes section of the PKCS #10 CertificationRequest <xref
      target="RFC5967" format="default"/> to prove that the client is indeed
      in control of the private key at the time of the (D)TLS session
      establishment. In the case of handshake message fragmentation, if
      proof-of-possession is desired, the Finished message added as the
      challengePassword in the Certificate Signing Request (CSR) is calculated
      as specified by (D)TLS. We summarize it here for convenience. For DTLS
      1.2, in the event of handshake message fragmentation, the hash of the
      handshake messages used in the Message Authentication Code (MAC)
      calculation of the Finished message must be computed on each reassembled
      message, as if each message had not been fragmented (<xref
      target="RFC6347" sectionFormat="of" section="4.2.6"/>). The Finished
      message is calculated as shown in <xref target="RFC5246"
      sectionFormat="of" section="7.4.9"/>. </t>
	  
	  <t>For (D)TLS 1.3, <xref target="RFC8446" sectionFormat="of"
	  section="C.5"/> describes the lack of channel bindings similar to
	  tls-unique.
	  <xref target="I-D.ietf-kitten-tls-channel-bindings-for-tls13" format="default"/>
	  can be used instead to derive a 32-byte tls-exporter binding from
	  the (D)TLS 1.3 master secret by using a PRF negotiated in the (D)TLS
	  1.3 handshake, "EXPORTER-Channel-Binding" with no terminating NUL as
	  the label, the ClientHello.random and ServerHello.random, and a
	  zero-length context string.  When proof-of-possession is desired, the
	  client adds the tls-exporter value as a challengePassword in the
	  attributes section of the PKCS #10 CertificationRequest <xref
	  target="RFC5967" format="default"/> to prove that the client is
	  indeed in control of the private key at the time of the (D)TLS
	  session establishment. </t>
	  
	  <t>In a constrained CoAP environment, endpoints can't always afford to
   establish a DTLS connection for every EST transaction. An EST-coaps DTLS
   connection <bcp14>MAY</bcp14> remain open for sequential EST transactions,
   which was not the case with <xref target="RFC7030" format="default"/>.  For
   example, if a /crts request is followed by a /sen request, both can use the
   same authenticated DTLS connection. However, when a /crts request is
   included in the set of sequential EST transactions, some additional
   security considerations apply regarding the use of the Implicit and
   Explicit TA database as explained in <xref target="sec-est"
   format="default"/>.</t>
      <t>Given that after a successful enrollment, it is more likely that a
      new EST transaction will not take place for a significant amount of
      time, the DTLS connections <bcp14>SHOULD</bcp14> only be kept alive for
      EST messages that are relatively close to each other. These could
      include a /sen immediately following a /crts when a device is getting
      bootstrapped. In some cases, like NAT rebinding, keeping the state of a
      connection is not possible when devices sleep for extended periods of
      time. In such occasions, <xref target="RFC9146"
      format="default"/> negotiates a connection ID that can eliminate the
      need for a new handshake and its additional cost; or, DTLS session
      resumption provides a less costly alternative than redoing a full DTLS
      handshake. </t>
    </section>

  

  <section anchor="design" numbered="true" toc="default">
      <name>Protocol Design</name>
      <t>EST-coaps uses CoAP to transfer EST messages, aided by Block-Wise Transfer
	<xref target="RFC7959" format="default"/>, to avoid IP 
	fragmentation. The use of blocks for the transfer of larger
	EST messages is specified in <xref target="fragment" format="default"/>. 
	<xref target="est-coaps-layers" format="default"/> shows the layered EST-coaps
	architecture.</t>
      <t>The EST-coaps protocol design follows closely the EST design. The supported 
	 message types in EST-coaps are: 
      </t>
      <ul spacing="normal">
        <li>CA certificate retrieval needed to receive the complete set of CA certificates. </li>
        <li>Simple enroll and re-enroll for a CA to sign client identity public keys.</li>
        <li>Certificate Signing Request (CSR) attribute messages that informs the client 
		of the fields to include in a CSR.</li>
        <li>Server-side key generation messages to provide a client identity private key when the client chooses so. </li>
      </ul>
      <t>
  While <xref target="RFC7030" format="default"/> permits a number of the EST functions to be used without
  authentication, this specification requires that the client <bcp14>MUST</bcp14> be authenticated 
  for all functions. </t>


	  
  <section anchor="discovery" numbered="true" toc="default">
        <name>Discovery and URIs</name>
        <t>EST-coaps is targeted for low-resource networks with small packets. Two types of installations are possible: (1) a rigid one, where the address and the supported functions of the EST server(s) are known, and (2) a flexible one, where the EST server and its supported functions need to be discovered.</t>
        <t>For both types of installations, saving header space is important and short EST-coaps URIs are specified in this document. These URIs are shorter than the ones in <xref target="RFC7030" format="default"/>. Two example EST-coaps resource path names are: </t>

       <artwork><![CDATA[
coaps://example.com:<port>/.well-known/est/<short-est>
coaps://example.com:<port>/.well-known/est/ArbitraryLabel/<short-est>
]]></artwork>

      <t>The short-est strings are defined in <xref target="est-uri" format="default"/>. 
	  Arbitrary Labels are usually defined and used by EST CAs in order
	  to route client requests to the appropriate certificate profile. 
	  Implementers should consider using short labels to minimize 
	  transmission overhead.</t>
        <t>The EST-coaps server URIs, obtained through discovery of the 
	  EST-coaps resource(s) as shown below, are of the form: </t>
<artwork><![CDATA[
coaps://example.com:<port>/<root-resource>/<short-est>
coaps://example.com:<port>/<root-resource>/ArbitraryLabel/<short-est>
]]></artwork>
        <t>Figure 5 in <xref target="RFC7030" sectionFormat="of"
        section="3.2.2"/> enumerates the operations and corresponding paths
        that are supported by EST. <xref target="est-uri" format="default"/>
        provides the mapping from the EST URI path to the shorter EST-coaps
        URI path.</t>
        <table anchor="est-uri" align="center">
          <name>Short EST-coaps URI Path</name>
          <thead>
            <tr>
              <th align="left">EST</th>
              <th align="left">EST-coaps</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left"> /cacerts  </td>
              <td align="left"> /crts </td>
            </tr>
            <tr>
              <td align="left"> /simpleenroll </td>
              <td align="left"> /sen </td>
            </tr>
            <tr>
              <td align="left"> /simplereenroll </td>
              <td align="left"> /sren </td>
            </tr>
            <tr>
              <td align="left"> /serverkeygen </td>
              <td align="left"> /skg (PKCS #7) </td>
            </tr>
            <tr>
              <td align="left"> /serverkeygen </td>
              <td align="left"> /skc (application/pkix-cert)</td>
            </tr>
            <tr>
              <td align="left"> /csrattrs </td>
              <td align="left"> /att </td>
            </tr>
          </tbody>
        </table>
        <t>The /skg message is the EST /serverkeygen equivalent where the
        client requests a certificate in PKCS #7 format and a private key. If
        the client prefers a single application/pkix-cert certificate instead
        of PKCS #7, it will make an /skc request. In both cases (i.e., /skg,
        /skc), a private key <bcp14>MUST</bcp14> be returned.</t>
        <t>Clients and servers <bcp14>MUST</bcp14> support the short resource EST-coaps URIs. </t>

      <t>In the context of CoAP, the presence and location of (path to) the
      EST resources are discovered by sending a GET request to
      "/.well-known/core" including a resource type (RT) parameter with the
      value "ace.est*" <xref target="RFC6690" format="default"/>. The example
      below shows the discovery over CoAPS of the presence and location of
      EST-coaps resources. Linefeeds are included only for readability.</t>

<sourcecode type="core-link-format"><![CDATA[
  REQ: GET /.well-known/core?rt=ace.est*

  RES: 2.05 Content
</est/crts>;rt="ace.est.crts";ct="281 287",
</est/sen>;rt="ace.est.sen";ct="281 287",
</est/sren>;rt="ace.est.sren";ct="281 287",
</est/att>;rt="ace.est.att";ct=285,
</est/skg>;rt="ace.est.skg";ct=62,
</est/skc>;rt="ace.est.skc";ct=62
]]></sourcecode>
      <t>The first three lines, describing ace.est.crts, ace.est.sen, and
      ace.est.sren, of the discovery response above <bcp14>MUST</bcp14> be
      returned if the server supports resource discovery. The last three lines
      are only included if the corresponding EST functions are implemented
      (see <xref target="est-implementation" format="default"/>). The
      Content-Formats in the response allow the client to request one that is
      supported by the server. These are the values that would be sent in the
      client request with an Accept Option. </t>

	  <t>Discoverable port numbers can be returned in the response payload. An example response payload for non-default CoAPS server port 61617 follows below. Linefeeds are included only for readability.</t>

<sourcecode type="core-link-format"><![CDATA[
  REQ: GET /.well-known/core?rt=ace.est*

  RES: 2.05 Content
<coaps://[2001:db8:3::123]:61617/est/crts>;rt="ace.est.crts";
              ct="281 287", 
<coaps://[2001:db8:3::123]:61617/est/sen>;rt="ace.est.sen";
              ct="281 287", 
<coaps://[2001:db8:3::123]:61617/est/sren>;rt="ace.est.sren";
              ct="281 287",
<coaps://[2001:db8:3::123]:61617/est/att>;rt="ace.est.att";
              ct=285,
<coaps://[2001:db8:3::123]:61617/est/skg>;rt="ace.est.skg";
              ct=62,
<coaps://[2001:db8:3::123]:61617/est/skc>;rt="ace.est.skc";
              ct=62
]]></sourcecode>

	  <t>The server <bcp14>MUST</bcp14> support the default /.well-known/est  
	  root resource. The server <bcp14>SHOULD</bcp14> support 
	  resource discovery when it supports non-default URIs 
	  (like /est or /est/ArbitraryLabel) or ports. The client 
	  <bcp14>SHOULD</bcp14> use resource discovery when it is unaware 
	  of the available EST-coaps resources.</t>

	  <t>Throughout this document, the example root resource of /est is used.</t>
      </section>


<section anchor="implementation" numbered="true" toc="default">
        <name>Mandatory/Optional EST Functions</name>
        <t>
This specification contains a set of required-to-implement functions, optional
functions, and not-specified functions. The unspecified functions are deemed
too expensive for low-resource devices in payload and calculation times.</t>
        <t> <xref target="est-implementation" format="default"/> specifies the
        mandatory-to-implement or optional implementation of the EST-coaps
        functions. Discovery of the existence of optional functions is
        described in <xref target="discovery" format="default"/>.</t>
        <table anchor="est-implementation" align="center">
          <name>List of EST-coaps Functions</name>
          <thead>
            <tr>
              <th align="left">EST Functions</th>
              <th align="left">EST-coaps Implementation</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left"> /cacerts  </td>
              <td align="left"> <bcp14>MUST</bcp14> </td>
            </tr>
            <tr>
              <td align="left"> /simpleenroll </td>
              <td align="left"> <bcp14>MUST</bcp14> </td>
            </tr>
            <tr>
              <td align="left"> /simplereenroll </td>
              <td align="left"> <bcp14>MUST</bcp14> </td>
            </tr>
            <tr>
              <td align="left"> /fullcmc     </td>
              <td align="left"> Not specified </td>
            </tr>
            <tr>
              <td align="left"> /serverkeygen </td>
              <td align="left"> <bcp14>OPTIONAL</bcp14> </td>
            </tr>
            <tr>
              <td align="left"> /csrattrs </td>
              <td align="left"> <bcp14>OPTIONAL</bcp14> </td>
            </tr>
          </tbody>
        </table>
      </section>


    <section anchor="format" numbered="true" toc="default">
        <name>Payload Formats</name>
        <t>EST-coaps is designed for low-resource devices; hence, it does not need
	  to send Base64-encoded data. Simple binary is more efficient (30% smaller payload for DER-encoded ASN.1) and
	  well supported by CoAP. Thus, the payload for a given media type follows the ASN.1
	  structure of the media type and is transported in binary format.</t>	  

      <t>The Content-Format (HTTP Content-Type equivalent) of the CoAP message
      determines which EST message is transported in the CoAP payload. The
      media types specified in the HTTP Content-Type header field (<xref
      target="RFC7030" sectionFormat="of" section="3.2.4"/>) are specified by
      the Content-Format Option (12) of CoAP. The combination of URI-Path and
      Content-Format in EST-coaps <bcp14>MUST</bcp14> map to an allowed
      combination of URI and media type in EST. The required Content-Formats
      for these requests and response messages are defined in <xref
      target="Content-Formats" format="default"/>. The CoAP response codes are
      defined in <xref target="codes" format="default"/>.</t>

	  <t>Content-Format 287 can be used in place of 281 to carry a single 
      certificate instead of a PKCS #7 container 
      in a /crts, /sen, /sren, or /skg response. 
      Content-Format 281 <bcp14>MUST</bcp14> be supported by EST-coaps servers. 
	  Servers <bcp14>MAY</bcp14> also support Content-Format 287.
	  It is up to the client to support only Content-Format 281, 
	  287 or both. 
      The client will use 
	  a CoAP Accept Option in the request to express the 
	  preferred response Content-Format. If an Accept Option is 
      not included in the request, the client is not expressing 
      any preference and the server <bcp14>SHOULD</bcp14> choose format 281.</t>
	  
	  <t>Content-Format 286 is used in /sen, /sren, and /skg requests 
	  and 285 in /att responses. </t>

	  <t>
      A representation with Content-Format identifier 62 contains a collection
      of representations along with their respective Content-Format. The
      Content-Format identifies the media type application/multipart-core
      specified in <xref target="RFC8710"
      format="default"/>.  For example, a collection, containing two
      representations in response to an EST-coaps server-side key generation
      /skg request, could include a private key in PKCS #8 <xref
      target="RFC5958" format="default"/> with Content-Format identifier 284
      (0x011C) and a single certificate in a PKCS #7 container with
      Content-Format identifier 281 (0x0119).  Such a collection would look
      like [284,h'0123456789abcdef', 281,h'fedcba9876543210'] in diagnostic
      Concise Binary Object Representation (CBOR) notation. The serialization of such CBOR content would be:</t>
        <figure>
          <name>Multipart /skg Response Serialization</name>
<sourcecode type="cbor-pretty"><![CDATA[
   84                  # array(4)
   19 011C             # unsigned(284)
   48                  # bytes(8)
      0123456789ABCDEF # "\x01#Eg\x89\xAB\xCD\xEF"
   19 0119             # unsigned(281)
   48                  # bytes(8)
      FEDCBA9876543210 # "\xFE\xDC\xBA\x98vT2\x10"
]]></sourcecode>
        </figure>
        <t>When the client makes an /skc request, the certificate returned
        with the private key is a single X.509 certificate (not a PKCS #7
        container) with Content-Format identifier 287 (0x011F) instead of
        281.  In cases where the private key is encrypted with Cryptographic
        Message Syntax (CMS) (as explained in <xref target="serverkey"
        format="default"/>), the Content-Format identifier is 280 (0x0118)
        instead of 284. The Content-Format used in the response is summarized
        in <xref target="skg-skc" format="default"/>.</t>
        <table anchor="skg-skc" align="center">
          <name>Response Content-Formats for /skg and /skc</name>
          <thead>
            <tr>
              <th align="left">Function</th>
              <th align="left">Response, Part 1</th>
              <th align="left">Response, Part 2</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left"> /skg  </td>
              <td align="left">   284  </td>
              <td align="left">  281</td>
            </tr>
            <tr>
              <td align="left"> /skc  </td>
              <td align="left">   280  </td>
              <td align="left">  287</td>
            </tr>
          </tbody>
        </table>
        <t>The key and certificate representations are DER-encoded ASN.1, 
   in its binary form. An example is shown in <xref target="appskg" format="default"/>.</t>


   </section>


    <section numbered="true" toc="default">
        <name>Message Bindings</name>
        <t>The general EST-coaps message characteristics are:
        </t>
        <ul spacing="normal">

		  <li>EST-coaps servers sometimes need to provide delayed
		  responses, which are preceded by an immediately returned
		  empty ACK or an ACK containing response code 5.03 as
		  explained in <xref target="pending" format="default"/>.
		  Thus, it is <bcp14>RECOMMENDED</bcp14> for implementers to
		  send EST-coaps requests in Confirmable (CON) CoAP
		  messages.</li>
          <li>The CoAP Options used are Uri-Host, Uri-Path, Uri-Port,
          Content-Format, Block1, Block2, and Accept.  These CoAP Options are
          used to communicate the HTTP fields specified in the EST REST
          messages. The Uri-host and Uri-Port Options can be omitted from the
          CoAP message sent on the wire. When omitted, they are logically
          assumed to be the transport protocol destination address and port,
          respectively. Explicit Uri-Host and Uri-Port Options are typically
          used when an endpoint hosts multiple virtual servers and uses the
          Options to route the requests accordingly.  Other CoAP Options
          should be handled in accordance with <xref target="RFC7252"
          format="default"/>.</li>

	  <li>EST URLs are HTTPS based (https://); in CoAP, these are assumed
	  to be translated to CoAPS (coaps://).</li>
        </ul>
        <t><xref target="est-uri" format="default"/> provides the mapping from the EST URI path to the EST-coaps URI path. 
		<xref target="messagebindings" format="default"/>  includes some practical examples of EST messages
		translated to CoAP.</t>
      </section>


    <section anchor="codes" numbered="true" toc="default">
        <name>CoAP Response Codes</name>
        <t><xref target="RFC7252" sectionFormat="of" section="5.9"/> and <xref
        target="RFC8075" sectionFormat="of" section="7"/> specify the mapping
        of HTTP response codes to CoAP response codes.  The success code in
        response to an EST-coaps GET request (/crts, /att) is 2.05. Similarly,
        2.04 is used in successful response to EST-coaps POST requests (/sen,
        /sren, /skg, /skc).</t>
	  
	  <t>EST makes use of HTTP 204 or 404 responses when a resource is not available 
	  for the client. In EST-coaps, 2.04 is used in response to 
	  a POST (/sen, /sren, /skg, /skc). 4.04 is 
	  used when the resource is not available for the client. </t>
        <t>HTTP response code 202 with a Retry-After header field  
	  in <xref target="RFC7030" format="default"/> has no equivalent in CoAP. 
	  HTTP 202 with Retry-After is used in EST for delayed server 
	  responses. <xref target="pending" format="default"/> specifies how EST-coaps 
	  handles delayed messages with 5.03 responses with a Max-Age Option.</t>

	  <t>Additionally, EST's HTTP 400, 401, 403, 404, and 503 status codes have 
	  their equivalent CoAP 4.00, 4.01, 4.03, 4.04, and 5.03 response codes 
	  in EST-coaps. 
	  <xref target="estcoaps-codes" format="default"/> summarizes the EST-coaps response codes. </t>
        <table anchor="estcoaps-codes" align="center">
          <name>EST-coaps Response Codes</name>
          <thead>
            <tr>
              <th align="left">Operation</th>
              <th align="left">EST-coaps Response Code</th>
              <th align="left">Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">/crts, /att</td>
              <td align="left">2.05</td>
              <td align="left">Success. Certs included in the response payload.</td>
            </tr>
            <tr>
              <td align="left"> </td>
              <td align="left">4.xx / 5.xx</td>
              <td align="left">Failure.</td>
            </tr>
            <tr>
              <td align="left">/sen, /skg, /sren, /skc</td>
              <td align="left">2.04 
		                                         </td>
              <td align="left">Success. Cert included in the response payload.</td>
            </tr>
            <tr>
              <td align="left"> </td>
              <td align="left">5.03</td>
              <td align="left">Retry in Max-Age Option time.</td>
            </tr>
            <tr>
              <td align="left"> </td>
              <td align="left">4.xx / 5.xx</td>
              <td align="left">Failure.</td>
            </tr>
          </tbody>
        </table>
      </section>


    <section anchor="fragment" numbered="true" toc="default">
        <name>Message Fragmentation</name>
        <t>DTLS defines fragmentation only for the handshake and not for
        secure data exchange (DTLS records). <xref target="RFC6347"
        format="default"/> states that to avoid using IP fragmentation, which
        involves error-prone datagram reconstitution, invokers of the DTLS
        record layer should size DTLS records so that they fit within any Path
        MTU estimates obtained from the record layer. In addition, invokers
        residing on 6LoWPAN (IPv6 over Low-Power Wireless Personal Area Networks)
        over IEEE 802.15.4 networks <xref target="IEEE802.15.4"
        format="default"/> are recommended to size CoAP messages such
        that each DTLS record will fit within one or two IEEE 802.15.4
        frames.</t>

      <t>That is not always possible in EST-coaps. Even though ECC
      certificates are small in size, they can vary greatly based on signature
      algorithms, key sizes, and Object Identifier (OID) fields used. For
      256-bit curves, common Elliptic Curve Digital Signature Algorithm
      (ECDSA) cert sizes are 500-1000 bytes, which could fluctuate further
      based on the algorithms, OIDs, Subject Alternative Names (SANs), and cert
      fields. For 384-bit curves, ECDSA certificates increase in size and can
      sometimes reach 1.5KB. Additionally, there are times when the EST
      cacerts response from the server can include multiple certificates that
      amount to large payloads. <xref target="RFC7252" sectionFormat="of"
      section="4.6"/> (CoAP) describes the possible payload sizes: "if nothing
      is known about the size of the headers, good upper bounds are 1152 bytes
      for the message size and 1024 bytes for the payload size". <xref
      target="RFC7252" sectionFormat="of" section="4.6"/> also suggests that
      IPv4 implementations may want to limit themselves to more conservative
      IPv4 datagram sizes such as 576 bytes. Even with ECC, EST-coaps messages
      can still exceed MTU sizes on the Internet or 6LoWPAN <xref
      target="RFC4919" format="default"/> (<xref target="RFC7959"
      sectionFormat="of" section="2"/>). EST-coaps needs to be able to
      fragment messages into multiple DTLS datagrams.</t>
        <t>To perform fragmentation in CoAP, <xref target="RFC7959"
        format="default"/> specifies the Block1 Option for fragmentation of
        the request payload and the Block2 Option for fragmentation of the
        return payload of a CoAP flow. As explained in <xref target="RFC7959"
        sectionFormat="of" section="1"/>, block-wise transfers should be used
        in Confirmable CoAP messages to avoid the exacerbation of lost
        blocks. EST-coaps servers <bcp14>MUST</bcp14> implement Block1 and
        Block2. EST-coaps clients <bcp14>MUST</bcp14> implement
        Block2. EST-coaps clients <bcp14>MUST</bcp14> implement Block1 only if
        they are expecting to send EST-coaps requests with a packet size that
        exceeds the path MTU. </t>

      <t><xref target="RFC7959" format="default"/> also defines Size1 and
      Size2 Options to provide size information about the resource
      representation in a request and response. The EST-coaps client and server
      <bcp14>MAY</bcp14> support Size1 and Size2 Options. </t>

      <t>Examples of fragmented EST-coaps messages are shown in <xref target="blockexamples" format="default"/>.</t>
      </section>


    <section anchor="pending" numbered="true" toc="default">
        <name>Delayed Responses</name>
        <t>Server responses can sometimes be delayed. According to <xref
        target="RFC7252" sectionFormat="of" section="5.2.2"/>, a slow server
        can acknowledge the request and respond later with the requested
        resource representation. In particular, a slow server can respond to
        an EST-coaps enrollment request with an empty ACK with code 0.00
        before sending the certificate to the client after a short delay. If
        the certificate response is large, the server will need more than one
        Block2 block to transfer it. </t>
        <t>This situation is shown in <xref target="fig-est-short-wait"
        format="default"/>. The client sends an enrollment request that uses
        N1+1 Block1 blocks. The server uses an empty 0.00 ACK to announce the
        delayed response, which is provided later with 2.04 messages
        containing N2+1 Block2 Options.  The first 2.04 is a Confirmable
        message that is acknowledged by the client.  Onwards, the client
        acknowledges all subsequent Block2 blocks. The notation of <xref
        target="fig-est-short-wait" format="default"/> is explained in <xref
        target="cacertsblock" format="default"/>.</t>
        <figure anchor="fig-est-short-wait">
          <name>EST-coaps Enrollment with Short Wait</name>

<artwork name="" type="" align="left" alt=""><![CDATA[
POST [2001:db8::2:1]:61616/est/sen (CON)(1:0/1/256) 
                   {CSR (frag# 1)} -->
   <-- (ACK) (1:0/1/256) (2.31 Continue)
POST [2001:db8::2:1]:61616/est/sen (CON)(1:1/1/256) 
                   {CSR (frag# 2)} -->
   <-- (ACK) (1:1/1/256) (2.31 Continue)
                  .
                  .
                  .
POST [2001:db8::2:1]:61616/est/sen(CON)(1:N1/0/256)
                   {CSR (frag# N1+1)}-->
   <-- (0.00 empty ACK)
                  |
   ... Short delay before the certificate is ready ...
                  |
   <-- (CON) (1:N1/0/256)(2:0/1/256)(2.04 Changed) 
                   {Cert resp (frag# 1)}
                                              (ACK)          -->
POST [2001:db8::2:1]:61616/est/sen (CON)(2:1/0/256)          -->
   <-- (ACK) (2:1/1/256) (2.04 Changed) {Cert resp (frag# 2)}
                  .
                  .
                  .
POST [2001:db8::2:1]:61616/est/sen (CON)(2:N2/0/256)          -->
   <-- (ACK) (2:N2/0/256) (2.04 Changed) {Cert resp (frag# N2+1)}
]]></artwork>
        </figure>
        <t>If the server is very slow (for example, manual intervention is
        required, which would take minutes), it <bcp14>SHOULD</bcp14> respond
        with an ACK containing response code 5.03 (Service unavailable) and a
        Max-Age Option to indicate the time the client <bcp14>SHOULD</bcp14>
        wait before sending another request to obtain the content. After a
        delay of Max-Age, the client <bcp14>SHOULD</bcp14> resend the
        identical CSR to the server.  As long as the server continues to
        respond with response code 5.03 (Service Unavailable) with a Max-Age
        Option, the client will continue to delay for Max-Age and then resend
        the enrollment request until the server responds with the certificate
        or the client abandons the request due to policy or other reasons. </t>
        <t>To demonstrate this scenario, <xref target="fig-est-long-wait"
        format="default"/> shows a client sending an enrollment request that
        uses N1+1 Block1 blocks to send the CSR to the server. The server
        needs N2+1 Block2 blocks to respond but also needs to take a long
        delay (minutes) to provide the response. Consequently, the server uses
        a 5.03 ACK response with a Max-Age Option. The client waits for a
        period of Max-Age as many times as it receives the same 5.03 response
        and retransmits the enrollment request until it receives a certificate
        in a fragmented 2.04 response. </t>

<figure anchor="fig-est-long-wait">
          <name>EST-coaps Enrollment with Long Wait</name>

<artwork name="" type="" align="left" alt=""><![CDATA[
POST [2001:db8::2:1]:61616/est/sen (CON)(1:0/1/256) 
                   {CSR (frag# 1)}  -->
  <-- (ACK) (1:0/1/256) (2.31 Continue)
POST [2001:db8::2:1]:61616/est/sen (CON)(1:1/1/256) 
                   {CSR (frag# 2)}  -->
  <-- (ACK) (1:1/1/256) (2.31 Continue)
                  .
                  .
                  .
POST [2001:db8::2:1]:61616/est/sen(CON)(1:N1/0/256)
                   {CSR (frag# N1+1)}-->
  <-- (ACK) (1:N1/0/256) (5.03 Service Unavailable) (Max-Age)
                  |
                  |
  ... Client tries again after Max-Age with identical payload ...
                  |
                  |
POST [2001:db8::2:1]:61616/est/sen(CON)(1:0/1/256)
                   {CSR (frag# 1)}-->
  <-- (ACK) (1:0/1/256) (2.31 Continue)
POST [2001:db8::2:1]:61616/est/sen (CON)(1:1/1/256) 
                   {CSR (frag# 2)}  -->
  <-- (ACK) (1:1/1/256) (2.31 Continue)
                  .
                  .
                  .
POST [2001:db8::2:1]:61616/est/sen(CON)(1:N1/0/256)
                   {CSR (frag# N1+1)}-->
                  |
   ... Immediate response when certificate is ready ...
                  |
  <-- (ACK) (1:N1/0/256) (2:0/1/256) (2.04 Changed)
                   {Cert resp (frag# 1)}
POST [2001:db8::2:1]:61616/est/sen (CON)(2:1/0/256)           -->
  <-- (ACK) (2:1/1/256) (2.04 Changed) {Cert resp (frag# 2)}
                  .
                  .
                  .
POST [2001:db8::2:1]:61616/est/sen (CON)(2:N2/0/256)          -->
  <-- (ACK) (2:N2/0/256) (2.04 Changed) {Cert resp (frag# N2+1)}
]]></artwork>
        </figure>

     </section>


    <section anchor="serverkey" numbered="true" toc="default">
        <name>Server-Side Key Generation</name>
        <t>Private keys can be generated on the server to support 
	  scenarios where server-side key generation is needed. Such scenarios  
	  include those where it is considered more secure to generate the 
	  long-lived, random private key that identifies the client at the server, 
	  or where the resources spent to generate a random private key at the 
	  client are considered scarce, or where the security policy requires 
	  that the certificate public and corresponding private keys are 
	  centrally generated and controlled. As always, it is necessary 
	  to use proper random numbers in various protocols such as (D)TLS (<xref target="sec-est" format="default"/>).</t>
        <t>When requesting server-side key generation, the client
      asks for the server or proxy to generate the private key and the certificate, 
      which are transferred back to the client in the server-side key generation
      response. In all respects, the server treats the CSR as it would treat any
      enroll or re-enroll CSR; the only distinction here is that the server
      <bcp14>MUST</bcp14> ignore the public key values and signature in the CSR. These
      are included in the request only to allow reuse of existing
      codebases for generating and parsing such requests.</t>
        <t>The client /skg request is for a certificate in a PKCS #7 container 
	  and private key in two application/multipart-core elements. 
	  Respectively, an /skc request is for a single application/pkix-cert 
	  certificate and a private key. 
	  The private key Content-Format requested by the client is indicated in the 
	  PKCS #10 CSR request. If the request contains SMIMECapabilities and 
	  DecryptKeyIdentifier or AsymmetricDecryptKeyIdentifier, the client 
	  is expecting Content-Format 280 for the private key. 
	  Then, this private key is encrypted symmetrically or asymmetrically  
	  per <xref target="RFC7030" format="default"/>. 
	  The symmetric key or the asymmetric keypair establishment method is 
	  out of scope of this specification.

	  An /skg or /skc request with a CSR without SMIMECapabilities 
	  expects an application/multipart-core with an unencrypted PKCS #8 private 
	  key with Content-Format 284.</t>
        <t>
	    The EST-coaps server-side key generation response is returned with
	    Content-Format application/multipart-core <xref
	    target="RFC8710" format="default"/> containing
	    a CBOR array with four items (<xref target="format"
	    format="default"/>).  The two representations (each consisting of
	    two CBOR array items) do not have to be in a particular order
	    since each representation is preceded by its Content-Format ID.
	    Depending on the request, the private key can be in unprotected
	    PKCS #8 format <xref target="RFC5958" format="default"/>
	    (Content-Format 284) or protected inside of CMS SignedData
	    (Content-Format 280). The SignedData, placed in the outermost
	    container, is signed by the party that generated the private key,
	    which may be the EST server or the EST CA. SignedData placed
	    within the Enveloped Data does not need additional signing as
	    explained in <xref target="RFC7030" sectionFormat="of"
	    section="4.4.2"/>. In summary, the symmetrically encrypted key is
	    included in the encryptedKey attribute in a KEKRecipientInfo
	    structure.  In the case where the asymmetric encryption key is
	    suitable for transport key operations, the generated private key is
	    encrypted with a symmetric key. The symmetric key itself is
	    encrypted by the client-defined (in the CSR) asymmetric public key
	    and is carried in an encryptedKey attribute in a
	    KeyTransRecipientInfo structure.  Finally, if the asymmetric
	    encryption key is suitable for key agreement, the generated
	    private key is encrypted with a symmetric key. The symmetric key
	    itself is encrypted by the client defined (in the CSR) asymmetric
	    public key and is carried in a recipientEncryptedKeys attribute
	    in a KeyAgreeRecipientInfo. </t>
	  
	  <t><xref target="RFC7030" format="default"/> recommends the use of
	  additional encryption of the returned private key. For the context
	  of this specification, clients and servers that choose to support
	  server-side key generation <bcp14>MUST</bcp14> support unprotected
	  (PKCS #8) private keys (Content-Format 284). Symmetric or asymmetric
	  encryption of the private key (CMS EnvelopedData, Content-Format
	  280) <bcp14>SHOULD</bcp14> be supported for deployments where
	  end-to-end encryption is needed between the client and a
	  server. Such cases could include architectures where an entity
	  between the client and the CA terminates the DTLS connection
	  (Registrar in <xref target="RAfig" format="default"/>).  Though
	  <xref target="RFC7030" format="default"/> strongly recommends that
	  clients request the use of CMS encryption on top of the TLS
	  channel's protection, this document does not make such a
	  recommendation; CMS encryption can still be used when mandated by
	  the use case. </t>

    </section>

  </section>


  <section anchor="proxy" numbered="true" toc="default">
      <name>HTTPS-CoAPS Registrar</name>
      <t>In real-world deployments, the EST server will not always reside within
	the CoAP boundary. The EST server can exist outside the constrained network,
	in which case it will support TLS/HTTP instead of CoAPS. In such environments,
	EST-coaps is used by the client within the CoAP boundary and TLS is used to
	transport the EST messages outside the CoAP boundary. A Registrar at the edge
	is required to operate between the CoAP environment and the external HTTP
	network as shown in
	<xref target="RAfig" format="default"/>. </t>

	<figure anchor="RAfig">
        <name>EST-coaps-to-HTTPS Registrar at the CoAP Boundary</name>
        <artwork name="" type="" align="center" alt=""><![CDATA[
                                     Constrained Network
.------.                         .----------------------------.
|  CA  |                         |.--------------------------.|
'------'                         ||                          ||
   |                             ||                          ||
.------.  HTTP   .------------------.  CoAPS  .-----------.  ||
| EST  |<------->|EST-coaps-to-HTTPS|<------->| EST Client|  ||
|Server|over TLS |   Registrar      |         '-----------'  ||
'------'         '------------------'                        ||
                                 ||                          ||
                                 |'--------------------------'|
                                 '----------------------------'
]]></artwork>
      </figure>
      <t>The EST-coaps-to-HTTPS Registrar <bcp14>MUST</bcp14> terminate EST-coaps downstream and
	initiate EST connections over TLS upstream. The Registrar <bcp14>MUST</bcp14> authenticate
	and optionally authorize the client requests while it <bcp14>MUST</bcp14> be authenticated
	by the EST server or CA. The trust relationship between the Registrar
	and the EST server <bcp14>SHOULD</bcp14> be pre-established for the Registrar to proxy
	these connections on behalf of various clients.</t>


      <t>When enforcing Proof-of-Possession (POP) linking, the tls-unique or
      tls-exporter value of the session for DTLS 1.2 and DTLS 1.3, respectively,
      is used to prove that the private key corresponding to the public key is
      in the possession of the client and was used to establish the connection
      as explained in <xref target="profile7925" format="default"/>.  The POP
      linking information is lost between the EST-coaps client and the EST
      server when a Registrar is present.  The EST server becomes aware of the
      presence of a Registrar from its TLS client certificate that includes
      the id-kp-cmcRA extended key usage (EKU) extension <xref
      target="RFC6402" format="default"/>. As explained in <xref
      target="RFC7030" sectionFormat="of" section="3.7"/>, the "EST server
      <bcp14>SHOULD</bcp14> apply authorization policy consistent with an RA
      client ... the EST server could be configured to accept POP linking
      information that does not match the current TLS session because the
      authenticated EST client RA has verified this information when acting as
      an EST server".</t>
      <t><xref target="est-uri" format="default"/> contains the URI mappings
      between EST-coaps and EST that the Registrar <bcp14>MUST</bcp14> adhere
      to. <xref target="codes" format="default"/> of this specification and
      <xref target="RFC8075" sectionFormat="of" section="7"/> define the
      mappings between EST-coaps and HTTP response codes that determine how
      the Registrar <bcp14>MUST</bcp14> translate CoAP response codes from/to
      HTTP status codes. The mapping from CoAP Content-Format to HTTP
      Content-Type is defined in <xref target="Content-Formats"
      format="default"/>.  Additionally, a conversion from CBOR major type 2
      to Base64 encoding <bcp14>MUST</bcp14> take place at the Registrar. If
      CMS end-to-end encryption is employed for the private key, the encrypted
      CMS EnvelopedData blob <bcp14>MUST</bcp14> be converted at the Registrar
      to binary CBOR type 2 downstream to the client. This is a format
      conversion that does not require decryption of the CMS
      EnvelopedData.</t>
      <t>A deviation from the mappings in <xref target="est-uri"
      format="default"/> could take place if clients that leverage server-side
      key generation preferred for the enrolled keys to be generated by the
      Registrar in the case the CA does not support server-side key
      generation. Such a Registrar is responsible for generating a new CSR
      signed by a new key that will be returned to the client along with the
      certificate from the CA. In these cases, the Registrar
      <bcp14>MUST</bcp14> use random number generation with proper
      entropy. </t>
      <t>Due to fragmentation of large messages into blocks, an
      EST-coaps-to-HTTP Registrar <bcp14>MUST</bcp14> reassemble the blocks
      before translating the binary content to Base64 and consecutively relay
      the message upstream. </t>
      <t>The EST-coaps-to-HTTP Registrar <bcp14>MUST</bcp14> support resource
      discovery according to the rules in <xref target="discovery"
      format="default"/>. </t>

  </section>
    <section numbered="true" toc="default">
      <name>Parameters</name>
      <t>This section addresses transmission parameters described in Sections
      <xref target="RFC7252" sectionFormat="bare" section="4.7"/> and <xref
      target="RFC7252" sectionFormat="bare" section="4.8"/> of <xref target="RFC7252"/>.  EST does not
      impose any unique values on the CoAP parameters in <xref
      target="RFC7252" format="default"/>, but the setting of the CoAP
      parameter values may have consequence for the setting of the EST
      parameter values. </t>

    <t>
	Implementations should follow the default CoAP configuration
	parameters <xref target="RFC7252" format="default"/>.  However,
	depending on the implementation scenario, retransmissions and timeouts
	can also occur on other networking layers, governed by other
	configuration parameters. When a change in a server parameter has
	taken place, the parameter values in the communicating endpoints
	<bcp14>MUST</bcp14> be adjusted as necessary. Examples of how
	parameters could be adjusted include higher-layer congestion
	protocols, provisioning agents, and configurations included in
	firmware updates.</t>
      <t>Some further comments about some specific parameters, mainly from
	Table 2 in <xref target="RFC7252" format="default"/>, include the following:
      </t>

<dl>

<dt>NSTART:
</dt>
<dd>A parameter that controls the number of simultaneous outstanding
interactions that a client maintains to a given server.  An EST-coaps client
is expected to control at most one interaction with a given server, which is
the default NSTART value defined in <xref target="RFC7252" format="default"/>.
</dd>

<dt>DEFAULT_LEISURE:
</dt>
<dd>A setting that is only relevant in multicast scenarios and is outside the scope of
EST-coaps.
</dd>

<dt>PROBING_RATE:
</dt>
<dd>A parameter that specifies the rate of resending Non-confirmable
messages. In the rare situations that Non-confirmable messages are used, the
default PROBING_RATE value defined in <xref target="RFC7252"
format="default"/> applies.
</dd>

</dl>



      <t>Finally, the Table 3 parameters in <xref target="RFC7252" format="default"/> are mainly
	derived from Table 2. Directly changing parameters on one table would
	affect parameters on the other.</t>
    </section>
    <section anchor="deploy-limit" numbered="true" toc="default">
      <name>Deployment Limitations</name>
      <t>Although EST-coaps paves the way for the utilization of EST by constrained devices in constrained networks, some classes of devices <xref target="RFC7228" format="default"/> will not have enough resources to handle the payloads that come with EST-coaps. The specification of EST-coaps is intended to ensure that EST works for networks of constrained devices that choose to limit their communications stack to DTLS/CoAP. It is up to the network designer to decide which devices execute the EST protocol and which do not.</t>
    </section>


  <section anchor="iana" numbered="true" toc="default">
      <name>IANA Considerations</name>
      <section anchor="Content-Formats" numbered="true" toc="default">
        <name>Content-Formats Registry</name>
        <t>IANA has registered the following Content-Formats given in <xref target="Content-Format" format="default"/> in the "CoAP Content-Formats" subregistry within the "CoRE Parameters"
	registry <xref target="CORE-PARAMS" format="default"/>.
	These have been registered in the IETF Review or IESG Approval range (256-9999).</t>

        <table anchor="Content-Format" align="center">
          <name>New CoAP Content-Formats</name>
          <thead>
            <tr>
              <th align="left">Media Type</th>
              <th align="right">ID</th>
              <th align="left">Reference</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">application/pkcs7-mime; smime-type=server-generated-key</td>
              <td align="right">280</td>
              <td align="left">
                <xref target="RFC7030" format="default"/> <xref target="RFC8551" format="default"/> RFC 9148</td>
            </tr>
            <tr>
              <td align="left">application/pkcs7-mime; smime-type=certs-only</td>
              <td align="right">281</td>
              <td align="left">
                <xref target="RFC8551" format="default"/> RFC 9148</td>
            </tr>
            <tr>
              <td align="left">application/pkcs8</td>
              <td align="right">284</td>
              <td align="left">
                <xref target="RFC5958" format="default"/> <xref target="RFC8551" format="default"/> RFC 9148</td>
            </tr>
            <tr>
              <td align="left">application/csrattrs</td>
              <td align="right">285</td>
              <td align="left">
                <xref target="RFC7030" format="default"/> RFC 9148</td>
            </tr>
            <tr>
              <td align="left">application/pkcs10</td>
              <td align="right">286</td>
              <td align="left">
                <xref target="RFC5967" format="default"/> <xref target="RFC8551" format="default"/> RFC 9148</td>
            </tr>
            <tr>
              <td align="left">application/pkix-cert</td>
              <td align="right">287</td>
              <td align="left">
                <xref target="RFC2585" format="default"/> RFC 9148</td>
            </tr>
          </tbody>
        </table>
      </section>


<section anchor="resource-type" numbered="true" toc="default">
        <name>Resource Type Registry</name>
        <t>IANA has registered the following Resource Type (rt=) Link Target Attributes
   given in <xref target="rt-table"/> in the "Resource Type (rt=) Link Target Attribute Values"
   subregistry under the "Constrained RESTful Environments (CoRE)
   Parameters" registry.
        </t>

<table anchor="rt-table">
  <name>New Resource Type (rt=) Link Target Attributes</name>
  <thead>
    <tr>
      <th>Value</th>
      <th>Description</th>
      <th>Reference</th>
   </tr>
  </thead>
  <tbody>
    <tr>
      <td>ace.est.crts</td>
      <td>This resource depicts the support of EST GET cacerts.</td>
      <td>RFC 9148</td>
   </tr>
    <tr>
      <td>ace.est.sen</td>
      <td>This resource depicts the support of EST simple enroll.</td>
      <td>RFC 9148</td>
   </tr>
    <tr>
      <td>ace.est.sren</td>
      <td>This resource depicts the support of EST simple reenroll.</td>
      <td>RFC 9148</td>
   </tr>
    <tr>
      <td>ace.est.att</td>
      <td>This resource depicts the support of EST GET CSR attributes.</td>
      <td>RFC 9148</td>
   </tr>
    <tr>
      <td>ace.est.skg</td>
      <td>This resource depicts the support of EST server-side key generation with the returned certificate in a PKCS #7 container.</td>
      <td>RFC 9148</td>
   </tr>
    <tr>
      <td>ace.est.skc</td>
      <td>This resource depicts the support of EST server-side key generation with the returned certificate in application/pkix-cert format.</td>
      <td>RFC 9148</td>
   </tr>
  </tbody>
</table>
      </section>


  <section anchor="well-known-uris" numbered="true" toc="default">
        <name>Well-Known URIs Registry</name>
        <t>IANA has added an additional reference to
	  the est URI in the "Well-Known URIs" registry: </t>

<dl>
  <dt>URI Suffix:</dt> <dd>est</dd>
  <dt>Change Controller:</dt> <dd>IETF</dd>
  <dt>References:</dt> <dd><xref target="RFC7030" format="default"/> RFC 9148</dd>
  <dt>Status:</dt> <dd>permanent</dd>
  <dt>Related Information:</dt> <dd></dd>
  <dt>Date Registered:</dt> <dd>2013-08-16</dd>
  <dt>Date Modified:</dt> <dd>2020-04-29</dd>
</dl>
      </section>

  
  </section>


  <section anchor="sec" numbered="true" toc="default">
      <name>Security Considerations</name>
      <section anchor="sec-est" numbered="true" toc="default">
        <name>EST Server Considerations</name>
        <t>The security considerations in <xref target="RFC7030"
        sectionFormat="of" section="6"/> are only partially valid for the
        purposes of this document. As HTTP Basic Authentication is not
        supported, the considerations expressed for using passwords do not
        apply. The other portions of the security considerations in <xref
        target="RFC7030" format="default"/> continue to apply.</t>
        <t>Modern security protocols require random numbers to be available
        during the protocol run, for example, for nonces and ephemeral (EC)
        Diffie-Hellman key generation. This capability to generate random
        numbers is also needed when the constrained device generates the
        private key (that corresponds to the public key enrolled in the
        CSR). When server-side key generation is used, the constrained device
        depends on the server to generate the private key randomly, but it
        still needs locally generated random numbers for use in security
        protocols, as explained in <xref target="RFC7925"
        sectionFormat="of" section="12"/>.  Additionally, the transport of keys generated at
        the server is inherently risky.  For those deploying server-side key
        generation, analysis <bcp14>SHOULD</bcp14> be done to establish
        whether server-side key generation increases or decreases the
        probability of digital identity theft.</t>
        <t>It is important to note that, as pointed out in <xref target="PsQs" format="default"/>,   sources contributing to the randomness 
      pool used to generate random numbers on laptops or desktop PCs, 
	  such as mouse movement, timing of keystrokes, or air turbulence 
	  on the movement of hard drive heads,
      are not available on many constrained devices.  
	  Other sources have to be used or dedicated hardware has to be added.
      Selecting hardware for an IoT device that is capable of producing
      high-quality random numbers is therefore important <xref target="RSA-FACT" format="default"/>.</t>

	  <t>As discussed in <xref target="RFC7030" sectionFormat="of"
	  section="6"/>, it is 
</t>

<blockquote>
<bcp14>RECOMMENDED</bcp14> that the Implicit Trust Anchor database used for
EST server authentication be carefully managed to reduce the chance of a
third-party CA with poor certification practices from being trusted.
Disabling the Implicit Trust Anchor database after successfully receiving the
Distribution of CA certificates response (<xref target="RFC7030"
format="default" sectionFormat="comma" section="6"/>)
limits any vulnerability to the first TLS exchange.
</blockquote>

<t>


  Alternatively, in a case where a /sen request immediately follows a /crts, a
  client <bcp14>MAY</bcp14> choose to keep the connection authenticated by the
  Implicit TA open for efficiency reasons (<xref target="profile7925"
  format="default"/>). A client that interleaves EST-coaps /crts request with
  other requests in the same DTLS connection <bcp14>SHOULD</bcp14> revalidate
  the server certificate chain against the updated Explicit TA from the /crts
  response before proceeding with the subsequent requests. If the server
  certificate chain does not authenticate against the database, the client
  <bcp14>SHOULD</bcp14> close the connection without completing the rest of
  the requests. The updated Explicit TA <bcp14>MUST</bcp14> continue to be
  used in new DTLS connections.</t>
        <t>In cases where the Initial Device Identifier (IDevID) used to authenticate the client is
        expired, the server <bcp14>MAY</bcp14> still authenticate the client because IDevIDs
        are expected to live as long as the device itself (<xref
        target="profile7925" format="default"/>). In such occasions, checking
        the certificate revocation status or authorizing the client using
        another method is important for the server to raise its confidence
        that the client can be trusted. </t>
        <t>In accordance with <xref target="RFC7030" format="default"/>, TLS
        cipher suites that include "_EXPORT_" and "_DES_" in their names <bcp14>MUST
        NOT</bcp14> be used. More recommendations for secure use of TLS and DTLS are
        included in <xref target="BCP195" format="default"/>.</t>

      <t>As described in Certificate Management over CMS (CMC), <xref
      target="RFC5272" sectionFormat="of" section="6.7"/>, "For keys that can
      be used as signature keys, signing the certification request with the
      private key serves as a POP on that key pair". In (D)TLS 1.2, the
      inclusion of tls-unique in the certificate request links the
      proof-of-possession to the (D)TLS proof-of-identity. This implies but
      does not prove that only the authenticated client currently has access
      to the private key.</t>
	  
      <t>What's more, CMC POP linking uses tls-unique as it is defined in
      <xref target="RFC5929" format="default"/>. The 3SHAKE attack <xref
      target="TRIPLESHAKE" format="default"/> poses a risk by allowing an
      on-path active attacker to leverage session resumption and
      renegotiation to inject itself between a client and server even when
      channel binding is in use. Implementers should use the Extended Master
      Secret Extension in DTLS <xref target="RFC7627" format="default"/> to
      prevent such attacks.  In the context of this specification, an
      attacker could invalidate the purpose of the POP linking
      challengePassword in the client request by resuming an EST-coaps
      connection. Even though the practical risk of such an attack to
      EST-coaps is not devastating, we would rather use a more secure
      channel-binding mechanism.
	  In this specification, we still depend on the tls-unique
      mechanism defined in <xref target="RFC5929" format="default"/> for DTLS 1.2
	  because a 3SHAKE attack does not expose messages exchanged
      with EST-coaps. But for DTLS 1.3,
	  <xref target="I-D.ietf-kitten-tls-channel-bindings-for-tls13" format="default"/>
	  is used instead to derive a 32-byte tls-exporter binding
	  in place of the tls-unique value in the CSR. That would alleviate the risks
	  from the 3SHAKE attack <xref target="TRIPLESHAKE" format="default"/>. 
      </t>
      
	  <t>Interpreters of ASN.1 structures should be aware of the use of invalid ASN.1
	  length fields and should take appropriate measures to guard against buffer overflows,
	  stack overruns in particular, and malicious content in general.</t>
      </section>


    <section anchor="sec-proxy" numbered="true" toc="default">
        <name>HTTPS-CoAPS Registrar Considerations</name>
        <t>The Registrar proposed in <xref target="proxy" format="default"/>
        must be deployed with care and only when direct client-server
        connections are not possible. When POP linking is used, the Registrar
        terminating the DTLS connection establishes a new TLS connection with
        the upstream CA. Thus, it is impossible for POP linking to be enforced
        end to end for the EST transaction. The EST server could be configured
        to accept POP linking information that does not match the current TLS
        session because the authenticated EST Registrar is assumed to have
        verified POP linking downstream to the client.</t>
        <t>The introduction of an EST-coaps-to-HTTP Registrar assumes the   
	    client can authenticate 
		the Registrar using its implicit or explicit TA database. It also assumes
		the Registrar has a trust relationship with the upstream EST server in order
		to act on behalf of the clients. When a client uses the Implicit TA
		database for certificate validation, it <bcp14>SHOULD</bcp14> confirm if the server
		is acting as an RA by the presence of the id-kp-cmcRA EKU 
		<xref target="RFC6402" format="default"/> in the server certificate. </t>

	  <t>In a server-side key generation case, if no end-to-end encryption
	  is used, the Registrar may be able see the private key as it acts as
	  a man in the middle.  Thus, the client puts its trust on the
	  Registrar not exposing the private key. </t>
        <t>Clients that leverage server-side key generation without end-to-end
        encryption of the private key (<xref target="serverkey"
        format="default"/>) have no knowledge as to whether the Registrar will be
        generating the private key and enrolling the certificates with the CA
        or if the CA will be responsible for generating the key.  In such
        cases, the existence of a Registrar requires the client to put its
        trust on the Registrar when it is generating the private key. </t>
      </section>

  </section>


</middle>
  <back>


<displayreference target="I-D.ietf-kitten-tls-channel-bindings-for-tls13"  to="TLS13-CHANNEL-BINDINGS"/>
<displayreference target="I-D.moskowitz-ecdsa-pki" to="PKI-GUIDE"/>
<references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2585.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5246.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5958.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5967.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6347.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6690.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7030.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7252.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7925.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7959.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8075.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8422.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8446.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.9147.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8710.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8551.xml"/>



      </references>
      <references>
        <name>Informative References</name>

        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5272.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6402.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7230.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7228.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7251.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7299.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7627.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4919.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5929.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7748.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.9146.xml"/>
        <xi:include href="https://datatracker.ietf.org/doc/bibxml3/reference.I-D.moskowitz-ecdsa-pki-10.xml"/>
		
		<xi:include href="https://datatracker.ietf.org/doc/bibxml3/reference.I-D.ietf-kitten-tls-channel-bindings-for-tls13.xml"/>

<referencegroup anchor="BCP195" target="https://www.rfc-editor.org/info/bcp195">
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7525.xml"/>
</referencegroup>

        <reference anchor="IEEE802.15.4">
          <front>
            <title>IEEE 802.15.4-2020 - IEEE Standard for Low-Rate Wireless
            Networks</title>
            <author>
	      <organization>IEEE</organization>
        </author>
            <date month="May" year="2020"/>
          </front>
        </reference>

        <reference anchor="IEEE802.1AR">
          <front>
            <title>IEEE Standard for Local and metropolitan area networks -
	    Secure Device Identity</title>
            <author>
<organization>IEEE
</organization>
        </author>
            <date month="December" year="2009"/>
          </front>
        </reference>

        <reference anchor="PsQs">
          <front>
            <title>Mining Your Ps and Qs: Detection of Widespread Weak Keys in Network Devices</title>
<author initials="N." surname="Heninger" fullname="Nadia Heninger"/>
<author initials="Z." surname="Durumeric" fullname="Zakir Durumeric"/>
<author initials="E." surname="Wustrow" fullname="Eric Wustrow"/>
<author initials="J." surname="Alex Halderman" fullname="J. Alex Halderman"/>
            <date month="August" year="2012"/>
          </front>
            <refcontent>USENIX Security Symposium 2012</refcontent>
            <seriesInfo name="ISBN" value="978-931971-95-9"/>
        </reference>

        <reference anchor="TRIPLESHAKE">
          <front>
            <title>Triple Handshakes and Cookie Cutters: Breaking and Fixing Authentication over TLS</title>

<author initials="B." surname="Bhargavan" fullname="Karthikeyan Bhargavan"/>
<author initials="A." surname="Delignat-Lavaud" fullname="Antoine Delignat-Lavaud"/>
<author initials="C." surname="Fournet" fullname="Cedric Fournet"/>
<author initials="A." surname="Pironti" fullname="Alfredo Pironti"/>
<author initials="P." surname="Strub" fullname="Pierre-Yves Strub"/>
            <date month="May" year="2014"/>
          </front>
<seriesInfo name="ISBN" value="978-1-4799-4686-0"/>
<seriesInfo name="DOI" value="10.1109/SP.2014.14"/>
        </reference>


        <reference anchor="RSA-FACT">
          <front>
            <title>Factoring RSA keys from certified smart cards: Coppersmith in the wild</title>
<author initials="D." surname="Bernstein" fullname="Daniel J. Bernstein"/>
<author initials="Y." surname="Chang" fullname="Yun-An Chang"/>
<author initials="C." surname="Cheng" fullname="Chen-Mou Cheng"/>
<author initials="L." surname="Chou" fullname="Li-Ping Chou"/>
<author initials="N." surname="Heninger" fullname="Nadia Heninger"/>
<author initials="T." surname="Lange" fullname="Tanja Lange"/>
<author initials="N." surname="Someren" fullname="Nicko van Someren"/>
            <date month="August" year="2013"/>
          </front>
<refcontent>Advances in Cryptology - ASIACRYPT 2013</refcontent>
        </reference>

        <reference anchor="CORE-PARAMS" target="https://www.iana.org/assignments/core-parameters/">
          <front>
            <title>Constrained RESTful Environments (CoRE) Parameters</title>
            <author>
<organization>IANA</organization>
</author>
          </front>
        </reference>

      </references>
    </references>
    <section anchor="messagebindings" numbered="true" toc="default">
      <name>EST Messages to EST-coaps</name>
      <t>This section shows similar examples to the ones presented in <xref
      target="RFC7030" sectionFormat="of" section="A"/>. The payloads in the
      examples are the hex-encoded binary, generated with 'xxd -p', of the PKI
      certificates created following <xref target="I-D.moskowitz-ecdsa-pki"
      format="default"/>. Hex is used for visualization purposes because a
      binary representation cannot be rendered well in text.  The hexadecimal
      representations would not be transported in hex, but in binary.  The
      payloads are shown unencrypted. In practice, the message content would be
      transferred over an encrypted DTLS channel. </t>

    <t>The certificate responses included in the examples contain
    Content-Format 281 (application/pkcs7). If the client had requested
    Content-Format 287 (application/pkix-cert), the server would respond with
    a single DER binary certificate. That certificate would be in a
    multipart-core container specifically in the case of a response to a
    /est/skc query.</t>

      <t>These examples assume a short resource path of "/est". Even though
      omitted from the examples for brevity, before making the EST-coaps
      requests, a client would learn about the server supported EST-coaps
      resources with a GET request for /.well-known/core?rt=ace.est* as
      explained in <xref target="discovery" format="default"/>.</t>
      <t>The corresponding CoAP headers are only shown in <xref target="cacerts" format="default"/>.
	Creating CoAP headers is assumed to be generally understood.</t>

      <t>The message content is presented in plain text in <xref
      target="cont_breakdown" format="default"/>.</t>
      <section anchor="cacerts" numbered="true" toc="default">
        <name>cacerts</name>
        <t>In EST-coaps, a cacerts message can be the following:</t>

<artwork><![CDATA[
GET example.com:9085/est/crts
(Accept:  281)
]]></artwork>

        <t>The corresponding CoAP header fields are shown below. The use of
        block and DTLS are shown in <xref target="blockexamples"
        format="default"/>.</t>

<sourcecode type="coap"><![CDATA[
  Ver = 1
  T = 0 (CON)
  Code = 0x01 (0.01 is GET)
  Token = 0x9a (client generated)
  Options
  Option (Uri-Host) 
     Option Delta = 0x3  (option# 3)
     Option Length = 0xB
     Option Value = "example.com"
  Option (Uri-Port) 
     Option Delta = 0x4  (option# 3+4=7)
     Option Length = 0x2
     Option Value = 9085
   Option (Uri-Path)
     Option Delta = 0x4   (option# 7+4=11)
     Option Length = 0x3
     Option Value = "est"
   Option (Uri-Path)
     Option Delta = 0x0   (option# 11+0=11)
     Option Length = 0x4
     Option Value = "crts"
   Option (Accept)
     Option Delta = 0x6   (option# 11+6=17)
     Option Length = 0x2
     Option Value = 281 
  Payload = [Empty]
]]></sourcecode>
        <t>As specified in <xref target="RFC7252" sectionFormat="of"
        section="5.10.1"/>, the Uri-Host and Uri-Port Options can be omitted
        if they coincide with the transport protocol destination address and
        port, respectively.</t>

      <t>A 2.05 Content response with a cert in EST-coaps will then be the following:</t>
<artwork><![CDATA[
2.05 Content (Content-Format: 281)
   {payload with certificate in binary format}
]]></artwork>
        <t>With the following CoAP fields:</t>

<sourcecode type="coap"><![CDATA[
  Ver = 1
  T = 2 (ACK)
  Code = 0x45 (2.05 Content)
  Token = 0x9a   (copied from request by server)
  Options
    Option (Content-Format)
      Option Delta = 0xC  (option# 12)
      Option Length = 0x2
      Option Value = 281

  [ The hexadecimal representation below would NOT be transported
  in hex, but in binary. Hex is used because a binary representation
  cannot be rendered well in text. ]

  Payload =
3082027a06092a864886f70d010702a082026b308202670201013100300b
06092a864886f70d010701a082024d30820249308201efa0030201020208
0b8bb0fe604f6a1e300a06082a8648ce3d0403023067310b300906035504
0613025553310b300906035504080c024341310b300906035504070c024c
4131143012060355040a0c0b4578616d706c6520496e6331163014060355
040b0c0d63657274696669636174696f6e3110300e06035504030c07526f
6f74204341301e170d3139303133313131323730335a170d333930313236
3131323730335a3067310b3009060355040613025553310b300906035504
080c024341310b300906035504070c024c4131143012060355040a0c0b45
78616d706c6520496e6331163014060355040b0c0d636572746966696361
74696f6e3110300e06035504030c07526f6f742043413059301306072a86
48ce3d020106082a8648ce3d030107034200040c1b1e82ba8cc72680973f
97edb8a0c72ab0d405f05d4fe29b997a14ccce89008313d09666b6ce375c
595fcc8e37f8e4354497011be90e56794bd91ad951ab45a3818430818130
1d0603551d0e041604141df1208944d77b5f1d9dcb51ee244a523f3ef5de
301f0603551d230418301680141df1208944d77b5f1d9dcb51ee244a523f
3ef5de300f0603551d130101ff040530030101ff300e0603551d0f0101ff
040403020106301e0603551d110417301581136365727469667940657861
6d706c652e636f6d300a06082a8648ce3d040302034800304502202b891d
d411d07a6d6f621947635ba4c43165296b3f633726f02e51ecf464bd4002
2100b4be8a80d08675f041fbc719acf3b39dedc85dc92b3035868cb2daa8
f05db196a1003100
]]></sourcecode>
        <t>The payload is shown in plain text in <xref target="cacertsdis"
        format="default"/>. </t>
      </section>


    <section numbered="true" toc="default">
        <name>enroll / reenroll</name>

<t>
	    During the (re-)enroll exchange, the EST-coaps client uses a CSR
	    (Content-Format 286) request in the POST request payload.  The
	    Accept Option tells the server that the client is expecting
	    Content-Format 281 (PKCS #7) in the response.  As shown in <xref
	    target="enrolldis" format="default"/>, the CSR contains a
	    challengePassword, which is used for POP linking (<xref
	    target="profile7925" format="default"/>).
        </t>
<artwork><![CDATA[
POST [2001:db8::2:321]:61616/est/sen
(Token: 0x45) 
(Accept: 281)
(Content-Format: 286)

[ The hexadecimal representation below would NOT be transported
in hex, but in binary. Hex is used because a binary representation
cannot be rendered well in text. ]

3082018b30820131020100305c310b3009060355040613025553310b3009
06035504080c024341310b300906035504070c024c413114301206035504
0a0c0b6578616d706c6520496e63310c300a060355040b0c03496f54310f
300d060355040513065774313233343059301306072a8648ce3d02010608
2a8648ce3d03010703420004c8b421f11c25e47e3ac57123bf2d9fdc494f
028bc351cc80c03f150bf50cff958d75419d81a6a245dffae790be95cf75
f602f9152618f816a2b23b5638e59fd9a073303406092a864886f70d0109
0731270c2576437630292a264a4b4a3bc3a2c280c2992f3e3c2e2c3d6b6e
7634332323403d204e787e60303b06092a864886f70d01090e312e302c30
2a0603551d1104233021a01f06082b06010505070804a013301106092b06
010401b43b0a01040401020304300a06082a8648ce3d0403020348003045
02210092563a546463bd9ecff170d0fd1f2ef0d3d012160e5ee90cffedab
ec9b9a38920220179f10a3436109051abad17590a09bc87c4dce5453a6fc
1135a1e84eed754377
]]></artwork>
        <t>
	    After verification of the CSR by the server, a 2.04 Changed response
		with the issued certificate will be returned to the client. 
        </t>
<artwork><![CDATA[
2.04 Changed 
(Token: 0x45)
(Content-Format: 281)

[ The hexadecimal representation below would NOT be transported
in hex, but in binary. Hex is used because a binary representation
cannot be rendered well in text. ]

3082026e06092a864886f70d010702a082025f3082025b0201013100300b
06092a864886f70d010701a08202413082023d308201e2a0030201020208
7e7661d7b54e4632300a06082a8648ce3d040302305d310b300906035504
0613025553310b300906035504080c02434131143012060355040a0c0b45
78616d706c6520496e6331163014060355040b0c0d636572746966696361
74696f6e3113301106035504030c0a3830322e3141522043413020170d31
39303133313131323931365a180f39393939313233313233353935395a30
5c310b3009060355040613025553310b300906035504080c024341310b30
0906035504070c024c4131143012060355040a0c0b6578616d706c652049
6e63310c300a060355040b0c03496f54310f300d06035504051306577431
3233343059301306072a8648ce3d020106082a8648ce3d03010703420004
c8b421f11c25e47e3ac57123bf2d9fdc494f028bc351cc80c03f150bf50c
ff958d75419d81a6a245dffae790be95cf75f602f9152618f816a2b23b56
38e59fd9a3818a30818730090603551d1304023000301d0603551d0e0416
041496600d8716bf7fd0e752d0ac760777ad665d02a0301f0603551d2304
183016801468d16551f951bfc82a431d0d9f08bc2d205b1160300e060355
1d0f0101ff0404030205a0302a0603551d1104233021a01f06082b060105
05070804a013301106092b06010401b43b0a01040401020304300a06082a
8648ce3d0403020349003046022100c0d81996d2507d693f3c48eaa5ee94
91bda6db214099d98117c63b361374cd86022100a774989f4c321a5cf25d
832a4d336a08ad67df20f1506421188a0ade6d349236a1003100
]]></artwork>
        <t>The request and response is shown in plain text in <xref
        target="enrolldis" format="default"/>.</t>
	  
    </section>


    <section anchor="appskg" numbered="true" toc="default">
        <name>serverkeygen</name>
        <t>In a serverkeygen exchange, the CoAP POST request looks like the following:</t>
<artwork><![CDATA[
POST 192.0.2.1:8085/est/skg
(Token: 0xa5)
(Accept: 62)
(Content-Format: 286)

[ The hexadecimal representation below would NOT be transported
in hex, but in binary. Hex is used because a binary representation
cannot be rendered well in text. ]

3081d03078020100301631143012060355040a0c0b736b67206578616d70
6c653059301306072a8648ce3d020106082a8648ce3d03010703420004c8
b421f11c25e47e3ac57123bf2d9fdc494f028bc351cc80c03f150bf50cff
958d75419d81a6a245dffae790be95cf75f602f9152618f816a2b23b5638
e59fd9a000300a06082a8648ce3d040302034800304502207c553981b1fe
349249d8a3f50a0346336b7dfaa099cf74e1ec7a37a0a760485902210084
79295398774b2ff8e7e82abb0c17eaef344a5088fa69fd63ee611850c34b
0a
]]></artwork>
        <t>The response would follow <xref target="RFC8710" format="default"/> and could look like the following:</t>
<artwork><![CDATA[
2.04 Changed 
(Token: 0xa5)
(Content-Format: 62)

[ The hexadecimal representations below would NOT be transported
in hex, but in binary. Hex is used because a binary representation
cannot be rendered well in text. ]

84                                   # array(4)
19 011C                              # unsigned(284)
58 8A                                # bytes(138)
308187020100301306072a8648ce3d020106082a8648ce3d030107046d30
6b020101042061336a86ac6e7af4a96f632830ad4e6aa0837679206094d7
679a01ca8c6f0c37a14403420004c8b421f11c25e47e3ac57123bf2d9fdc
494f028bc351cc80c03f150bf50cff958d75419d81a6a245dffae790be95
cf75f602f9152618f816a2b23b5638e59fd9
19 0119                              # unsigned(281)
59 01D3                              # bytes(467)
308201cf06092a864886f70d010702a08201c0308201bc0201013100300b
06092a864886f70d010701a08201a23082019e30820144a0030201020209
00b3313e8f3fc9538e300a06082a8648ce3d040302301631143012060355
040a0c0b736b67206578616d706c65301e170d3139303930343037343430
335a170d3339303833303037343430335a301631143012060355040a0c0b
736b67206578616d706c653059301306072a8648ce3d020106082a8648ce
3d03010703420004c8b421f11c25e47e3ac57123bf2d9fdc494f028bc351
cc80c03f150bf50cff958d75419d81a6a245dffae790be95cf75f602f915
2618f816a2b23b5638e59fd9a37b307930090603551d1304023000302c06
096086480186f842010d041f161d4f70656e53534c2047656e6572617465
64204365727469666963617465301d0603551d0e0416041496600d8716bf
7fd0e752d0ac760777ad665d02a0301f0603551d2304183016801496600d
8716bf7fd0e752d0ac760777ad665d02a0300a06082a8648ce3d04030203
48003045022100e95bfa25a08976652246f2d96143da39fce0dc4c9b26b9
cce1f24164cc2b12b602201351fd8eea65764e3459d324e4345ff5b2a915
38c04976111796b3698bf6379ca1003100
]]></artwork>
        <t>The private key in the response above is without CMS EnvelopedData
	  and has no additional encryption beyond DTLS (<xref target="serverkey" format="default"/>).</t>
          <t>The request and response is shown in plain text in <xref
          target="disskgrequest" format="default"/>.</t>
      </section>

	
    <section numbered="true" toc="default">
        <name>csrattrs</name>
        <t>The following is a csrattrs exchange:</t>
<artwork><![CDATA[
REQ:
GET example.com:61616/est/att

RES:
2.05 Content 
(Content-Format: 285)

[ The hexadecimal representation below would NOT be transported
in hex, but in binary. Hex is used because a binary representation
cannot be rendered well in text. ]

307c06072b06010101011630220603883701311b131950617273652053455
420617320322e3939392e31206461746106092a864886f70d010907302c06
0388370231250603883703060388370413195061727365205345542061732
0322e3939392e32206461746106092b240303020801010b06096086480165
03040202
]]></artwork>

      <t>A 2.05 Content response should contain attributes that are
        relevant for the authenticated client. This example is copied from
        <xref target="RFC7030" sectionFormat="of" section="A.2"/>, where the
        base64 representation is replaced with a hexadecimal representation of
        the equivalent binary format.  The EST-coaps server returns attributes
        that the client can ignore if they are unknown to the client.</t>
      </section>

  </section>


  <section anchor="blockexamples" numbered="true" toc="default">
      <name>EST-coaps Block Message Examples</name>
      <t>Two examples are presented in this section:
      </t>
      <ol spacing="normal" type="1">
        <li>A cacerts exchange shows the use of Block2 and the block headers.</li>
        <li>An enroll exchange shows the Block1 and Block2 size negotiation
        for request and response payloads.</li>
      </ol>
      <t>The payloads are shown unencrypted. In practice, the message contents
	would be binary formatted and transferred over an encrypted DTLS tunnel.
	The corresponding CoAP headers are only shown in <xref target="cacertsblock" format="default"/>.
	Creating CoAP headers is assumed to be generally known.</t>
      <section anchor="cacertsblock" numbered="true" toc="default">
        <name>cacerts</name>

        <t>This section provides a detailed example of the messages using DTLS
        and CoAP Option Block2. The example block length is taken as 64,
        which gives an SZX value of 2.</t>
        <t>The following is an example of a cacerts exchange over DTLS. The
        content length of the cacerts response in <xref target="RFC7030"
        sectionFormat="of" section="A.1"/> contains 639 bytes in binary in
        this example. The CoAP message adds around 10 bytes in this example,
        and the DTLS record around 29 bytes. To avoid IP fragmentation, the
        CoAP Block Option is used and an MTU of 127 is assumed to stay within
        one IEEE 802.15.4 packet. To stay below the MTU of 127, the payload is
        split in 9 packets with a payload of 64 bytes each, followed by a
        last tenth packet of 63 bytes. The client sends an IPv6 packet
        containing a UDP datagram with DTLS record protection that
        encapsulates a CoAP request 10 times (one fragment of the request per
        block). The server returns an IPv6 packet containing a UDP datagram
        with the DTLS record that encapsulates the CoAP response. The CoAP
        request-response exchange with block option is shown below. Block
        Option is shown in a decomposed way (block-option:NUM/M/size)
        indicating the kind of Block Option (2 in this case) followed by a
        colon, and then the block number (NUM), the more bit (M = 0 in Block2
        response means it is last block), and block size with exponent
        (2<sup>(SZX+4)</sup>) separated by slashes.  The Length 64 is used with
        SZX=2. The CoAP Request is sent Confirmable (CON), and the
        Content-Format of the response, even though not shown, is 281
        (application/pkcs7-mime; smime-type=certs-only).  The transfer of the
        10 blocks with partially filled block NUM=9 is shown below.</t>


       <sourcecode type="coap"><![CDATA[
   GET example.com:9085/est/crts (2:0/0/64)  -->
                 <--   (2:0/1/64) 2.05 Content
   GET example.com:9085/est/crts (2:1/0/64)  -->
                 <--   (2:1/1/64) 2.05 Content
                               |
                               |
                               |
   GET example.com:9085/est/crts (2:9/0/64) -->
                 <--   (2:9/0/64) 2.05 Content
]]></sourcecode>
        <t>The header of the GET request looks like the following:</t>

<sourcecode type="coap"><![CDATA[
  Ver = 1
  T = 0 (CON)
  Code = 0x01 (0.1 GET)
  Token = 0x9a    (client generated)
  Options
   Option (Uri-Host) 
     Option Delta = 0x3  (option# 3)
     Option Length = 0xB
     Option Value = "example.com"
   Option (Uri-Port) 
     Option Delta = 0x4   (option# 3+4=7)
     Option Length = 0x2
     Option Value = 9085
   Option (Uri-Path)
     Option Delta = 0x4    (option# 7+4=11)
     Option Length = 0x3
     Option Value = "est"
   Option (Uri-Path)Uri-Path)
     Option Delta = 0x0    (option# 11+0=11)
     Option Length = 0x4
     Option Value = "crts"
   Option (Accept)
     Option Delta = 0x6   (option# 11+6=17)
     Option Length = 0x2
     Option Value = 281 
  Payload = [Empty]
]]></sourcecode>
        <t>The Uri-Host and Uri-Port Options can be omitted if they coincide
        with the transport protocol destination address and port,
        respectively. Explicit Uri-Host and Uri-Port Options are typically
        used when an endpoint hosts multiple virtual servers and uses the
        Options to route the requests accordingly. </t>

    <t>To provide further details on the CoAP headers, the first two and the last blocks are
	written out below. The header of the first Block2 response looks like the following:</t>

<sourcecode type="coap"><![CDATA[
  Ver = 1
  T = 2 (ACK)
  Code = 0x45 (2.05 Content)
  Token = 0x9a     (copied from request by server)
  Options
    Option
      Option Delta = 0xC  (option# 12 Content-Format)
      Option Length = 0x2
      Option Value = 281
    Option
      Option Delta = 0xB  (option# 12+11=23 Block2)
      Option Length = 0x1
      Option Value = 0x0A (block#=0, M=1, SZX=2)

  [ The hexadecimal representation below would NOT be transported
  in hex, but in binary. Hex is used because a binary representation
  cannot be rendered well in text. ]

  Payload =
3082027b06092a864886f70d010702a082026c308202680201013100300b
06092a864886f70d010701a082024e3082024a308201f0a0030201020209
009189bc
]]></sourcecode>
        <t>The header of the second Block2 response looks like the following:</t>

<sourcecode type="coap"><![CDATA[
  Ver = 1
  T = 2 (means ACK)
  Code = 0x45 (2.05 Content)
  Token = 0x9a     (copied from request by server)
  Options
    Option
      Option Delta = 0xC  (option# 12 Content-Format)
      Option Length = 0x2
      Option Value = 281
    Option
      Option Delta = 0xB  (option 12+11=23 Block2)
      Option Length = 0x1
      Option Value = 0x1A (block#=1, M=1, SZX=2)

  [ The hexadecimal representation below would NOT be transported
  in hex, but in binary. Hex is used because a binary representation
  cannot be rendered well in text. ]

  Payload =
df9c99244b300a06082a8648ce3d0403023067310b300906035504061302
5553310b300906035504080c024341310b300906035504070c024c413114
30120603
]]></sourcecode>
        <t>The header of the tenth and final Block2 response looks like the following:</t>


<sourcecode type="coap"><![CDATA[
  Ver = 1
  T = 2 (means ACK)
  Code = 0x45      (2.05 Content)
  Token = 0x9a     (copied from request by server)
  Options
    Option
      Option Delta = 0xC  (option# 12 Content-Format)
      Option Length = 0x2
      Option Value = 281
    Option
      Option Delta = 0xB  (option# 12+11=23 Block2 )
      Option Length = 0x1
      Option Value = 0x92 (block#=9, M=0, SZX=2)

  [ The hexadecimal representation below would NOT be transported
  in hex, but in binary. Hex is used because a binary representation
  cannot be rendered well in text. ]

  Payload =
2ec0b4af52d46f3b7ecc9687ddf267bcec368f7b7f1353272f022047a28a
e5c7306163b3c3834bab3c103f743070594c089aaa0ac870cd13b902caa1
003100
]]></sourcecode>
      </section>


    <section anchor="enrollblock" numbered="true" toc="default">
        <name>enroll / reenroll</name>
        <t>
      In this example, the requested Block2 size of 256 bytes, required by the
      client, is transferred to the server in the very first request
      message. The block size of 256 is equal to (2<sup>(SZX+4)</sup>), which
      gives SZX=4. The notation for block numbering is the same as in <xref
      target="cacertsblock" format="default"/>. The header fields and the
      payload are omitted for brevity.
        </t>

        <figure anchor="fig-est-multiple-block">
          <name>EST-coaps Enrollment with Multiple Blocks</name>
<artwork name="" type="" align="left" alt=""><![CDATA[
POST [2001:db8::2:1]:61616/est/sen (CON)(1:0/1/256) 
                   {CSR (frag# 1)} -->

       <-- (ACK) (1:0/1/256) (2.31 Continue)
POST [2001:db8::2:1]:61616/est/sen (CON)(1:1/1/256) 
                   {CSR (frag# 2)} -->
       <-- (ACK) (1:1/1/256) (2.31 Continue)
                      .
                      .
                      .
POST [2001:db8::2:1]:61616/est/sen (CON)(1:N1/0/256)
                   {CSR(frag# N1+1)}-->
                      |
    ...........Immediate response  .........
                      |
  <-- (ACK) (1:N1/0/256)(2:0/1/256)(2.04 Changed)
                   {Cert resp (frag# 1)}
POST [2001:db8::2:1]:61616/est/sen (CON)(2:1/0/256)           -->
  <-- (ACK) (2:1/1/256)(2.04 Changed) 
                   {Cert resp (frag# 2)}
                      .
                      .
                      .
POST [2001:db8::2:321]:61616/est/sen (CON)(2:N2/0/256)          -->
  <-- (ACK) (2:N2/0/256) (2.04 Changed) 
                   {Cert resp (frag# N2+1)}
]]></artwork>
        </figure>
        <t>N1+1 blocks have been transferred from client to server, and N2+1 blocks have been
	  transferred from server to client.</t>
      </section>

  </section>


  <section anchor="cont_breakdown" numbered="true" toc="default">
      <name>Message Content Breakdown</name>
      <t>This appendix presents the hexadecimal dumps of the binary payloads
      in plain text shown in <xref target="messagebindings"
      format="default"/>.
</t>
      <section anchor="cacertsdis" numbered="true" toc="default">
        <name>cacerts</name>
        <t>The cacerts response containing one root CA certificate is
        presented in plain text in the following: </t>


<sourcecode type="asn.1"><![CDATA[
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number: 831953162763987486 (0xb8bb0fe604f6a1e)
    Signature Algorithm: ecdsa-with-SHA256
        Issuer: C=US, ST=CA, L=LA, O=Example Inc, 
                  OU=certification, CN=Root CA
        Validity
            Not Before: Jan 31 11:27:03 2019 GMT
            Not After : Jan 26 11:27:03 2039 GMT
        Subject: C=US, ST=CA, L=LA, O=Example Inc,
                     OU=certification, CN=Root CA
        Subject Public Key Info:
            Public Key Algorithm: id-ecPublicKey
                Public-Key: (256 bit)
                pub: 
                    04:0c:1b:1e:82:ba:8c:c7:26:80:97:3f:97:ed:b8:
                    a0:c7:2a:b0:d4:05:f0:5d:4f:e2:9b:99:7a:14:cc:
                    ce:89:00:83:13:d0:96:66:b6:ce:37:5c:59:5f:cc:
                    8e:37:f8:e4:35:44:97:01:1b:e9:0e:56:79:4b:d9:
                    1a:d9:51:ab:45
                ASN1 OID: prime256v1
                NIST CURVE: P-256
        X509v3 extensions:
            X509v3 Subject Key Identifier:
1D:F1:20:89:44:D7:7B:5F:1D:9D:CB:51:EE:24:4A:52:3F:3E:F5:DE
            X509v3 Authority Key Identifier: 
                  keyid:
1D:F1:20:89:44:D7:7B:5F:1D:9D:CB:51:EE:24:4A:52:3F:3E:F5:DE

            X509v3 Basic Constraints: critical
                CA:TRUE
            X509v3 Key Usage: critical
                Certificate Sign, CRL Sign
            X509v3 Subject Alternative Name: 
                email:certify@example.com
    Signature Algorithm: ecdsa-with-SHA256
         30:45:02:20:2b:89:1d:d4:11:d0:7a:6d:6f:62:19:47:63:5b:
         a4:c4:31:65:29:6b:3f:63:37:26:f0:2e:51:ec:f4:64:bd:40:
         02:21:00:b4:be:8a:80:d0:86:75:f0:41:fb:c7:19:ac:f3:b3:
         9d:ed:c8:5d:c9:2b:30:35:86:8c:b2:da:a8:f0:5d:b1:96
]]></sourcecode>
      </section>


   <section anchor="enrolldis" numbered="true" toc="default">
        <name>enroll / reenroll</name>
        <t>The enrollment request is presented in plain text in the
        following:</t>
<sourcecode type="asn.1"><![CDATA[
Certificate Request:
    Data:
        Version: 0 (0x0)
        Subject: C=US, ST=CA, L=LA, O=example Inc,
                    OU=IoT/serialNumber=Wt1234
        Subject Public Key Info:
            Public Key Algorithm: id-ecPublicKey
                Public-Key: (256 bit)
                pub: 
                    04:c8:b4:21:f1:1c:25:e4:7e:3a:c5:71:23:bf:2d:
                    9f:dc:49:4f:02:8b:c3:51:cc:80:c0:3f:15:0b:f5:
                    0c:ff:95:8d:75:41:9d:81:a6:a2:45:df:fa:e7:90:
                    be:95:cf:75:f6:02:f9:15:26:18:f8:16:a2:b2:3b:
                    56:38:e5:9f:d9
                ASN1 OID: prime256v1
                NIST CURVE: P-256
        Attributes:
            challengePassword:   <256-bit POP linking value>
        Requested Extensions:
            X509v3 Subject Alternative Name: 
                othername:<unsupported>
    Signature Algorithm: ecdsa-with-SHA256
         30:45:02:21:00:92:56:3a:54:64:63:bd:9e:cf:f1:70:d0:fd:
         1f:2e:f0:d3:d0:12:16:0e:5e:e9:0c:ff:ed:ab:ec:9b:9a:38:
         92:02:20:17:9f:10:a3:43:61:09:05:1a:ba:d1:75:90:a0:9b:
         c8:7c:4d:ce:54:53:a6:fc:11:35:a1:e8:4e:ed:75:43:77
]]></sourcecode>
        <t>The CSR contains a challengePassword, which is used for POP linking
        (<xref target="profile7925" format="default"/>). The CSR also contains
        an id-on-hardwareModuleName hardware identifier to customize the
        returned certificate to the requesting device (See <xref
        target="RFC7299" format="default"/> and <xref
        target="I-D.moskowitz-ecdsa-pki" format="default"/>).</t>
        <t>The issued certificate presented in plain text in the following:</t>
<sourcecode type="asn.1"><![CDATA[
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number: 9112578475118446130 (0x7e7661d7b54e4632)
    Signature Algorithm: ecdsa-with-SHA256
        Issuer: C=US, ST=CA, O=Example Inc, 
                      OU=certification, CN=802.1AR CA
        Validity
            Not Before: Jan 31 11:29:16 2019 GMT
            Not After : Dec 31 23:59:59 9999 GMT
        Subject: C=US, ST=CA, L=LA, O=example Inc,
                OU=IoT/serialNumber=Wt1234
        Subject Public Key Info:
            Public Key Algorithm: id-ecPublicKey
                Public-Key: (256 bit)
                pub: 
                    04:c8:b4:21:f1:1c:25:e4:7e:3a:c5:71:23:bf:2d:
                    9f:dc:49:4f:02:8b:c3:51:cc:80:c0:3f:15:0b:f5:
                    0c:ff:95:8d:75:41:9d:81:a6:a2:45:df:fa:e7:90:
                    be:95:cf:75:f6:02:f9:15:26:18:f8:16:a2:b2:3b:
                    56:38:e5:9f:d9
                ASN1 OID: prime256v1
                NIST CURVE: P-256
        X509v3 extensions:
            X509v3 Basic Constraints: 
                CA:FALSE
            X509v3 Subject Key Identifier: 
96:60:0D:87:16:BF:7F:D0:E7:52:D0:AC:76:07:77:AD:66:5D:02:A0
            X509v3 Authority Key Identifier: 
                keyid:
68:D1:65:51:F9:51:BF:C8:2A:43:1D:0D:9F:08:BC:2D:20:5B:11:60

            X509v3 Key Usage: critical
                Digital Signature, Key Encipherment
            X509v3 Subject Alternative Name: 
                othername:<unsupported>
    Signature Algorithm: ecdsa-with-SHA256
         30:46:02:21:00:c0:d8:19:96:d2:50:7d:69:3f:3c:48:ea:a5:
         ee:94:91:bd:a6:db:21:40:99:d9:81:17:c6:3b:36:13:74:cd:
         86:02:21:00:a7:74:98:9f:4c:32:1a:5c:f2:5d:83:2a:4d:33:
         6a:08:ad:67:df:20:f1:50:64:21:18:8a:0a:de:6d:34:92:36
]]></sourcecode>
      </section>


   <section anchor="disskgrequest" numbered="true" toc="default">
        <name>serverkeygen</name>
        <t>The following is the server-side key generation request presented in plain text:</t>
<sourcecode type="asn.1"><![CDATA[
Certificate Request:
    Data:
        Version: 0 (0x0)
        Subject: O=skg example
        Subject Public Key Info:
            Public Key Algorithm: id-ecPublicKey
                Public-Key: (256 bit)
                pub: 
                    04:c8:b4:21:f1:1c:25:e4:7e:3a:c5:71:23:bf:2d:
                    9f:dc:49:4f:02:8b:c3:51:cc:80:c0:3f:15:0b:f5:
                    0c:ff:95:8d:75:41:9d:81:a6:a2:45:df:fa:e7:90:
                    be:95:cf:75:f6:02:f9:15:26:18:f8:16:a2:b2:3b:
                    56:38:e5:9f:d9
                ASN1 OID: prime256v1
                NIST CURVE: P-256
        Attributes:
            a0:00
    Signature Algorithm: ecdsa-with-SHA256
         30:45:02:20:7c:55:39:81:b1:fe:34:92:49:d8:a3:f5:0a:03:
         46:33:6b:7d:fa:a0:99:cf:74:e1:ec:7a:37:a0:a7:60:48:59:
         02:21:00:84:79:29:53:98:77:4b:2f:f8:e7:e8:2a:bb:0c:17:
         ea:ef:34:4a:50:88:fa:69:fd:63:ee:61:18:50:c3:4b:0a
]]></sourcecode>
        <t>The following is the private key content of the server-side key
        generation response presented in plain text: </t>


<artwork><![CDATA[
Private-Key: (256 bit)
priv:
    61:33:6a:86:ac:6e:7a:f4:a9:6f:63:28:30:ad:4e:
    6a:a0:83:76:79:20:60:94:d7:67:9a:01:ca:8c:6f:
    0c:37
pub: 
    04:c8:b4:21:f1:1c:25:e4:7e:3a:c5:71:23:bf:2d:
    9f:dc:49:4f:02:8b:c3:51:cc:80:c0:3f:15:0b:f5:
    0c:ff:95:8d:75:41:9d:81:a6:a2:45:df:fa:e7:90:
    be:95:cf:75:f6:02:f9:15:26:18:f8:16:a2:b2:3b:
    56:38:e5:9f:d9
ASN1 OID: prime256v1
NIST CURVE: P-256
]]></artwork>
        <t>The following is the certificate in the server-side key generation
        response payload presented in plain text:</t>


<sourcecode type="asn.1"><![CDATA[
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            b3:31:3e:8f:3f:c9:53:8e
    Signature Algorithm: ecdsa-with-SHA256
        Issuer: O=skg example
        Validity
            Not Before: Sep  4 07:44:03 2019 GMT
            Not After : Aug 30 07:44:03 2039 GMT
        Subject: O=skg example
        Subject Public Key Info:
            Public Key Algorithm: id-ecPublicKey
                Public-Key: (256 bit)
                pub: 
                    04:c8:b4:21:f1:1c:25:e4:7e:3a:c5:71:23:bf:2d:
                    9f:dc:49:4f:02:8b:c3:51:cc:80:c0:3f:15:0b:f5:
                    0c:ff:95:8d:75:41:9d:81:a6:a2:45:df:fa:e7:90:
                    be:95:cf:75:f6:02:f9:15:26:18:f8:16:a2:b2:3b:
                    56:38:e5:9f:d9
                ASN1 OID: prime256v1
                NIST CURVE: P-256
        X509v3 extensions:
            X509v3 Basic Constraints: 
                CA:FALSE
            Netscape Comment: 
                OpenSSL Generated Certificate
            X509v3 Subject Key Identifier: 
96:60:0D:87:16:BF:7F:D0:E7:52:D0:AC:76:07:77:AD:66:5D:02:A0
            X509v3 Authority Key Identifier: 
                keyid:
96:60:0D:87:16:BF:7F:D0:E7:52:D0:AC:76:07:77:AD:66:5D:02:A0

    Signature Algorithm: ecdsa-with-SHA256
         30:45:02:21:00:e9:5b:fa:25:a0:89:76:65:22:46:f2:d9:61:
         43:da:39:fc:e0:dc:4c:9b:26:b9:cc:e1:f2:41:64:cc:2b:12:
         b6:02:20:13:51:fd:8e:ea:65:76:4e:34:59:d3:24:e4:34:5f:
         f5:b2:a9:15:38:c0:49:76:11:17:96:b3:69:8b:f6:37:9c
]]></sourcecode>
      </section>


  </section>



  <section anchor="ack" numbered="false" toc="default">
      <name>Acknowledgements</name>
      <t>The authors are very grateful to <contact fullname="Klaus Hartke"/>
      for his detailed explanations on the use of Block with DTLS and his
      support for the Content-Format specification.  The authors would like to
      thank <contact fullname="Esko Dijk"/> and <contact fullname="Michael
      Verschoor"/> for the valuable discussions that helped in shaping the
      solution. They would also like to thank <contact fullname="Peter
      Panburana"/> for his feedback on technical details of the
      solution. Constructive comments were received from <contact
      fullname="Benjamin Kaduk"/>, <contact fullname="Eliot Lear"/>, <contact
      fullname="Jim Schaad"/>, <contact fullname="Hannes Tschofenig"/>,
      <contact fullname="Julien Vermillard"/>, <contact fullname="John
      Manuel"/>, <contact fullname="Oliver Pfaff"/>, <contact fullname="Pete
      Beal"/>, and <contact fullname="Carsten Bormann"/>.</t>
      <t>Interop tests were done by <contact fullname="Oliver Pfaff"/>,
      <contact fullname="Thomas Werner"/>, <contact fullname="Oskar Camezind"/>,
	<contact fullname="Bjorn Elmers"/>, and <contact fullname="Joel Hoglund"/>.</t>
      <t><contact fullname="Robert Moskowitz"/> provided code to create the examples.</t>
    </section>



  <section anchor="contrib" numbered="false" toc="default">
      <name>Contributors</name>

    <t><contact fullname="Martin Furuhed"/> contributed to the EST-coaps
    specification by providing feedback based on the Nexus EST-over-CoAPS
    server implementation that started in 2015.  <contact fullname="Sandeep
    Kumar"/> kick-started this specification and was instrumental in drawing
    attention to the importance of the subject. </t>
    </section>


</back>
</rfc>
