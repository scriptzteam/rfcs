<?xml version='1.0' encoding='UTF-8'?>

<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>

<rfc xmlns:xi="http://www.w3.org/2001/XInclude" category="std" docName="draft-ietf-mpls-ri-rsvp-frr-22" number="9705" ipr="pre5378Trust200902" submissionType="IETF" consensus="true" obsoletes="" updates="4090" tocInclude="true" tocDepth="4" symRefs="true" sortRefs="true" version="3" xml:lang="en" >

 <front>
   <title abbrev="RI-RSVP-FRR Bypass">Refresh-Interval Independent RSVP Fast Reroute Facility Protection</title>
    <seriesInfo name="RFC" value="9705"/>
    <author initials="C." surname="Ramachandran" fullname="Chandra Ramachandran">
      <organization>Juniper Networks, Inc.</organization>
      <address>
        <email>csekar@juniper.net</email>
      </address>
    </author>
    <author initials="T." surname="Saad" fullname="Tarek Saad">
      <organization>Cisco Systems, Inc.</organization>
      <address>
        <email>tsaad@cisco.com</email>
      </address>
    </author>
    <author initials="D." surname="Pacella" fullname="Dante Pacella">
      <organization>Verizon, Inc.</organization>
      <address>
        <email>dante.j.pacella@verizon.com</email>
      </address>
    </author>
    <date year="2025" month="March"/>

   <area>RTG</area>
    <workgroup>mpls</workgroup>
    <keyword>ri-rsvp-frr</keyword>
    <keyword>RI-RSVP-FRR</keyword>

  <abstract>
      <t>The RSVP-TE Fast Reroute (FRR) extensions specified in RFC 4090
      define two local repair techniques to reroute Label Switched Path (LSP)
      traffic over pre-established backup tunnels. Facility backup method
      allows one or more LSPs traversing a connected link or node to be
      protected using a bypass tunnel. The many-to-one nature of local repair
      technique is attractive from a scalability point of view. This document
      enumerates facility backup procedures in RFC 4090 that rely on refresh
      timeout, hence, making facility backup method refresh-interval
      dependent. The RSVP-TE extensions defined in this document will enhance
      the facility backup protection mechanism by making the corresponding
      procedures refresh-interval independent, and hence, compatible with the
      Refresh-Interval Independent RSVP (RI-RSVP) capability specified in RFC
      8370. Hence, this document updates RFC 4090 in order to support the
      RI-RSVP capability specified in RFC 8370.
      </t>
    </abstract>
  </front>

  <middle>
    <section anchor="intro">
      <name>Introduction</name>
      <t>RSVP-TE relies on a periodic refresh of RSVP messages to synchronize
      and maintain the states related to the Label Switched Path (LSP) along the
      reserved path. In the absence of refresh messages, the LSP-related
      states are automatically deleted. Reliance on periodic refreshes and
      refresh timeouts are problematic from the scalability point of view. The
      number of RSVP-TE LSPs that a router needs to maintain has been growing
      in service provider networks, and the implementations should be capable
      of handling increases in LSP scale.
      </t>
      <t><xref target="RFC2961"/> specifies mechanisms to eliminate the
      reliance on periodic refreshes and refresh timeouts of RSVP messages and
      enables a router to increase the message refresh interval to values much
      longer than the default 30 seconds defined in <xref
      target="RFC2205"/>. However, the protocol extensions defined in <xref
      target="RFC4090"/> for supporting Fast Reroute (FRR) using bypass
      tunnels implicitly rely on short refresh timeouts to clean up stale
      states.
      </t>
      <t>In order to eliminate the reliance on refresh timeouts, the routers
      should unambiguously determine when a particular LSP state should be
      deleted. In scenarios involving FRR using bypass tunnels <xref
      target="RFC4090"/>, additional explicit teardown messages are
      necessary. The Refresh-Interval Independent RSVP-TE FRR (RI-RSVP-FRR)
      extensions specified in this document consist of procedures to enable
      LSP state cleanup that are essential in supporting the RI-RSVP capability
      for FRR using bypass tunnels from <xref target="RFC4090"/>.
      </t>
      <section anchor="intro_motivation">
        <name>Motivation</name>

        <t>Base RSVP <xref target="RFC2205"/> maintains state via the
        generation of RSVP Path and Resv refresh messages. Refresh messages are
        used to both synchronize state between RSVP neighbors and to recover
        from lost RSVP messages. The use of Refresh messages to cover many
        possible failures has resulted in a number of operational problems.
        </t>
        <ul>
          <li>One problem relates to RSVP control plane scaling due to
          periodic refreshes of Path and Resv messages.</li>
	  <li>Another problem relates to the
          reliability and latency of RSVP signaling.</li>
          <li>An additional problem is the time to clean up the stale state
          after a tear message is lost. For more on these problems, see <xref
          target="RFC2961" sectionFormat="of" section="1"/>.</li>
	</ul>

        <t>The problems listed above adversely affect RSVP control plane
        scalability, and RSVP-TE <xref target="RFC3209"/> inherited these
        problems from standard RSVP. Procedures specified in <xref
        target="RFC2961"/> address the above-mentioned problems by eliminating
        dependency on refreshes for state synchronization and for recovering
        from lost RSVP messages, and also by eliminating dependency on refresh
        timeout for stale state cleanup. Implementing these procedures allows
        implementations to improve RSVP-TE control plane scalability. For more
        details on eliminating dependency on refresh timeouts for stale state
        cleanup, refer to <xref target="RFC8370" sectionFormat="of"
        section="3"/>.
        </t>

        <t>However, the facility backup protection procedures specified in 
     <xref target="RFC4090"/> do not fully address stale state cleanup as the 
     procedures depend on refresh timeouts for stale state cleanup. The 
     updated facility backup protection procedures specified in this document, 
     in combination with RSVP-TE Scaling Techniques <xref target="RFC8370"/>, 
     eliminate this dependency on refresh timeouts for stale state cleanup.
     </t>

        <t>The procedures specified in this document assume reliable delivery of 
     RSVP messages, as specified in <xref target="RFC2961"/>. Therefore, <xref target="RFC2961"/> is a prerequisite for this 
     document.
        </t>
      </section>
    </section>

    <section anchor="terms-abbrevs">
      <name>Abbreviations and Terminology</name>
        <t>
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>",
    "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL NOT</bcp14>",
    "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>",
    "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be
    interpreted as described in BCP&nbsp;14 <xref target="RFC2119"/> <xref
    target="RFC8174"/> when, and only when, they appear in all capitals, as
    shown here.
        </t>      
	<t>
	  In addition, the reader is expected to be familiar with the terminology in <xref
	  target="RFC2205"/>, <xref target="RFC3209"/>, <xref
	  target="RFC4090"/>, <xref target="RFC4558"/>, <xref
	  target="RFC8370"/>, and <xref target="RFC8796"/>.
	</t>

<section anchor="abbrevs">
  <name>Abbreviations</name>
      <dl>
	<dt>PHOP:</dt><dd>Previous-Hop (can refer to a router or node along the LSP)</dd>
	<dt>PPHOP:</dt><dd>Previous-Previous-Hop (can refer to a router or node along the LSP)</dd>
	<dt>NHOP:</dt><dd>Next-Hop (can refer to a router or node along the LSP)</dd>
	<dt>NNHOP:</dt><dd>Next-Next-Hop (can refer to a router or node along the LSP)</dd>
	<dt>PLR:</dt><dd>Point of Local Repair (can refer to a router as defined in <xref target="RFC4090"/>)</dd>
	<dt>MP:</dt><dd>Merge Point (can refer to a router as defined in <xref target="RFC4090"/>)</dd>
	<dt>LP-MP:</dt><dd>Link-Protecting Merge Point (can refer to a router or node at the tail of a Link-Protecting bypass tunnel</dd>
	<dt>NP-MP:</dt><dd>Node-Protecting Merge Point (can refer to a router or node at the tail of a Node-Protecting bypass tunnel</dd>
        <dt>PSB:</dt><dd>Path State Block</dd>
        <dt>RSB:</dt><dd>Reservation State Block</dd>
	<dt>RRO:</dt><dd>Record Route Object (as defined in <xref target="RFC3209"/>)</dd>
	<dt>TED:</dt><dd>Traffic Engineering Database</dd>
	<dt>RI-RSVP:</dt><dd>Refresh-Interval Independent RSVP (the set of procedures defined in <xref section="3" sectionFormat="of" target="RFC8370"/> to eliminate RSVP's reliance on periodic
	message refreshes)</dd>
	<dt>RI-RSVP-FRR:</dt><dd>Refresh-Interval Independent RSVP-TE FRR (the set of procedures defined in this document to eliminate 
	RSVP's reliance on periodic message refreshes when supporting facility backup 
	protection <xref target="RFC4090"/>)</dd>	
      </dl>
</section>
<section anchor="terms">
  <name>Terminology</name>
  <dl>
	<dt>B-SFRR-Ready:</dt><dd>Bypass Summary FRR Ready Extended ASSOCIATION object as defined
	in <xref target="RFC8796"/> and added by the PLR 
	for each protected LSP</dd>  
	<dt>Conditional PathTear:</dt><dd>A PathTear message containing a suggestion to a 
	receiving downstream router to retain the path state if the receiving router 
	is an NP-MP</dd>
	<dt>Remote PathTear:</dt><dd>A PathTear message sent from a PLR
	to the MP to delete the LSP state on the MP if the PLR had not previously sent the 
	backup path state reliably</dd>
	<dt>LSP state</dt><dd>The combination of "path state" maintained as a PSB and
        "reservation state" maintained as an RSB forms an individual LSP state on an
        RSVP-TE speaker</dd>
      </dl>
    </section>
  </section>
    <section anchor="prob_desc">
      <name>Problem Description</name>
      <figure anchor="example_network">
        <name>Example Topology</name>
        <artwork align="center"><![CDATA[
        E
      /   \
     /     \
    /       \
   /         \
  /           \
 /             \
A ----- B ----- C ----- D
        \             /
         \           /
          \         /
           \       /
            \     /
             \   /
               F
]]></artwork>
      </figure>

      <t>In the topology in <xref target="example_network"/>, consider a 
	large number of LSPs from A to D transiting B and C. Assume that refresh 
	interval has been configured to be as long as the order of minutes and 
	that refresh reduction extensions are enabled on all routers.
      </t>
      <t>In addition, assume that node protection has been configured for the LSPs 
	and the LSPs are protected by each router in the following way:
      </t>
      <ul>
	<li>A has made node protection available using bypass LSP A -&gt; E
	-&gt; C; A is the PLR and C is the NP-MP.</li>
	<li>B has made node protection available using bypass LSP B -&gt; F
	-&gt; D; B is the PLR and D is the NP-MP.</li>
	<li>C has made link protection available using bypass LSP C -&gt; B
	-&gt; F -&gt; D; C is the PLR and D is the LP-MP.</li>
     </ul>

      <t>
	In the above condition, assume that the B-C link fails. The following is
	the sequence of events that is expected to occur for all protected
	LSPs under normal conditions.
      </t>

      <ol type="Step %d.">
        <li anchor="step1">B performs a local repair and redirects LSP traffic over the bypass
        LSP B -&gt; F -&gt; D.</li>
	<li anchor="step2">B also creates a backup state for the LSP and triggers the sending of
	a backup LSP state to D over the bypass LSP B -&gt; F -&gt; D.</li>
	<li anchor="step3">D receives the backup LSP states and merges the backups with the
	protected LSPs.</li>
        <li anchor="step4">As the link on C, over which the LSP states are refreshed, has
        failed, C will no longer receive state refreshes. Consequently, the
        protected LSP states on C will time out and C will send the teardown
        messages for all LSPs. As each router should consider itself as an MP,
        C will time out the state only after waiting for an additional
        duration equal to the refresh timeout.</li>
      </ol>

      <t>While the above sequence of events has been described in <xref target="RFC4090"/>, 
	there are a few problems for which no mechanism has been specified 
	explicitly:
      </t>

      <ul>
        <li>If the protected LSP on C times out before D receives signaling
        for the backup LSP, then D would receive a PathTear from C prior to
        receiving signaling for the backup LSP, thus resulting in deleting the
        LSP state.  This would be possible at scale even with the default refresh
        time.</li>
        
        <li>If C is to keep state until its timeout upon the link failure,
        then with a long refresh interval, this may result in a large amount
        of stale state on C.  Alternatively, if C is to
        delete the state and send a PathTear to D upon the link failure, then this would result in
        deleting the state on D, thus deleting the LSP. D needs a reliable
        mechanism to determine whether or not it is an MP to overcome this
        problem.</li>
        
	<li>If head-end A attempts to tear down the LSP after <xref target="step1"
	format="none">Step 1</xref> but before <xref target="step2"
	format="none">Step 2</xref> of the above sequence, then B may receive
	the teardown message before <xref target="step2" format="none">Step
	2</xref> and delete the LSP state from its state database. If B
	deletes its state without informing D, with a long refresh interval, this
	could cause a (large) buildup of stale state on D.</li>

        <li>If B fails to perform a local repair in <xref target="step1" format="none">Step 1</xref>, then B will delete
        the LSP state from its state database without informing D. As B
        deletes its state without informing D, with a long refresh interval, this
        could cause a (large) buildup of stale state on D.</li>
      </ul>

      <t>The purpose of this document is to provide solutions to the above 
	problems, which will then make it practical to scale up to a large 
	number of protected LSPs in the network.
      </t>
    </section>

    <section anchor="solution">
      <name>Solution Aspects</name>
      <t>The solution consists of five parts:</t>
      <ol>
        <li>Utilize the MP determination mechanism specified in RSVP-TE Summary
        FRR <xref target="RFC8796"/> that enables the PLR to signal the
        availability of local protection to the MP. In addition, introduce PLR
        and MP procedures to establish a Node-ID-based Hello session between the
        PLR and the MP to detect router failures and to determine capability.
        See <xref target="sig_handshake"/> of this document for more
        details. This part of the solution reuses some of the extensions
        defined in <xref target="RFC8796"/> and <xref target="RFC8370"/>, and the subsequent
        subsections will list the extensions in these documents that are
        utilized in this document.</li>

        <li>Handle upstream link or node failures by cleaning up LSP states if
        the node has not found itself as an MP through the MP determination
        mechanism. See <xref target="failures"/> of this document for more
        details.</li>

        <li>Introduce extensions to enable a router to send a teardown
        message to the downstream router that enables the receiving router to
        conditionally delete its local LSP state.  See <xref
        target="cnd_path_tear"/> of this document for more details.</li>

        <li>Enhance facility backup protection by allowing a PLR to directly
        send a teardown message to the MP without requiring the PLR to either
        have a working bypass LSP or have already signaled the backup LSP
        state. See <xref target="rem_tear"/> of this document for more
        details.</li>

        <li>Introduce extensions to enable the above procedures to be backward
        compatible with routers along the LSP running implementations that
        do not support these procedures.  See <xref target="compatible"/> of
        this document for more details.</li>
      </ol>

      <section anchor="adv_capability">
        <name>Requirement for RFC 4090 Capable Nodes to Advertise the RI-RSVP Capability</name>
        <t>A node supporting facility backup protection <xref
        target="RFC4090"/> <bcp14>MUST NOT</bcp14> set the RI-RSVP flag (I-bit) that is defined in <xref target="RFC8370"
        sectionFormat="of" section="3.1"/> unless it supports all the extensions
        specified in the rest of this document.  Hence, this document updates
        <xref target="RFC4090"/> by defining extensions and additional
        procedures over facility backup protection <xref target="RFC4090"/> in
        order to advertise the RI-RSVP capability <xref
        target="RFC8370"/>. However, if a node supporting facility backup
        protection <xref target="RFC4090"/> does set the RI-RSVP capability (I-bit) but does not support all the extensions specified in the rest of
        this document, then it may result in lingering stale states due to the
        long refresh intervals recommended by <xref target="RFC8370"/>.  This
        can also disrupt normal Fast Reroute (FRR) operations.  <xref
        target="cap_bit_without_support"/> of this document delves into this in
        detail.
        </t>
      </section>
      <section anchor="sig_handshake">
        <name>Signaling Handshake Between PLR and MP</name>
        <section anchor="sig_plr_behavior">
          <name>PLR Behavior</name>
          <t>As per the facility backup procedures <xref target="RFC4090"/>, when 
	    an LSP becomes operational on a node and the "local protection desired" 
	    flag has been set in the SESSION_ATTRIBUTE object carried in the Path 
	    message corresponding to the LSP, then the node attempts to make local 
	    protection available for the LSP.
          </t>
	  <ul>            
            <li>If the "node protection desired" flag is set, then the node
            tries to become a PLR by attempting to create an NP-bypass LSP to
            the NNHOP node avoiding the NHOP node on a protected LSP. In
            case node protection could not be made available, the node
            attempts to create an LP-bypass LSP to the NHOP node avoiding only
            the link that the protected LSP takes to reach the NHOP.</li>
            <li>If the "node protection desired" flag is not set, then the PLR
            attempts to create an LP-bypass LSP to the NHOP node avoiding the
            link that the protected LSP takes to reach the NHOP.</li>
	  </ul>

          <t>With regard to the PLR procedures described above and specified
          in <xref target="RFC4090"/>, this document specifies the following
          additional procedures to support RI-RSVP <xref
          target="RFC8370"/>.</t>

	  <ul>            
            <li>While selecting the destination address of the bypass LSP, the
            PLR <bcp14>MUST</bcp14> select the router ID of the NNHOP or NHOP
            node from the Node-ID sub-object included in the RRO that is
            carried in the most recent Resv message corresponding to the
            LSP. If the MP has not included a Node-ID sub-object in the Resv
            RRO and if the PLR and the MP are in the same area, then the PLR
            may utilize the TED to determine the router ID corresponding to
            the interface address that is included by the MP in the RRO. If the
            NP-MP in a different IGP area has not included a Node-ID
            sub-object in the RRO, then the PLR <bcp14>MUST</bcp14> execute
            backward compatibility procedures as if the downstream nodes along
            the LSP do not support the extensions defined in the document (see
            <xref target="dnstr_no_support"/>).</li>

            <li>The PLR <bcp14>MUST</bcp14> also include its router ID in a
            Node-ID sub-object in the RRO that is carried in any subsequent Path
            message corresponding to the LSP. While doing so, the
            PLR <bcp14>MUST</bcp14> include the Node-ID sub-object after
            including its IPv4/IPv6 address or unnumbered interface ID
            sub-object.</li>

<li>In parallel to the attempt made to create an NP-bypass or an
            LP-bypass, the PLR <bcp14>MUST</bcp14> initiate a Node-ID-based
            Hello session to the NNHOP or NHOP node respectively along the LSP
            to establish the RSVP-TE signaling adjacency. This Hello session
            is used to detect MP node failure as well as to determine the
            capability of the MP node. The
            PLR <bcp14>MUST</bcp14> conclude that the MP supports the refresh-interval independent FRR procedures defined in this
            document if the MP has set the I-bit in the
            CAPABILITY object <xref target="RFC8370"/> carried in the Hello
            message corresponding to the Node-ID-based Hello session.
            If the MP has not sent Node-ID-based Hello messages or
            has not set the I-bit in the CAPABILITY object <xref
            target="RFC8370"/>, then the PLR <bcp14>MUST</bcp14> execute
            backward compatibility procedures defined in <xref
            target="dnstr_no_support"/> of this document.</li>
            <li>When the PLR associates a bypass to a protected LSP, it
            <bcp14>MUST</bcp14> include a B-SFRR-Ready Extended ASSOCIATION
            object <xref target="RFC8796"/> and trigger a Path message to be
            sent for the LSP. If a B-SFRR-Ready Extended ASSOCIATION object is
            included in the Path message corresponding to the LSP, the
            encoding and object ordering rules specified in RSVP-TE Summary
            FRR <xref target="RFC8796"/> <bcp14>MUST</bcp14> be followed. In
            addition to those rules, the PLR <bcp14>MUST</bcp14> set the
            Association Source in the object to its Node-ID address.</li>
	  </ul>
        </section>
        <section anchor="sig_rem_adjacency">
          <name>Remote Signaling Adjacency</name>
          <t>A Node-ID-based RSVP-TE Hello session is one in which a Node-ID is 
	   used in the source and the destination address fields of RSVP Hello 
	   messages <xref target="RFC4558"/>. This document extends Node-ID-based 
	   RSVP Hello sessions to track the state of any RSVP-TE neighbor that is 
	   not directly connected by at least one interface. In order to apply 
	   Node-ID-based RSVP-TE Hello sessions between any two routers that are 
	   not immediate neighbors, the router that supports the extensions 
	   defined in the document <bcp14>MUST</bcp14> set the TTL to 255 in all outgoing 
	   Node-ID-based Hello messages exchanged between the PLR and the MP. The 
	   default hello interval for this Node-ID Hello session <bcp14>MUST</bcp14> be set 
	   to the default specified in RSVP-TE Scaling Techniques 
	   <xref target="RFC8370"/>.
          </t>
          <t>In the rest of the document, the terms "signaling adjacency" 
	    and "remote signaling adjacency" refer specifically to the 
	    RSVP-TE signaling adjacency.
          </t>
        </section>
        <section anchor="sig_mp_behavior">
          <name>MP Behavior</name>
          <t>With regard to the MP procedures that are defined in 
	   <xref target="RFC4090"/>, this document specifies the following 
	   additional procedures to support RI-RSVP as defined in 
	   <xref target="RFC8370"/>.
          </t>
          <t>Each node along an LSP supporting the extensions defined in 
	   this document <bcp14>MUST</bcp14> also include its router ID in the Node-ID 
	   sub-object of the RRO that is carried in the Resv message of the 
	   corresponding LSP. If the PLR has not included a Node-ID sub-object 
	   in the RRO that is carried in the Path message and if the PLR is in 
	   a different IGP area, then the router <bcp14>MUST NOT</bcp14> execute the MP 
	   procedures specified in this document for those LSPs. Instead, the 
	   node <bcp14>MUST</bcp14> execute backward compatibility procedures defined in 
	   <xref target="upstr_no_support"/> of this document as if the upstream nodes along 
	   the LSP do not support the extensions defined in this document.
          </t>

          <t>A node receiving a Path message should determine:</t>
	  <ul>
	   <li>whether the message contains a B-SFRR-Ready Extended
	   ASSOCIATION object with its own address as the bypass destination
	   address and</li>
	   <li>whether it has an operational Node-ID signaling adjacency with
	   the Association Source.</li>
	   </ul>

<t>The node <bcp14>MUST</bcp14> execute the 
	   backward compatibility procedures defined in 
<xref target="upstr_no_support"/> of this document if:</t>
<ul>
<li>the PLR has not included the B-SFRR-Ready Extended 
ASSOCIATION object,</li>
<li>there is no operational Node-ID signaling 
	   adjacency with the PLR identified by the Association Source address, or</li> 
	   <li>the PLR has not advertised the RI-RSVP capability in its 
	   Node-ID-based Hello messages.</li>
          </ul>
          <t>If a matching B-SFRR-Ready Extended ASSOCIATION object is found
          in the Path message and if there is an operational remote Node-ID
          signaling adjacency with the PLR (identified by the Association
          Source) that has advertised the RI-RSVP capability (I-bit) <xref
          target="RFC8370"/>, then the node <bcp14>MUST</bcp14> consider
          itself as the MP for the PLR. The matching and ordering rules for
          Bypass Summary FRR Extended Association specified in RSVP-TE Summary
          FRR <xref target="RFC8796"/> <bcp14>MUST</bcp14> be followed by the
          implementations supporting this document.
          </t>
	  <ul>
	    <li>If a matching Bypass Summary FRR Extended Association object
	    is included by the PPHOP node of an LSP and if a corresponding
	    Node-ID signaling adjacency exists with the PPHOP node, then the
	    router <bcp14>MUST</bcp14> conclude it is the NP-MP.</li>
            <li>If a matching Bypass Summary FRR Extended Association object
            is included by the PHOP node of an LSP and if a corresponding
            Node-ID signaling adjacency exists with the PHOP node, then the
            router <bcp14>MUST</bcp14> conclude it is the LP-MP.</li>
	  </ul>
        </section>

        <section anchor="sig_rem_state">
          <name>"Remote" State on MP</name>
          <t>Once a router concludes it is the MP for a PLR running
          refresh-interval independent FRR procedures as described in the
          preceding section, it <bcp14>MUST</bcp14> create a remote path state
          for the LSP.  The only difference between the "remote" path state
          and the LSP state is the RSVP_HOP object. The RSVP_HOP object in a
          "remote" path state contains the address that the PLR uses to send
          Node-ID Hello messages to the MP.
          </t>
          <t>The MP <bcp14>MUST</bcp14> consider the "remote" path state corresponding 
	    to the LSP automatically deleted if:
          </t>
	  <ul>
	    <li>the MP later receives a Path message for the LSP with no
	    matching B-SFRR-Ready Extended ASSOCIATION object corresponding to
	    the PLR's IP address contained in the Path RRO,</li>
            <li>the Node-ID signaling adjacency with the PLR goes down,</li>
            <li>the MP receives backup LSP signaling for the LSP from the PLR,</li>
            <li>the MP receives a PathTear for the LSP, or</li>
            <li>the MP deletes the LSP state on a local policy or an exception event.</li>
          </ul>
          <t>The purpose of "remote" path state is to enable the PLR 
	    to explicitly tear down the path and reservation states corresponding 
	    to the LSP by sending a tear message for the "remote" path 
	    state. Such a message tearing down the "remote" path state is 
	    called "Remote" PathTear.
          </t>
          <t>The scenarios in which a "Remote" PathTear is applied are 
	    described in <xref target="rem_tear"/> of this document.
          </t>
        </section>
      </section>
      <section anchor="failures">
        <name>Impact of Failures on LSP State</name>
        <t>This section describes the procedures that must be executed upon 
	  different kinds of failures by nodes along the path of the LSP. The 
	  procedures that must be executed upon detecting RSVP signaling adjacency 
	  failures do not impact the RSVP-TE graceful restart mechanisms 
	  <xref target="RFC3473"/> <xref target="RFC5063"/>. If a node  
	  executing these procedures acts as a helper for a neighboring router, 
	  then the signaling adjacency with the neighbor will be declared as having 
	  failed only after taking into account the grace period extended for the 
	  neighbor by this node acting as a helper.
        </t>
        <t>Node failures are detected from the state of Node-ID Hello 
	  sessions established with immediate neighbors. RSVP-TE Scaling 
	  Techniques <xref target="RFC8370"/> recommends that each node 
	  establish Node-ID Hello sessions with all its immediate neighbors. 
	  A non-immediate PLR or MP failure is detected from the state of remote 
	  signaling adjacency established according to 
	  <xref target="sig_rem_adjacency"/> of this document.
        </t>
        <section anchor="failures_nonmp">
          <name>Non-MP Behavior</name>
          <t>When a router detects the PHOP link or the PHOP node failure for an LSP 
	   and the router is not an MP for the LSP, then it <bcp14>MUST</bcp14> send a Conditional 
	   PathTear (refer to <xref target="cnd_path_tear"/> of this document)
	   and delete the PSB and RSB states corresponding to 
	   the LSP.
          </t>
        </section>
        <section anchor="failures_lpmp">
          <name>LP-MP Behavior</name>
          <t>When the PHOP link for an LSP fails on a router that is an LP-MP for 
	   the LSP, the LP-MP <bcp14>MUST</bcp14> retain the PSB and RSB states corresponding 
	   to the LSP until the occurrence of any of the following events:
          </t>
          <ul>
            <li>the Node-ID signaling adjacency with the PHOP PLR goes down,</li>
            <li>the MP receives a normal or "Remote" PathTear for its PSB, or</li>
            <li>the MP receives a ResvTear for its RSB.</li>
	  </ul>
          <t>When a router that is an LP-MP for an LSP detects PHOP node failure 
	   from the Node-ID signaling adjacency state, the LP-MP <bcp14>MUST</bcp14> send a normal 
	   PathTear and delete the PSB and RSB states corresponding to the LSP.
          </t>
        </section>

        <section anchor="failures_npmp">
          <name>NP-MP Behavior</name>
          <t>When a router that is an NP-MP for an LSP detects PHOP link failure
	   or PHOP node failure from the Node-ID signaling adjacency, the router 
	   <bcp14>MUST</bcp14> retain the PSB and RSB states corresponding to the LSP until the 
	   occurrence of any of the following events:
          </t>
	  <ul>
            <li>the remote Node-ID signaling adjacency with the PPHOP PLR goes down,</li>
            <li>the MP receives a normal or "Remote" PathTear for its PSB, or</li>
            <li>the MP receives a ResvTear for its RSB.</li>
          </ul>
          <t>When a router that is an NP-MP for an LSP does not detect the PHOP
          link or the PHOP node failure but receives a Conditional PathTear
          from the PHOP node, then the router <bcp14>MUST</bcp14> retain the
          PSB and RSB states corresponding to the LSP until the occurrence of
          any of the following events:
          </t>
	  <ul>
            <li>the remote Node-ID signaling adjacency with the PPHOP PLR goes down,</li>
            <li>the MP receives a normal or "Remote" PathTear for its PSB, or</li>
            <li>the MP receives a ResvTear for its RSB.</li>
          </ul>
          <t>Receiving a Conditional PathTear from the PHOP node will not
          impact the "remote" state from the PPHOP PLR. Note that the PHOP
          node must have sent the Conditional PathTear as it was not an MP for
          the LSP (see <xref target="failures_nonmp"/> of this document).
          </t>

          <t>In the example topology in <xref target="example_network"/>, we assume 
	   C and D are the NP-MPs for the PLRs A and B, respectively. Now, when the 
	   A-B link fails, B will delete the LSP state, because B is not an MP and its PHOP link has failed (this behavior is required for unprotected LSPs; 
	   refer to <xref target="failures_nonmp"/> of this document). In the data 
	   plane, that would require B to delete the label forwarding entry 
	   corresponding to the LSP. Thus, if B's downstream nodes C and D continue to 
	   retain state, it would not be correct for D to continue to assume itself 
	   as the NP-MP for the PLR B.
          </t>
          <t>The mechanism that enables D to stop considering itself as the 
	   NP-MP for B and delete the corresponding "remote" path 
	   state is given below.
          </t>
	  <ol>
            <li>When C receives a Conditional PathTear from B, it decides to
            retain the LSP state as it is the NP-MP of the PLR A.  It also checks
            whether PHOP B had previously signaled availability of node
            protection. As B had previously signaled NP availability by
            including the B-SFRR-Ready Extended ASSOCIATION object, C removes the
            B-SFRR-Ready Extended ASSOCIATION object containing the Association
            Source set to B from the Path message and triggers a Path to
            D.</li>
            <li>When D receives the Path message, it realizes that it is no
            longer the NP-MP for B and so it deletes the corresponding
            "remote" path state. D does not propagate the Path further down
            because the only change is that the B-SFRR-Ready Extended
            ASSOCIATION object corresponding to Association Source B is no
            longer present in the Path message.</li>
	  </ol>
        </section>

        <section anchor="failures_lpnpmp">
          <name>Behavior of a Router That Is Both the LP-MP and NP-MP</name>
          <t>A router may simultaneously be the LP-MP and the NP-MP for the
          PHOP and PPHOP nodes of an LSP, respectively. If the PHOP link
          fails on such a node, the node <bcp14>MUST</bcp14> retain the PSB
          and RSB states corresponding to the LSP until the occurrence of any
          of the following events:
          </t>
          <ul>
            <li>both Node-ID signaling adjacencies with PHOP and PPHOP nodes go down,</li>
            <li>the MP receives a normal or "Remote" PathTear for its PSB, or</li>
            <li>the MP receives a ResvTear for its RSB.</li>
	  </ul>
          <t>If a router that is both an LP-MP and an NP-MP detects PHOP node 
	   failure, then the node <bcp14>MUST</bcp14> retain the PSB and RSB states corresponding 
	   to the LSP until the occurrence of any of the following events:
          </t>
	  <ul>
            <li>the remote Node-ID signaling adjacency with the PPHOP PLR goes down,</li>
            <li>the MP receives a normal or "Remote" PathTear for its PSB, or</li>
            <li>the MP receives a ResvTear for its RSB.</li>
	  </ul>
        </section>
      </section>

      <section anchor="cnd_path_tear">
        <name>Conditional PathTear</name>
        <t>In the example provided in <xref target="failures_npmp"/> of this
        document, B deletes the PSB and RSB states corresponding to the LSP
        once B detects its PHOP link has gone down as B is not an MP. If B
        were to send a PathTear normally, then C would delete the LSP state
        immediately. In order to avoid this, there should be some mechanism by
        which B can indicate to C that B does not require the receiving node
        to unconditionally delete the LSP state immediately. For this, B
        <bcp14>MUST</bcp14> add a new optional CONDITIONS object in the
        PathTear. The CONDITIONS object is defined in <xref
        target="cnd_path_tear_obj"/> of this document. If node C also
        understands the new object, then C <bcp14>MUST NOT</bcp14> delete the
        LSP state if it is an NP-MP.
        </t>

        <section anchor="cnd_path_tear_send">
          <name>Sending the Conditional PathTear</name>
          <t>A router that is not an MP for an LSP <bcp14>MUST</bcp14> delete the PSB and RSB 
	   states corresponding to the LSP if the PHOP link or the PHOP Node-ID 
	   signaling adjacency goes down (see <xref target="failures_nonmp"/> of this document). 
	   The router <bcp14>MUST</bcp14> send a Conditional PathTear if the following are also 
	   true:
          </t>
          <ul>
            <li>the ingress has requested node protection for the LSP and</li>
            <li>no PathTear is received from the upstream node.</li>
	  </ul>
        </section>

        <section anchor="cnd_path_tear_recv">
          <name>Processing the Conditional PathTear</name>
          <t>When a router that is not an NP-MP receives a Conditional PathTear, 
	   the node <bcp14>MUST</bcp14> delete the PSB and RSB states corresponding to the LSP
	   and process the Conditional PathTear by considering it as a normal 
	   PathTear. Specifically, the node <bcp14>MUST NOT</bcp14> propagate the Conditional 
	   PathTear downstream but remove the optional object and send a normal 
	   PathTear downstream.
          </t>
          <t>When a node that is an NP-MP receives a Conditional PathTear, it 
	   <bcp14>MUST NOT</bcp14> delete the LSP state. The node <bcp14>MUST</bcp14> check whether the 
	   PHOP node had previously included the B-SFRR-Ready Extended ASSOCIATION 
	   object in the Path. If the object had been included previously by the 
	   PHOP, then the node processing the Conditional PathTear from the PHOP 
	   <bcp14>MUST</bcp14> remove the corresponding object and trigger a Path downstream.
          </t>
          <t>If a Conditional PathTear is received from a neighbor that has not 
	   advertised support (refer to <xref target="compatible"/> of this document) for the
	   new procedures defined in this document, then the node <bcp14>MUST</bcp14> 
	   consider the message as a normal PathTear. The node <bcp14>MUST</bcp14> propagate 
	   the normal PathTear downstream and delete the LSP state.
          </t>
        </section>
        <section anchor="cnd_path_tear_obj">
          <name>CONDITIONS Object</name>
          <t>Any implementation that does not support a Conditional PathTear 
	   needs to ignore the new object but process the message as a normal 
	   PathTear without generating any error. For this reason, the Class-Num 
	   of the new object follows the pattern 10bbbbbb, where "b" represents a bit.
	   (The behavior for objects of this type is specified in <xref target="RFC2205" sectionFormat="of" section="3.10"/>.)
          </t>
          <t>The new object is called the "CONDITIONS" object and will 
	   specify the conditions under which default processing rules of the 
	   RSVP-TE message <bcp14>MUST</bcp14> be invoked.
          </t>
          <t>The object has the following format:</t>
          <figure anchor="fig_conditions">
            <name>CONDITIONS Object</name>
            <artwork align="left"><![CDATA[
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Length               |  Class        |     C-type    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                  Flags (Reserved)                           |M|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
          </figure>

  <dl spacing="compact" newline="false">
	      <dt>Class:</dt> <dd>135</dd>
	      <dt>C-type:</dt> <dd>1</dd>
	      <dt>Flags:</dt> <dd>32 bit field</dd>
	      <dt>M:</dt> <dd>Bit 31 is the Merge-point condition (M) bit.
	      If the M bit is set to 1, then the PathTear message <bcp14>MUST</bcp14> be processed 
	      according to the receiver router role, i.e., if the receiving router 
	      is an MP or not for the LSP. If it is not set, then the PathTear 
	      message <bcp14>MUST</bcp14> be processed as a normal PathTear message for the LSP.</dd>
  </dl>
  <t>Bits 0-30 are reserved; they <bcp14>MUST</bcp14> be set to zero on transmission and
	      <bcp14>MUST</bcp14> be ignored on receipt.</t>
        </section>
      </section>

      <section anchor="rem_tear">
        <name>Remote State Teardown</name>
        <t>If the ingress wants to tear down the LSP because of a management 
	   event while the LSP is being locally repaired at a transit PLR, it 
	   would not be desirable to wait until the completion of backup LSP 
	   signaling to perform state cleanup. In this case, the PLR <bcp14>MUST</bcp14> send a 
	   "Remote" PathTear message instructing the MP to delete the PSB 
	   and RSB states corresponding to the LSP. The TTL in the "Remote" 
	   PathTear message <bcp14>MUST</bcp14> be set to 255. Doing this enables LSP state cleanup 
           when the LSP is being locally repaired.
        </t>
        <t>Consider that node C in the example topology 
	   (<xref target="example_network"/>) has gone down and node B locally 
	   repairs the LSP:
        </t>
	<ol>        
	  <li>Ingress A receives a management event to tear down the LSP.</li>
	  <li>A sends a normal PathTear for the LSP to B.</li>
	  <li>Assume B has not initiated the backup signaling for the 
	  LSP during local repair. To enable LSP state cleanup, B sends a 
	  "Remote" PathTear with the destination IP address set to 
	  that of the node D used in the Node-ID signaling adjacency with D
	  and the RSVP_HOP object containing the local address used in the 
	  Node-ID signaling adjacency.</li>
	  <li>B then deletes the PSB and RSB states corresponding to the LSP.</li>
	  <li>On D, there would be a remote signaling adjacency with 
	  B, and so D accepts the "Remote" PathTear and deletes the
	  PSB and RSB states corresponding to the LSP.</li>
        </ol>

        <section anchor="lcl_repair_fail">
          <name>PLR Behavior on Local Repair Failure</name>
          <t>If local repair fails on the PLR after a failure, the PLR <bcp14>MUST</bcp14> send a 
	   "Remote" PathTear to the MP. The purpose of this is to clean 
	   up LSP state from the PLR to the egress. Upon receiving the PathTear,
	   the MP <bcp14>MUST</bcp14> delete the states corresponding to the LSP and also 
	   propagate the PathTear downstream, thereby achieving state cleanup from 
	   all downstream nodes up to the LSP egress. Note that in the case of link 
	   protection, the PathTear <bcp14>MUST</bcp14> be directed to the LP-MP's Node-ID IP 
	   address rather than the NHOP interface address.
          </t>
        </section>
        <section anchor="resv_rro_chng">
          <name>PLR Behavior on Resv RRO Change</name>
          <t>When a PLR router that has already made NP available for an LSP 
	   detects a change in the RRO carried in the Resv message that indicates 
	   that the router's former NP-MP is no longer present on the path of 
	   the LSP, then the router <bcp14>MUST</bcp14> send a "Remote" PathTear 
	   directly to its former NP-MP.
          </t>
          <t>In the example topology in <xref target="example_network"/>, assume node 
	   A has made node protection available for an LSP and C has concluded it 
	   is the NP-MP for PLR A. When the B-C link fails, then C, implementing the 
	   procedure specified in <xref target="failures_lpnpmp"/> of this 
	   document, will retain the states corresponding to the LSP until one of the following occurs:</t>
	   <ul>
	     <li>the remote Node-ID signaling adjacency with A goes down
	     or</li>
	     <li>a PathTear or a ResvTear is received for its PSB or RSB,
	     respectively.</li>
	   </ul>
	   <t>If B also has made node protection available, B will eventually
	   complete backup LSP signaling with its NP-MP D and trigger a Resv
	   to A with RRO changed.  The new RRO of the LSP carried in the Resv
	   will not contain C. When A processes the Resv message with a new
	   RRO not containing C, its former NP-MP, A, sends a "Remote"
	   PathTear to C. When C receives the "Remote" PathTear for its PSB
	   state, C will send a normal PathTear downstream to D and delete
	   both the PSB and RSB states corresponding to the LSP.  As D has
	   already received backup LSP signaling from B, D will retain the control
	   plane and forwarding states corresponding to the LSP.
          </t>
        </section>
        <section anchor="lcl_repair_preempt">
          <name>LSP Preemption During Local Repair</name>
          <section anchor="lcl_repair_preempt_lpnp">
            <name>Preemption on LP-MP After PHOP Link Failure</name>
            <t>If an LSP is preempted on an LP-MP after its PHOP link has already 
	   failed but the backup LSP has not been signaled yet as part of the local 
	   repair procedure, then the node <bcp14>MUST</bcp14> send a normal PathTear and delete 
	   both the PSB and RSB states corresponding to the LSP. As the LP-MP has 
	   retained the LSP state expecting the PLR to initiate backup LSP signaling, 
	   preemption would bring down the LSP and the node would not be LP-MP anymore, requiring the node to clean up the LSP state.
            </t>
          </section>

          <section anchor="lcl_repair_preempt_npmp">
            <name>Preemption on NP-MP After PHOP Link Failure</name>
            <t>If an LSP is preempted on an NP-MP after its PHOP link has already 
	   failed but the backup LSP has not been signaled yet, then the node 
	   <bcp14>MUST</bcp14> send a normal PathTear and delete the PSB and RSB states 
	   corresponding to the LSP. As the NP-MP has retained the LSP state 
	   expecting the PLR to initiate backup LSP signaling, preemption 
	   would bring down the LSP and the node would not be NP-MP anymore, 
	   requiring the node to clean up LSP state.
            </t>
	    <t>Consider that the B-C link goes down on the same example topology 
	   (<xref target="example_network"/>). As C is the NP-MP for the PLR A, C 
	   will retain the LSP state.
            </t>

	    <ol>
              <li>The LSP is preempted on C.</li>
              <li>C will delete the RSB state corresponding to the
              LSP. However, C cannot send a PathErr or a ResvTear to the PLR A
              because the backup LSP has not been signaled yet.</li>
              <li>As the only reason for C having retained state after PHOP
              node failure was that it was an NP-MP, C sends a normal PathTear
              to D and also deletes its PSB state. D would also delete the PSB
              and RSB states on receiving a PathTear from C.</li>
              <li>B starts backup LSP signaling to D. However, as D does not have
              the LSP state, it will reject the backup LSP Path message and send a
              PathErr to B.</li>
              <li>B will delete its reservation and send a ResvTear to A.</li>
	    </ol>
          </section>
        </section>
      </section>

      <section anchor="compatible">
        <name>Backward Compatibility Procedures</name>
        <t>"Refresh-Interval Independent RSVP FRR" and "RI-RSVP-FRR" refer to the  
	set of procedures defined in this document to eliminate the reliance on
	periodic refreshes. The extensions proposed in RSVP-TE Summary FRR 
	<xref target="RFC8796"/> may apply to implementations that do not support 
	RI-RSVP-FRR. On the other hand, RI-RSVP-FRR extensions relating to LSP 
	state cleanup, namely Conditional and "Remote" PathTears, require 
	support from one-hop and two-hop neighboring nodes along the LSP. 
	Thus, procedures that fall under the LSP state cleanup category <bcp14>MUST NOT</bcp14> be 
	turned on if any of the nodes involved in the node protection FRR (i.e., 
	the PLR, the MP, and the intermediate node in the case of NP) do not 
	support RI-RSVP-FRR extensions. Note that for LSPs requesting link 
	protection, only the PLR and the LP-MP <bcp14>MUST</bcp14> support the extensions.
        </t>

<section anchor="compat_detect">
          <name>Detecting Support for Refresh-Interval Independent RSVP FRR</name>
          <t>An implementation supporting RI-RSVP-FRR extensions <bcp14>MUST</bcp14> set the RI-RSVP Capable flag in the 
	 CAPABILITY object carried in Hello messages as specified in RSVP-TE 
	 Scaling Techniques <xref target="RFC8370"/>. If an implementation does 
	 not set the flag even if it supports RI-RSVP-FRR extensions, then its 
	 neighbors will view the node as any node that does not support the
	 extensions.
          </t>
          <ul>
	    <li>As nodes supporting the RI-RSVP-FRR extensions initiate
	    Node-ID-based signaling adjacency with all immediate neighbors,
	    such a node on the path of a protected LSP can determine whether
	    its PHOP and NHOP neighbors support RI-RSVP-FRR enhancements.</li>
            
            <li>As nodes supporting the RI-RSVP-FRR extensions also initiate
            Node-ID-based signaling adjacency with the NNHOP along the path of
            the LSP requesting node protection (see <xref
            target="sig_plr_behavior"/> of this document), each node along the
            LSP can determine whether its NNHOP node supports RI-RSVP-FRR
            enhancements. If the NNHOP (a) does not reply to remote Node-ID
            Hello messages or (b) does not set the RI-RSVP flag in the
            CAPABILITY object carried in its Node-ID Hello messages, then the
            node acting as the PLR can conclude that NNHOP does not support
            RI-RSVP-FRR extensions.</li>
            
            <li>If node protection is requested for an LSP and if (a) the
            PPHOP node has not included a matching B-SFRR-Ready Extended
            ASSOCIATION object in its Path messages, (b) the PPHOP node has
            not initiated remote Node-ID Hello messages, or (c) the PPHOP node
            does not set the RI-RSVP flag in the CAPABILITY object carried in
            its Node-ID Hello messages, then the node <bcp14>MUST</bcp14>
            conclude that the PLR does not support RI-RSVP-FRR
            extensions.</li>
	  </ul>
        </section>

        <section anchor="compat_procedures">
          <name>Procedures for Backward Compatibility</name>

          <t>Every node that supports RI-RSVP-FRR <bcp14>MUST</bcp14> support the procedures defined 
	 in this section in order to support backward compatibility for 
	 those subsets of LSPs that also traverse nodes that do not support
	 RI-RSVP-FRR.
          </t>

          <section anchor="dnstr_no_support">
            <name>Lack of Support on Downstream Nodes</name>

            <t>The procedures on the downstream direction are as follows:</t>
	    <ul>
              <li>If a node finds that the NHOP node along the LSP does not
              support the RI-RSVP-FRR extensions, then the node
              <bcp14>MUST</bcp14> reduce the "refresh period" in the
              TIME_VALUES object carried in the Path messages to the default
              short refresh interval.</li>
              <li>If node protection is requested for the LSP and the NNHOP
              node along the LSP does not support the RI-RSVP-FRR
              extensions, then the node <bcp14>MUST</bcp14> reduce the
              "refresh period" in the TIME_VALUES object carried in the Path
              messages to the default short refresh interval.</li>
	    </ul>

            <t>If a node reduces the refresh time using the above procedures,
            it <bcp14>MUST NOT</bcp14> send any "Remote" PathTear or
            Conditional PathTear message to the downstream node.</t>

            <t>Consider the example topology in <xref
            target="example_network"/>.  If C does not support the RI-RSVP-FRR
            extensions, then:</t>

            <ul>
                <li>A and B reduce the refresh time to the default short
                refresh interval of 30 seconds and trigger a Path message.</li>
              
		<li>If B is not an MP and if the PHOP link of B fails, B cannot
		send a Conditional PathTear to C but times out the PSB state
		from A normally. Note that B can only normally time out the PSB state A
		if A did not set the long refresh in the TIME_VALUES
		object carried in the Path messages sent earlier.</li>
	    </ul>
          </section>

          <section anchor="upstr_no_support">
            <name>Lack of Support on Upstream Nodes</name>

            <t>The procedures on the upstream direction are as follows:</t>

            <ul>
	      <li>If a node finds that the PHOP node along the LSP does
	      not support the RI-RSVP-FRR extensions, then the node
	      <bcp14>MUST</bcp14> reduce the "refresh period" in the
	      TIME_VALUES object carried in the Resv messages to the default
	      short refresh interval.</li>
              
              <li>If node protection is requested for the LSP and the PHOP
              node along the LSP does not support the RI-RSVP-FRR
              extensions, then the node <bcp14>MUST</bcp14> reduce the
              "refresh period" in the TIME_VALUES object carried in the Path
              messages to the default short refresh interval (thus, the NHOP
              can use compatible values when sending a Resv).</li>
              
              <li>If node protection is requested for the LSP and the PPHOP
              node does not support the RI-RSVP-FRR extensions, then the node
              <bcp14>MUST</bcp14> reduce the "refresh period" in the
              TIME_VALUES object carried in the Resv messages to the default
              short refresh interval.</li>
              
              <li>If the node reduces the refresh time using the above
              procedures, it <bcp14>MUST NOT</bcp14> execute MP procedures
              specified in <xref target="failures"/> of this document.</li>
	      </ul>
          </section>

          <section anchor="incr_deploy">
            <name>Incremental Deployment</name>
	    
            <t>The backward compatibility procedures described in the previous 
	  subsections imply that a router supporting the RI-RSVP-FRR 
	  extensions specified in this document can apply the procedures 
	  specified in this document either in the downstream or upstream 
	  direction of an LSP, depending on the capability of the routers 
	  downstream or upstream in the LSP.
            </t>

              <ul>
              <li>RI-RSVP-FRR extensions and procedures are enabled for 
		downstream Path, PathTear, and ResvErr messages corresponding 
		to an LSP if link protection is requested for the LSP and the 
		NHOP node supports the extensions.</li>

              <li>RI-RSVP-FRR extensions and procedures are enabled for 
		downstream Path, PathTear, and ResvErr messages corresponding 
		to an LSP if node protection is requested for the LSP and both 
		NHOP and NNHOP nodes support the extensions.</li>
              
              <li>RI-RSVP-FRR extensions and procedures are enabled for
              upstream PathErr, Resv, and ResvTear messages corresponding to an
              LSP if link protection is requested for the LSP and the PHOP
              node supports the extensions.</li>
                          
              <li>RI-RSVP-FRR extensions and procedures are enabled for
              upstream PathErr, Resv, and ResvTear messages corresponding to an
              LSP if node protection is requested for the LSP and both PHOP
              and PPHOP nodes support the extensions.</li>
	    </ul>

            <t>For example, if an implementation supporting the RI-RSVP-FRR 
	  extensions specified in this document is deployed on all routers in a
	  particular region of the network and if all the LSPs in the network 
	  request node protection, then the FRR extensions will only be 
	  applied for the LSP segments that traverse the particular region. 
	  This will aid incremental deployment of these extensions and also 
	  allow reaping the benefits of the extensions in portions of the 
	  network where it is supported.
            </t>
          </section>
        </section>
      </section>
      <section anchor="cap_bit_without_support">
        <name>Consequences of Advertising RI-RSVP Without RI-RSVP-FRR</name>
        <t>If a node supporting facility backup protection <xref target="RFC4090"/> 
	  sets the RI-RSVP capability (I-bit) but does not support the RI-RSVP-FRR
          extensions, due to an implementation bug or configuration error, then it 
          leaves room for the stale state to linger around for an inordinate period of 
	  time or for disruption of normal FRR operations
	  (see <xref target="prob_desc"/> of this document). Consider the example 
	  topology (<xref target="example_network"/>) provided in this document.
        </t>

        <ul>
          <li>Assume node B does set the RI-RSVP capability in its Node-ID-based
          Hello messages even though it does not support RI-RSVP-FRR
          extensions. When B detects the failure of its PHOP link along an
          LSP, it will not send a Conditional PathTear to C as required by the
          RI-RSVP-FRR procedures. If B simply leaves the LSP state without
          deleting, then B may end up holding on to the stale state until the
          (long) refresh timeout.</li>

          <li>Instead of node B, assume node C does set the RI-RSVP capability in
          its Node-ID-based Hello messages even though it does not support
          RI-RSVP-FRR extensions. When B details the failure of its PHOP link
          along an LSP, it will send a Conditional PathTear to C as required by
          the RI-RSVP-FRR procedures. However, C would not recognize the condition
          encoded in the PathTear and end up tearing down the LSP.</li>
          
          <li>Assume node B does set the RI-RSVP capability in its Node-ID-based
          Hello messages even though it does not support RI-RSVP-FRR
          extensions. In addition, assume local repair is about to commence on node B
          for an LSP that has only requested link protection, that is, B has
          not initiated the backup LSP signaling for the LSP. If node B
          receives a normal PathTear at this time from ingress A because of a
          management event initiated on A, then B simply deletes the LSP state
          without sending a Remote PathTear to the LP-MP C, so C may end up
          holding on to the stale state until the (long) refresh timeout.</li>
	</ul>
      </section>
    </section>

    <section anchor="Security">
      <name>Security Considerations</name>
      <t>The security considerations pertaining to the original RSVP protocol
         (<xref target="RFC2205"/>, <xref target="RFC3209"/>, and <xref target="RFC5920"/>) 
	 remain relevant. When using RSVP cryptographic authentication 
	 <xref target="RFC2747"/>,  more robust algorithms such as HMAC-SHA256,
	 HMAC-SHA384, or HMAC-SHA512 <xref target="RFC2104"/> <xref target="FIPS-180-4"/> 
	 <bcp14>SHOULD</bcp14> be used when computing the keyed message digest where possible.
      </t>

      <t>This document extends the applicability of Node-ID-based Hello
      sessions between immediate neighbors. The Node-ID-based Hello session
      between the PLR and the NP-MP may require the two routers to exchange
      Hello messages with a non-immediate neighbor. Therefore, the
      implementations <bcp14>SHOULD</bcp14> provide the option to configure either a
      specific neighbor or global Node-ID authentication key to authentication
      messages received from Node-ID neighbors. The network administrator
      <bcp14>SHOULD</bcp14> utilize this option to enable RSVP-TE routers to
      authenticate Node-ID Hello messages received with a TTL greater than 1.
      Implementations <bcp14>SHOULD</bcp14> also provide the option to specify
      a limit on the number of Node-ID-based Hello sessions that can be
      established on a router supporting the extensions defined in this
      document.
      </t>
    </section>

<section anchor="IANA">
      <name>IANA Considerations</name>
      <section anchor="IANA_Conditions">
        <name>CONDITIONS Object</name>
        <t>IANA maintains the "Class Names, Class Numbers, and Class Types" registry 
	  in the "RSVP Parameters" registry group (see
          <eref target="http://www.iana.org/assignments/rsvp-parameters/" brackets="angle"/>).
          IANA has extended these registries by adding a new Class Number 
          (in the 10bbbbbb range) and assigning a new C-Type under this Class Number, 
          as described below (see <xref target="cnd_path_tear_obj"/>). New Class Type values for Class Name "CONDITIONS" can be added via "IETF Review" <xref target="RFC8126"/>.
        </t>

<table anchor="table1"> 
  <name>Class Names, Class Numbers, and Class Types</name>
  <thead>
    <tr>
      <th>Class Number</th>
      <th>Class Name</th>
      <th>Reference</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>135</td>
      <td>CONDITIONS</td>
      <td>RFC 9705</td>
    </tr>
  </tbody>
</table>

<table anchor="table2"> 
  <name>Class Types or C-Types - 135 CONDITIONS</name>
  <thead>
    <tr>
      <th>Value</th>
      <th>Description</th>
      <th>Reference</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>CONDITIONS</td>
      <td>RFC 9705</td>
    </tr>
  </tbody>
</table>
        <t>IANA has added a subregistry called "CONDITIONS Object
	  Flags" as shown below.  New registrations can be added via "IETF Review" <xref target="RFC8126"/>.</t>

<table anchor="table3"> 
  <name>CONDITIONS Object Flags</name>
  <thead>
    <tr>
      <th>Bit Number</th>
      <th>32-Bit Value</th>
      <th>Name</th>
      <th>Reference</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0-30</td>
      <td></td>
      <td>Unassigned</td>
      <td></td>
    </tr>
    <tr>
      <td>31</td>
      <td>0x0001</td>
      <td>Merge-point</td>
      <td>RFC 9705</td>
    </tr>
  </tbody>
</table>        

      </section>
    </section>

  </middle>
  <back>

    
   <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
	
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2747.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.3209.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4090.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2961.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2205.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4558.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.3473.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.5063.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8126.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8370.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8796.xml"/>
      </references>

      <references>
        <name>Informative References</name>

        <reference anchor="FIPS-180-4" target="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf">
          <front>
            <title>Secure Hash Standard</title>
            <author>
              <organization>National Institute of Standards and Technology</organization>
            </author>
            <date month="August" year="2015"/>
          </front>
          <seriesInfo name="FIPS PUB" value="180-4"/>
	  <seriesInfo name="DOI" value="10.6028/NIST.FIPS.180-4"/>
        </reference>

        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2104.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.5920.xml"/>

      </references>
    </references>



   <section anchor="Acknowledgements" numbered="false">
      <name>Acknowledgements</name>
      <t>We are very grateful to <contact fullname="Yakov Rekhter"/> for his
      contributions to the development of the idea and thorough review of the
      content of the document.  We are thankful to <contact fullname="Raveendra
      Torvi"/> and <contact fullname="Yimin Shen"/> for their comments and
      inputs on early versions of the document. We also thank <contact
      fullname="Alexander Okonnikov"/> for his review and comments on the
      document.
      </t>
    </section>

   <section anchor="Contributors" numbered="false">
      <name>Contributors</name>

    <contact fullname="Ina Minei">
      <organization>Google, Inc.</organization>
      <address>
        <email>inaminei@google.com</email>
      </address>
    </contact>
      
 <contact fullname="Markus Jork">
   <organization>Juniper Networks, Inc.</organization>
   <address>
     <email>mjork@juniper.net</email>
   </address>
 </contact>

 <contact fullname="Harish Sitaraman">
   <organization>Individual Contributor</organization>
   <address>
     <email>harish.ietf@gmail.com</email>
   </address>
 </contact>

 <contact fullname="Vishnu Pavan Beeram">
   <organization>Juniper Networks, Inc.</organization>
   <address>
     <email>vbeeram@juniper.net</email>
   </address>
 </contact>

 <contact fullname="Ebben Aries">
   <organization>Juniper Networks, Inc.</organization>
   <address>
     <email>exa@juniper.com</email>
   </address>
 </contact>

 <contact fullname="Mike Taillon">
   <organization>Cisco Systems, Inc.</organization>
   <address>
     <postal/>
     <email>mtaillon@cisco.com</email>
   </address>
 </contact>
    </section>

  </back>
</rfc>
