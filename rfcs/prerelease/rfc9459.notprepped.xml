<?xml version="1.0" encoding="UTF-8"?>

<!-- draft submitted in xml v3 -->

<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>

<!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.5.26 (Ruby 2.3.7) -->

<rfc xmlns:xi="http://www.w3.org/2001/XInclude" ipr="trust200902" docName="draft-ietf-cose-aes-ctr-and-cbc-06" number="9459" submissionType="IETF" category="std" consensus="true" tocInclude="true" sortRefs="true" symRefs="true"
updates="" obsoletes="" xml:lang="en" version="3">

  <!-- xml2rfc v2v3 conversion 3.17.1 -->
  <front>
    <title abbrev="AES-CTR and AES-CBC with COSE">CBOR Object Signing and Encryption (COSE): AES-CTR and AES-CBC</title>
    <seriesInfo name="RFC" value="9459"/>
    <author initials="R." surname="Housley" fullname="Russ Housley">
      <organization abbrev="Vigil Security">Vigil Security, LLC</organization>
      <address>
        <email>housley@vigilsec.com</email>
      </address>
    </author>
    <author initials="H." surname="Tschofenig" fullname="Hannes Tschofenig">
    
      <address>
        <email>hannes.tschofenig@gmx.net</email>
      </address>
    </author>
    <date year="2023" month="September"/>
    <area>sec</area>
    <workgroup>cose</workgroup>

    <abstract>
      <t>The Concise Binary Object Representation (CBOR) data format is designed
for small code size and small message size. CBOR Object Signing and
Encryption (COSE) is specified in RFC 9052 to provide basic
security services using the CBOR data format. This document specifies the
conventions for using AES-CTR and AES-CBC as content encryption
algorithms with COSE.</t>
    </abstract>
  </front>
  <middle>
    <section anchor="intro">
      <name>Introduction</name>
      <t>This document specifies the conventions for using AES-CTR and AES-CBC 
as content encryption algorithms with the CBOR Object Signing and Encryption
(COSE) <xref target="RFC9052"/> syntax.  Today, encryption with COSE uses Authenticated
Encryption with Associated Data (AEAD) algorithms <xref target="RFC5116"/>, which provide
both confidentiality and integrity protection.  However, there are situations
where another mechanism, such as a digital signature, is used to provide
integrity.  In these cases, an AEAD algorithm is not needed.  The software
manifest being defined by the IETF SUIT WG <xref target="I-D.ietf-suit-manifest"/> is one
example where a digital signature is always present.</t>
    </section>
    <section anchor="conventions-and-terminology">
      <name>Conventions and Terminology</name>
        <t>
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>",
    "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL NOT</bcp14>",
    "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>",
    "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be
    interpreted as described in BCP&nbsp;14 <xref target="RFC2119"/> <xref
    target="RFC8174"/> when, and only when, they appear in all capitals, as
    shown here.
        </t>
    </section>
    <section anchor="aes-alg">
      <name>AES Modes of Operation</name>
      <t>NIST has defined several modes of operation for the Advanced Encryption
Standard <xref target="AES"/> <xref target="MODES"/>.  AES supports three key sizes: 128 bits,
192 bits, and 256 bits.  AES has a block size of 128 bits (16 octets).
Each of these modes has different characteristics.  The modes include:
CBC (Cipher Block Chaining), CFB (Cipher FeedBack), OFB (Output FeedBack),
and CTR (Counter).</t>
      <t>Only AES Counter (AES-CTR) mode and AES Cipher Block Chaining (AES-CBC) are
discussed in this document.</t>
    </section>
    <section anchor="aes-ctr">
      <name>AES Counter Mode</name>
      <t>When AES-CTR is used as a COSE content encryption algorithm, the
encryptor generates a unique value that is communicated to the
decryptor.  This value is called an "Initialization Vector" (or "IV") in this
document.  The same IV and AES key combination <bcp14>MUST NOT</bcp14> be used more
than once.  The encryptor can generate the IV in any manner that ensures
the same IV value is not used more than once with the same AES key.</t>
      <t>When using AES-CTR, each AES encrypt operation generates 128 bits of key
stream.  AES-CTR encryption is the XOR of the key stream with the
plaintext.  AES-CTR decryption is the XOR of the key stream with the
ciphertext.  If the generated key stream is longer than the plaintext or
ciphertext, the extra key stream bits are simply discarded.  For this reason,
AES-CTR does not require the plaintext to be padded to a multiple of the
      block size.</t>
      
      <t>AES-CTR has many properties that make it an attractive COSE content encryption
algorithm.  AES-CTR uses the AES block cipher to create a stream cipher.  Data
is encrypted and decrypted by XORing with the key stream produced by AES
      encrypting sequential IV block values, called "counter blocks", where:</t>
      <ul><li>The first
      block of the key stream is the AES encryption of the IV.</li>
      <li>The second block of
      the key stream is the AES encryption of (IV + 1) mod 2<sup>128</sup>.</li>
      <li>The third block of
the key stream is the AES encryption of (IV + 2) mod 2<sup>128</sup>, and so on.</li></ul><t>AES-CTR
is easy to implement, can be pipelined and parallelized, and supports key stream precomputation.  Sending of the IV is the only
source of expansion because the plaintext and ciphertext are the same size.</t>
      <t>When used correctly, AES-CTR provides a high level of confidentiality.
Unfortunately, AES-CTR is easy to use incorrectly.  Being a stream
cipher, reuse of the IV with the same key is catastrophic.  An IV
collision immediately leaks information about the plaintext.  For
this reason, it is inappropriate to use AES-CTR with static
keys.  Extraordinary measures would be needed to prevent reuse of an
IV value with the static key across power cycles.  To be safe,
implementations <bcp14>MUST</bcp14> use fresh keys with AES-CTR.</t>
      <t>AES-CTR keys may be obtained either from a key structure or from a recipient
structure.  Implementations encrypting and decrypting <bcp14>MUST</bcp14> validate that the
key type, key length, and algorithm are correct and appropriate for the
entities involved.</t>
      <t>With AES-CTR, it is trivial to use a valid ciphertext to forge other
(valid to the decryptor) ciphertexts.  Thus, it is equally catastrophic to
use AES-CTR without a companion authentication and integrity
mechanism.  Implementations <bcp14>MUST</bcp14> use AES-CTR in conjunction with an
authentication and integrity mechanism, such as a digital signature.</t>
      <t>The instructions in <xref target="RFC9052" sectionFormat="of" section="5.4"/> are followed for AES-CTR.
Since AES-CTR cannot provide integrity protection for external additional
authenticated data, the decryptor <bcp14>MUST</bcp14> ensure that no external additional
      authenticated data was supplied.  See <xref target="impl-cons"/>.</t>

              <t>The 'protected' header <bcp14>MUST</bcp14> be a zero-length byte string.</t>
      <section anchor="aes-ctr-key">
        <name>AES-CTR COSE Key</name>
        <t>When using a COSE key for the AES-CTR algorithm, the following checks are made:</t>
        <ul spacing="normal">
          <li>The 'kty' field <bcp14>MUST</bcp14> be present, and it <bcp14>MUST</bcp14> be 'Symmetric'.</li>
          <li>If the 'alg' field is present, it <bcp14>MUST</bcp14> match the AES-CTR algorithm being used.</li>
          <li>If the 'key_ops' field is present, it <bcp14>MUST</bcp14> include 'encrypt' when encrypting.</li>
          <li>If the 'key_ops' field is present, it <bcp14>MUST</bcp14> include 'decrypt' when decrypting.</li>
        </ul>

      </section>
      <section anchor="aes-ctr-alg">
        <name>AES-CTR COSE Algorithm Identifiers</name>
        <t>The following table defines the COSE AES-CTR algorithm values.  Note that
these algorithms are being registered as "Deprecated" to avoid accidental
use without a companion integrity protection mechanism.</t>
        <table>
          <thead>
            <tr>
              <th align="left">Name</th>
              <th align="center">Value</th>
              <th align="center">Key Size</th>
              <th align="center">Description</th>
              <th align="right">Recommended</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">A128CTR</td>
              <td align="center">-65534</td>
              <td align="center">128</td>
              <td align="center">AES-CTR w/ 128-bit key</td>
              <td align="right">Deprecated</td>
            </tr>
            <tr>
              <td align="left">A192CTR</td>
              <td align="center">-65533</td>
              <td align="center">192</td>
              <td align="center">AES-CTR w/ 192-bit key</td>
              <td align="right">Deprecated</td>
            </tr>
            <tr>
              <td align="left">A256CTR</td>
              <td align="center">-65532</td>
              <td align="center">256</td>
              <td align="center">AES-CTR w/ 256-bit key</td>
              <td align="right">Deprecated</td>
            </tr>
          </tbody>
        </table>
      </section>
    </section>
    <section anchor="aes-cbc">
      <name>AES Cipher Block Chaining Mode</name>
      <t>AES-CBC mode requires a 16-octet IV.  Use of a
randomly or pseudorandomly generated IV ensures that the encryption of the
same plaintext will yield different ciphertext.</t>
      <t>AES-CBC performs an XOR of the IV with the first plaintext block before it
is encrypted.  For successive blocks, AES-CBC performs an XOR of the previous
ciphertext block with the current plaintext before it is encrypted.</t>
      <t>AES-CBC requires padding of the plaintext; the padding algorithm specified
in <xref target="RFC5652" sectionFormat="of" section="6.3"/> <bcp14>MUST</bcp14> be used prior to encrypting the
plaintext.  This padding algorithm allows the decryptor to unambiguously
remove the padding.</t>
      <t>The simplicity of AES-CBC makes it an attractive COSE content encryption
algorithm.  The need to carry an IV and the need for padding lead to an
increase in the overhead (when compared to AES-CTR).  AES-CBC is much safer
for use with static keys than AES-CTR.  That said, as described in <xref target="RFC4107"/>,
the use of automated key management to generate fresh keys is greatly
preferred.</t>
      <t>AES-CBC does not provide integrity protection.  Thus, an attacker
can introduce undetectable errors if AES-CBC is used without a companion
authentication and integrity mechanism.  Implementations <bcp14>MUST</bcp14> use AES-CBC
in conjunction with an authentication and integrity mechanism, such as a
digital signature.</t>
      <t>The instructions in <xref target="RFC9052" sectionFormat="of" section="5.4"/> are followed for AES-CBC.
Since AES-CBC cannot provide integrity protection for external additional
authenticated data, the decryptor <bcp14>MUST</bcp14> ensure that no external additional
      authenticated data was supplied.  See <xref target="impl-cons"/>.</t>

              <t>The 'protected' header <bcp14>MUST</bcp14> be a zero-length byte string.</t>
      <section anchor="aes-cbc-key">
        <name>AES-CBC COSE Key</name>
        <t>When using a COSE key for the AES-CBC algorithm, the following checks are made:</t>
        <ul spacing="normal">
          <li>The 'kty' field <bcp14>MUST</bcp14> be present, and it <bcp14>MUST</bcp14> be 'Symmetric'.</li>
          <li>If the 'alg' field is present, it <bcp14>MUST</bcp14> match the AES-CBC algorithm being used.</li>
          <li>If the 'key_ops' field is present, it <bcp14>MUST</bcp14> include 'encrypt' when encrypting.</li>
          <li>If the 'key_ops' field is present, it <bcp14>MUST</bcp14> include 'decrypt' when decrypting.</li>
        </ul>
      </section>
      <section anchor="aes-cbc-alg">
        <name>AES-CBC COSE Algorithm Identifiers</name>
        <t>The following table defines the COSE AES-CBC algorithm values. Note that
these algorithms are being registered as "Deprecated" to avoid accidental
use without a companion integrity protection mechanism.</t>
        <table>
          <thead>
            <tr>
              <th align="left">Name</th>
              <th align="center">Value</th>
              <th align="center">Key Size</th>
              <th align="center">Description</th>
              <th align="right">Recommended</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">A128CBC</td>
              <td align="center">-65531</td>
              <td align="center">128</td>
              <td align="center">AES-CBC w/ 128-bit key</td>
              <td align="right">Deprecated</td>
            </tr>
            <tr>
              <td align="left">A192CBC</td>
              <td align="center">-65530</td>
              <td align="center">192</td>
              <td align="center">AES-CBC w/ 192-bit key</td>
              <td align="right">Deprecated</td>
            </tr>
            <tr>
              <td align="left">A256CBC</td>
              <td align="center">-65529</td>
              <td align="center">256</td>
              <td align="center">AES-CBC w/ 256-bit key</td>
              <td align="right">Deprecated</td>
            </tr>
          </tbody>
        </table>
      </section>
    </section>
    <section anchor="impl-cons">
      <name>Implementation Considerations</name>
      <t>COSE libraries that support either AES-CTR or AES-CBC and accept
Additional Authenticated Data (AAD) as input <bcp14>MUST</bcp14> return an
error if one of these non-AEAD content encryption algorithms is
selected.  This ensures that a caller does not expect the AAD
to be protected when the cryptographic algorithm is unable to do so.</t>
    </section>
    <section anchor="iana-cons">
      <name>IANA Considerations</name>
      
      <t>IANA has registered six COSE algorithm identifiers for AES-CTR and
AES-CBC in the "COSE Algorithms" registry <xref target="IANA-COSE"/>.</t>
      <t>The information for the six COSE algorithm identifiers is provided in
Sections <xref target="aes-ctr-alg" format="counter"/> and <xref target="aes-cbc-alg" format="counter"/>.  Also, for all six entries, the
"Capabilities" column contains "[kty]", the "Change Controller"
column contains "IETF", and the "Reference" column contains
a reference to this document.</t>

    </section>
    <section anchor="sec-cons">
      <name>Security Considerations</name>
      <t>This document specifies AES-CTR and AES-CBC for COSE, which are not
AEAD ciphers.  The use of the ciphers is limited to special use cases, such as firmware encryption, where integrity and authentication is provided by another mechanism.</t>
      <t>Since AES has a 128-bit block size, regardless of the mode
employed, the ciphertext generated by AES encryption becomes
distinguishable from random values after 2<sup>64</sup> blocks are encrypted
with a single key.  Implementations should change the key before
reaching this limit.</t>
      <t>To avoid cross-protocol concerns, implementations <bcp14>MUST NOT</bcp14> use the same
keying material with more than one mode.  For example, the same keying
material must not be used with AES-CTR and AES-CBC.</t>
      <t>There are fairly generic precomputation attacks against all block cipher
modes that allow a meet-in-the-middle attack against the key.  These attacks
require the creation and searching of huge tables of ciphertext associated
with known plaintext and known keys.  Assuming that the memory and processor
resources are available for a precomputation attack, then the theoretical
strength of AES-CTR and AES-CBC is limited to 2<sup>(n/2)</sup> bits, where n is the
number of bits in the key.  The use of long keys is the best countermeasure
to precomputation attacks.</t>
      <t>When used properly, AES-CTR mode provides strong confidentiality. Unfortunately,
it is very easy to misuse this counter mode.  If counter block values are ever
used for more than one plaintext with the same key, then the same key stream
will be used to encrypt both plaintexts, and the confidentiality guarantees are
voided.</t>
      <t>What happens if the encryptor XORs the same key stream with two different
plaintexts? Suppose two plaintext octet sequences P1, P2, P3 and Q1, Q2, Q3
are both encrypted with key stream K1, K2, K3. The two corresponding
ciphertexts are:</t>
      <artwork><![CDATA[
   (P1 XOR K1), (P2 XOR K2), (P3 XOR K3)

   (Q1 XOR K1), (Q2 XOR K2), (Q3 XOR K3)
]]></artwork>
      <t>If both of these two ciphertext streams are exposed to an attacker, then a
catastrophic failure of confidentiality results, since:</t>
      <artwork><![CDATA[
   (P1 XOR K1) XOR (Q1 XOR K1) = P1 XOR Q1
   (P2 XOR K2) XOR (Q2 XOR K2) = P2 XOR Q2
   (P3 XOR K3) XOR (Q3 XOR K3) = P3 XOR Q3
]]></artwork>
      <t>Once the attacker obtains the two plaintexts XORed together, it is relatively
straightforward to separate them.  Thus, using any stream cipher, including
AES-CTR, to encrypt two plaintexts under the same key stream leaks the
plaintext.</t>
      <t>Data forgery is trivial with AES-CTR mode. The demonstration of this attack
is similar to the key stream reuse discussion above.  If a known plaintext
octet sequence P1, P2, P3 is encrypted with key stream K1, K2, K3, then the
attacker can replace the plaintext with one of its own choosing.  The
ciphertext is:</t>
      <artwork><![CDATA[
   (P1 XOR K1), (P2 XOR K2), (P3 XOR K3)
]]></artwork>
      <t>The attacker simply XORs a selected sequence Q1, Q2, Q3 with the
ciphertext to obtain:</t>
      <artwork><![CDATA[
   (Q1 XOR (P1 XOR K1)), (Q2 XOR (P2 XOR K2)), (Q3 XOR (P3 XOR K3))
]]></artwork>
      <t>Which is the same as:</t>
      <artwork><![CDATA[
   ((Q1 XOR P1) XOR K1), ((Q2 XOR P2) XOR K2), ((Q3 XOR P3) XOR K3)
]]></artwork>
      <t>Decryption of the attacker-generated ciphertext will yield exactly what
the attacker intended:</t>
      <artwork><![CDATA[
   (Q1 XOR P1), (Q2 XOR P2), (Q3 XOR P3)
]]></artwork>
      <t>AES-CBC does not provide integrity protection.  Thus, an attacker
can introduce undetectable errors if AES-CBC is used without a companion
      authentication mechanism.</t>
      
      <t>If an attacker is able to strip the authentication and integrity mechanism,
then the attacker can replace it with one of their own creation, even
without knowing the plaintext.  The usual defense against such an attack is
an Authenticated Encryption with Associated Data (AEAD) algorithm <xref target="RFC5116"/>.  Of course, neither AES-CTR nor AES-CBC is an AEAD.  Thus,
an implementation should provide integrity protection for the 'kid' field
to prevent undetected stripping of the authentication and integrity
mechanism; this prevents an attacker from altering the 'kid' to trick the
recipient into using a different key.</t>
      <t>With AES-CBC mode, implementers should perform integrity checks prior to
decryption to avoid padding oracle vulnerabilities <xref target="Vaudenay"/>.</t>
      <t>With the assignment of COSE algorithm identifiers for AES-CTR and
AES-CBC in the COSE Algorithms Registry, an attacker can replace the
COSE algorithm identifiers with one of these identifiers.  Then, the
attacker might be able to manipulate the ciphertext to learn some of the
plaintext or extract the keying material used for authentication and
integrity.</t>
      <t>Since AES-CCM <xref target="RFC3610"/> and AES-GCM <xref target="GCMMODE"/> use AES-CTR for encryption,
an attacker can switch the algorithm identifier to AES-CTR and then strip the
authentication tag to bypass the authentication and integrity, allowing the
      attacker to manipulate the ciphertext.</t>

      
      <t>An attacker can switch the algorithm identifier from AES-GCM to AES-CBC,
guessing 16 bytes of plaintext at a time, and see if the recipient
accepts the padding. Padding oracle vulnerabilities are discussed
further in <xref target="Vaudenay" format="default"/>.</t>
    </section>

  </middle>
  <back>

<displayreference target="I-D.ietf-suit-manifest" to="SUIT-MANIFEST"/>

    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>

<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4107.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.5652.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9052.xml"/>



        <reference anchor="AES">
          <front>
            <title>Advanced Encryption Standard (AES)</title>
            <author>
              <organization>National Institute of Standards and Technology (NIST)</organization>
            </author>
            <date year="2023" month="May"/>
          </front>
          <seriesInfo name="NIST FIPS" value="197"/>
	  <seriesInfo name='DOI' value="10.6028/NIST.FIPS.197-upd1" />
        </reference>

        <reference anchor="MODES">
          <front>
            <title>Recommendation for Block Cipher Modes of Operation: Methods and Techniques</title>
            <author initials="M." surname="Dworkin" fullname="Morris Dworkin">
              <organization>National Institute of Standards and Technology (NIST)</organization>
            </author>
            <date year="2001" month="December"/>
          </front>
          <seriesInfo name="NIST Special Publication" value="800-38A"/>
	  <seriesInfo name="DOI" value="10.6028/NIST.SP.800-38A "/>
        </reference>
      </references>
      <references>
        <name>Informative References</name>

<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.3610.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.5116.xml"/>

<!-- [I-D.ietf-suit-manifest] IESG state AD Evaluation::Revised I-D Needed - Used Long Way to capture non-ASCII initial-->

<reference anchor="I-D.ietf-suit-manifest" target="https://datatracker.ietf.org/doc/html/draft-ietf-suit-manifest-22">
  <front>
    <title>A Concise Binary Object Representation (CBOR)-based Serialization Format for the Software Updates for Internet of Things (SUIT) Manifest</title>
    <author fullname="Brendan Moran" initials="B." surname="Moran">
      <organization>Arm Limited</organization>
    </author>
    <author fullname="Hannes Tschofenig" initials="H." surname="Tschofenig">
      <organization>Arm Limited</organization>
    </author>
    <author fullname="Henk Birkholz" initials="H." surname="Birkholz">
      <organization>Fraunhofer SIT</organization>
    </author>
    <author fullname="Koen Zandberg" initials="K." surname="Zandberg">
      <organization>Inria</organization>
    </author>
    <author fullname="Øyvind Rønningstad" initials="Ø." surname="Rønningstad">
      <organization>Nordic Semiconductor</organization>
    </author>
    <date day="27" month="February" year="2023"/>
  </front>
  <seriesInfo name="Internet-Draft" value="draft-ietf-suit-manifest-22"/>
</reference>

        <reference anchor="GCMMODE">
          <front>
            <title>Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC</title>
            <author initials="M." surname="Dworkin" fullname="Morris Dworkin">
              <organization>National Institute of Standards and Technology (NIST)</organization>
            </author>
            <date year="2007" month="November"/>
          </front>
          <seriesInfo name="NIST Special Publication" value="800-38D"/>
	  <seriesInfo name="DOI" value="10.6028/NIST.SP.800-38D "/>
        </reference>

	
        <reference anchor="IANA-COSE" target="https://www.iana.org/assignments/cose">
          <front>
            <title>CBOR Object Signing and Encryption (COSE)</title>
            <author>
              <organization>IANA</organization>
            </author>
          </front>
        </reference>

        <reference anchor="Vaudenay" target="https://www.iacr.org/cryptodb/archive/2002/EUROCRYPT/2850/2850.pdf">
          <front>
            <title>Security Flaws Induced by CBC Padding -- Applications to SSL, IPSEC, WTLS...</title>
            <author initials="S." surname="Vaudenay" fullname="Serge Vaudenay">
              <organization>Swiss Federal Institute of Technology (EPFL)</organization>
            </author>
            <date year="2002"/>
          </front>
          <seriesInfo name="EUROCRYPT" value="2002"/>
        </reference>
      </references>
    </references>

    <section anchor="acknowledgements" numbered="false">
      <name>Acknowledgements</name>
      <t>Many thanks to <contact fullname="David Brown"/> for raising the need for non-AEAD algorithms
to support encryption within the SUIT manifest.  Many thanks to
<contact fullname="Ilari Liusvaara"/>,
<contact fullname="Scott Arciszewski"/>,
<contact fullname="John Preuß Mattsson"/>,
<contact fullname="Laurence Lundblade"/>,
<contact fullname="Paul Wouters"/>,
<contact fullname="Roman Danyliw"/>,
<contact fullname="Sophie Schmieg"/>, <contact fullname="Stephen Farrell"/>, <contact fullname="Carsten Bormann"/>, <contact fullname="Scott Fluhrer"/>, <contact fullname="Brendan Moran"/>, and
<contact fullname="John Scudder"/>
for the review and thoughtful comments.</t>
    </section>    
  </back>
</rfc>
