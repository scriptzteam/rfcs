<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" ipr="trust200902" number="9605" docName="draft-ietf-sframe-enc-09" category="std" consensus="true" submissionType="IETF" tocInclude="true" sortRefs="true" symRefs="true" version="3">
  <front>
    <title abbrev="SFrame">Secure Frame (SFrame): Lightweight Authenticated Encryption for Real&nbhy;Time Media</title>
    <seriesInfo name="RFC" value="9605"/>
    <author initials="E." surname="Omara" fullname="Emad Omara">
      <organization>Apple</organization>
      <address>
        <email>eomara@apple.com</email>
      </address>
    </author>
    <author initials="J." surname="Uberti" fullname="Justin Uberti">
      <organization>Fixie.ai</organization>
      <address>
        <email>justin@fixie.ai</email>
      </address>
    </author>
    <author initials="S. G." surname="Murillo" fullname="Sergio Garcia Murillo">
      <organization>CoSMo Software</organization>
      <address>
        <email>sergio.garcia.murillo@cosmosoftware.io</email>
      </address>
    </author>
    <author initials="R." surname="Barnes" fullname="Richard Barnes" role="editor">
      <organization>Cisco</organization>
      <address>
        <email>rlb@ipv.sx</email>
      </address>
    </author>
    <author initials="Y." surname="Fablet" fullname="Youenn Fablet">
      <organization>Apple</organization>
      <address>
        <email>youenn@apple.com</email>
      </address>
    </author>
    <date year="2024" month="August"/>
    <area>Applications and Real-Time</area>
    <workgroup>sframe</workgroup>
    <keyword>security</keyword>
    <keyword>real-time media encryption</keyword>
    <keyword>end-to-end encryption</keyword>
    <abstract>

<t>This document describes the Secure Frame (SFrame) end-to-end encryption and
authentication mechanism for media frames in a multiparty conference call, in
which central media servers (Selective Forwarding Units or SFUs) can access the
media metadata needed to make forwarding decisions without having access to the
actual media.</t>
      <t>This mechanism differs from the Secure Real-Time Protocol (SRTP) in that
it is independent of RTP (thus compatible with non-RTP media transport) and can
be applied to whole media frames in order to be more bandwidth efficient.</t>
    </abstract>
  </front>
  <middle>

<section anchor="introduction">
      <name>Introduction</name>
      <t>Modern multiparty video call systems use Selective Forwarding Unit (SFU)
servers to efficiently route media streams to call endpoints based on factors such
as available bandwidth, desired video size, codec support, and other factors. An
SFU typically does not need access to the media content of the conference,
which allows the media to be encrypted "end to end" so that it cannot be
decrypted by the SFU. In order for the SFU to work properly, though, it usually
needs to be able to access RTP metadata and RTCP feedback messages, which is not
possible if all RTP/RTCP traffic is end-to-end encrypted.</t>
      <t>As such, two layers of encryption and authentication are required:</t>
      <ol spacing="normal" type="1"><li>
          <t>Hop-by-hop (HBH) encryption of media, metadata, and feedback messages
between the endpoints and SFU</t>
        </li>
        <li>
          <t>End-to-end (E2E) encryption (E2EE) of media between the endpoints</t>
        </li>
      </ol>
      <t>The Secure Real-Time Protocol (SRTP) is already widely used for HBH encryption
<xref target="RFC3711"/>. The SRTP "double encryption" scheme defines a way to do E2E
encryption in SRTP <xref target="RFC8723"/>. Unfortunately, this scheme has poor efficiency
and high complexity, and its entanglement with RTP makes it unworkable in
several realistic SFU scenarios.</t>
      <t>This document proposes a new E2EE protection scheme known as SFrame,
specifically designed to work in group conference calls with SFUs. SFrame is a
general encryption framing that can be used to protect media payloads, agnostic
of transport.</t>
    </section>
    <section anchor="terminology">
      <name>Terminology</name>
        <t>The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>",
        "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL NOT</bcp14>",
        "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>",
        "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
        "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be
        interpreted as described in BCP&nbsp;14 <xref target="RFC2119"/> <xref
        target="RFC8174"/> when, and only when, they appear in all capitals, as
        shown here.</t>
<dl>
        <dt>MAC:</dt>
        <dd>
          <t>Message Authentication Code</t>
        </dd>
        <dt>E2EE:</dt>
        <dd>
          <t>End-to-End Encryption</t>
        </dd>
        <dt>HBH:</dt>
        <dd>
          <t>Hop-by-Hop</t>
        </dd>
      </dl>
      <t>We use "Selective Forwarding Unit (SFU)" and "media stream" in a less formal sense
than in <xref target="RFC7656"/>.  An SFU is a selective switching function for media
payloads, and a media stream is a sequence of media payloads,
regardless of whether those media payloads are transported over RTP or some
other protocol.</t>
    </section>
    <section anchor="goals">
      <name>Goals</name>
      <t>SFrame is designed to be a suitable E2EE protection scheme for conference call
media in a broad range of scenarios, as outlined by the following goals:</t>
      <ol spacing="normal" type="1"><li>
          <t>Provide a secure E2EE mechanism for audio and video in conference calls
that can be used with arbitrary SFU servers.</t>
        </li>
        <li>
          <t>Decouple media encryption from key management to allow SFrame to be used
with an arbitrary key management system.</t>
        </li>
        <li>
          <t>Minimize packet expansion to allow successful conferencing in as many
network conditions as possible.</t>
        </li>
        <li>
          <t>Decouple the media encryption framework from the underlying transport,
allowing use in non-RTP scenarios, e.g., WebTransport
<xref target="I-D.ietf-webtrans-overview"/>.</t>
        </li>
        <li>
          <t>When used with RTP and its associated error-resilience mechanisms, i.e., RTX
and Forward Error Correction (FEC), require no special handling for RTX and FEC packets.</t>
        </li>
        <li>
          <t>Minimize the changes needed in SFU servers.</t>
        </li>
        <li>
          <t>Minimize the changes needed in endpoints.</t>
        </li>
        <li>
          <t>Work with the most popular audio and video codecs used in conferencing
scenarios.</t>
        </li>
      </ol>
    </section>
    <section anchor="sframe">
      <name>SFrame</name>
      <t>This document defines an encryption mechanism that provides effective E2EE,
is simple to implement, has no dependencies on RTP, and minimizes
encryption bandwidth overhead. This section describes how the mechanism
works and includes details of how applications utilize SFrame for media protection
as well as the actual mechanics of E2EE for protecting media.</t>
      <section anchor="application-context">
        <name>Application Context</name>
        <t>SFrame is a general encryption framing, intended to be used as an E2EE
layer over an underlying HBH-encrypted transport such as SRTP or QUIC
<xref target="RFC3711"/><xref target="I-D.ietf-moq-transport"/>.</t>
        <t>The scale at which SFrame encryption is applied to media determines the overall
amount of overhead that SFrame adds to the media stream as well as the
engineering complexity involved in integrating SFrame into a particular
environment. Two patterns are common: using SFrame to encrypt either whole
media frames (per frame) or individual transport-level media payloads
(per packet).</t>
        <t>For example, <xref target="media-stack"/> shows a typical media sender stack that takes media
from some source, encodes it into frames, divides those frames into media
packets, and then sends those payloads in SRTP packets. The receiver stack
performs the reverse operations, reassembling frames from SRTP packets and
decoding.  Arrows indicate two different ways that SFrame protection could be
integrated into this media stack: to encrypt whole frames or individual media
packets.</t>
        <t>Applying SFrame per frame in this system offers higher efficiency but may
require a more complex integration in environments where depacketization relies
on the content of media packets. Applying SFrame per packet avoids this
complexity at the cost of higher bandwidth consumption.  Some quantitative
discussion of these trade-offs is provided in <xref target="overhead-analysis"/>.</t>
        <t>As noted above, however, SFrame is a general media encapsulation and can be
applied in other scenarios.  The important thing is that the sender and
receivers of an SFrame-encrypted object agree on that object's semantics.
SFrame does not provide this agreement; it must be arranged by the application.</t>
        <figure anchor="media-stack">
          <name>Two Options for Integrating SFrame in a Typical Media Stack</name>
          <artset>
            <artwork type="svg"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="576" width="584" viewBox="0 0 584 576" class="diagram" text-anchor="middle" font-family="monospace" font-size="13px" stroke-linecap="round">
                <path d="M 24,112 L 24,144" fill="none" stroke="black"/>
                <path d="M 24,432 L 24,464" fill="none" stroke="black"/>
                <path d="M 56,32 L 56,240" fill="none" stroke="black"/>
                <path d="M 56,352 L 56,560" fill="none" stroke="black"/>
                <path d="M 80,64 L 80,128" fill="none" stroke="black"/>
                <path d="M 80,464 L 80,528" fill="none" stroke="black"/>
                <path d="M 152,64 L 152,128" fill="none" stroke="black"/>
                <path d="M 152,464 L 152,528" fill="none" stroke="black"/>
                <path d="M 184,104 L 184,144" fill="none" stroke="black"/>
                <path d="M 184,208 L 184,384" fill="none" stroke="black"/>
                <path d="M 184,448 L 184,488" fill="none" stroke="black"/>
                <path d="M 208,64 L 208,128" fill="none" stroke="black"/>
                <path d="M 208,464 L 208,528" fill="none" stroke="black"/>
                <path d="M 320,64 L 320,128" fill="none" stroke="black"/>
                <path d="M 320,464 L 320,528" fill="none" stroke="black"/>
                <path d="M 344,104 L 344,144" fill="none" stroke="black"/>
                <path d="M 344,208 L 344,384" fill="none" stroke="black"/>
                <path d="M 352,448 L 352,488" fill="none" stroke="black"/>
                <path d="M 376,64 L 376,128" fill="none" stroke="black"/>
                <path d="M 376,464 L 376,528" fill="none" stroke="black"/>
                <path d="M 424,136 L 424,272" fill="none" stroke="black"/>
                <path d="M 424,320 L 424,456" fill="none" stroke="black"/>
                <path d="M 472,64 L 472,128" fill="none" stroke="black"/>
                <path d="M 472,464 L 472,528" fill="none" stroke="black"/>
                <path d="M 496,32 L 496,88" fill="none" stroke="black"/>
                <path d="M 496,104 L 496,240" fill="none" stroke="black"/>
                <path d="M 496,352 L 496,488" fill="none" stroke="black"/>
                <path d="M 496,504 L 496,560" fill="none" stroke="black"/>
                <path d="M 504,272 L 504,320" fill="none" stroke="black"/>
                <path d="M 560,96 L 560,264" fill="none" stroke="black"/>
                <path d="M 560,320 L 560,496" fill="none" stroke="black"/>
                <path d="M 576,272 L 576,320" fill="none" stroke="black"/>
                <path d="M 56,32 L 496,32" fill="none" stroke="black"/>
                <path d="M 80,64 L 152,64" fill="none" stroke="black"/>
                <path d="M 208,64 L 320,64" fill="none" stroke="black"/>
                <path d="M 376,64 L 472,64" fill="none" stroke="black"/>
                <path d="M 160,96 L 200,96" fill="none" stroke="black"/>
                <path d="M 328,96 L 368,96" fill="none" stroke="black"/>
                <path d="M 480,96 L 560,96" fill="none" stroke="black"/>
                <path d="M 80,128 L 152,128" fill="none" stroke="black"/>
                <path d="M 208,128 L 320,128" fill="none" stroke="black"/>
                <path d="M 376,128 L 472,128" fill="none" stroke="black"/>
                <path d="M 56,240 L 176,240" fill="none" stroke="black"/>
                <path d="M 192,240 L 336,240" fill="none" stroke="black"/>
                <path d="M 352,240 L 416,240" fill="none" stroke="black"/>
                <path d="M 432,240 L 496,240" fill="none" stroke="black"/>
                <path d="M 504,272 L 576,272" fill="none" stroke="black"/>
                <path d="M 184,304 L 216,304" fill="none" stroke="black"/>
                <path d="M 320,304 L 344,304" fill="none" stroke="black"/>
                <path d="M 504,320 L 576,320" fill="none" stroke="black"/>
                <path d="M 56,352 L 176,352" fill="none" stroke="black"/>
                <path d="M 192,352 L 336,352" fill="none" stroke="black"/>
                <path d="M 352,352 L 416,352" fill="none" stroke="black"/>
                <path d="M 432,352 L 496,352" fill="none" stroke="black"/>
                <path d="M 80,464 L 152,464" fill="none" stroke="black"/>
                <path d="M 208,464 L 320,464" fill="none" stroke="black"/>
                <path d="M 376,464 L 472,464" fill="none" stroke="black"/>
                <path d="M 160,496 L 200,496" fill="none" stroke="black"/>
                <path d="M 328,496 L 368,496" fill="none" stroke="black"/>
                <path d="M 480,496 L 560,496" fill="none" stroke="black"/>
                <path d="M 80,528 L 152,528" fill="none" stroke="black"/>
                <path d="M 208,528 L 320,528" fill="none" stroke="black"/>
                <path d="M 376,528 L 472,528" fill="none" stroke="black"/>
                <path d="M 56,560 L 496,560" fill="none" stroke="black"/>
                <path d="M 24,464 L 40,496" fill="none" stroke="black"/>
                <path d="M 24,432 L 40,464" fill="none" stroke="black"/>
                <path d="M 24,144 L 40,176" fill="none" stroke="black"/>
                <path d="M 24,112 L 40,144" fill="none" stroke="black"/>
                <path d="M 8,144 L 24,112" fill="none" stroke="black"/>
                <path d="M 8,176 L 24,144" fill="none" stroke="black"/>
                <path d="M 8,464 L 24,432" fill="none" stroke="black"/>
                <path d="M 8,496 L 24,464" fill="none" stroke="black"/>
                <path d="M 24,80 C 15.16936,80 8,87.16936 8,96" fill="none" stroke="black"/>
                <path d="M 24,80 C 32.83064,80 40,87.16936 40,96" fill="none" stroke="black"/>
                <path d="M 24,112 C 15.16936,112 8,104.83064 8,96" fill="none" stroke="black"/>
                <path d="M 24,112 C 32.83064,112 40,104.83064 40,96" fill="none" stroke="black"/>
                <path d="M 24,400 C 15.16936,400 8,407.16936 8,416" fill="none" stroke="black"/>
                <path d="M 24,400 C 32.83064,400 40,407.16936 40,416" fill="none" stroke="black"/>
                <path d="M 24,432 C 15.16936,432 8,424.83064 8,416" fill="none" stroke="black"/>
                <path d="M 24,432 C 32.83064,432 40,424.83064 40,416" fill="none" stroke="black"/>
                <polygon class="arrowhead" points="568,264 556,258.4 556,269.6" fill="black" transform="rotate(90,560,264)"/>
                <polygon class="arrowhead" points="488,496 476,490.4 476,501.6" fill="black" transform="rotate(180,480,496)"/>
                <polygon class="arrowhead" points="432,456 420,450.4 420,461.6" fill="black" transform="rotate(90,424,456)"/>
                <polygon class="arrowhead" points="432,136 420,130.4 420,141.6" fill="black" transform="rotate(270,424,136)"/>
                <polygon class="arrowhead" points="376,96 364,90.4 364,101.6" fill="black" transform="rotate(0,368,96)"/>
                <polygon class="arrowhead" points="360,488 348,482.4 348,493.6" fill="black" transform="rotate(90,352,488)"/>
                <polygon class="arrowhead" points="352,384 340,378.4 340,389.6" fill="black" transform="rotate(90,344,384)"/>
                <polygon class="arrowhead" points="352,208 340,202.4 340,213.6" fill="black" transform="rotate(270,344,208)"/>
                <polygon class="arrowhead" points="352,104 340,98.4 340,109.6" fill="black" transform="rotate(270,344,104)"/>
                <polygon class="arrowhead" points="336,496 324,490.4 324,501.6" fill="black" transform="rotate(180,328,496)"/>
                <polygon class="arrowhead" points="208,96 196,90.4 196,101.6" fill="black" transform="rotate(0,200,96)"/>
                <polygon class="arrowhead" points="192,488 180,482.4 180,493.6" fill="black" transform="rotate(90,184,488)"/>
                <polygon class="arrowhead" points="192,384 180,378.4 180,389.6" fill="black" transform="rotate(90,184,384)"/>
                <polygon class="arrowhead" points="192,208 180,202.4 180,213.6" fill="black" transform="rotate(270,184,208)"/>
                <polygon class="arrowhead" points="192,104 180,98.4 180,109.6" fill="black" transform="rotate(270,184,104)"/>
                <polygon class="arrowhead" points="168,496 156,490.4 156,501.6" fill="black" transform="rotate(180,160,496)"/>
                <g class="text">
                  <text x="424" y="84">HBH</text>
                  <text x="116" y="100">Encode</text>
                  <text x="264" y="100">Packetize</text>
                  <text x="424" y="100">Protect</text>
                  <text x="180" y="164">SFrame</text>
                  <text x="340" y="164">SFrame</text>
                  <text x="184" y="180">Protect</text>
                  <text x="344" y="180">Protect</text>
                  <text x="24" y="196">Alice</text>
                  <text x="156" y="196">(per</text>
                  <text x="204" y="196">frame)</text>
                  <text x="316" y="196">(per</text>
                  <text x="368" y="196">packet)</text>
                  <text x="248" y="292">E2E</text>
                  <text x="280" y="292">Key</text>
                  <text x="416" y="292">HBH</text>
                  <text x="448" y="292">Key</text>
                  <text x="536" y="292">Media</text>
                  <text x="268" y="308">Management</text>
                  <text x="436" y="308">Management</text>
                  <text x="540" y="308">Server</text>
                  <text x="180" y="404">SFrame</text>
                  <text x="348" y="404">SFrame</text>
                  <text x="184" y="420">Unprotect</text>
                  <text x="352" y="420">Unprotect</text>
                  <text x="156" y="436">(per</text>
                  <text x="204" y="436">frame)</text>
                  <text x="324" y="436">(per</text>
                  <text x="376" y="436">packet)</text>
                  <text x="424" y="484">HBH</text>
                  <text x="116" y="500">Decode</text>
                  <text x="264" y="500">Depacketize</text>
                  <text x="424" y="500">Unprotect</text>
                  <text x="24" y="516">Bob</text>
                </g>
              </svg>
            </artwork>
            <artwork type="ascii-art"><![CDATA[
      +------------------------------------------------------+
      |                                                      |
      |  +--------+      +-------------+      +-----------+  |
 .-.  |  |        |      |             |      |    HBH    |  |
|   | |  | Encode |----->|  Packetize  |----->|  Protect  |----------+
 '+'  |  |        |   ^  |             |  ^   |           |  |       |
 /|\  |  +--------+   |  +-------------+  |   +-----------+  |       |
/ + \ |               |                   |         ^        |       |
 / \  |            SFrame              SFrame       |        |       |
/   \ |            Protect             Protect      |        |       |
Alice |          (per frame)         (per packet)   |        |       |
      |               ^                   ^         |        |       |
      |               |                   |         |        |       |
      +---------------|-------------------|---------|--------+       |
                      |                   |         |                v
                      |                   |         |         +------+-+
                      |      E2E Key      |       HBH Key     | Media  |
                      +---- Management ---+      Management   | Server |
                      |                   |         |         +------+-+
                      |                   |         |                |
      +---------------|-------------------|---------|--------+       |
      |               |                   |         |        |       |
      |               V                   V         |        |       |
 .-.  |            SFrame               SFrame      |        |       |
|   | |           Unprotect            Unprotect    |        |       |
 '+'  |          (per frame)          (per packet)  |        |       |
 /|\  |               |                    |        V        |       |
/ + \ |  +--------+   |  +-------------+   |  +-----------+  |       |
 / \  |  |        |   V  |             |   V  |    HBH    |  |       |
/   \ |  | Decode |<-----| Depacketize |<-----| Unprotect |<---------+
 Bob  |  |        |      |             |      |           |  |
      |  +--------+      +-------------+      +-----------+  |
      |                                                      |
      +------------------------------------------------------+
]]></artwork>
          </artset>
        </figure>
        <t>Like SRTP, SFrame does not define how the keys used for SFrame are exchanged by
the parties in the conference.  Keys for SFrame might be distributed over an
existing E2E-secure channel (see <xref target="sender-keys"/>) or derived from an E2E-secure
shared secret (see <xref target="mls"/>).  The key management system <bcp14>MUST</bcp14> ensure that each
key used for encrypting media is used by exactly one media sender in order to
avoid reuse of nonces.</t>
      </section>
      <section anchor="sframe-ciphertext">
        <name>SFrame Ciphertext</name>
        <t>An SFrame ciphertext comprises an SFrame header followed by the output of an
Authenticated Encryption with Associated Data (AEAD) encryption of the plaintext <xref target="RFC5116"/>, with the header provided as additional
authenticated data (AAD).</t>
        <t>The SFrame header is a variable-length structure described in detail in
<xref target="sframe-header"/>.  The structure of the encrypted data and authentication tag
are determined by the AEAD algorithm in use.</t>
        <figure anchor="sframe-ciphertext-struct">
          <name>Structure of an SFrame Ciphertext</name>
          <artset>
            <artwork type="svg"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="320" width="512" viewBox="0 0 512 320" class="diagram" text-anchor="middle" font-family="monospace" font-size="13px" stroke-linecap="round">
                <path d="M 8,64 L 8,304" fill="none" stroke="black"/>
                <path d="M 32,32 L 32,256" fill="none" stroke="black"/>
                <path d="M 48,32 L 48,64" fill="none" stroke="black"/>
                <path d="M 88,32 L 88,64" fill="none" stroke="black"/>
                <path d="M 104,32 L 104,64" fill="none" stroke="black"/>
                <path d="M 144,32 L 144,64" fill="none" stroke="black"/>
                <path d="M 312,32 L 312,64" fill="none" stroke="black"/>
                <path d="M 480,32 L 480,256" fill="none" stroke="black"/>
                <path d="M 504,32 L 504,304" fill="none" stroke="black"/>
                <path d="M 32,32 L 504,32" fill="none" stroke="black"/>
                <path d="M 8,64 L 480,64" fill="none" stroke="black"/>
                <path d="M 8,224 L 504,224" fill="none" stroke="black"/>
                <path d="M 32,256 L 480,256" fill="none" stroke="black"/>
                <path d="M 8,304 L 32,304" fill="none" stroke="black"/>
                <path d="M 480,304 L 504,304" fill="none" stroke="black"/>
                <polygon class="arrowhead" points="496,224 484,218.4 484,229.6" fill="black" transform="rotate(180,488,224)"/>
                <polygon class="arrowhead" points="496,32 484,26.4 484,37.6" fill="black" transform="rotate(180,488,32)"/>
                <polygon class="arrowhead" points="32,224 20,218.4 20,229.6" fill="black" transform="rotate(0,24,224)"/>
                <polygon class="arrowhead" points="32,64 20,58.4 20,69.6" fill="black" transform="rotate(0,24,64)"/>
                <g class="text">
                  <text x="40" y="52">K</text>
                  <text x="68" y="52">KLEN</text>
                  <text x="96" y="52">C</text>
                  <text x="124" y="52">CLEN</text>
                  <text x="216" y="52">Key</text>
                  <text x="244" y="52">ID</text>
                  <text x="392" y="52">Counter</text>
                  <text x="224" y="148">Encrypted</text>
                  <text x="284" y="148">Data</text>
                  <text x="228" y="244">Authentication</text>
                  <text x="304" y="244">Tag</text>
                  <text x="80" y="308">Encrypted</text>
                  <text x="152" y="308">Portion</text>
                  <text x="352" y="308">Authenticated</text>
                  <text x="440" y="308">Portion</text>
                </g>
              </svg>
            </artwork>
            <artwork type="ascii-art"><![CDATA[
   +-+----+-+----+--------------------+--------------------+<-+
   |K|KLEN|C|CLEN|       Key ID       |      Counter       |  |
+->+-+----+-+----+--------------------+--------------------+  |
|  |                                                       |  |
|  |                                                       |  |
|  |                                                       |  |
|  |                                                       |  |
|  |                   Encrypted Data                      |  |
|  |                                                       |  |
|  |                                                       |  |
|  |                                                       |  |
|  |                                                       |  |
+->+-------------------------------------------------------+<-+
|  |                 Authentication Tag                    |  |
|  +-------------------------------------------------------+  |
|                                                             |
|                                                             |
+--- Encrypted Portion               Authenticated Portion ---+
]]></artwork>
          </artset>
        </figure>
        <t>When SFrame is applied per packet, the payload of each packet will be an SFrame
ciphertext.  When SFrame is applied per frame, the SFrame ciphertext
representing an encrypted frame will span several packets, with the header
appearing in the first packet and the authentication tag in the last packet.
It is the responsibility of the application to reassemble an encrypted frame from
individual packets, accounting for packet loss and reordering as necessary.</t>
      </section>
      <section anchor="sframe-header">
        <name>SFrame Header</name>
        <t>The SFrame header specifies two values from which encryption parameters are
derived:</t>
        <ul spacing="normal">
          <li>
            <t>A Key ID (KID) that determines which encryption key should be used</t>
          </li>
          <li>
            <t>A Counter (CTR) that is used to construct the nonce for the encryption</t>
          </li>
        </ul>
        <t>Applications <bcp14>MUST</bcp14> ensure that each (KID, CTR) combination is used for exactly
one SFrame encryption operation. A typical approach to achieve this guarantee is
outlined in <xref target="header-value-uniqueness"/>.</t>
        <figure anchor="fig-sframe-header">
          <name>SFrame Header</name>
          <artset>
            <artwork type="svg"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="160" width="352" viewBox="0 0 352 160" class="diagram" text-anchor="middle" font-family="monospace" font-size="13px" stroke-linecap="round">
                <path d="M 8,112 L 8,144" fill="none" stroke="black"/>
                <path d="M 24,112 L 24,144" fill="none" stroke="black"/>
                <path d="M 72,112 L 72,144" fill="none" stroke="black"/>
                <path d="M 88,112 L 88,144" fill="none" stroke="black"/>
                <path d="M 136,112 L 136,144" fill="none" stroke="black"/>
                <path d="M 240,112 L 240,144" fill="none" stroke="black"/>
                <path d="M 344,112 L 344,144" fill="none" stroke="black"/>
                <path d="M 24,64 L 56,64" fill="none" stroke="black"/>
                <path d="M 88,64 L 120,64" fill="none" stroke="black"/>
                <path d="M 8,112 L 344,112" fill="none" stroke="black"/>
                <path d="M 8,144 L 344,144" fill="none" stroke="black"/>
                <path d="M 24,64 C 15.16936,64 8,71.16936 8,80" fill="none" stroke="black"/>
                <path d="M 56,64 C 64.83064,64 72,56.83064 72,48" fill="none" stroke="black"/>
                <path d="M 88,64 C 79.16936,64 72,56.83064 72,48" fill="none" stroke="black"/>
                <path d="M 120,64 C 128.83064,64 136,71.16936 136,80" fill="none" stroke="black"/>
                <g class="text">
                  <text x="52" y="36">Config</text>
                  <text x="100" y="36">Byte</text>
                  <text x="16" y="100">0</text>
                  <text x="32" y="100">1</text>
                  <text x="48" y="100">2</text>
                  <text x="64" y="100">3</text>
                  <text x="80" y="100">4</text>
                  <text x="96" y="100">5</text>
                  <text x="112" y="100">6</text>
                  <text x="128" y="100">7</text>
                  <text x="16" y="132">X</text>
                  <text x="48" y="132">K</text>
                  <text x="80" y="132">Y</text>
                  <text x="112" y="132">C</text>
                  <text x="188" y="132">KID...</text>
                  <text x="292" y="132">CTR...</text>
                </g>
              </svg>
            </artwork>
            <artwork type="ascii-art"><![CDATA[
   Config Byte
        |
 .-----' '-----.
|               |
 0 1 2 3 4 5 6 7
+-+-+-+-+-+-+-+-+------------+------------+
|X|  K  |Y|  C  |   KID...   |   CTR...   |
+-+-+-+-+-+-+-+-+------------+------------+
]]></artwork>
          </artset>
        </figure>
        <t>The SFrame header has the overall structure shown in <xref target="fig-sframe-header"/>.  The
first byte is a "config byte", with the following fields:</t>
        <dl>
          <dt>Extended KID Flag (X, 1 bit):</dt>
          <dd>
            <t>Indicates if the K field contains the KID or the KID length.</t>
          </dd>
          <dt>KID or KID Length (K, 3 bits):</dt>
          <dd>
            <t>If the X flag is set to 0, this field contains the KID.  If the X flag is
set to 1, then it contains the length of the KID, minus one.</t>
          </dd>
          <dt>Extended CTR Flag (Y, 1 bit):</dt>
          <dd>
            <t>Indicates if the C field contains the CTR or the CTR length.</t>
          </dd>
          <dt>CTR or CTR Length (C, 3 bits):</dt>
          <dd>
            <t>This field contains the CTR if the Y flag is set to 0, or the CTR
length, minus one, if set to 1.</t>
          </dd>
        </dl>
        <t>The KID and CTR fields are encoded as compact unsigned integers in
network (big-endian) byte order.  If the value of one of these fields is in the
range 0-7, then the value is carried in the corresponding bits of the config
byte (K or C) and the corresponding flag (X or Y) is set to zero.  Otherwise,
the value <bcp14>MUST</bcp14> be encoded with the minimum number of bytes required and
appended after the config byte, with the KID first and CTR second.
The header field (K or C) is set to the number of bytes in the encoded value,
minus one.  The value 000 represents a length of 1, 001 a length of 2, etc.
This allows a 3-bit length field to represent the value lengths 1-8.</t>
        <t>The SFrame header can thus take one of the four forms shown in
<xref target="fig-sframe-header-cases"/>, depending on which of the X and Y flags are set.</t>
        <figure anchor="fig-sframe-header-cases">
          <name>Forms of Encoded SFrame Header</name>
          <artset>
            <artwork type="svg"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="336" width="544" viewBox="0 0 544 336" class="diagram" text-anchor="middle" font-family="monospace" font-size="13px" stroke-linecap="round">
                <path d="M 8,48 L 8,80" fill="none" stroke="black"/>
                <path d="M 8,128 L 8,160" fill="none" stroke="black"/>
                <path d="M 8,208 L 8,240" fill="none" stroke="black"/>
                <path d="M 8,288 L 8,320" fill="none" stroke="black"/>
                <path d="M 24,48 L 24,80" fill="none" stroke="black"/>
                <path d="M 24,128 L 24,160" fill="none" stroke="black"/>
                <path d="M 24,208 L 24,240" fill="none" stroke="black"/>
                <path d="M 24,288 L 24,320" fill="none" stroke="black"/>
                <path d="M 72,48 L 72,80" fill="none" stroke="black"/>
                <path d="M 72,128 L 72,160" fill="none" stroke="black"/>
                <path d="M 72,192 L 72,240" fill="none" stroke="black"/>
                <path d="M 72,272 L 72,320" fill="none" stroke="black"/>
                <path d="M 88,48 L 88,80" fill="none" stroke="black"/>
                <path d="M 88,128 L 88,160" fill="none" stroke="black"/>
                <path d="M 88,208 L 88,240" fill="none" stroke="black"/>
                <path d="M 88,288 L 88,320" fill="none" stroke="black"/>
                <path d="M 136,48 L 136,80" fill="none" stroke="black"/>
                <path d="M 136,128 L 136,160" fill="none" stroke="black"/>
                <path d="M 136,208 L 136,240" fill="none" stroke="black"/>
                <path d="M 136,288 L 136,320" fill="none" stroke="black"/>
                <path d="M 336,128 L 336,160" fill="none" stroke="black"/>
                <path d="M 336,208 L 336,240" fill="none" stroke="black"/>
                <path d="M 336,288 L 336,320" fill="none" stroke="black"/>
                <path d="M 536,288 L 536,320" fill="none" stroke="black"/>
                <path d="M 8,48 L 136,48" fill="none" stroke="black"/>
                <path d="M 8,80 L 136,80" fill="none" stroke="black"/>
                <path d="M 8,128 L 336,128" fill="none" stroke="black"/>
                <path d="M 8,160 L 336,160" fill="none" stroke="black"/>
                <path d="M 8,208 L 336,208" fill="none" stroke="black"/>
                <path d="M 8,240 L 336,240" fill="none" stroke="black"/>
                <path d="M 8,288 L 536,288" fill="none" stroke="black"/>
                <path d="M 8,320 L 536,320" fill="none" stroke="black"/>
                <g class="text">
                  <text x="16" y="36">KID</text>
                  <text x="40" y="36">&lt;</text>
                  <text x="60" y="36">8,</text>
                  <text x="88" y="36">CTR</text>
                  <text x="112" y="36">&lt;</text>
                  <text x="132" y="36">8:</text>
                  <text x="16" y="68">0</text>
                  <text x="48" y="68">KID</text>
                  <text x="80" y="68">0</text>
                  <text x="112" y="68">CTR</text>
                  <text x="16" y="116">KID</text>
                  <text x="40" y="116">&lt;</text>
                  <text x="60" y="116">8,</text>
                  <text x="88" y="116">CTR</text>
                  <text x="116" y="116">&gt;=</text>
                  <text x="140" y="116">8:</text>
                  <text x="16" y="148">0</text>
                  <text x="48" y="148">KID</text>
                  <text x="80" y="148">1</text>
                  <text x="108" y="148">CLEN</text>
                  <text x="180" y="148">CTR...</text>
                  <text x="264" y="148">(length=CLEN)</text>
                  <text x="16" y="196">KID</text>
                  <text x="44" y="196">&gt;=</text>
                  <text x="64" y="196">8</text>
                  <text x="96" y="196">CTR</text>
                  <text x="120" y="196">&lt;</text>
                  <text x="140" y="196">8:</text>
                  <text x="16" y="228">1</text>
                  <text x="44" y="228">KLEN</text>
                  <text x="80" y="228">0</text>
                  <text x="112" y="228">CTR</text>
                  <text x="180" y="228">KID...</text>
                  <text x="264" y="228">(length=KLEN)</text>
                  <text x="16" y="276">KID</text>
                  <text x="44" y="276">&gt;=</text>
                  <text x="64" y="276">8</text>
                  <text x="96" y="276">CTR</text>
                  <text x="124" y="276">&gt;=</text>
                  <text x="148" y="276">8:</text>
                  <text x="16" y="308">1</text>
                  <text x="44" y="308">KLEN</text>
                  <text x="80" y="308">1</text>
                  <text x="108" y="308">CLEN</text>
                  <text x="180" y="308">KID...</text>
                  <text x="264" y="308">(length=KLEN)</text>
                  <text x="380" y="308">CTR...</text>
                  <text x="464" y="308">(length=CLEN)</text>
                </g>
              </svg>
            </artwork>
            <artwork type="ascii-art"><![CDATA[
KID < 8, CTR < 8:
+-+-----+-+-----+
|0| KID |0| CTR |
+-+-----+-+-----+

KID < 8, CTR >= 8:
+-+-----+-+-----+------------------------+
|0| KID |1|CLEN |  CTR... (length=CLEN)  |
+-+-----+-+-----+------------------------+

KID >= 8, CTR < 8:
+-+-----+-+-----+------------------------+
|1|KLEN |0| CTR |  KID... (length=KLEN)  |
+-+-----+-+-----+------------------------+

KID >= 8, CTR >= 8:
+-+-----+-+-----+------------------------+------------------------+
|1|KLEN |1|CLEN |  KID... (length=KLEN)  |  CTR... (length=CLEN)  |
+-+-----+-+-----+------------------------+------------------------+
]]></artwork>
          </artset>
        </figure>
      </section>
      <section anchor="encryption-schema">
        <name>Encryption Schema</name>
        <t>SFrame encryption uses an AEAD encryption algorithm and hash function defined by
the cipher suite in use (see <xref target="cipher-suites"/>).  We will refer to the following
aspects of the AEAD and the hash algorithm below:</t>
        <ul spacing="normal">
          <li>
            <t><tt>AEAD.Encrypt</tt> and <tt>AEAD.Decrypt</tt> - The encryption and decryption functions
for the AEAD.  We follow the convention of RFC 5116 <xref target="RFC5116"/> and consider
the authentication tag part of the ciphertext produced by <tt>AEAD.Encrypt</tt> (as
opposed to a separate field as in SRTP <xref target="RFC3711"/>).</t>
          </li>
          <li>
            <t><tt>AEAD.Nk</tt> - The size in bytes of a key for the encryption algorithm</t>
          </li>
          <li>
            <t><tt>AEAD.Nn</tt> - The size in bytes of a nonce for the encryption algorithm</t>
          </li>
          <li>
            <t><tt>AEAD.Nt</tt> - The overhead in bytes of the encryption algorithm (typically the
size of a "tag" that is added to the plaintext)</t>
          </li>
          <li>
            <t><tt>AEAD.Nka</tt> - For cipher suites using the compound AEAD described in
<xref target="aes-ctr-with-sha2"/>, the size in bytes of a key for the underlying encryption
algorithm</t>
          </li>
          <li>
            <t><tt>Hash.Nh</tt> - The size in bytes of the output of the hash function</t>
          </li>
        </ul>
        <section anchor="key-selection">
          <name>Key Selection</name>
          <t>Each SFrame encryption or decryption operation is premised on a single secret
<tt>base_key</tt>, which is labeled with an integer KID value signaled in the SFrame
header.</t>
          <t>The sender and receivers need to agree on which <tt>base_key</tt> should be used for a given
KID.  Moreover, senders and receivers need to agree on whether a <tt>base_key</tt> will be used
for encryption or decryption only. The process for provisioning <tt>base_key</tt> values and their KID
values is beyond the scope of this specification, but its security properties will
bound the assurances that SFrame provides.  For example, if SFrame is used to
provide E2E security against intermediary media nodes, then SFrame keys need to
be negotiated in a way that does not make them accessible to these intermediaries.</t>
          <t>For each known KID value, the client stores the corresponding symmetric key
<tt>base_key</tt>.  For keys that can be used for encryption, the client also stores
the next CTR value to be used when encrypting (initially 0).</t>
          <t>When encrypting a plaintext, the application specifies which KID is to be used,
and the CTR value is incremented after successful encryption.  When decrypting,
the <tt>base_key</tt> for decryption is selected from the available keys using the KID
value in the SFrame header.</t>
          <t>A given <tt>base_key</tt> <bcp14>MUST NOT</bcp14> be used for encryption by multiple senders.  Such reuse
would result in multiple encrypted frames being generated with the same (key,
nonce) pair, which harms the protections provided by many AEAD algorithms.
Implementations <bcp14>MUST</bcp14> mark each <tt>base_key</tt> as usable for encryption or decryption,
never both.</t>
          <t>Note that the set of available keys might change over the lifetime of a
real-time session.  In such cases, the client will need to manage key usage to
avoid media loss due to a key being used to encrypt before all receivers are
able to use it to decrypt.  For example, an application may make decryption-only
keys available immediately, but delay the use of keys for encryption until (a)
all receivers have acknowledged receipt of the new key, or (b) a timeout expires.</t>
        </section>
        <section anchor="key-derivation">
          <name>Key Derivation</name>
          <t>SFrame encryption and decryption use a key and salt derived from the <tt>base_key</tt>
associated with a KID.  Given a <tt>base_key</tt> value, the key and salt are derived
using HMAC-based Key Derivation Function (HKDF) <xref target="RFC5869"/> as follows:</t>
          <sourcecode type="pseudocode"><![CDATA[
def derive_key_salt(KID, base_key):
  sframe_secret = HKDF-Extract("", base_key)

  sframe_key_label = "SFrame 1.0 Secret key " + KID + cipher_suite
  sframe_key =
    HKDF-Expand(sframe_secret, sframe_key_label, AEAD.Nk)

  sframe_salt_label = "SFrame 1.0 Secret salt " + KID + cipher_suite
  sframe_salt =
    HKDF-Expand(sframe_secret, sframe_salt_label, AEAD.Nn)

  return sframe_key, sframe_salt
]]></sourcecode>
          <t>In the derivation of <tt>sframe_secret</tt>:</t>
          <ul spacing="normal">
            <li>
              <t>The <tt>+</tt> operator represents concatenation of byte strings.</t>
            </li>
            <li>
              <t>The KID value is encoded as an 8-byte big-endian integer, not the compressed
form used in the SFrame header.</t>
            </li>
            <li>
              <t>The <tt>cipher_suite</tt> value is a 2-byte big-endian integer representing the
cipher suite in use (see <xref target="sframe-cipher-suites"/>).</t>
            </li>
          </ul>
          <t>The hash function used for HKDF is determined by the cipher suite in use.</t>
        </section>
        <section anchor="encryption">
          <name>Encryption</name>
          <t>SFrame encryption uses the AEAD encryption algorithm for the cipher suite in use.
The key for the encryption is the <tt>sframe_key</tt>.  The nonce is formed by first XORing
the <tt>sframe_salt</tt> with the current CTR value, and then encoding the result as a big-endian integer of
length <tt>AEAD.Nn</tt>.</t>
          <t>The encryptor forms an SFrame header using the CTR and KID values provided.
The encoded header is provided as AAD to the AEAD encryption operation, together
with application-provided metadata about the encrypted media (see <xref target="metadata"/>).</t>
          <sourcecode type="pseudocode"><![CDATA[
def encrypt(CTR, KID, metadata, plaintext):
  sframe_key, sframe_salt = key_store[KID]

  # encode_big_endian(x, n) produces an n-byte string encoding the
  # integer x in big-endian byte order.
  ctr = encode_big_endian(CTR, AEAD.Nn)
  nonce = xor(sframe_salt, CTR)

  # encode_sframe_header produces a byte string encoding the
  # provided KID and CTR values into an SFrame header.
  header = encode_sframe_header(CTR, KID)
  aad = header + metadata

  ciphertext = AEAD.Encrypt(sframe_key, nonce, aad, plaintext)
  return header + ciphertext
]]></sourcecode>
          <t>For example, the metadata input to encryption allows for frame metadata to be
authenticated when SFrame is applied per frame.  After encoding the frame and
before packetizing it, the necessary media metadata will be moved out of the
encoded frame buffer to be sent in some channel visible to the SFU (e.g., an
RTP header extension).</t>
          <figure>
            <name>Encrypting an SFrame Ciphertext</name>
            <artset>
              <artwork type="svg"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="608" width="416" viewBox="0 0 416 608" class="diagram" text-anchor="middle" font-family="monospace" font-size="13px" stroke-linecap="round">
                  <path d="M 40,224 L 40,480" fill="none" stroke="black"/>
                  <path d="M 64,176 L 64,272" fill="none" stroke="black"/>
                  <path d="M 96,160 L 96,288" fill="none" stroke="black"/>
                  <path d="M 128,320 L 128,352" fill="none" stroke="black"/>
                  <path d="M 144,160 L 144,288" fill="none" stroke="black"/>
                  <path d="M 168,176 L 168,208" fill="none" stroke="black"/>
                  <path d="M 168,464 L 168,592" fill="none" stroke="black"/>
                  <path d="M 192,352 L 192,384" fill="none" stroke="black"/>
                  <path d="M 264,320 L 264,352" fill="none" stroke="black"/>
                  <path d="M 280,32 L 280,128" fill="none" stroke="black"/>
                  <path d="M 296,464 L 296,592" fill="none" stroke="black"/>
                  <path d="M 320,208 L 320,240" fill="none" stroke="black"/>
                  <path d="M 344,128 L 344,400" fill="none" stroke="black"/>
                  <path d="M 344,432 L 344,528" fill="none" stroke="black"/>
                  <path d="M 408,32 L 408,128" fill="none" stroke="black"/>
                  <path d="M 280,32 L 408,32" fill="none" stroke="black"/>
                  <path d="M 280,128 L 408,128" fill="none" stroke="black"/>
                  <path d="M 96,160 L 144,160" fill="none" stroke="black"/>
                  <path d="M 144,176 L 192,176" fill="none" stroke="black"/>
                  <path d="M 296,176 L 336,176" fill="none" stroke="black"/>
                  <path d="M 168,208 L 192,208" fill="none" stroke="black"/>
                  <path d="M 304,208 L 320,208" fill="none" stroke="black"/>
                  <path d="M 40,224 L 64,224" fill="none" stroke="black"/>
                  <path d="M 96,224 L 144,224" fill="none" stroke="black"/>
                  <path d="M 144,240 L 336,240" fill="none" stroke="black"/>
                  <path d="M 96,288 L 144,288" fill="none" stroke="black"/>
                  <path d="M 128,320 L 264,320" fill="none" stroke="black"/>
                  <path d="M 128,352 L 264,352" fill="none" stroke="black"/>
                  <path d="M 40,384 L 336,384" fill="none" stroke="black"/>
                  <path d="M 168,464 L 296,464" fill="none" stroke="black"/>
                  <path d="M 40,480 L 160,480" fill="none" stroke="black"/>
                  <path d="M 168,496 L 296,496" fill="none" stroke="black"/>
                  <path d="M 304,528 L 344,528" fill="none" stroke="black"/>
                  <path d="M 168,592 L 296,592" fill="none" stroke="black"/>
                  <path d="M 80,160 C 71.16936,160 64,167.16936 64,176" fill="none" stroke="black"/>
                  <path d="M 80,288 C 71.16936,288 64,280.83064 64,272" fill="none" stroke="black"/>
                  <polygon class="arrowhead" points="344,384 332,378.4 332,389.6" fill="black" transform="rotate(0,336,384)"/>
                  <polygon class="arrowhead" points="344,240 332,234.4 332,245.6" fill="black" transform="rotate(0,336,240)"/>
                  <polygon class="arrowhead" points="344,176 332,170.4 332,181.6" fill="black" transform="rotate(0,336,176)"/>
                  <polygon class="arrowhead" points="312,528 300,522.4 300,533.6" fill="black" transform="rotate(180,304,528)"/>
                  <polygon class="arrowhead" points="200,208 188,202.4 188,213.6" fill="black" transform="rotate(0,192,208)"/>
                  <polygon class="arrowhead" points="200,176 188,170.4 188,181.6" fill="black" transform="rotate(0,192,176)"/>
                  <polygon class="arrowhead" points="168,480 156,474.4 156,485.6" fill="black" transform="rotate(0,160,480)"/>
                  <g class="text">
                    <text x="344" y="84">plaintext</text>
                    <text x="244" y="180">sframe_key</text>
                    <text x="368" y="180">Key</text>
                    <text x="28" y="196">Header</text>
                    <text x="120" y="196">KID</text>
                    <text x="248" y="212">sframe_salt</text>
                    <text x="376" y="244">Nonce</text>
                    <text x="120" y="260">CTR</text>
                    <text x="196" y="340">metadata</text>
                    <text x="368" y="388">AAD</text>
                    <text x="348" y="420">AEAD.Encrypt</text>
                    <text x="188" y="452">SFrame</text>
                    <text x="260" y="452">Ciphertext</text>
                    <text x="204" y="484">SFrame</text>
                    <text x="260" y="484">Header</text>
                    <text x="236" y="548">ciphertext</text>
                  </g>
                </svg>
              </artwork>
              <artwork type="ascii-art"><![CDATA[
                                  +---------------+
                                  |               |
                                  |               |
                                  |   plaintext   |
                                  |               |
                                  |               |
                                  +-------+-------+
                                          |
        .- +-----+                        |
       |   |     +--+--> sframe_key ----->| Key
Header |   | KID |  |                     |
       |   |     |  +--> sframe_salt --+  |
    +--+   +-----+                     |  |
    |  |   |     +---------------------+->| Nonce
    |  |   | CTR |                        |
    |  |   |     |                        |
    |   '- +-----+                        |
    |                                     |
    |          +----------------+         |
    |          |    metadata    |         |
    |          +-------+--------+         |
    |                  |                  |
    +------------------+----------------->| AAD
    |                                     |
    |                                AEAD.Encrypt
    |                                     |
    |               SFrame Ciphertext     |
    |               +---------------+     |
    +-------------->| SFrame Header |     |
                    +---------------+     |
                    |               |     |
                    |               |<----+
                    |   ciphertext  |
                    |               |
                    |               |
                    +---------------+
]]></artwork>
            </artset>
          </figure>
        </section>
        <section anchor="decryption">
          <name>Decryption</name>
          <t>Before decrypting, a receiver needs to assemble a full SFrame ciphertext. When
an SFrame ciphertext is fragmented into multiple parts for transport (e.g.,
a whole encrypted frame sent in multiple SRTP packets), the receiving client
collects all the fragments of the ciphertext, using appropriate sequencing
and start/end markers in the transport. Once all of the required fragments are
available, the client reassembles them into the SFrame ciphertext and passes
the ciphertext to SFrame for decryption.</t>
          <t>The KID field in the SFrame header is used to find the right key and salt for
the encrypted frame, and the CTR field is used to construct the nonce. The SFrame
decryption procedure is as follows:</t>
          <sourcecode type="pseudocode"><![CDATA[
def decrypt(metadata, sframe_ciphertext):
  KID, CTR, header, ciphertext = parse_ciphertext(sframe_ciphertext)

  sframe_key, sframe_salt = key_store[KID]

  ctr = encode_big_endian(CTR, AEAD.Nn)
  nonce = xor(sframe_salt, ctr)
  aad = header + metadata

  return AEAD.Decrypt(sframe_key, nonce, aad, ciphertext)
]]></sourcecode>
          <t>If a ciphertext fails to decrypt because there is no key available for the KID
in the SFrame header, the client <bcp14>MAY</bcp14> buffer the ciphertext and retry decryption
once a key with that KID is received.  If a ciphertext fails to decrypt for any
other reason, the client <bcp14>MUST</bcp14> discard the ciphertext. Invalid ciphertexts <bcp14>SHOULD</bcp14> be
discarded in a way that is indistinguishable (to an external observer) from having
processed a valid ciphertext.  In other words, the SFrame decrypt operation
should take the same amount of time regardless of whether decryption succeeds or fails.</t>
          <figure>
            <name>Decrypting an SFrame Ciphertext</name>
            <artset>
              <artwork type="svg"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="640" width="384" viewBox="0 0 384 640" class="diagram" text-anchor="middle" font-family="monospace" font-size="13px" stroke-linecap="round">
                  <path d="M 8,64 L 8,432" fill="none" stroke="black"/>
                  <path d="M 32,224 L 32,320" fill="none" stroke="black"/>
                  <path d="M 64,208 L 64,336" fill="none" stroke="black"/>
                  <path d="M 96,368 L 96,400" fill="none" stroke="black"/>
                  <path d="M 112,208 L 112,336" fill="none" stroke="black"/>
                  <path d="M 136,48 L 136,176" fill="none" stroke="black"/>
                  <path d="M 136,224 L 136,256" fill="none" stroke="black"/>
                  <path d="M 160,400 L 160,432" fill="none" stroke="black"/>
                  <path d="M 232,368 L 232,400" fill="none" stroke="black"/>
                  <path d="M 248,512 L 248,608" fill="none" stroke="black"/>
                  <path d="M 264,48 L 264,176" fill="none" stroke="black"/>
                  <path d="M 288,256 L 288,288" fill="none" stroke="black"/>
                  <path d="M 312,112 L 312,448" fill="none" stroke="black"/>
                  <path d="M 312,496 L 312,504" fill="none" stroke="black"/>
                  <path d="M 376,512 L 376,608" fill="none" stroke="black"/>
                  <path d="M 136,48 L 264,48" fill="none" stroke="black"/>
                  <path d="M 8,64 L 128,64" fill="none" stroke="black"/>
                  <path d="M 136,80 L 264,80" fill="none" stroke="black"/>
                  <path d="M 272,112 L 312,112" fill="none" stroke="black"/>
                  <path d="M 136,176 L 264,176" fill="none" stroke="black"/>
                  <path d="M 64,208 L 112,208" fill="none" stroke="black"/>
                  <path d="M 112,224 L 160,224" fill="none" stroke="black"/>
                  <path d="M 264,224 L 304,224" fill="none" stroke="black"/>
                  <path d="M 136,256 L 160,256" fill="none" stroke="black"/>
                  <path d="M 272,256 L 288,256" fill="none" stroke="black"/>
                  <path d="M 8,272 L 24,272" fill="none" stroke="black"/>
                  <path d="M 64,272 L 112,272" fill="none" stroke="black"/>
                  <path d="M 112,288 L 304,288" fill="none" stroke="black"/>
                  <path d="M 64,336 L 112,336" fill="none" stroke="black"/>
                  <path d="M 96,368 L 232,368" fill="none" stroke="black"/>
                  <path d="M 96,400 L 232,400" fill="none" stroke="black"/>
                  <path d="M 8,432 L 304,432" fill="none" stroke="black"/>
                  <path d="M 248,512 L 376,512" fill="none" stroke="black"/>
                  <path d="M 248,608 L 376,608" fill="none" stroke="black"/>
                  <path d="M 48,208 C 39.16936,208 32,215.16936 32,224" fill="none" stroke="black"/>
                  <path d="M 48,336 C 39.16936,336 32,328.83064 32,320" fill="none" stroke="black"/>
                  <polygon class="arrowhead" points="320,504 308,498.4 308,509.6" fill="black" transform="rotate(90,312,504)"/>
                  <polygon class="arrowhead" points="312,432 300,426.4 300,437.6" fill="black" transform="rotate(0,304,432)"/>
                  <polygon class="arrowhead" points="312,288 300,282.4 300,293.6" fill="black" transform="rotate(0,304,288)"/>
                  <polygon class="arrowhead" points="312,224 300,218.4 300,229.6" fill="black" transform="rotate(0,304,224)"/>
                  <polygon class="arrowhead" points="168,256 156,250.4 156,261.6" fill="black" transform="rotate(0,160,256)"/>
                  <polygon class="arrowhead" points="168,224 156,218.4 156,229.6" fill="black" transform="rotate(0,160,224)"/>
                  <polygon class="arrowhead" points="32,272 20,266.4 20,277.6" fill="black" transform="rotate(0,24,272)"/>
                  <g class="text">
                    <text x="156" y="36">SFrame</text>
                    <text x="228" y="36">Ciphertext</text>
                    <text x="172" y="68">SFrame</text>
                    <text x="228" y="68">Header</text>
                    <text x="204" y="132">ciphertext</text>
                    <text x="212" y="228">sframe_key</text>
                    <text x="336" y="228">Key</text>
                    <text x="88" y="244">KID</text>
                    <text x="216" y="260">sframe_salt</text>
                    <text x="344" y="292">Nonce</text>
                    <text x="88" y="308">CTR</text>
                    <text x="164" y="388">metadata</text>
                    <text x="336" y="436">AAD</text>
                    <text x="316" y="468">AEAD.Decrypt</text>
                    <text x="312" y="484">|</text>
                    <text x="312" y="564">plaintext</text>
                  </g>
                </svg>
              </artwork>
              <artwork type="ascii-art"><![CDATA[
                    SFrame Ciphertext
                    +---------------+
    +---------------| SFrame Header |
    |               +---------------+
    |               |               |
    |               |               |-----+
    |               |   ciphertext  |     |
    |               |               |     |
    |               |               |     |
    |               +---------------+     |
    |                                     |
    |   .- +-----+                        |
    |  |   |     +--+--> sframe_key ----->| Key
    |  |   | KID |  |                     |
    |  |   |     |  +--> sframe_salt --+  |
    +->+   +-----+                     |  |
    |  |   |     +---------------------+->| Nonce
    |  |   | CTR |                        |
    |  |   |     |                        |
    |   '- +-----+                        |
    |                                     |
    |          +----------------+         |
    |          |    metadata    |         |
    |          +-------+--------+         |
    |                  |                  |
    +------------------+----------------->| AAD
                                          |
                                     AEAD.Decrypt
                                          |
                                          V
                                  +---------------+
                                  |               |
                                  |               |
                                  |   plaintext   |
                                  |               |
                                  |               |
                                  +---------------+
]]></artwork>
            </artset>
          </figure>
        </section>
      </section>
      <section anchor="cipher-suites">
        <name>Cipher Suites</name>
        <t>Each SFrame session uses a single cipher suite that specifies the following
primitives:</t>
        <ul spacing="normal">
          <li>
            <t>A hash function used for key derivation</t>
          </li>
          <li>
            <t>An AEAD encryption algorithm <xref target="RFC5116"/> used for frame encryption, optionally
with a truncated authentication tag</t>
          </li>
        </ul>
        <t>This document defines the following cipher suites, with the constants defined in
<xref target="encryption-schema"/>:</t>
        <table anchor="cipher-suite-constants">
          <name>SFrame Cipher Suite Constants</name>
          <thead>
            <tr>
              <th align="left">Name</th>
              <th align="left">Nh</th>
              <th align="left">Nka</th>
              <th align="left">Nk</th>
              <th align="left">Nn</th>
              <th align="left">Nt</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">
                <tt>AES_128_CTR_HMAC_SHA256_80</tt></td>
              <td align="left">32</td>
              <td align="left">16</td>
              <td align="left">48</td>
              <td align="left">12</td>
              <td align="left">10</td>
            </tr>
            <tr>
              <td align="left">
                <tt>AES_128_CTR_HMAC_SHA256_64</tt></td>
              <td align="left">32</td>
              <td align="left">16</td>
              <td align="left">48</td>
              <td align="left">12</td>
              <td align="left">8</td>
            </tr>
            <tr>
              <td align="left">
                <tt>AES_128_CTR_HMAC_SHA256_32</tt></td>
              <td align="left">32</td>
              <td align="left">16</td>
              <td align="left">48</td>
              <td align="left">12</td>
              <td align="left">4</td>
            </tr>
            <tr>
              <td align="left">
                <tt>AES_128_GCM_SHA256_128</tt></td>
              <td align="left">32</td>
              <td align="left">n/a</td>
              <td align="left">16</td>
              <td align="left">12</td>
              <td align="left">16</td>
            </tr>
            <tr>
              <td align="left">
                <tt>AES_256_GCM_SHA512_128</tt></td>
              <td align="left">64</td>
              <td align="left">n/a</td>
              <td align="left">32</td>
              <td align="left">12</td>
              <td align="left">16</td>
            </tr>
          </tbody>
        </table>
        <t>Numeric identifiers for these cipher suites are defined in the IANA registry
created in <xref target="sframe-cipher-suites"/>.</t>
        <t>In the suite names, the length of the authentication tag is indicated by
the last value: "_128" indicates a 128-bit tag, "_80" indicates
an 80-bit tag, "_64" indicates a 64-bit tag, and "_32" indicates a
32-bit tag.</t>
        <t>In a session that uses multiple media streams, different cipher suites might be
configured for different media streams.  For example, in order to conserve
bandwidth, a session might use a cipher suite with 80-bit tags for video frames
and another cipher suite with 32-bit tags for audio frames.</t>
        <section anchor="aes-ctr-with-sha2">
          <name>AES-CTR with SHA2</name>
          <t>In order to allow very short tag sizes, we define a synthetic AEAD function
using the authenticated counter mode of AES together with HMAC for
authentication.  We use an encrypt-then-MAC approach, as in SRTP <xref target="RFC3711"/>.</t>
          <t>Before encryption or decryption, encryption and authentication subkeys are
derived from the single AEAD key.  The overall length of the AEAD key is <tt>Nka +
Nh</tt>, where <tt>Nka</tt> represents the key size for the AES block cipher in use and <tt>Nh</tt>
represents the output size of the hash function  (as in <xref target="encryption-schema"/>).
The encryption subkey comprises the first <tt>Nka</tt> bytes and the authentication
subkey comprises the remaining <tt>Nh</tt> bytes.</t>
          <sourcecode type="pseudocode"><![CDATA[
def derive_subkeys(sframe_key):
  # The encryption key comprises the first Nka bytes
  enc_key = sframe_key[..Nka]

  # The authentication key comprises Nh remaining bytes
  auth_key = sframe_key[Nka..]

  return enc_key, auth_key
]]></sourcecode>
          <t>The AEAD encryption and decryption functions are then composed of individual
calls to the CTR encrypt function and HMAC.  The resulting MAC value is truncated
to a number of bytes <tt>Nt</tt> fixed by the cipher suite.</t>
          <sourcecode type="pseudocode"><![CDATA[
def truncate(tag, n):
  # Take the first `n` bytes of `tag`
  return tag[..n]

def compute_tag(auth_key, nonce, aad, ct):
  aad_len = encode_big_endian(len(aad), 8)
  ct_len = encode_big_endian(len(ct), 8)
  tag_len = encode_big_endian(Nt, 8)
  auth_data = aad_len + ct_len + tag_len + nonce + aad + ct
  tag = HMAC(auth_key, auth_data)
  return truncate(tag, Nt)

def AEAD.Encrypt(key, nonce, aad, pt):
  enc_key, auth_key = derive_subkeys(key)
  initial_counter = nonce + 0x00000000 # append four zero bytes
  ct = AES-CTR.Encrypt(enc_key, initial_counter, pt)
  tag = compute_tag(auth_key, nonce, aad, ct)
  return ct + tag

def AEAD.Decrypt(key, nonce, aad, ct):
  inner_ct, tag = split_ct(ct, tag_len)

  enc_key, auth_key = derive_subkeys(key)
  candidate_tag = compute_tag(auth_key, nonce, aad, inner_ct)
  if !constant_time_equal(tag, candidate_tag):
    raise Exception("Authentication Failure")

  initial_counter = nonce + 0x00000000 # append four zero bytes
  return AES-CTR.Decrypt(enc_key, initial_counter, inner_ct)
]]></sourcecode>
        </section>
      </section>
    </section>
    <section anchor="key-management">
      <name>Key Management</name>
      <t>SFrame must be integrated with an E2E key management framework to exchange and
rotate the keys used for SFrame encryption. The key management
framework provides the following functions:</t>
      <ul spacing="normal">
        <li>
          <t>Provisioning KID / <tt>base_key</tt> mappings to participating clients</t>
        </li>
        <li>
          <t>Updating the above data as clients join or leave</t>
        </li>
      </ul>
      <t>It is the responsibility of the application to provide the key management
framework, as described in <xref target="key-management-framework"/>.</t>
      <section anchor="sender-keys">
        <name>Sender Keys</name>
        <t>If the participants in a call have a preexisting E2E-secure channel, they can
use it to distribute SFrame keys.  Each client participating in a call generates
a fresh <tt>base_key</tt> value that it will use to encrypt media. The client then uses
the E2E-secure channel to send their encryption key to the other participants.</t>
        <t>In this scheme, it is assumed that receivers have a signal outside of SFrame for
which client has sent a given frame (e.g., an RTP synchronization source (SSRC)).  SFrame KID
values are then used to distinguish between versions of the sender's <tt>base_key</tt>.</t>
        <t>KID values in this scheme have two parts: a "key generation" and a "ratchet step".
Both are unsigned integers that begin at zero.  The key generation increments
each time the sender distributes a new key to receivers.  The ratchet step is
incremented each time the sender ratchets their key forward for forward secrecy:</t>
        <sourcecode type="pseudocode"><![CDATA[
base_key[i+1] = HKDF-Expand(
                  HKDF-Extract("", base_key[i]),
                  "SFrame 1.0 Ratchet", CipherSuite.Nh)
]]></sourcecode>
        <t>For compactness, we do not send the whole ratchet step.  Instead, we send only
its low-order <tt>R</tt> bits, where <tt>R</tt> is a value set by the application.  Different
senders may use different values of <tt>R</tt>, but each receiver of a given sender
needs to know what value of <tt>R</tt> is used by the sender so that they can recognize
when they need to ratchet (vs. expecting a new key).  <tt>R</tt> effectively defines a
reordering window, since no more than 2<sup><tt>R</tt></sup> ratchet steps can be
active at a given time.  The key generation is sent in the remaining <tt>64 - R</tt>
bits of the KID.</t>
        <sourcecode type="pseudocode"><![CDATA[
KID = (key_generation << R) + (ratchet_step % (1 << R))
]]></sourcecode>
        <figure anchor="sender-keys-kid">
          <name>Structure of a KID in the Sender Keys Scheme</name>
          <artset>
            <artwork type="svg"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="112" width="280" viewBox="0 0 280 112" class="diagram" text-anchor="middle" font-family="monospace" font-size="13px" stroke-linecap="round">
                <path d="M 8,64 L 8,96" fill="none" stroke="black"/>
                <path d="M 152,64 L 152,96" fill="none" stroke="black"/>
                <path d="M 272,64 L 272,96" fill="none" stroke="black"/>
                <path d="M 16,48 L 144,48" fill="none" stroke="black"/>
                <path d="M 160,48 L 264,48" fill="none" stroke="black"/>
                <path d="M 8,64 L 272,64" fill="none" stroke="black"/>
                <path d="M 8,96 L 272,96" fill="none" stroke="black"/>
                <polygon class="arrowhead" points="272,48 260,42.4 260,53.6" fill="black" transform="rotate(0,264,48)"/>
                <polygon class="arrowhead" points="168,48 156,42.4 156,53.6" fill="black" transform="rotate(180,160,48)"/>
                <polygon class="arrowhead" points="152,48 140,42.4 140,53.6" fill="black" transform="rotate(0,144,48)"/>
                <polygon class="arrowhead" points="24,48 12,42.4 12,53.6" fill="black" transform="rotate(180,16,48)"/>
                <g class="text">
                  <text x="60" y="36">64-R</text>
                  <text x="100" y="36">bits</text>
                  <text x="192" y="36">R</text>
                  <text x="220" y="36">bits</text>
                  <text x="32" y="84">Key</text>
                  <text x="92" y="84">Generation</text>
                  <text x="192" y="84">Ratchet</text>
                  <text x="244" y="84">Step</text>
                </g>
              </svg>
            </artwork>
            <artwork type="ascii-art"><![CDATA[
     64-R bits         R bits
 <---------------> <------------>
+-----------------+--------------+
| Key Generation  | Ratchet Step |
+-----------------+--------------+
]]></artwork>
          </artset>
        </figure>
        <t>The sender signals such a ratchet step update by sending with a KID value in
which the ratchet step has been incremented.  A receiver who receives from a
sender with a new KID computes the new key as above.  The old key may be kept
for some time to allow for out-of-order delivery, but should be deleted
promptly.</t>
        <t>If a new participant joins in the middle of a session, they will need to receive
from each sender (a) the current sender key for that sender and (b) the current
KID value for the sender. Evicting a participant requires each sender to send
a fresh sender key to all receivers.</t>
        <t>It is the application's responsibility to decide when sender keys are updated.  A sender
key may be updated by sending a new <tt>base_key</tt> (updating the key generation) or
by hashing the current <tt>base_key</tt> (updating the ratchet step).  Ratcheting the
key forward is useful when adding new receivers to an SFrame-based interaction,
since it ensures that the new receivers can't decrypt any media encrypted before
they were added.  If a sender wishes to assure the opposite property when
removing a receiver (i.e., ensuring that the receiver can't decrypt media after
they are removed), then the sender will need to distribute a new sender key.</t>
      </section>
      <section anchor="mls">
        <name>MLS</name>
        <t>The Messaging Layer Security (MLS) protocol provides group authenticated key
exchange <xref target="I-D.ietf-mls-architecture"/> <xref target="RFC9420"/>.  In
principle, it could be used to instantiate the sender key scheme above, but it
can also be used more efficiently directly.</t>
        <t>MLS creates a linear sequence of keys, each of which is shared among the members
of a group at a given point in time.  When a member joins or leaves the group, a
new key is produced that is known only to the augmented or reduced group.  Each
step in the lifetime of the group is known as an "epoch", and each member of the
group is assigned an "index" that is constant for the time they are in the
group.</t>
        <t>To generate keys and nonces for SFrame, we use the MLS exporter function to
generate a <tt>base_key</tt> value for each MLS epoch.  Each member of the group is
assigned a set of KID values so that each member has a unique <tt>sframe_key</tt> and
<tt>sframe_salt</tt> that it uses to encrypt with.  Senders may choose any KID value
within their assigned set of KID values, e.g., to allow a single sender to send
multiple, uncoordinated outbound media streams.</t>
        <sourcecode type="pseudocode"><![CDATA[
base_key = MLS-Exporter("SFrame 1.0 Base Key", "", AEAD.Nk)
]]></sourcecode>
        <t>For compactness, we do not send the whole epoch number.  Instead, we send only
its low-order <tt>E</tt> bits, where <tt>E</tt> is a value set by the application.  <tt>E</tt>
effectively defines a reordering window, since no more than 2<sup><tt>E</tt></sup>
epochs can be active at a given time.  To handle rollover of the epoch counter,
receivers <bcp14>MUST</bcp14> remove an old epoch when a new epoch with the same low-order
E bits is introduced.</t>
        <t>Let <tt>S</tt> be the number of bits required to encode a member index in the group,
i.e., the smallest value such that <tt>group_size &lt;= (1 &lt;&lt; S)</tt>.  The sender index
is encoded in the <tt>S</tt> bits above the epoch.  The remaining <tt>64 - S - E</tt> bits of
the KID value are a <tt>context</tt> value chosen by the sender (<tt>context</tt> value <tt>0</tt> will
produce the shortest encoded KID).</t>
        <sourcecode type="pseudocode"><![CDATA[
KID = (context << (S + E)) + (sender_index << E) + (epoch % (1 << E))
]]></sourcecode>
        <figure anchor="mls-kid">
          <name>Structure of a KID for an MLS Sender</name>
          <artset>
            <artwork type="svg"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="112" width="264" viewBox="0 0 264 112" class="diagram" text-anchor="middle" font-family="monospace" font-size="13px" stroke-linecap="round">
                <path d="M 8,64 L 8,96" fill="none" stroke="black"/>
                <path d="M 120,64 L 120,96" fill="none" stroke="black"/>
                <path d="M 192,64 L 192,96" fill="none" stroke="black"/>
                <path d="M 256,64 L 256,96" fill="none" stroke="black"/>
                <path d="M 16,48 L 112,48" fill="none" stroke="black"/>
                <path d="M 128,48 L 184,48" fill="none" stroke="black"/>
                <path d="M 200,48 L 256,48" fill="none" stroke="black"/>
                <path d="M 8,64 L 256,64" fill="none" stroke="black"/>
                <path d="M 8,96 L 256,96" fill="none" stroke="black"/>
                <polygon class="arrowhead" points="264,48 252,42.4 252,53.6" fill="black" transform="rotate(0,256,48)"/>
                <polygon class="arrowhead" points="208,48 196,42.4 196,53.6" fill="black" transform="rotate(180,200,48)"/>
                <polygon class="arrowhead" points="192,48 180,42.4 180,53.6" fill="black" transform="rotate(0,184,48)"/>
                <polygon class="arrowhead" points="136,48 124,42.4 124,53.6" fill="black" transform="rotate(180,128,48)"/>
                <polygon class="arrowhead" points="120,48 108,42.4 108,53.6" fill="black" transform="rotate(0,112,48)"/>
                <polygon class="arrowhead" points="24,48 12,42.4 12,53.6" fill="black" transform="rotate(180,16,48)"/>
                <g class="text">
                  <text x="44" y="36">64-S-E</text>
                  <text x="92" y="36">bits</text>
                  <text x="136" y="36">S</text>
                  <text x="164" y="36">bits</text>
                  <text x="208" y="36">E</text>
                  <text x="236" y="36">bits</text>
                  <text x="48" y="84">Context</text>
                  <text x="92" y="84">ID</text>
                  <text x="152" y="84">Index</text>
                  <text x="224" y="84">Epoch</text>
                </g>
              </svg>
            </artwork>
            <artwork type="ascii-art"><![CDATA[
  64-S-E bits   S bits   E bits
 <-----------> <------> <------>
+-------------+--------+-------+
| Context ID  | Index  | Epoch |
+-------------+--------+-------+
]]></artwork>
          </artset>
        </figure>
        <t>Once an SFrame stack has been provisioned with the <tt>sframe_epoch_secret</tt> for an
epoch, it can compute the required KID values on demand (as well as the
resulting SFrame keys/nonces derived from the <tt>base_key</tt> and KID) as it needs
to encrypt or decrypt for a given member.</t>
        <figure anchor="mls-evolution">
          <name>An Example Sequence of KIDs for an MLS-based SFrame Session (E=4; S=6, Allowing for 64 Group Members)</name>
          <artset>
            <artwork type="svg"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="448" width="472" viewBox="0 0 472 448" class="diagram" text-anchor="middle" font-family="monospace" font-size="13px" stroke-linecap="round">
                <path d="M 80,48 L 80,416" fill="none" stroke="black"/>
                <path d="M 104,80 L 104,144" fill="none" stroke="black"/>
                <path d="M 104,192 L 104,224" fill="none" stroke="black"/>
                <path d="M 104,352 L 104,384" fill="none" stroke="black"/>
                <path d="M 216,272 L 216,304" fill="none" stroke="black"/>
                <path d="M 80,80 L 120,80" fill="none" stroke="black"/>
                <path d="M 200,80 L 224,80" fill="none" stroke="black"/>
                <path d="M 104,112 L 120,112" fill="none" stroke="black"/>
                <path d="M 200,112 L 224,112" fill="none" stroke="black"/>
                <path d="M 104,144 L 120,144" fill="none" stroke="black"/>
                <path d="M 208,144 L 224,144" fill="none" stroke="black"/>
                <path d="M 80,192 L 120,192" fill="none" stroke="black"/>
                <path d="M 200,192 L 224,192" fill="none" stroke="black"/>
                <path d="M 104,224 L 120,224" fill="none" stroke="black"/>
                <path d="M 200,224 L 224,224" fill="none" stroke="black"/>
                <path d="M 80,272 L 120,272" fill="none" stroke="black"/>
                <path d="M 200,272 L 240,272" fill="none" stroke="black"/>
                <path d="M 352,272 L 368,272" fill="none" stroke="black"/>
                <path d="M 216,304 L 240,304" fill="none" stroke="black"/>
                <path d="M 352,304 L 368,304" fill="none" stroke="black"/>
                <path d="M 80,352 L 120,352" fill="none" stroke="black"/>
                <path d="M 208,352 L 224,352" fill="none" stroke="black"/>
                <path d="M 104,384 L 120,384" fill="none" stroke="black"/>
                <path d="M 208,384 L 224,384" fill="none" stroke="black"/>
                <polygon class="arrowhead" points="376,304 364,298.4 364,309.6" fill="black" transform="rotate(0,368,304)"/>
                <polygon class="arrowhead" points="376,272 364,266.4 364,277.6" fill="black" transform="rotate(0,368,272)"/>
                <polygon class="arrowhead" points="248,304 236,298.4 236,309.6" fill="black" transform="rotate(0,240,304)"/>
                <polygon class="arrowhead" points="248,272 236,266.4 236,277.6" fill="black" transform="rotate(0,240,272)"/>
                <polygon class="arrowhead" points="232,384 220,378.4 220,389.6" fill="black" transform="rotate(0,224,384)"/>
                <polygon class="arrowhead" points="232,352 220,346.4 220,357.6" fill="black" transform="rotate(0,224,352)"/>
                <polygon class="arrowhead" points="232,224 220,218.4 220,229.6" fill="black" transform="rotate(0,224,224)"/>
                <polygon class="arrowhead" points="232,192 220,186.4 220,197.6" fill="black" transform="rotate(0,224,192)"/>
                <polygon class="arrowhead" points="232,144 220,138.4 220,149.6" fill="black" transform="rotate(0,224,144)"/>
                <polygon class="arrowhead" points="232,112 220,106.4 220,117.6" fill="black" transform="rotate(0,224,112)"/>
                <polygon class="arrowhead" points="232,80 220,74.4 220,85.6" fill="black" transform="rotate(0,224,80)"/>
                <g class="text">
                  <text x="32" y="36">...</text>
                  <text x="24" y="84">Epoch</text>
                  <text x="60" y="84">14</text>
                  <text x="160" y="84">index=3</text>
                  <text x="248" y="84">KID</text>
                  <text x="272" y="84">=</text>
                  <text x="300" y="84">0x3e</text>
                  <text x="160" y="116">index=7</text>
                  <text x="248" y="116">KID</text>
                  <text x="272" y="116">=</text>
                  <text x="300" y="116">0x7e</text>
                  <text x="164" y="148">index=20</text>
                  <text x="248" y="148">KID</text>
                  <text x="272" y="148">=</text>
                  <text x="304" y="148">0x14e</text>
                  <text x="24" y="196">Epoch</text>
                  <text x="60" y="196">15</text>
                  <text x="160" y="196">index=3</text>
                  <text x="248" y="196">KID</text>
                  <text x="272" y="196">=</text>
                  <text x="300" y="196">0x3f</text>
                  <text x="160" y="228">index=5</text>
                  <text x="248" y="228">KID</text>
                  <text x="272" y="228">=</text>
                  <text x="300" y="228">0x5f</text>
                  <text x="24" y="276">Epoch</text>
                  <text x="60" y="276">16</text>
                  <text x="160" y="276">index=2</text>
                  <text x="280" y="276">context</text>
                  <text x="320" y="276">=</text>
                  <text x="336" y="276">2</text>
                  <text x="392" y="276">KID</text>
                  <text x="416" y="276">=</text>
                  <text x="448" y="276">0x820</text>
                  <text x="280" y="308">context</text>
                  <text x="320" y="308">=</text>
                  <text x="336" y="308">3</text>
                  <text x="392" y="308">KID</text>
                  <text x="416" y="308">=</text>
                  <text x="448" y="308">0xc20</text>
                  <text x="24" y="356">Epoch</text>
                  <text x="60" y="356">17</text>
                  <text x="164" y="356">index=33</text>
                  <text x="248" y="356">KID</text>
                  <text x="272" y="356">=</text>
                  <text x="304" y="356">0x211</text>
                  <text x="164" y="388">index=51</text>
                  <text x="248" y="388">KID</text>
                  <text x="272" y="388">=</text>
                  <text x="304" y="388">0x331</text>
                  <text x="32" y="436">...</text>
                </g>
              </svg>
            </artwork>
            <artwork type="ascii-art"><![CDATA[
  ...
         |
         |
Epoch 14 +--+-- index=3 ---> KID = 0x3e
         |  |
         |  +-- index=7 ---> KID = 0x7e
         |  |
         |  +-- index=20 --> KID = 0x14e
         |
         |
Epoch 15 +--+-- index=3 ---> KID = 0x3f
         |  |
         |  +-- index=5 ---> KID = 0x5f
         |
         |
Epoch 16 +----- index=2 --+--> context = 2 --> KID = 0x820
         |                |
         |                +--> context = 3 --> KID = 0xc20
         |
         |
Epoch 17 +--+-- index=33 --> KID = 0x211
         |  |
         |  +-- index=51 --> KID = 0x331
         |
         |
  ...
]]></artwork>
          </artset>
        </figure>
      </section>
    </section>
    <section anchor="media-considerations">
      <name>Media Considerations</name>
      <section anchor="selective-forwarding-units">
        <name>Selective Forwarding Units</name>
        <t>SFUs (e.g., those described in <xref section="3.7" sectionFormat="of" target="RFC7667"/>) receive the media streams from each participant and select which
ones should be forwarded to each of the other participants.  There are several
approaches for stream selection, but in general, the SFU needs to access
metadata associated with each frame and modify the RTP information of the incoming
packets when they are transmitted to the received participants.</t>
        <t>This section describes how these normal SFU modes of operation interact with the
E2EE provided by SFrame.</t>
        <section anchor="rtp-stream-reuse">
          <name>RTP Stream Reuse</name>
          <t>The SFU may choose to send only a certain number of streams based on the voice
activity of the participants. To avoid the overhead involved in establishing new
transport streams, the SFU may decide to reuse previously existing streams or
even pre-allocate a predefined number of streams and choose in each moment in
time which participant media will be sent through it.</t>
          <t>This means that the same transport-level stream (e.g., an RTP stream defined
by either SSRC or Media Identification (MID)) may carry media from different
streams of different participants. Because each participant uses a different key
to encrypt their media, the receiver will be able to verify the sender of the
media within the RTP stream at any given point in time. Thus the receiver will
correctly associate the media with the sender indicated by the authenticated
SFrame KID value, irrespective of how the SFU transmits the media to the client.</t>
          <t>Note that in order to prevent impersonation by a malicious participant (not the
SFU), a mechanism based on digital signature would be required. SFrame does not
protect against such attacks.</t>
        </section>
        <section anchor="simulcast">
          <name>Simulcast</name>
          <t>When using simulcast, the same input image will produce N different encoded
frames (one per simulcast layer), which would be processed independently by the
frame encryptor and assigned an unique CTR value for each.</t>
        </section>
        <section anchor="scalable-video-coding-svc">
          <name>Scalable Video Coding (SVC)</name>
          <t>In both temporal and spatial scalability, the SFU may choose to drop layers in
order to match a certain bitrate or to forward specific media sizes or frames per
second. In order to support the SFU selectively removing layers, the sender <bcp14>MUST</bcp14>
encapsulate each layer in a different SFrame ciphertext.</t>
        </section>
      </section>
      <section anchor="video-key-frames">
        <name>Video Key Frames</name>
        <t>Forward security and post-compromise security require that the E2EE keys (base keys)
are updated any time a participant joins or leaves the call.</t>
        <t>The key exchange happens asynchronously and on a different path than the SFU signaling
and media. So it may happen that when a new participant joins the call and the
SFU side requests a key frame, the sender generates the E2EE frame
with a key that is not known by the receiver, so it will be discarded. When the sender
updates his sending key with the new key, it will send it in a non-key frame, so
the receiver will be able to decrypt it, but not decode it.</t>
        <t>The new receiver will then re-request a key frame, but due to sender and SFU
policies, that new key frame could take some time to be generated.</t>
        <t>If the sender sends a key frame after the new E2EE key is in use, the time
required for the new participant to display the video is minimized.</t>
        <t>Note that this issue does not arise for media streams that do not have
dependencies among frames, e.g., audio streams.  In these streams, each frame is
independently decodable, so a frame never depends on another frame that might be
on the other side of a key rotation.</t>
      </section>
      <section anchor="partial-decoding">
        <name>Partial Decoding</name>
        <t>Some codecs support partial decoding, where individual packets can be decoded
without waiting for the full frame to arrive.  When SFrame is applied per frame,
partial decoding is not possible because the decoder cannot access data until an entire
frame has arrived and has been decrypted.</t>
      </section>
    </section>
    <section anchor="security-considerations">
      <name>Security Considerations</name>
      <section anchor="no-header-confidentiality">
        <name>No Header Confidentiality</name>
        <t>SFrame provides integrity protection to the SFrame header (the KID and
CTR values), but it does not provide confidentiality protection.  Parties that
can observe the SFrame header may learn, for example, which parties are sending
SFrame payloads (from KID values) and at what rates (from CTR values).  In cases
where SFrame is used for end-to-end security on top of hop-by-hop protections
(e.g., running over SRTP as described in <xref target="sframe-over-rtp"/>), the hop-by-hop security
mechanisms provide confidentiality protection of the SFrame header between hops.</t>
      </section>
      <section anchor="no-per-sender-authentication">
        <name>No Per-Sender Authentication</name>
        <t>SFrame does not provide per-sender authentication of media data.  Any sender in
a session can send media that will be associated with any other sender.  This is
because SFrame uses symmetric encryption to protect media data, so that any
receiver also has the keys required to encrypt packets for the sender.</t>
      </section>
      <section anchor="key-management-1">
        <name>Key Management</name>
        <t>The specifics of key management are beyond the scope of this document. However, every client
<bcp14>SHOULD</bcp14> change their keys when new clients join or leave the call for forward
secrecy and post-compromise security.</t>
      </section>
      <section anchor="replay">
        <name>Replay</name>
        <t>The handling of replay is out of the scope of this document. However, senders
<bcp14>MUST</bcp14> reject requests to encrypt multiple times with the same key and nonce
since several AEAD algorithms fail badly in such cases (see, e.g., <xref section="5.1.1" sectionFormat="of" target="RFC5116"/>).</t>
      </section>
      <section anchor="risks-due-to-short-tags">
        <name>Risks Due to Short Tags</name>
        <t>The SFrame cipher suites based on AES-CTR allow for the use of short
authentication tags, which bring a higher risk that an attacker will be
able to cause an SFrame receiver to accept an SFrame ciphertext of the
attacker's choosing.</t>
        <t>Assuming that the authentication properties of the cipher suite are robust, the
only attack that an attacker can mount is an attempt to find an acceptable
(ciphertext, tag) combination through brute force.  Such a brute-force attack
will have an expected success rate of the following form:</t>
        <t><tt>
attacker_success_rate = attempts_per_second / 2^(8*Nt)
</tt></t>
        <t>For example, a gigabit Ethernet connection is able to transmit roughly 2<sup>20</sup>
packets per second.  If an attacker saturated such a link with guesses against a
32-bit authentication tag (<tt>Nt=4</tt>), then the attacker would succeed on average
roughly once every 2<sup>12</sup> seconds, or about once an hour.</t>
        <t>In a typical SFrame usage in a real-time media application, there are a few
approaches to mitigating this risk:</t>
        <ul spacing="normal">
          <li>
            <t>Receivers only accept SFrame ciphertexts over HBH-secure channels (e.g., SRTP
security associations or QUIC connections).  If this is the case, only an
entity that is part of such a channel can mount the above attack.</t>
          </li>
          <li>
            <t>The expected packet rate for a media stream is very predictable (and typically
far lower than the above example).  On the one hand, attacks at this rate will
succeed even less often than the high-rate attack described above.  On the
other hand, the application may use an elevated packet arrival rate as a
signal of a brute-force attack.  This latter approach is common in other
settings, e.g., mitigating brute-force attacks on passwords.</t>
          </li>
          <li>
            <t>Media applications typically do not provide feedback to media senders as to
which media packets failed to decrypt.  When media-quality feedback
mechanisms are used, decryption failures will typically appear as packet
losses, but only at an aggregate level.</t>
          </li>
          <li>
            <t>Anti-replay mechanisms (see <xref target="replay"/>) prevent the attacker from reusing
valid ciphertexts (either observed or guessed by the attacker).  A receiver
applying anti-replay controls will only accept one valid plaintext per CTR
value.  Since the CTR value is covered by SFrame authentication, an attacker
has to do a fresh search for a valid tag for every forged ciphertext, even if
the encrypted content is unchanged.  In other words, when the above brute-force
attack succeeds, it only allows the attacker to send a single SFrame
ciphertext; the ciphertext cannot be reused because either it will have the
same CTR value and be discarded as a replay, or else it will have a different
CTR value and its tag will no longer be valid.</t>
          </li>
        </ul>
        <t>Nonetheless, without these mitigations, an application that makes use of short
tags will be at heightened risk of forgery attacks.  In many cases, it is
simpler to use full-size tags and tolerate slightly higher bandwidth usage
rather than to add the additional defenses necessary to safely use short tags.</t>
      </section>
    </section>
    <section anchor="iana-considerations">
      <name>IANA Considerations</name>
      <t>IANA has created a new registry called "SFrame Cipher Suites" (<xref target="sframe-cipher-suites"/>)
under the "SFrame" group registry heading.</t>
      <section anchor="sframe-cipher-suites">
        <name>SFrame Cipher Suites</name>
        <t>The "SFrame Cipher Suites" registry lists identifiers for SFrame cipher suites as defined in
<xref target="cipher-suites"/>.  The cipher suite field is two bytes wide, so the valid cipher
suites are in the range 0x0000 to 0xFFFF.  Except as noted below, assignments are made
via the Specification Required policy <xref target="RFC8126"/>.</t>
        <t>The registration template is as follows:</t>
        <ul spacing="normal">
          <li>
            <t>Value: The numeric value of the cipher suite</t>
          </li>
          <li>
            <t>Name: The name of the cipher suite</t>
          </li>
          <li>
            <t>Recommended: Whether support for this cipher suite is recommended by the IETF.
Valid values are "Y", "N", and "D" as described in <xref section="17.1" sectionFormat="of" target="RFC9420"/>. The default value of the "Recommended" column is "N". Setting the
Recommended item to "Y" or "D", or changing an item whose current value is "Y"
or "D", requires Standards Action <xref target="RFC8126"/>.</t>
          </li>
          <li>
            <t>Reference: The document where this cipher suite is defined</t>
          </li>
          <li>
            <t>Change Controller: Who is authorized to update the row in the registry</t>
          </li>
        </ul>
        <t>Initial contents:</t>
        <table anchor="iana-cipher-suites">
          <name>SFrame Cipher Suites</name>
          <thead>
            <tr>
              <th align="left">Value</th>
              <th align="left">Name</th>
              <th align="left">R</th>
              <th align="left">Reference</th>
              <th align="left">Change Controller</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">0x0000</td>
              <td align="left">Reserved</td>
              <td align="left">-</td>
              <td align="left">RFC 9605</td>
              <td align="left">IETF</td>
            </tr>
            <tr>
              <td align="left">0x0001</td>
              <td align="left">
                <tt>AES_128_CTR_HMAC_SHA256_80</tt></td>
              <td align="left">Y</td>
              <td align="left">RFC 9605</td>
              <td align="left">IETF</td>
            </tr>
            <tr>
              <td align="left">0x0002</td>
              <td align="left">
                <tt>AES_128_CTR_HMAC_SHA256_64</tt></td>
              <td align="left">Y</td>
              <td align="left">RFC 9605</td>
              <td align="left">IETF</td>
            </tr>
            <tr>
              <td align="left">0x0003</td>
              <td align="left">
                <tt>AES_128_CTR_HMAC_SHA256_32</tt></td>
              <td align="left">Y</td>
              <td align="left">RFC 9605</td>
              <td align="left">IETF</td>
            </tr>
            <tr>
              <td align="left">0x0004</td>
              <td align="left">
                <tt>AES_128_GCM_SHA256_128</tt></td>
              <td align="left">Y</td>
              <td align="left">RFC 9605</td>
              <td align="left">IETF</td>
            </tr>
            <tr>
              <td align="left">0x0005</td>
              <td align="left">
                <tt>AES_256_GCM_SHA512_128</tt></td>
              <td align="left">Y</td>
              <td align="left">RFC 9605</td>
              <td align="left">IETF</td>
            </tr>
            <tr>
              <td align="left">0xF000 - 0xFFFF</td>
              <td align="left">Reserved for Private Use</td>
              <td align="left">-</td>
              <td align="left">RFC 9605</td>
              <td align="left">IETF</td>
            </tr>
          </tbody>
        </table>
      </section>
    </section>
    <section anchor="application-responsibilities">
      <name>Application Responsibilities</name>
      <t>To use SFrame, an application needs to define the inputs to the SFrame
encryption and decryption operations, and how SFrame ciphertexts are delivered
from sender to receiver (including any fragmentation and reassembly).  In this
section, we lay out additional requirements that an application must meet in
order for SFrame to operate securely.</t>
      <t>In general, an application using SFrame is responsible for configuring SFrame.
The application must first define when SFrame is applied at all.  When SFrame is
applied, the application must define which cipher suite is to be used.  If new
versions of SFrame are defined in the future, it will be the application's responsibility
to determine which version should be used.</t>
      <t>This division of responsibilities is similar to the way other media parameters
(e.g., codecs) are typically handled in media applications, in the sense that
they are set up in some signaling protocol and not described in the media.
Applications might find it useful to extend the protocols used for negotiating
other media parameters (e.g., Session Description Protocol (SDP) <xref target="RFC8866"/>) to also negotiate parameters for
SFrame.</t>
      <section anchor="header-value-uniqueness">
        <name>Header Value Uniqueness</name>
        <t>Applications <bcp14>MUST</bcp14> ensure that each (<tt>base_key</tt>, KID, CTR) combination is used
for at most one SFrame encryption operation. This ensures that the (key, nonce)
pairs used by the underlying AEAD algorithm are never reused. Typically this is
done by assigning each sender a KID or set of KIDs, then having each sender use
the CTR field as a monotonic counter, incrementing for each plaintext that is
encrypted. In addition to its simplicity, this scheme minimizes overhead by
keeping CTR values as small as possible.</t>
        <t>In applications where an SFrame context might be written to persistent storage,
this context needs to include the last-used CTR value.  When the context is used
later, the application should use the stored CTR value to determine the next CTR
value to be used in an encryption operation, and then write the next CTR value
back to storage before using the CTR value for encryption.  Storing the CTR
value before usage (vs. after) helps ensure that a storage failure will not
cause reuse of the same (<tt>base_key</tt>, KID, CTR) combination.</t>
      </section>
      <section anchor="key-management-framework">
        <name>Key Management Framework</name>
        <t>The application is responsible for provisioning SFrame with a mapping of KID values to
<tt>base_key</tt> values and the resulting keys and salts.  More importantly, the
application specifies which KID values are used for which purposes (e.g., by
which senders).  An application's KID assignment strategy <bcp14>MUST</bcp14> be structured to
assure the non-reuse properties discussed in <xref target="header-value-uniqueness"/>.</t>
        <t>The application is also responsible for defining a rotation schedule for keys.  For
example, one application might have an ephemeral group for every call and keep
rotating keys when endpoints join or leave the call, while another application
could have a persistent group that can be used for multiple calls and simply
derives ephemeral symmetric keys for a specific call.</t>
        <t>It should be noted that KID values are not encrypted by SFrame and are thus
visible to any application-layer intermediaries that might handle an SFrame
ciphertext.  If there are application semantics included in KID values, then
this information would be exposed to intermediaries.  For example, in the scheme
of <xref target="sender-keys"/>, the number of ratchet steps per sender is exposed, and in
the scheme of <xref target="mls"/>, the number of epochs and the MLS sender ID of the SFrame
sender are exposed.</t>
      </section>
      <section anchor="anti-replay">
        <name>Anti-Replay</name>
        <t>It is the responsibility of the application to handle anti-replay. Replay by network
attackers is assumed to be prevented by network-layer facilities (e.g., TLS, SRTP).
As mentioned in <xref target="replay"/>, senders <bcp14>MUST</bcp14> reject requests to encrypt multiple times
with the same key and nonce.</t>
        <t>It is not mandatory to implement anti-replay on the receiver side. Receivers <bcp14>MAY</bcp14>
apply time- or counter-based anti-replay mitigations.  For example, <xref section="3.3.2" sectionFormat="of" target="RFC3711"/> specifies a counter-based anti-replay mitigation, which
could be adapted to use with SFrame, using the CTR field as the counter.</t>
      </section>
      <section anchor="metadata">
        <name>Metadata</name>
        <t>The <tt>metadata</tt> input to SFrame operations is an opaque byte string specified by the application. As
such, the application needs to define what information should go in the
<tt>metadata</tt> input and ensure that it is provided to the encryption and decryption
functions at the appropriate points.  A receiver <bcp14>MUST NOT</bcp14> use SFrame-authenticated
metadata until after the SFrame decrypt function has authenticated it, unless
the purpose of such usage is to prepare an SFrame ciphertext for SFrame
decryption.  Essentially, metadata may be used "upstream of SFrame" in a
processing pipeline, but only to prepare for SFrame decryption.</t>
        <t>For example, consider an application where SFrame is used to encrypt audio
frames that are sent over SRTP, with some application data included in the RTP
header extension. Suppose the application also includes this application data in
the SFrame metadata, so that the SFU is allowed to read, but not modify, the
application data.  A receiver can use the application data in the RTP header
extension as part of the standard SRTP decryption process since this is
required to recover the SFrame ciphertext carried in the SRTP payload.  However,
the receiver <bcp14>MUST NOT</bcp14> use the application data for other purposes before SFrame
decryption has authenticated the application data.</t>
      </section>
    </section>
  </middle>
  <back>
    <displayreference target="RFC9420" to="MLS-PROTO"/>
    <displayreference target="I-D.ietf-webtrans-overview" to="WEBTRANSPORT"/>
    <displayreference target="I-D.ietf-moq-transport" to="MOQ-TRANSPORT"/>
    <displayreference target="I-D.ietf-mls-architecture" to="MLS-ARCH"/>
    <displayreference target="I-D.gouaillard-avtcore-codec-agn-rtp-payload" to="RTP-PAYLOAD"/>
    <references>
      <name>References</name>
      <references anchor="sec-normative-references">
        <name>Normative References</name>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.5116.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.5869.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9420.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8126.xml"/>
      </references>
      <references anchor="sec-informative-references">
        <name>Informative References</name>
        <reference anchor="TestVectors" target="https://github.com/sframe-wg/sframe/blob/025d568/test-vectors/test-vectors.json">
          <front>
            <title>SFrame Test Vectors</title>
            <author>
              <organization/>
            </author>
            <date year="2023" month="September"/>
          </front>
          <refcontent>commit 025d568</refcontent>
        </reference>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.3711.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8723.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7656.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-webtrans-overview.xml"/>
        <reference anchor="I-D.ietf-moq-transport" target="https://datatracker.ietf.org/doc/html/draft-ietf-moq-transport-05">
          <front>
            <title>Media over QUIC Transport</title>
            <author fullname="Luke Curley" initials="L." surname="Curley">
              <organization>Discord</organization>
            </author>
            <author fullname="Kirill Pugin" initials="K." surname="Pugin">
              <organization>Meta</organization>
            </author>
            <author fullname="Suhas Nandakumar" initials="S." surname="Nandakumar">
              <organization>Cisco</organization>
            </author>
            <author fullname="Victor Vasiliev" initials="V." surname="Vasiliev">
              <organization>Google</organization>
            </author>
            <author fullname="Ian Swett" initials="I." surname="Swett" role="editor">
              <organization>Google</organization>
            </author>
            <date day="8" month="July" year="2024"/>
          </front>
          <seriesInfo name="Internet-Draft" value="draft-ietf-moq-transport-05"/>
        </reference>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-mls-architecture.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7667.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8866.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6716.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml3/reference.I-D.gouaillard-avtcore-codec-agn-rtp-payload.xml"/>
      </references>
    </references>

<section anchor="example-api">
      <name>Example API</name>
      <t><strong>This section is not normative.</strong></t>
      <t>This section describes a notional API that an SFrame implementation might
expose.  The core concept is an "SFrame context", within which KID values are
meaningful.  In the key management scheme described in <xref target="sender-keys"/>, each
sender has a different context; in the scheme described in <xref target="mls"/>, all senders
share the same context.</t>
      <t>An SFrame context stores mappings from KID values to "key contexts", which are
different depending on whether the KID is to be used for sending or receiving
(an SFrame key should never be used for both operations).  A key context tracks
the key and salt associated to the KID, and the current CTR value.  A key
context to be used for sending also tracks the next CTR value to be used.</t>
      <t>The primary operations on an SFrame context are as follows:</t>
      <ul spacing="normal">
        <li>
          <t><strong>Create an SFrame context:</strong> The context is initialized with a cipher suite and
no KID mappings.</t>
        </li>
        <li>
          <t><strong>Add a key for sending:</strong> The key and salt are derived from the base key and
used to initialize a send context, together with a zero CTR value.</t>
        </li>
        <li>
          <t><strong>Add a key for receiving:</strong> The key and salt are derived from the base key and
used to initialize a send context.</t>
        </li>
        <li>
          <t><strong>Encrypt a plaintext:</strong> Encrypt a given plaintext using the key for a given KID,
including the specified metadata.</t>
        </li>
        <li>
          <t><strong>Decrypt an SFrame ciphertext:</strong> Decrypt an SFrame ciphertext with the KID
and CTR values specified in the SFrame header, and the provided metadata.</t>
        </li>
      </ul>
      <t><xref target="rust-api"/> shows an example of the types of structures and methods that could
be used to create an SFrame API in Rust.</t>
      <figure anchor="rust-api">
        <name>An Example SFrame API</name>
        <sourcecode type="rust"><![CDATA[
type KeyId = u64;
type Counter = u64;
type CipherSuite = u16;

struct SendKeyContext {
  key: Vec<u8>,
  salt: Vec<u8>,
  next_counter: Counter,
}

struct RecvKeyContext {
  key: Vec<u8>,
  salt: Vec<u8>,
}

struct SFrameContext {
  cipher_suite: CipherSuite,
  send_keys: HashMap<KeyId, SendKeyContext>,
  recv_keys: HashMap<KeyId, RecvKeyContext>,
}

trait SFrameContextMethods {
  fn create(cipher_suite: CipherSuite) -> Self;
  fn add_send_key(&self, kid: KeyId, base_key: &[u8]);
  fn add_recv_key(&self, kid: KeyId, base_key: &[u8]);
  fn encrypt(&mut self, kid: KeyId, metadata: &[u8],
             plaintext: &[u8]) -> Vec<u8>;
  fn decrypt(&self, metadata: &[u8], ciphertext: &[u8]) -> Vec<u8>;
}
]]></sourcecode>
      </figure>
    </section>
    <section anchor="overhead-analysis">
      <name>Overhead Analysis</name>
      <t>Any use of SFrame will impose overhead in terms of the amount of bandwidth
necessary to transmit a given media stream.  Exactly how much overhead will be added
depends on several factors:</t>
      <ul spacing="normal">
        <li>
          <t>The number of senders involved in a conference (length of KID)</t>
        </li>
        <li>
          <t>The duration of the conference (length of CTR)</t>
        </li>
        <li>
          <t>The cipher suite in use (length of authentication tag)</t>
        </li>
        <li>
          <t>Whether SFrame is used to encrypt packets, whole frames, or some other unit</t>
        </li>
      </ul>
      <t>Overall, the overhead rate in kilobits per second can be estimated as:</t>
      <t><tt>
OverheadKbps = (1 + |CTR| + |KID| + |TAG|) * 8 * CTPerSecond / 1024
</tt></t>
      <t>Here the constant value <tt>1</tt> reflects the fixed SFrame header; <tt>|CTR|</tt> and
<tt>|KID|</tt> reflect the lengths of those fields; <tt>|TAG|</tt> reflects the cipher
overhead; and <tt>CTPerSecond</tt> reflects the number of SFrame ciphertexts
sent per second (e.g., packets or frames per second).</t>
      <t>In the remainder of this section, we compute overhead estimates for a collection
of common scenarios.</t>
      <section anchor="assumptions">
        <name>Assumptions</name>
        <t>In the below calculations, we make conservative assumptions about SFrame
overhead so that the overhead amounts we compute here are likely to be an upper
bound of those seen in practice.</t>
        <table anchor="analysis-assumptions">
          <name>Overhead Analysis Assumptions</name>
          <thead>
            <tr>
              <th align="left">Field</th>
              <th align="right">Bytes</th>
              <th align="left">Explanation</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">Config byte</td>
              <td align="right">1</td>
              <td align="left">Fixed</td>
            </tr>
            <tr>
              <td align="left">Key ID (KID)</td>
              <td align="right">2</td>
              <td align="left">&gt;255 senders; or MLS epoch (E=4) and &gt;16 senders</td>
            </tr>
            <tr>
              <td align="left">Counter (CTR)</td>
              <td align="right">3</td>
              <td align="left">More than 24 hours of media in common cases</td>
            </tr>
            <tr>
              <td align="left">Cipher overhead</td>
              <td align="right">16</td>
              <td align="left">Full authentication tag (longest defined here)</td>
            </tr>
          </tbody>
        </table>
        <t>In total, then, we assume that each SFrame encryption will add 22 bytes of
overhead.</t>
        <t>We consider two scenarios: applying SFrame per frame and per packet.  In each
scenario, we compute the SFrame overhead in absolute terms (kbps) and as a
percentage of the base bandwidth.</t>
      </section>
      <section anchor="audio">
        <name>Audio</name>
        <t>In audio streams, there is typically a one-to-one relationship between frames
and packets, so the overhead is the same whether one uses SFrame at a per-packet
or per-frame level.</t>
        <t><xref target="audio-overhead"/> considers three scenarios that are based on recommended configurations
of the Opus codec <xref target="RFC6716"/> (where "fps" stands for "frames per second"):</t>
        <table anchor="audio-overhead">
          <name>SFrame Overhead for Audio Streams</name>
          <thead>
            <tr>
              <th align="left">Scenario</th>
              <th align="center">Frame length</th>
              <th align="center">fps</th>
              <th align="center">Base kbps</th>
              <th align="center">Overhead kbps</th>
              <th align="center">Overhead %</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">Narrow-band speech</td>
              <td align="center">120 ms</td>
              <td align="center">8.3</td>
              <td align="center">8</td>
              <td align="center">1.4</td>
              <td align="center">17.9%</td>
            </tr>
            <tr>
              <td align="left">Full-band speech</td>
              <td align="center">20 ms</td>
              <td align="center">50</td>
              <td align="center">32</td>
              <td align="center">8.6</td>
              <td align="center">26.9%</td>
            </tr>
            <tr>
              <td align="left">Full-band stereo music</td>
              <td align="center">10 ms</td>
              <td align="center">100</td>
              <td align="center">128</td>
              <td align="center">17.2</td>
              <td align="center">13.4%</td>
            </tr>
          </tbody>
        </table>
      </section>
      <section anchor="video">
        <name>Video</name>
        <t>Video frames can be larger than an MTU and thus are commonly split across
multiple frames.  Tables <xref target="video-overhead-per-frame" format="counter"/>
and <xref target="video-overhead-per-packet" format="counter"/>
show the estimated overhead of encrypting a video stream, where SFrame is
applied per frame and per packet, respectively.  The choices of resolution,
frames per second, and bandwidth roughly reflect the capabilities of
modern video codecs across a range from very low to very high quality.</t>
        <table anchor="video-overhead-per-frame">
          <name>SFrame Overhead for a Video Stream Encrypted per Frame</name>
          <thead>
            <tr>
              <th align="left">Scenario</th>
              <th align="center">fps</th>
              <th align="center">Base kbps</th>
              <th align="center">Overhead kbps</th>
              <th align="center">Overhead %</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">426 x 240</td>
              <td align="center">7.5</td>
              <td align="center">45</td>
              <td align="center">1.3</td>
              <td align="center">2.9%</td>
            </tr>
            <tr>
              <td align="left">640 x 360</td>
              <td align="center">15</td>
              <td align="center">200</td>
              <td align="center">2.6</td>
              <td align="center">1.3%</td>
            </tr>
            <tr>
              <td align="left">640 x 360</td>
              <td align="center">30</td>
              <td align="center">400</td>
              <td align="center">5.2</td>
              <td align="center">1.3%</td>
            </tr>
            <tr>
              <td align="left">1280 x 720</td>
              <td align="center">30</td>
              <td align="center">1500</td>
              <td align="center">5.2</td>
              <td align="center">0.3%</td>
            </tr>
            <tr>
              <td align="left">1920 x 1080</td>
              <td align="center">60</td>
              <td align="center">7200</td>
              <td align="center">10.3</td>
              <td align="center">0.1%</td>
            </tr>
          </tbody>
        </table>
        <table anchor="video-overhead-per-packet">
          <name>SFrame Overhead for a Video Stream Encrypted per Packet</name>
          <thead>
            <tr>
              <th align="left">Scenario</th>
              <th align="center">fps</th>
              <th align="center">Packets per Second (pps)</th>
              <th align="center">Base kbps</th>
              <th align="center">Overhead kbps</th>
              <th align="center">Overhead %</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">426 x 240</td>
              <td align="center">7.5</td>
              <td align="center">7.5</td>
              <td align="center">45</td>
              <td align="center">1.3</td>
              <td align="center">2.9%</td>
            </tr>
            <tr>
              <td align="left">640 x 360</td>
              <td align="center">15</td>
              <td align="center">30</td>
              <td align="center">200</td>
              <td align="center">5.2</td>
              <td align="center">2.6%</td>
            </tr>
            <tr>
              <td align="left">640 x 360</td>
              <td align="center">30</td>
              <td align="center">60</td>
              <td align="center">400</td>
              <td align="center">10.3</td>
              <td align="center">2.6%</td>
            </tr>
            <tr>
              <td align="left">1280 x 720</td>
              <td align="center">30</td>
              <td align="center">180</td>
              <td align="center">1500</td>
              <td align="center">30.9</td>
              <td align="center">2.1%</td>
            </tr>
            <tr>
              <td align="left">1920 x 1080</td>
              <td align="center">60</td>
              <td align="center">780</td>
              <td align="center">7200</td>
              <td align="center">134.1</td>
              <td align="center">1.9%</td>
            </tr>
          </tbody>
        </table>
        <t>In the per-frame case, the SFrame percentage overhead approaches zero as the
quality of the video improves since bandwidth is driven more by picture size
than frame rate.  In the per-packet case, the SFrame percentage overhead
approaches the ratio between the SFrame overhead per packet and the MTU (here 22
bytes of SFrame overhead divided by an assumed 1200-byte MTU, or about 1.8%).</t>
      </section>
      <section anchor="conferences">
        <name>Conferences</name>
        <t>Real conferences usually involve several audio and video streams.  The overhead
of SFrame in such a conference is the aggregate of the overhead across all the
individual streams.  Thus, while SFrame incurs a large percentage overhead on an
audio stream, if the conference also involves a video stream, then the audio
overhead is likely negligible relative to the overall bandwidth of the
conference.</t>
        <t>For example, <xref target="conference-overhead"/> shows the overhead estimates for a two-person
conference where one person is sending low-quality media and the other is
sending high-quality media.  (And we assume that SFrame is applied per frame.)  The
video streams dominate the bandwidth at the SFU, so the total bandwidth overhead
is only around 1%.</t>
        <table anchor="conference-overhead">
          <name>SFrame Overhead for a Two-Person Conference</name>
          <thead>
            <tr>
              <th align="left">Stream</th>
              <th align="center">Base Kbps</th>
              <th align="center">Overhead Kbps</th>
              <th align="center">Overhead %</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">Participant 1 audio</td>
              <td align="center">8</td>
              <td align="center">1.4</td>
              <td align="center">17.9%</td>
            </tr>
            <tr>
              <td align="left">Participant 1 video</td>
              <td align="center">45</td>
              <td align="center">1.3</td>
              <td align="center">2.9%</td>
            </tr>
            <tr>
              <td align="left">Participant 2 audio</td>
              <td align="center">32</td>
              <td align="center">9</td>
              <td align="center">26.9%</td>
            </tr>
            <tr>
              <td align="left">Participant 2 video</td>
              <td align="center">1500</td>
              <td align="center">5</td>
              <td align="center">0.3%</td>
            </tr>
            <tr>
              <td align="left">Total at SFU</td>
              <td align="center">1585</td>
              <td align="center">16.5</td>
              <td align="center">1.0%</td>
            </tr>
          </tbody>
        </table>
      </section>
      <section anchor="sframe-over-rtp">
        <name>SFrame over RTP</name>
        <t>SFrame is a generic encapsulation format, but many of the applications in which
it is likely to be integrated are based on RTP.  This section discusses how an
integration between SFrame and RTP could be done, and some of the challenges
that would need to be overcome.</t>
        <t>As discussed in <xref target="application-context"/>, there are two natural patterns for
integrating SFrame into an application: applying SFrame per frame or per packet.
In RTP-based applications, applying SFrame per packet means that the payload of
each RTP packet will be an SFrame ciphertext, starting with an SFrame header, as
shown in <xref target="sframe-packet"/>.  Applying SFrame per frame means that different
RTP payloads will have different formats: The first payload of a frame will
contain the SFrame headers, and subsequent payloads will contain further chunks
of the ciphertext, as shown in <xref target="sframe-multi-packet"/>.</t>
        <t>In order for these media payloads to be properly interpreted by receivers,
receivers will need to be configured to know which of the above schemes the
sender has  applied to a given sequence of RTP packets. SFrame does not provide
a mechanism for distributing this configuration information. In applications
that use SDP for negotiating RTP media streams <xref target="RFC8866"/>, an appropriate
extension to SDP could provide this function.</t>
        <t>Applying SFrame per frame also requires that packetization and depacketization
be done in a generic manner that does not depend on the media content of the
packets, since the content being packetized or depacketized will be opaque
ciphertext (except for the SFrame header).  In order for such a generic
packetization scheme to work interoperably, one would have to be defined, e.g.,
as proposed in <xref target="I-D.gouaillard-avtcore-codec-agn-rtp-payload"/>.</t>
        <figure anchor="sframe-packet">
          <name>SRTP Packet with SFrame-Protected Payload</name>
          <artset>
            <artwork type="svg"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="384" width="552" viewBox="0 0 552 384" class="diagram" text-anchor="middle" font-family="monospace" font-size="13px" stroke-linecap="round">
                <path d="M 8,208 L 8,368" fill="none" stroke="black"/>
                <path d="M 32,32 L 32,336" fill="none" stroke="black"/>
                <path d="M 64,32 L 64,64" fill="none" stroke="black"/>
                <path d="M 80,32 L 80,64" fill="none" stroke="black"/>
                <path d="M 96,32 L 96,64" fill="none" stroke="black"/>
                <path d="M 160,32 L 160,64" fill="none" stroke="black"/>
                <path d="M 176,32 L 176,64" fill="none" stroke="black"/>
                <path d="M 192,208 L 192,240" fill="none" stroke="black"/>
                <path d="M 272,32 L 272,64" fill="none" stroke="black"/>
                <path d="M 520,32 L 520,336" fill="none" stroke="black"/>
                <path d="M 544,32 L 544,368" fill="none" stroke="black"/>
                <path d="M 32,32 L 544,32" fill="none" stroke="black"/>
                <path d="M 32,64 L 520,64" fill="none" stroke="black"/>
                <path d="M 32,96 L 520,96" fill="none" stroke="black"/>
                <path d="M 32,126 L 520,126" fill="none" stroke="black"/>
                <path d="M 32,130 L 520,130" fill="none" stroke="black"/>
                <path d="M 32,176 L 520,176" fill="none" stroke="black"/>
                <path d="M 8,208 L 520,208" fill="none" stroke="black"/>
                <path d="M 32,240 L 192,240" fill="none" stroke="black"/>
                <path d="M 8,304 L 544,304" fill="none" stroke="black"/>
                <path d="M 32,336 L 520,336" fill="none" stroke="black"/>
                <path d="M 8,368 L 32,368" fill="none" stroke="black"/>
                <path d="M 520,368 L 544,368" fill="none" stroke="black"/>
                <polygon class="arrowhead" points="536,304 524,298.4 524,309.6" fill="black" transform="rotate(180,528,304)"/>
                <polygon class="arrowhead" points="536,32 524,26.4 524,37.6" fill="black" transform="rotate(180,528,32)"/>
                <polygon class="arrowhead" points="32,304 20,298.4 20,309.6" fill="black" transform="rotate(0,24,304)"/>
                <polygon class="arrowhead" points="32,208 20,202.4 20,213.6" fill="black" transform="rotate(0,24,208)"/>
                <g class="text">
                  <text x="48" y="52">V=2</text>
                  <text x="72" y="52">P</text>
                  <text x="88" y="52">X</text>
                  <text x="124" y="52">CC</text>
                  <text x="168" y="52">M</text>
                  <text x="228" y="52">PT</text>
                  <text x="364" y="52">sequence</text>
                  <text x="428" y="52">number</text>
                  <text x="280" y="84">timestamp</text>
                  <text x="176" y="116">synchronization</text>
                  <text x="268" y="116">source</text>
                  <text x="324" y="116">(SSRC)</text>
                  <text x="396" y="116">identifier</text>
                  <text x="172" y="148">contributing</text>
                  <text x="252" y="148">source</text>
                  <text x="308" y="148">(CSRC)</text>
                  <text x="384" y="148">identifiers</text>
                  <text x="292" y="164">....</text>
                  <text x="192" y="196">RTP</text>
                  <text x="260" y="196">extension(s)</text>
                  <text x="356" y="196">(OPTIONAL)</text>
                  <text x="76" y="228">SFrame</text>
                  <text x="132" y="228">header</text>
                  <text x="132" y="276">SFrame</text>
                  <text x="200" y="276">encrypted</text>
                  <text x="256" y="276">and</text>
                  <text x="328" y="276">authenticated</text>
                  <text x="416" y="276">payload</text>
                  <text x="204" y="324">SRTP</text>
                  <text x="284" y="324">authentication</text>
                  <text x="360" y="324">tag</text>
                  <text x="60" y="372">SRTP</text>
                  <text x="120" y="372">Encrypted</text>
                  <text x="192" y="372">Portion</text>
                  <text x="316" y="372">SRTP</text>
                  <text x="392" y="372">Authenticated</text>
                  <text x="480" y="372">Portion</text>
                </g>
              </svg>
            </artwork>
            <artwork type="ascii-art"><![CDATA[
   +---+-+-+-------+-+-----------+------------------------------+<-+
   |V=2|P|X|  CC   |M|     PT    |       sequence number        |  |
   +---+-+-+-------+-+-----------+------------------------------+  |
   |                          timestamp                         |  |
   +------------------------------------------------------------+  |
   |          synchronization source (SSRC) identifier          |  |
   +============================================================+  |
   |           contributing source (CSRC) identifiers           |  |
   |                              ....                          |  |
   +------------------------------------------------------------+  |
   |                  RTP extension(s) (OPTIONAL)               |  |
+->+-------------------+----------------------------------------+  |
|  |  SFrame header    |                                        |  |
|  +-------------------+                                        |  |
|  |                                                            |  |
|  |         SFrame encrypted and authenticated payload         |  |
|  |                                                            |  |
+->+------------------------------------------------------------+<-+
|  |                   SRTP authentication tag                  |  |
|  +------------------------------------------------------------+  |
|                                                                  |
+--- SRTP Encrypted Portion          SRTP Authenticated Portion ---+
]]></artwork>
          </artset>
        </figure>
        <figure anchor="sframe-multi-packet">
          <name>Encryption Flow with per-Frame Encryption for RTP</name>
          <artset>
            <artwork type="svg"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="624" width="504" viewBox="0 0 504 624" class="diagram" text-anchor="middle" font-family="monospace" font-size="13px" stroke-linecap="round">
                <path d="M 8,192 L 8,224" fill="none" stroke="black"/>
                <path d="M 8,512 L 8,608" fill="none" stroke="black"/>
                <path d="M 32,32 L 32,64" fill="none" stroke="black"/>
                <path d="M 32,232 L 32,504" fill="none" stroke="black"/>
                <path d="M 72,464 L 72,504" fill="none" stroke="black"/>
                <path d="M 96,64 L 96,184" fill="none" stroke="black"/>
                <path d="M 136,512 L 136,608" fill="none" stroke="black"/>
                <path d="M 168,32 L 168,64" fill="none" stroke="black"/>
                <path d="M 192,32 L 192,128" fill="none" stroke="black"/>
                <path d="M 192,288 L 192,400" fill="none" stroke="black"/>
                <path d="M 192,512 L 192,608" fill="none" stroke="black"/>
                <path d="M 256,128 L 256,184" fill="none" stroke="black"/>
                <path d="M 256,232 L 256,280" fill="none" stroke="black"/>
                <path d="M 256,400 L 256,416" fill="none" stroke="black"/>
                <path d="M 256,448 L 256,504" fill="none" stroke="black"/>
                <path d="M 320,32 L 320,128" fill="none" stroke="black"/>
                <path d="M 320,192 L 320,224" fill="none" stroke="black"/>
                <path d="M 320,288 L 320,400" fill="none" stroke="black"/>
                <path d="M 320,512 L 320,608" fill="none" stroke="black"/>
                <path d="M 368,512 L 368,608" fill="none" stroke="black"/>
                <path d="M 432,464 L 432,504" fill="none" stroke="black"/>
                <path d="M 496,512 L 496,608" fill="none" stroke="black"/>
                <path d="M 32,32 L 168,32" fill="none" stroke="black"/>
                <path d="M 192,32 L 320,32" fill="none" stroke="black"/>
                <path d="M 32,64 L 168,64" fill="none" stroke="black"/>
                <path d="M 192,128 L 320,128" fill="none" stroke="black"/>
                <path d="M 8,192 L 320,192" fill="none" stroke="black"/>
                <path d="M 8,224 L 320,224" fill="none" stroke="black"/>
                <path d="M 192,288 L 320,288" fill="none" stroke="black"/>
                <path d="M 192,400 L 320,400" fill="none" stroke="black"/>
                <path d="M 72,464 L 328,464" fill="none" stroke="black"/>
                <path d="M 360,464 L 432,464" fill="none" stroke="black"/>
                <path d="M 8,512 L 136,512" fill="none" stroke="black"/>
                <path d="M 192,512 L 320,512" fill="none" stroke="black"/>
                <path d="M 368,512 L 496,512" fill="none" stroke="black"/>
                <path d="M 8,544 L 136,544" fill="none" stroke="black"/>
                <path d="M 8,608 L 136,608" fill="none" stroke="black"/>
                <path d="M 192,608 L 320,608" fill="none" stroke="black"/>
                <path d="M 368,608 L 496,608" fill="none" stroke="black"/>
                <polygon class="arrowhead" points="440,504 428,498.4 428,509.6" fill="black" transform="rotate(90,432,504)"/>
                <polygon class="arrowhead" points="264,504 252,498.4 252,509.6" fill="black" transform="rotate(90,256,504)"/>
                <polygon class="arrowhead" points="264,280 252,274.4 252,285.6" fill="black" transform="rotate(90,256,280)"/>
                <polygon class="arrowhead" points="264,184 252,178.4 252,189.6" fill="black" transform="rotate(90,256,184)"/>
                <polygon class="arrowhead" points="104,184 92,178.4 92,189.6" fill="black" transform="rotate(90,96,184)"/>
                <polygon class="arrowhead" points="80,504 68,498.4 68,509.6" fill="black" transform="rotate(90,72,504)"/>
                <polygon class="arrowhead" points="40,504 28,498.4 28,509.6" fill="black" transform="rotate(90,32,504)"/>
                <g class="text">
                  <text x="64" y="52">frame</text>
                  <text x="124" y="52">metadata</text>
                  <text x="256" y="84">frame</text>
                  <text x="132" y="212">SFrame</text>
                  <text x="192" y="212">Encrypt</text>
                  <text x="256" y="340">encrypted</text>
                  <text x="256" y="356">frame</text>
                  <text x="208" y="436">generic</text>
                  <text x="256" y="436">RTP</text>
                  <text x="312" y="436">packetize</text>
                  <text x="344" y="468">...</text>
                  <text x="44" y="532">SFrame</text>
                  <text x="100" y="532">header</text>
                  <text x="240" y="564">payload</text>
                  <text x="288" y="564">2/N</text>
                  <text x="344" y="564">...</text>
                  <text x="416" y="564">payload</text>
                  <text x="464" y="564">N/N</text>
                  <text x="56" y="580">payload</text>
                  <text x="104" y="580">1/N</text>
                </g>
              </svg>
            </artwork>
            <artwork type="ascii-art"><![CDATA[
   +----------------+  +---------------+
   | frame metadata |  |               |
   +-------+--------+  |               |
           |           |     frame     |
           |           |               |
           |           |               |
           |           +-------+-------+
           |                   |
           |                   |
           V                   V
+--------------------------------------+
|            SFrame Encrypt            |
+--------------------------------------+
   |                           |
   |                           |
   |                           V
   |                   +-------+-------+
   |                   |               |
   |                   |               |
   |                   |   encrypted   |
   |                   |     frame     |
   |                   |               |
   |                   |               |
   |                   +-------+-------+
   |                           |
   |                  generic RTP packetize
   |                           |
   |    +----------------------+--------.....--------+
   |    |                      |                     |
   V    V                      V                     V
+---------------+      +---------------+     +---------------+
| SFrame header |      |               |     |               |
+---------------+      |               |     |               |
|               |      |  payload 2/N  | ... |  payload N/N  |
|  payload 1/N  |      |               |     |               |
|               |      |               |     |               |
+---------------+      +---------------+     +---------------+
]]></artwork>
          </artset>
        </figure>
      </section>
    </section>
    <section anchor="test-vectors">
      <name>Test Vectors</name>
      <t>This section provides a set of test vectors that implementations can use to
verify that they correctly implement SFrame encryption and decryption.  In
addition to test vectors for the overall process of SFrame
encryption/decryption, we also provide test vectors for header
encoding/decoding, and for AEAD encryption/decryption using the AES-CTR
construction defined in <xref target="aes-ctr-with-sha2"/>.</t>
      <t>All values are either numeric or byte strings.  Numeric values are represented
as hex values, prefixed with <tt>0x</tt>.  Byte strings are represented in hex
encoding.</t>
      <t>Line breaks and whitespace within values are inserted to conform to the width
requirements of the RFC format.  They should be removed before use.</t>
      <t>These test vectors are also available in JSON format at <xref target="TestVectors"/>.  In the
JSON test vectors, numeric values are JSON numbers and byte string values are
JSON strings containing the hex encoding of the byte strings.</t>
      <section anchor="header-encodingdecoding">
        <name>Header Encoding/Decoding</name>
        <t>For each case, we provide:</t>
        <ul spacing="normal">
          <li>
            <t><tt>kid</tt>: A KID value</t>
          </li>
          <li>
            <t><tt>ctr</tt>: A CTR value</t>
          </li>
          <li>
            <t><tt>header</tt>: An encoded SFrame header</t>
          </li>
        </ul>
        <t>An implementation should verify that:</t>
        <ul spacing="normal">
          <li>
            <t>Encoding a header with the KID and CTR results in the provided header value</t>
          </li>
          <li>
            <t>Decoding the provided header value results in the provided KID and CTR values</t>
          </li>
        </ul>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000000
ctr: 0x0000000000000000
header: 00
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000000
ctr: 0x0000000000000001
header: 01
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000000
ctr: 0x00000000000000ff
header: 08ff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000000
ctr: 0x0000000000000100
header: 090100
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000000
ctr: 0x000000000000ffff
header: 09ffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000000
ctr: 0x0000000000010000
header: 0a010000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000000
ctr: 0x0000000000ffffff
header: 0affffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000000
ctr: 0x0000000001000000
header: 0b01000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000000
ctr: 0x00000000ffffffff
header: 0bffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000000
ctr: 0x0000000100000000
header: 0c0100000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000000
ctr: 0x000000ffffffffff
header: 0cffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000000
ctr: 0x0000010000000000
header: 0d010000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000000
ctr: 0x0000ffffffffffff
header: 0dffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000000
ctr: 0x0001000000000000
header: 0e01000000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000000
ctr: 0x00ffffffffffffff
header: 0effffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000000
ctr: 0x0100000000000000
header: 0f0100000000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000000
ctr: 0xffffffffffffffff
header: 0fffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000001
ctr: 0x0000000000000000
header: 10
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000001
ctr: 0x0000000000000001
header: 11
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000001
ctr: 0x00000000000000ff
header: 18ff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000001
ctr: 0x0000000000000100
header: 190100
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000001
ctr: 0x000000000000ffff
header: 19ffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000001
ctr: 0x0000000000010000
header: 1a010000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000001
ctr: 0x0000000000ffffff
header: 1affffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000001
ctr: 0x0000000001000000
header: 1b01000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000001
ctr: 0x00000000ffffffff
header: 1bffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000001
ctr: 0x0000000100000000
header: 1c0100000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000001
ctr: 0x000000ffffffffff
header: 1cffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000001
ctr: 0x0000010000000000
header: 1d010000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000001
ctr: 0x0000ffffffffffff
header: 1dffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000001
ctr: 0x0001000000000000
header: 1e01000000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000001
ctr: 0x00ffffffffffffff
header: 1effffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000001
ctr: 0x0100000000000000
header: 1f0100000000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000001
ctr: 0xffffffffffffffff
header: 1fffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00000000000000ff
ctr: 0x0000000000000000
header: 80ff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00000000000000ff
ctr: 0x0000000000000001
header: 81ff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00000000000000ff
ctr: 0x00000000000000ff
header: 88ffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00000000000000ff
ctr: 0x0000000000000100
header: 89ff0100
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00000000000000ff
ctr: 0x000000000000ffff
header: 89ffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00000000000000ff
ctr: 0x0000000000010000
header: 8aff010000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00000000000000ff
ctr: 0x0000000000ffffff
header: 8affffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00000000000000ff
ctr: 0x0000000001000000
header: 8bff01000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00000000000000ff
ctr: 0x00000000ffffffff
header: 8bffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00000000000000ff
ctr: 0x0000000100000000
header: 8cff0100000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00000000000000ff
ctr: 0x000000ffffffffff
header: 8cffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00000000000000ff
ctr: 0x0000010000000000
header: 8dff010000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00000000000000ff
ctr: 0x0000ffffffffffff
header: 8dffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00000000000000ff
ctr: 0x0001000000000000
header: 8eff01000000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00000000000000ff
ctr: 0x00ffffffffffffff
header: 8effffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00000000000000ff
ctr: 0x0100000000000000
header: 8fff0100000000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00000000000000ff
ctr: 0xffffffffffffffff
header: 8fffffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000100
ctr: 0x0000000000000000
header: 900100
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000100
ctr: 0x0000000000000001
header: 910100
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000100
ctr: 0x00000000000000ff
header: 980100ff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000100
ctr: 0x0000000000000100
header: 9901000100
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000100
ctr: 0x000000000000ffff
header: 990100ffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000100
ctr: 0x0000000000010000
header: 9a0100010000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000100
ctr: 0x0000000000ffffff
header: 9a0100ffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000100
ctr: 0x0000000001000000
header: 9b010001000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000100
ctr: 0x00000000ffffffff
header: 9b0100ffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000100
ctr: 0x0000000100000000
header: 9c01000100000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000100
ctr: 0x000000ffffffffff
header: 9c0100ffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000100
ctr: 0x0000010000000000
header: 9d0100010000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000100
ctr: 0x0000ffffffffffff
header: 9d0100ffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000100
ctr: 0x0001000000000000
header: 9e010001000000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000100
ctr: 0x00ffffffffffffff
header: 9e0100ffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000100
ctr: 0x0100000000000000
header: 9f01000100000000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000000100
ctr: 0xffffffffffffffff
header: 9f0100ffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x000000000000ffff
ctr: 0x0000000000000000
header: 90ffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x000000000000ffff
ctr: 0x0000000000000001
header: 91ffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x000000000000ffff
ctr: 0x00000000000000ff
header: 98ffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x000000000000ffff
ctr: 0x0000000000000100
header: 99ffff0100
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x000000000000ffff
ctr: 0x000000000000ffff
header: 99ffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x000000000000ffff
ctr: 0x0000000000010000
header: 9affff010000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x000000000000ffff
ctr: 0x0000000000ffffff
header: 9affffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x000000000000ffff
ctr: 0x0000000001000000
header: 9bffff01000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x000000000000ffff
ctr: 0x00000000ffffffff
header: 9bffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x000000000000ffff
ctr: 0x0000000100000000
header: 9cffff0100000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x000000000000ffff
ctr: 0x000000ffffffffff
header: 9cffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x000000000000ffff
ctr: 0x0000010000000000
header: 9dffff010000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x000000000000ffff
ctr: 0x0000ffffffffffff
header: 9dffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x000000000000ffff
ctr: 0x0001000000000000
header: 9effff01000000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x000000000000ffff
ctr: 0x00ffffffffffffff
header: 9effffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x000000000000ffff
ctr: 0x0100000000000000
header: 9fffff0100000000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x000000000000ffff
ctr: 0xffffffffffffffff
header: 9fffffffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000010000
ctr: 0x0000000000000000
header: a0010000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000010000
ctr: 0x0000000000000001
header: a1010000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000010000
ctr: 0x00000000000000ff
header: a8010000ff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000010000
ctr: 0x0000000000000100
header: a90100000100
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000010000
ctr: 0x000000000000ffff
header: a9010000ffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000010000
ctr: 0x0000000000010000
header: aa010000010000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000010000
ctr: 0x0000000000ffffff
header: aa010000ffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000010000
ctr: 0x0000000001000000
header: ab01000001000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000010000
ctr: 0x00000000ffffffff
header: ab010000ffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000010000
ctr: 0x0000000100000000
header: ac0100000100000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000010000
ctr: 0x000000ffffffffff
header: ac010000ffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000010000
ctr: 0x0000010000000000
header: ad010000010000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000010000
ctr: 0x0000ffffffffffff
header: ad010000ffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000010000
ctr: 0x0001000000000000
header: ae01000001000000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000010000
ctr: 0x00ffffffffffffff
header: ae010000ffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000010000
ctr: 0x0100000000000000
header: af0100000100000000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000010000
ctr: 0xffffffffffffffff
header: af010000ffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000ffffff
ctr: 0x0000000000000000
header: a0ffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000ffffff
ctr: 0x0000000000000001
header: a1ffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000ffffff
ctr: 0x00000000000000ff
header: a8ffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000ffffff
ctr: 0x0000000000000100
header: a9ffffff0100
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000ffffff
ctr: 0x000000000000ffff
header: a9ffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000ffffff
ctr: 0x0000000000010000
header: aaffffff010000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000ffffff
ctr: 0x0000000000ffffff
header: aaffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000ffffff
ctr: 0x0000000001000000
header: abffffff01000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000ffffff
ctr: 0x00000000ffffffff
header: abffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000ffffff
ctr: 0x0000000100000000
header: acffffff0100000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000ffffff
ctr: 0x000000ffffffffff
header: acffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000ffffff
ctr: 0x0000010000000000
header: adffffff010000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000ffffff
ctr: 0x0000ffffffffffff
header: adffffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000ffffff
ctr: 0x0001000000000000
header: aeffffff01000000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000ffffff
ctr: 0x00ffffffffffffff
header: aeffffffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000ffffff
ctr: 0x0100000000000000
header: afffffff0100000000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000000ffffff
ctr: 0xffffffffffffffff
header: afffffffffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000001000000
ctr: 0x0000000000000000
header: b001000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000001000000
ctr: 0x0000000000000001
header: b101000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000001000000
ctr: 0x00000000000000ff
header: b801000000ff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000001000000
ctr: 0x0000000000000100
header: b9010000000100
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000001000000
ctr: 0x000000000000ffff
header: b901000000ffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000001000000
ctr: 0x0000000000010000
header: ba01000000010000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000001000000
ctr: 0x0000000000ffffff
header: ba01000000ffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000001000000
ctr: 0x0000000001000000
header: bb0100000001000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000001000000
ctr: 0x00000000ffffffff
header: bb01000000ffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000001000000
ctr: 0x0000000100000000
header: bc010000000100000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000001000000
ctr: 0x000000ffffffffff
header: bc01000000ffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000001000000
ctr: 0x0000010000000000
header: bd01000000010000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000001000000
ctr: 0x0000ffffffffffff
header: bd01000000ffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000001000000
ctr: 0x0001000000000000
header: be0100000001000000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000001000000
ctr: 0x00ffffffffffffff
header: be01000000ffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000001000000
ctr: 0x0100000000000000
header: bf010000000100000000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000001000000
ctr: 0xffffffffffffffff
header: bf01000000ffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00000000ffffffff
ctr: 0x0000000000000000
header: b0ffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00000000ffffffff
ctr: 0x0000000000000001
header: b1ffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00000000ffffffff
ctr: 0x00000000000000ff
header: b8ffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00000000ffffffff
ctr: 0x0000000000000100
header: b9ffffffff0100
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00000000ffffffff
ctr: 0x000000000000ffff
header: b9ffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00000000ffffffff
ctr: 0x0000000000010000
header: baffffffff010000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00000000ffffffff
ctr: 0x0000000000ffffff
header: baffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00000000ffffffff
ctr: 0x0000000001000000
header: bbffffffff01000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00000000ffffffff
ctr: 0x00000000ffffffff
header: bbffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00000000ffffffff
ctr: 0x0000000100000000
header: bcffffffff0100000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00000000ffffffff
ctr: 0x000000ffffffffff
header: bcffffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00000000ffffffff
ctr: 0x0000010000000000
header: bdffffffff010000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00000000ffffffff
ctr: 0x0000ffffffffffff
header: bdffffffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00000000ffffffff
ctr: 0x0001000000000000
header: beffffffff01000000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00000000ffffffff
ctr: 0x00ffffffffffffff
header: beffffffffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00000000ffffffff
ctr: 0x0100000000000000
header: bfffffffff0100000000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00000000ffffffff
ctr: 0xffffffffffffffff
header: bfffffffffffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000100000000
ctr: 0x0000000000000000
header: c00100000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000100000000
ctr: 0x0000000000000001
header: c10100000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000100000000
ctr: 0x00000000000000ff
header: c80100000000ff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000100000000
ctr: 0x0000000000000100
header: c901000000000100
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000100000000
ctr: 0x000000000000ffff
header: c90100000000ffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000100000000
ctr: 0x0000000000010000
header: ca0100000000010000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000100000000
ctr: 0x0000000000ffffff
header: ca0100000000ffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000100000000
ctr: 0x0000000001000000
header: cb010000000001000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000100000000
ctr: 0x00000000ffffffff
header: cb0100000000ffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000100000000
ctr: 0x0000000100000000
header: cc01000000000100000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000100000000
ctr: 0x000000ffffffffff
header: cc0100000000ffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000100000000
ctr: 0x0000010000000000
header: cd0100000000010000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000100000000
ctr: 0x0000ffffffffffff
header: cd0100000000ffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000100000000
ctr: 0x0001000000000000
header: ce010000000001000000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000100000000
ctr: 0x00ffffffffffffff
header: ce0100000000ffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000100000000
ctr: 0x0100000000000000
header: cf01000000000100000000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000000100000000
ctr: 0xffffffffffffffff
header: cf0100000000ffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x000000ffffffffff
ctr: 0x0000000000000000
header: c0ffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x000000ffffffffff
ctr: 0x0000000000000001
header: c1ffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x000000ffffffffff
ctr: 0x00000000000000ff
header: c8ffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x000000ffffffffff
ctr: 0x0000000000000100
header: c9ffffffffff0100
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x000000ffffffffff
ctr: 0x000000000000ffff
header: c9ffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x000000ffffffffff
ctr: 0x0000000000010000
header: caffffffffff010000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x000000ffffffffff
ctr: 0x0000000000ffffff
header: caffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x000000ffffffffff
ctr: 0x0000000001000000
header: cbffffffffff01000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x000000ffffffffff
ctr: 0x00000000ffffffff
header: cbffffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x000000ffffffffff
ctr: 0x0000000100000000
header: ccffffffffff0100000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x000000ffffffffff
ctr: 0x000000ffffffffff
header: ccffffffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x000000ffffffffff
ctr: 0x0000010000000000
header: cdffffffffff010000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x000000ffffffffff
ctr: 0x0000ffffffffffff
header: cdffffffffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x000000ffffffffff
ctr: 0x0001000000000000
header: ceffffffffff01000000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x000000ffffffffff
ctr: 0x00ffffffffffffff
header: ceffffffffffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x000000ffffffffff
ctr: 0x0100000000000000
header: cfffffffffff0100000000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x000000ffffffffff
ctr: 0xffffffffffffffff
header: cfffffffffffffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000010000000000
ctr: 0x0000000000000000
header: d0010000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000010000000000
ctr: 0x0000000000000001
header: d1010000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000010000000000
ctr: 0x00000000000000ff
header: d8010000000000ff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000010000000000
ctr: 0x0000000000000100
header: d90100000000000100
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000010000000000
ctr: 0x000000000000ffff
header: d9010000000000ffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000010000000000
ctr: 0x0000000000010000
header: da010000000000010000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000010000000000
ctr: 0x0000000000ffffff
header: da010000000000ffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000010000000000
ctr: 0x0000000001000000
header: db01000000000001000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000010000000000
ctr: 0x00000000ffffffff
header: db010000000000ffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000010000000000
ctr: 0x0000000100000000
header: dc0100000000000100000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000010000000000
ctr: 0x000000ffffffffff
header: dc010000000000ffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000010000000000
ctr: 0x0000010000000000
header: dd010000000000010000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000010000000000
ctr: 0x0000ffffffffffff
header: dd010000000000ffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000010000000000
ctr: 0x0001000000000000
header: de01000000000001000000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000010000000000
ctr: 0x00ffffffffffffff
header: de010000000000ffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000010000000000
ctr: 0x0100000000000000
header: df0100000000000100000000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000010000000000
ctr: 0xffffffffffffffff
header: df010000000000ffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000ffffffffffff
ctr: 0x0000000000000000
header: d0ffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000ffffffffffff
ctr: 0x0000000000000001
header: d1ffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000ffffffffffff
ctr: 0x00000000000000ff
header: d8ffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000ffffffffffff
ctr: 0x0000000000000100
header: d9ffffffffffff0100
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000ffffffffffff
ctr: 0x000000000000ffff
header: d9ffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000ffffffffffff
ctr: 0x0000000000010000
header: daffffffffffff010000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000ffffffffffff
ctr: 0x0000000000ffffff
header: daffffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000ffffffffffff
ctr: 0x0000000001000000
header: dbffffffffffff01000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000ffffffffffff
ctr: 0x00000000ffffffff
header: dbffffffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000ffffffffffff
ctr: 0x0000000100000000
header: dcffffffffffff0100000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000ffffffffffff
ctr: 0x000000ffffffffff
header: dcffffffffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000ffffffffffff
ctr: 0x0000010000000000
header: ddffffffffffff010000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000ffffffffffff
ctr: 0x0000ffffffffffff
header: ddffffffffffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000ffffffffffff
ctr: 0x0001000000000000
header: deffffffffffff01000000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000ffffffffffff
ctr: 0x00ffffffffffffff
header: deffffffffffffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000ffffffffffff
ctr: 0x0100000000000000
header: dfffffffffffff0100000000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0000ffffffffffff
ctr: 0xffffffffffffffff
header: dfffffffffffffffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0001000000000000
ctr: 0x0000000000000000
header: e001000000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0001000000000000
ctr: 0x0000000000000001
header: e101000000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0001000000000000
ctr: 0x00000000000000ff
header: e801000000000000ff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0001000000000000
ctr: 0x0000000000000100
header: e9010000000000000100
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0001000000000000
ctr: 0x000000000000ffff
header: e901000000000000ffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0001000000000000
ctr: 0x0000000000010000
header: ea01000000000000010000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0001000000000000
ctr: 0x0000000000ffffff
header: ea01000000000000ffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0001000000000000
ctr: 0x0000000001000000
header: eb0100000000000001000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0001000000000000
ctr: 0x00000000ffffffff
header: eb01000000000000ffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0001000000000000
ctr: 0x0000000100000000
header: ec010000000000000100000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0001000000000000
ctr: 0x000000ffffffffff
header: ec01000000000000ffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0001000000000000
ctr: 0x0000010000000000
header: ed01000000000000010000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0001000000000000
ctr: 0x0000ffffffffffff
header: ed01000000000000ffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0001000000000000
ctr: 0x0001000000000000
header: ee0100000000000001000000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0001000000000000
ctr: 0x00ffffffffffffff
header: ee01000000000000ffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0001000000000000
ctr: 0x0100000000000000
header: ef010000000000000100000000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0001000000000000
ctr: 0xffffffffffffffff
header: ef01000000000000ffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00ffffffffffffff
ctr: 0x0000000000000000
header: e0ffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00ffffffffffffff
ctr: 0x0000000000000001
header: e1ffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00ffffffffffffff
ctr: 0x00000000000000ff
header: e8ffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00ffffffffffffff
ctr: 0x0000000000000100
header: e9ffffffffffffff0100
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00ffffffffffffff
ctr: 0x000000000000ffff
header: e9ffffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00ffffffffffffff
ctr: 0x0000000000010000
header: eaffffffffffffff010000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00ffffffffffffff
ctr: 0x0000000000ffffff
header: eaffffffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00ffffffffffffff
ctr: 0x0000000001000000
header: ebffffffffffffff01000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00ffffffffffffff
ctr: 0x00000000ffffffff
header: ebffffffffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00ffffffffffffff
ctr: 0x0000000100000000
header: ecffffffffffffff0100000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00ffffffffffffff
ctr: 0x000000ffffffffff
header: ecffffffffffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00ffffffffffffff
ctr: 0x0000010000000000
header: edffffffffffffff010000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00ffffffffffffff
ctr: 0x0000ffffffffffff
header: edffffffffffffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00ffffffffffffff
ctr: 0x0001000000000000
header: eeffffffffffffff01000000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00ffffffffffffff
ctr: 0x00ffffffffffffff
header: eeffffffffffffffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00ffffffffffffff
ctr: 0x0100000000000000
header: efffffffffffffff0100000000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x00ffffffffffffff
ctr: 0xffffffffffffffff
header: efffffffffffffffffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0100000000000000
ctr: 0x0000000000000000
header: f00100000000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0100000000000000
ctr: 0x0000000000000001
header: f10100000000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0100000000000000
ctr: 0x00000000000000ff
header: f80100000000000000ff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0100000000000000
ctr: 0x0000000000000100
header: f901000000000000000100
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0100000000000000
ctr: 0x000000000000ffff
header: f90100000000000000ffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0100000000000000
ctr: 0x0000000000010000
header: fa0100000000000000010000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0100000000000000
ctr: 0x0000000000ffffff
header: fa0100000000000000ffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0100000000000000
ctr: 0x0000000001000000
header: fb010000000000000001000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0100000000000000
ctr: 0x00000000ffffffff
header: fb0100000000000000ffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0100000000000000
ctr: 0x0000000100000000
header: fc01000000000000000100000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0100000000000000
ctr: 0x000000ffffffffff
header: fc0100000000000000ffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0100000000000000
ctr: 0x0000010000000000
header: fd0100000000000000010000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0100000000000000
ctr: 0x0000ffffffffffff
header: fd0100000000000000ffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0100000000000000
ctr: 0x0001000000000000
header: fe010000000000000001000000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0100000000000000
ctr: 0x00ffffffffffffff
header: fe0100000000000000ffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0100000000000000
ctr: 0x0100000000000000
header: ff010000000000000001000000000000
        00
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0x0100000000000000
ctr: 0xffffffffffffffff
header: ff0100000000000000ffffffffffffff
        ff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0xffffffffffffffff
ctr: 0x0000000000000000
header: f0ffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0xffffffffffffffff
ctr: 0x0000000000000001
header: f1ffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0xffffffffffffffff
ctr: 0x00000000000000ff
header: f8ffffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0xffffffffffffffff
ctr: 0x0000000000000100
header: f9ffffffffffffffff0100
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0xffffffffffffffff
ctr: 0x000000000000ffff
header: f9ffffffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0xffffffffffffffff
ctr: 0x0000000000010000
header: faffffffffffffffff010000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0xffffffffffffffff
ctr: 0x0000000000ffffff
header: faffffffffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0xffffffffffffffff
ctr: 0x0000000001000000
header: fbffffffffffffffff01000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0xffffffffffffffff
ctr: 0x00000000ffffffff
header: fbffffffffffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0xffffffffffffffff
ctr: 0x0000000100000000
header: fcffffffffffffffff0100000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0xffffffffffffffff
ctr: 0x000000ffffffffff
header: fcffffffffffffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0xffffffffffffffff
ctr: 0x0000010000000000
header: fdffffffffffffffff010000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0xffffffffffffffff
ctr: 0x0000ffffffffffff
header: fdffffffffffffffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0xffffffffffffffff
ctr: 0x0001000000000000
header: feffffffffffffffff01000000000000
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0xffffffffffffffff
ctr: 0x00ffffffffffffff
header: feffffffffffffffffffffffffffffff
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0xffffffffffffffff
ctr: 0x0100000000000000
header: ffffffffffffffffff01000000000000
        00
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
kid: 0xffffffffffffffff
ctr: 0xffffffffffffffff
header: ffffffffffffffffffffffffffffffff
        ff
]]></sourcecode>
      </section>
      <section anchor="aead-encryptiondecryption-using-aes-ctr-and-hmac">
        <name>AEAD Encryption/Decryption Using AES-CTR and HMAC</name>
        <t>For each case, we provide:</t>
        <ul spacing="normal">
          <li>
            <t><tt>cipher_suite</tt>: The index of the cipher suite in use (see
<xref target="sframe-cipher-suites"/>)</t>
          </li>
          <li>
            <t><tt>key</tt>: The <tt>key</tt> input to encryption/decryption</t>
          </li>
          <li>
            <t><tt>enc_key</tt>: The encryption subkey produced by the <tt>derive_subkeys()</tt> algorithm</t>
          </li>
          <li>
            <t><tt>auth_key</tt>: The encryption subkey produced by the <tt>derive_subkeys()</tt> algorithm</t>
          </li>
          <li>
            <t><tt>nonce</tt>: The <tt>nonce</tt> input to encryption/decryption</t>
          </li>
          <li>
            <t><tt>aad</tt>: The <tt>aad</tt> input to encryption/decryption</t>
          </li>
          <li>
            <t><tt>pt</tt>: The plaintext</t>
          </li>
          <li>
            <t><tt>ct</tt>: The ciphertext</t>
          </li>
        </ul>
        <t>An implementation should verify that the following are true, where
<tt>AEAD.Encrypt</tt> and <tt>AEAD.Decrypt</tt> are as defined in <xref target="aes-ctr-with-sha2"/>:</t>
        <ul spacing="normal">
          <li>
            <t><tt>AEAD.Encrypt(key, nonce, aad, pt) == ct</tt></t>
          </li>
          <li>
            <t><tt>AEAD.Decrypt(key, nonce, aad, ct) == pt</tt></t>
          </li>
        </ul>
        <t>The other values in the test vector are intermediate values provided to
facilitate debugging of test failures.</t>
        <sourcecode type="test-vectors"><![CDATA[
cipher_suite: 0x0001
key: 000102030405060708090a0b0c0d0e0f
     101112131415161718191a1b1c1d1e1f
     202122232425262728292a2b2c2d2e2f
enc_key: 000102030405060708090a0b0c0d0e0f
auth_key: 101112131415161718191a1b1c1d1e1f
          202122232425262728292a2b2c2d2e2f
nonce: 101112131415161718191a1b
aad: 4945544620534672616d65205747
pt: 64726166742d696574662d736672616d
    652d656e63
ct: 6339af04ada1d064688a442b8dc69d5b
    6bfa40f4bef0583e8081069cc60705
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
cipher_suite: 0x0002
key: 000102030405060708090a0b0c0d0e0f
     101112131415161718191a1b1c1d1e1f
     202122232425262728292a2b2c2d2e2f
enc_key: 000102030405060708090a0b0c0d0e0f
auth_key: 101112131415161718191a1b1c1d1e1f
          202122232425262728292a2b2c2d2e2f
nonce: 101112131415161718191a1b
aad: 4945544620534672616d65205747
pt: 64726166742d696574662d736672616d
    652d656e63
ct: 6339af04ada1d064688a442b8dc69d5b
    6bfa40f4be6e93b7da076927bb
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
cipher_suite: 0x0003
key: 000102030405060708090a0b0c0d0e0f
     101112131415161718191a1b1c1d1e1f
     202122232425262728292a2b2c2d2e2f
enc_key: 000102030405060708090a0b0c0d0e0f
auth_key: 101112131415161718191a1b1c1d1e1f
          202122232425262728292a2b2c2d2e2f
nonce: 101112131415161718191a1b
aad: 4945544620534672616d65205747
pt: 64726166742d696574662d736672616d
    652d656e63
ct: 6339af04ada1d064688a442b8dc69d5b
    6bfa40f4be09480509
]]></sourcecode>
      </section>
      <section anchor="sframe-encryptiondecryption">
        <name>SFrame Encryption/Decryption</name>
        <t>For each case, we provide:</t>
        <ul spacing="normal">
          <li>
            <t><tt>cipher_suite</tt>: The index of the cipher suite in use (see
<xref target="sframe-cipher-suites"/>)</t>
          </li>
          <li>
            <t><tt>kid</tt>: A KID value</t>
          </li>
          <li>
            <t><tt>ctr</tt>: A CTR value</t>
          </li>
          <li>
            <t><tt>base_key</tt>: The <tt>base_key</tt> input to the <tt>derive_key_salt</tt> algorithm</t>
          </li>
          <li>
            <t><tt>sframe_key_label</tt>: The label used to derive <tt>sframe_key</tt> in the <tt>derive_key_salt</tt> algorithm</t>
          </li>
          <li>
            <t><tt>sframe_salt_label</tt>: The label used to derive <tt>sframe_salt</tt> in the <tt>derive_key_salt</tt> algorithm</t>
          </li>
          <li>
            <t><tt>sframe_secret</tt>: The <tt>sframe_secret</tt> variable in the <tt>derive_key_salt</tt> algorithm</t>
          </li>
          <li>
            <t><tt>sframe_key</tt>: The <tt>sframe_key</tt> value produced by the <tt>derive_key_salt</tt> algorithm</t>
          </li>
          <li>
            <t><tt>sframe_salt</tt>: The <tt>sframe_salt</tt> value produced by the <tt>derive_key_salt</tt> algorithm</t>
          </li>
          <li>
            <t><tt>metadata</tt>: The <tt>metadata</tt> input to the SFrame <tt>encrypt</tt> algorithm</t>
          </li>
          <li>
            <t><tt>pt</tt>: The plaintext</t>
          </li>
          <li>
            <t><tt>ct</tt>: The SFrame ciphertext</t>
          </li>
        </ul>
        <t>An implementation should verify that the following are true, where
<tt>encrypt</tt> and <tt>decrypt</tt> are as defined in <xref target="encryption-schema"/>, using an SFrame
context initialized with <tt>base_key</tt> assigned to <tt>kid</tt>:</t>
        <ul spacing="normal">
          <li>
            <t><tt>encrypt(ctr, kid, metadata, plaintext) == ct</tt></t>
          </li>
          <li>
            <t><tt>decrypt(metadata, ct) == pt</tt></t>
          </li>
        </ul>
        <t>The other values in the test vector are intermediate values provided to
facilitate debugging of test failures.</t>
        <sourcecode type="test-vectors"><![CDATA[
cipher_suite: 0x0001
kid: 0x0000000000000123
ctr: 0x0000000000004567
base_key: 000102030405060708090a0b0c0d0e0f
sframe_key_label: 534672616d6520312e30205365637265
                  74206b65792000000000000001230001
sframe_salt_label: 534672616d6520312e30205365637265
                   742073616c7420000000000000012300
                   01
sframe_secret: d926952ca8b7ec4a95941d1ada3a5203
               ceff8cceee34f574d23909eb314c40c0
sframe_key: 3f7d9a7c83ae8e1c8a11ae695ab59314
            b367e359fadac7b9c46b2bc6f81f46e1
            6b96f0811868d59402b7e870102720b3
sframe_salt: 50b29329a04dc0f184ac3168
metadata: 4945544620534672616d65205747
nonce: 50b29329a04dc0f184ac740f
aad: 99012345674945544620534672616d65
     205747
pt: 64726166742d696574662d736672616d
    652d656e63
ct: 9901234567449408b6f490086165b9d6
    f62b24ae1a59a56486b4ae8ed036b889
    12e24f11
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
cipher_suite: 0x0002
kid: 0x0000000000000123
ctr: 0x0000000000004567
base_key: 000102030405060708090a0b0c0d0e0f
sframe_key_label: 534672616d6520312e30205365637265
                  74206b65792000000000000001230002
sframe_salt_label: 534672616d6520312e30205365637265
                   742073616c7420000000000000012300
                   02
sframe_secret: d926952ca8b7ec4a95941d1ada3a5203
               ceff8cceee34f574d23909eb314c40c0
sframe_key: e2ec5c797540310483b16bf6e7a570d2
            a27d192fe869c7ccd8584a8d9dab9154
            9fbe553f5113461ec6aa83bf3865553e
sframe_salt: e68ac8dd3d02fbcd368c5577
metadata: 4945544620534672616d65205747
nonce: e68ac8dd3d02fbcd368c1010
aad: 99012345674945544620534672616d65
     205747
pt: 64726166742d696574662d736672616d
    652d656e63
ct: 99012345673f31438db4d09434e43afa
    0f8a2f00867a2be085046a9f5cb4f101
    d607
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
cipher_suite: 0x0003
kid: 0x0000000000000123
ctr: 0x0000000000004567
base_key: 000102030405060708090a0b0c0d0e0f
sframe_key_label: 534672616d6520312e30205365637265
                  74206b65792000000000000001230003
sframe_salt_label: 534672616d6520312e30205365637265
                   742073616c7420000000000000012300
                   03
sframe_secret: d926952ca8b7ec4a95941d1ada3a5203
               ceff8cceee34f574d23909eb314c40c0
sframe_key: 2c5703089cbb8c583475e4fc461d97d1
            8809df79b6d550f78eb6d50ffa80d892
            11d57909934f46f5405e38cd583c69fe
sframe_salt: 38c16e4f5159700c00c7f350
metadata: 4945544620534672616d65205747
nonce: 38c16e4f5159700c00c7b637
aad: 99012345674945544620534672616d65
     205747
pt: 64726166742d696574662d736672616d
    652d656e63
ct: 990123456717fc8af28a5a695afcfc6c
    8df6358a17e26b2fcb3bae32e443
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
cipher_suite: 0x0004
kid: 0x0000000000000123
ctr: 0x0000000000004567
base_key: 000102030405060708090a0b0c0d0e0f
sframe_key_label: 534672616d6520312e30205365637265
                  74206b65792000000000000001230004
sframe_salt_label: 534672616d6520312e30205365637265
                   742073616c7420000000000000012300
                   04
sframe_secret: d926952ca8b7ec4a95941d1ada3a5203
               ceff8cceee34f574d23909eb314c40c0
sframe_key: d34f547f4ca4f9a7447006fe7fcbf768
sframe_salt: 75234edefe07819026751816
metadata: 4945544620534672616d65205747
nonce: 75234edefe07819026755d71
aad: 99012345674945544620534672616d65
     205747
pt: 64726166742d696574662d736672616d
    652d656e63
ct: 9901234567b7412c2513a1b66dbb4884
    1bbaf17f598751176ad847681a69c6d0
    b091c07018ce4adb34eb
]]></sourcecode>
        <sourcecode type="test-vectors"><![CDATA[
cipher_suite: 0x0005
kid: 0x0000000000000123
ctr: 0x0000000000004567
base_key: 000102030405060708090a0b0c0d0e0f
sframe_key_label: 534672616d6520312e30205365637265
                  74206b65792000000000000001230005
sframe_salt_label: 534672616d6520312e30205365637265
                   742073616c7420000000000000012300
                   05
sframe_secret: 0fc3ea6de6aac97a35f194cf9bed94d4
               b5230f1cb45a785c9fe5dce9c188938a
               b6ba005bc4c0a19181599e9d1bcf7b74
               aca48b60bf5e254e546d809313e083a3
sframe_key: d3e27b0d4a5ae9e55df01a70e6d4d28d
            969b246e2936f4b7a5d9b494da6b9633
sframe_salt: 84991c167b8cd23c93708ec7
metadata: 4945544620534672616d65205747
nonce: 84991c167b8cd23c9370cba0
aad: 99012345674945544620534672616d65
     205747
pt: 64726166742d696574662d736672616d
    652d656e63
ct: 990123456794f509d36e9beacb0e261d
    99c7d1e972f1fed787d4049f17ca2135
    3c1cc24d56ceabced279
]]></sourcecode>
      </section>
    </section>
    <section numbered="false" anchor="acknowledgements">
      <name>Acknowledgements</name>
      <t>The authors wish to specially thank <contact fullname="Dr. Alex Gouaillard"/> as one of the early
contributors to the document. His passion and energy were key to the design and
development of SFrame.</t>
    </section>
    <section anchor="contributors" numbered="false" toc="include" removeInRFC="false">
      <name>Contributors</name>
      <contact initials="F." surname="Jacobs" fullname="Frdric Jacobs">
        <organization>Apple</organization>
        <address>
          <email>frederic.jacobs@apple.com</email>
        </address>
      </contact>
      <contact initials="M." surname="Mularczyk" fullname="Marta Mularczyk">
        <organization>Amazon</organization>
        <address>
          <email>mulmarta@amazon.com</email>
        </address>
      </contact>
      <contact initials="S." surname="Nandakumar" fullname="Suhas Nandakumar">
        <organization>Cisco</organization>
        <address>
          <email>snandaku@cisco.com</email>
        </address>
      </contact>
      <contact initials="T." surname="Rigaux" fullname="Tomas Rigaux">
        <organization>Cisco</organization>
        <address>
          <email>trigaux@cisco.com</email>
        </address>
      </contact>
      <contact initials="R." surname="Robert" fullname="Raphael Robert">
        <organization>Phoenix R&amp;D</organization>
        <address>
          <email>ietf@raphaelrobert.com</email>
        </address>
      </contact>
    </section>
  </back>
</rfc>
