<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE rfc [
 <!ENTITY nbsp    "&#160;">
 <!ENTITY zwsp   "&#8203;">
 <!ENTITY nbhy   "&#8209;">
 <!ENTITY wj     "&#8288;">
]>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" ipr="trust200902" docName="draft-ietf-quic-http-34" number="9114" obsoletes="" updates="" submissionType="IETF" category="std" consensus="true" xml:lang="en" tocInclude="true"
sortRefs="true" symRefs="true" version="3">
  <link href='https://datatracker.ietf.org/doc/draft-ietf-quic-http-latest' rel='prev'/>
  <front>
    <title>HTTP/3</title>
    <seriesInfo name='RFC' value='9114'/>
    <author fullname='Mike Bishop' initials='M.' role='editor' surname='Bishop'>
      <organization>Akamai</organization>
      <address>
        <email>mbishop@evequefou.be</email>
      </address>
    </author>
    <date month='June' year='2022'/>
    <area>Transport</area>
    <workgroup>QUIC</workgroup>
    <keyword>HTTP/2</keyword>
    <keyword>HPACK</keyword>
    <keyword>QPACK</keyword>
    <keyword>Web</keyword>
    <abstract>
      <t>The QUIC transport protocol has several features that are desirable in a
transport for HTTP, such as stream multiplexing, per-stream flow control, and
low-latency connection establishment.  This document describes a mapping of HTTP
semantics over QUIC.  This document also identifies HTTP/2 features that are
subsumed by QUIC and describes how HTTP/2 extensions can be ported to HTTP/3.</t>
    </abstract>
  </front>
  <middle>
    <section anchor='introduction'>
      <name>Introduction</name>
      <t>HTTP semantics (<xref target='RFC9110'/>) are used for a broad range of services on the
Internet. These semantics have most commonly been used with HTTP/1.1 and HTTP/2.
HTTP/1.1 has been used over a variety of transport and session layers, while
HTTP/2 has been used primarily with TLS over TCP. HTTP/3 supports the same
semantics over a new transport protocol: QUIC.</t>
      <section anchor='prior-versions-of-http'>
        <name>Prior Versions of HTTP</name>
        <t>HTTP/1.1 (<xref target='RFC9112'/>) uses whitespace-delimited text fields to convey HTTP
messages.  While these exchanges are human readable, using whitespace for
message formatting leads to parsing complexity and excessive tolerance of
variant behavior.</t>
        <t>Because HTTP/1.1 does not include a multiplexing layer, multiple TCP connections
are often used to service requests in parallel. However, that has a negative
impact on congestion control and network efficiency, since TCP does not share
congestion control across multiple connections.</t>
        <t>HTTP/2 (<xref target='RFC9113'/>) introduced a binary framing and multiplexing layer
to improve latency without modifying the transport layer.  However, because the
parallel nature of HTTP/2's multiplexing is not visible to TCP's loss recovery
mechanisms, a lost or reordered packet causes all active transactions to
experience a stall regardless of whether that transaction was directly impacted
by the lost packet.</t>
      </section>
      <section anchor='delegation-to-quic'>
        <name>Delegation to QUIC</name>
        <t>The QUIC transport protocol incorporates stream multiplexing and per-stream flow
control, similar to that provided by the HTTP/2 framing layer. By providing
reliability at the stream level and congestion control across the entire
connection, QUIC has the capability to improve the performance of HTTP compared
to a TCP mapping.  QUIC also incorporates TLS 1.3 (<xref target='TLS'/>) at the
transport layer, offering comparable confidentiality and integrity to running
TLS over TCP, with the improved connection setup latency of TCP Fast Open
(<xref target='TFO'/>).</t>
        <t>This document defines HTTP/3: a mapping of HTTP semantics over the QUIC
transport protocol, drawing heavily on the design of HTTP/2.  HTTP/3 relies on
QUIC to provide confidentiality and integrity protection of data; peer
authentication; and reliable, in-order, per-stream delivery. While delegating
stream lifetime and flow-control issues to QUIC, a binary framing similar to the
HTTP/2 framing is used on each stream. Some HTTP/2 features are subsumed by
QUIC, while other features are implemented atop QUIC.</t>
        <t>QUIC is described in <xref target='QUIC-TRANSPORT'/>.  For a full description of
HTTP/2, see <xref target='RFC9113'/>.</t>
      </section>
    </section>
    <section anchor='http3-protocol-overview'>
      <name>HTTP/3 Protocol Overview</name>
      <t>HTTP/3 provides a transport for HTTP semantics using the QUIC transport protocol
and an internal framing layer similar to HTTP/2.</t>
      <t>Once a client knows that an HTTP/3 server exists at a certain endpoint, it opens
a QUIC connection. QUIC provides protocol negotiation, stream-based
multiplexing, and flow control.  Discovery of an HTTP/3 endpoint is described in
<xref target='discovery'/>.</t>
      <t>Within each stream, the basic unit of HTTP/3 communication is a frame
(<xref target='frames'/>).  Each frame type serves a different purpose.  For example, <xref format='none' target='frame-headers'>HEADERS</xref><iref item='HEADERS'/>
and <xref format='none' target='frame-data'>DATA</xref><iref item='DATA'/> frames form the basis of HTTP requests and responses
(<xref target='request-response'/>).  Frames that apply to the entire connection are
conveyed on a dedicated <xref format='none' target='control-streams'>control stream</xref><iref item='control stream'/>.</t>
      <t>Multiplexing of requests is performed using the QUIC stream abstraction, which
is described in <xref section='2' sectionFormat='of' target='QUIC-TRANSPORT'/>.  Each request-response pair
consumes a single QUIC stream.  Streams are independent of each other, so one
stream that is blocked or suffers packet loss does not prevent progress on other
streams.</t>
      <t>Server push is an interaction mode introduced in HTTP/2 (<xref target='RFC9113'/>) that
permits a server to push a request-response exchange to a client in anticipation
of the client making the indicated request.  This trades off network usage
against a potential latency gain.  Several HTTP/3 frames are used to manage
server push, such as <xref format='none' target='frame-push-promise'>PUSH_PROMISE</xref><iref item='PUSH_PROMISE'/>, <xref format='none' target='frame-max-push-id'>MAX_PUSH_ID</xref><iref item='MAX_PUSH_ID'/>, and <xref format='none' target='frame-cancel-push'>CANCEL_PUSH</xref><iref item='CANCEL_PUSH'/>.</t>
      <t>As in HTTP/2, request and response fields are compressed for transmission.
Because HPACK (<xref target='HPACK'/>) relies on in-order transmission of
compressed field sections (a guarantee not provided by QUIC), HTTP/3 replaces
HPACK with QPACK (<xref target='RFC9204'/>). QPACK uses separate unidirectional streams to
modify and track field table state, while encoded field sections refer to the
state of the table without modifying it.</t>
      <section anchor='document-organization'>
        <name>Document Organization</name>
        <t>The following sections provide a detailed overview of the lifecycle of an HTTP/3
connection:</t>
        <ul spacing='normal'>
          <li>"<xref format='title' target='connection-setup'/>" (<xref target='connection-setup'/>) covers how an HTTP/3
endpoint is discovered and an HTTP/3 connection is established.</li>
          <li>"<xref format='title' target='http-request-lifecycle'/>" (<xref target='http-request-lifecycle'/>) describes how HTTP
semantics are expressed using frames.</li>
          <li>"<xref format='title' target='connection-closure'/>" (<xref target='connection-closure'/>) describes how HTTP/3
connections are terminated, either gracefully or abruptly.</li>
        </ul>
        <t>The details of the wire protocol and interactions with the transport are
described in subsequent sections:</t>
        <ul spacing='normal'>
          <li>"<xref format='title' target='stream-mapping'/>" (<xref target='stream-mapping'/>) describes the way QUIC streams
are used.</li>
          <li>"<xref format='title' target='http-framing-layer'/>" (<xref target='http-framing-layer'/>) describes the frames used
on most streams.</li>
          <li>"<xref format='title' target='errors'/>" (<xref target='errors'/>) describes how error conditions are handled and
expressed, either on a particular stream or for the connection as a whole.</li>
        </ul>
        <t>Additional resources are provided in the final sections:</t>
        <ul spacing='normal'>
          <li>"<xref format='title' target='extensions'/>" (<xref target='extensions'/>) describes how new capabilities can be
added in future documents.</li>
          <li>A more detailed comparison between HTTP/2 and HTTP/3 can be found in
<xref target='h2-considerations'/>.</li>
        </ul>
      </section>
      <section anchor='conventions-and-terminology'>
        <name>Conventions and Terminology</name>
        <t>The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL
NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
"<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as
described in BCP&nbsp;14 <xref target="RFC2119" format="default"/> <xref target="RFC8174" format="default"/> when, and only when, they
appear in all capitals, as shown here.</t>
        <t>This document uses the variable-length integer encoding from
<xref target='QUIC-TRANSPORT'/>.</t>
        <t>The following terms are used:</t>
        <dl>
          <dt>abort:</dt>
          <dd>
            <t>An abrupt termination of a connection or stream, possibly due to an error
condition.</t>
          </dd>
          <dt>client:</dt>
          <dd>
            <t>The endpoint that initiates an HTTP/3 connection.  Clients send HTTP requests
and receive HTTP responses.</t>
          </dd>
          <dt>connection:</dt>
          <dd>
            <t>A transport-layer connection between two endpoints using QUIC as the
transport protocol.</t>
          </dd>
          <dt><xref format='none' target='errors'>connection error</xref><iref item='connection error'/>:</dt>
          <dd>
            <t>An error that affects the entire HTTP/3 connection.</t>
          </dd>
          <dt>endpoint:</dt>
          <dd>
            <t>Either the client or server of the connection.</t>
          </dd>
          <dt>frame:</dt>
          <dd>
            <t>The smallest unit of communication on a stream in HTTP/3, consisting of a
header and a variable-length sequence of bytes structured according to the
frame type.</t>
            <t>Protocol elements called "frames" exist in both this document and
<xref target='QUIC-TRANSPORT'/>. Where frames from <xref target='QUIC-TRANSPORT'/> are referenced, the
frame name will be prefaced with "QUIC".  For example, "QUIC CONNECTION_CLOSE
frames".  References without this preface refer to frames defined in
<xref target='frames'/>.</t>
          </dd>
          <dt>HTTP/3 connection:</dt>
          <dd>
            <t>A QUIC connection where the negotiated application protocol is HTTP/3.</t>
          </dd>
          <dt>peer:</dt>
          <dd>
            <t>An endpoint.  When discussing a particular endpoint, "peer" refers to the
endpoint that is remote to the primary subject of discussion.</t>
          </dd>
          <dt>receiver:</dt>
          <dd>
            <t>An endpoint that is receiving frames.</t>
          </dd>
          <dt>sender:</dt>
          <dd>
            <t>An endpoint that is transmitting frames.</t>
          </dd>
          <dt>server:</dt>
          <dd>
            <t>The endpoint that accepts an HTTP/3 connection.  Servers receive HTTP requests
and send HTTP responses.</t>
          </dd>
          <dt>stream:</dt>
          <dd>
            <t>A bidirectional or unidirectional bytestream provided by the QUIC transport.
All streams within an HTTP/3 connection can be considered "HTTP/3 streams",
but multiple stream types are defined within HTTP/3.</t>
          </dd>
          <dt><xref format='none' target='errors'>stream error</xref><iref item='stream error'/>:</dt>
          <dd>
            <t>An application-level error on the individual stream.</t>
          </dd>
        </dl>
        <t>The term "content" is defined in <xref section='6.4' sectionFormat='of' target='RFC9110'/>.</t>
        <t>Finally, the terms "resource", "message", "user agent", "origin server",
"gateway", "intermediary", "proxy", and "tunnel" are defined in <xref section='3' sectionFormat='of' target='RFC9110'/>.</t>
        <t>Packet diagrams in this document use the format defined in
<xref section='1.3' sectionFormat='of' target='QUIC-TRANSPORT'/> to illustrate the order and size of fields.</t>
      </section>
    </section>
    <section anchor='connection-setup'>
      <name>Connection Setup and Management</name>
      <section anchor='discovery'>
        <name>Discovering an HTTP/3 Endpoint</name>
        <t>HTTP relies on the notion of an authoritative response: a response that has been
determined to be the most appropriate response for that request given the state
of the target resource at the time of response message origination by (or at the
direction of) the origin server identified within the target URI.  Locating an
authoritative server for an HTTP URI is discussed in <xref section='4.3' sectionFormat='of' target='RFC9110'/>.</t>
        <t>The "https" scheme associates authority with possession of a certificate that
the client considers to be trustworthy for the host identified by the authority
component of the URI.  Upon receiving a server certificate in the TLS handshake,
the client          <bcp14>MUST</bcp14>
 verify that the certificate is an acceptable match for the URI's
origin server using the process described in <xref section='4.3.4' sectionFormat='of' target='RFC9110'/>. If
the certificate cannot be verified with respect to the URI's origin server, the
client          <bcp14>MUST NOT</bcp14>
 consider the server authoritative for that origin.</t>
        <t>A client          <bcp14>MAY</bcp14>
 attempt access to a resource with an "https" URI by resolving the
host identifier to an IP address, establishing a QUIC connection to that address
on the indicated port (including validation of the server certificate as
described above), and sending an HTTP/3 request message targeting the URI
to the server over that secured connection.  Unless some other mechanism is used
to select HTTP/3, the token "h3" is used in the Application-Layer Protocol
Negotiation (ALPN; see <xref target='RFC7301'/>) extension during the TLS handshake.</t>
        <t>Connectivity problems (e.g., blocking UDP) can result in a failure to establish
a QUIC connection; clients          <bcp14>SHOULD</bcp14>
 attempt to use TCP-based versions of HTTP
in this case.</t>
        <t>Servers          <bcp14>MAY</bcp14>
 serve HTTP/3 on any UDP port; an alternative service advertisement
always includes an explicit port, and URIs contain either an explicit port or a
default port associated with the scheme.</t>
        <section anchor='alt-svc'>
          <name>HTTP Alternative Services</name>
          <t>An HTTP origin can advertise the availability of an equivalent HTTP/3 endpoint
via the Alt-Svc HTTP response header field or the HTTP/2 ALTSVC frame
(<xref target='ALTSVC'/>) using the "h3" ALPN token.</t>
          <t>For example, an origin could indicate in an HTTP response that HTTP/3 was
available on UDP port 50781 at the same hostname by including the following
header field:</t>
          <sourcecode type='http-message'><![CDATA[
Alt-Svc: h3=":50781"
]]></sourcecode>
          <t>On receipt of an Alt-Svc record indicating HTTP/3 support, a client            <bcp14>MAY</bcp14>
 attempt
to establish a QUIC connection to the indicated host and port; if this
connection is successful, the client can send HTTP requests using the mapping
described in this document.</t>
        </section>
        <section anchor='other-schemes'>
          <name>Other Schemes</name>
          <t>Although HTTP is independent of the transport protocol, the "http" scheme
associates authority with the ability to receive TCP connections on the
indicated port of whatever host is identified within the authority component.
Because HTTP/3 does not use TCP, HTTP/3 cannot be used for direct access to the
authoritative server for a resource identified by an "http" URI.  However,
protocol extensions such as <xref target='ALTSVC'/> permit the authoritative server
to identify other services that are also authoritative and that might be
reachable over HTTP/3.</t>
          <t>Prior to making requests for an origin whose scheme is not "https", the client            <bcp14>MUST</bcp14>
 ensure the server is willing to serve that scheme. For origins whose scheme
is "http", an experimental method to accomplish this is described in
<xref target='RFC8164'/>. Other mechanisms might be defined for various schemes in the
future.</t>
        </section>
      </section>
      <section anchor='connection-establishment'>
        <name>Connection Establishment</name>
        <t>HTTP/3 relies on QUIC version 1 as the underlying transport.  The use of other
QUIC transport versions with HTTP/3          <bcp14>MAY</bcp14>
 be defined by future specifications.</t>
        <t>QUIC version 1 uses TLS version 1.3 or greater as its handshake protocol.
HTTP/3 clients          <bcp14>MUST</bcp14>
 support a mechanism to indicate the target host to the
server during the TLS handshake.  If the server is identified by a domain name
(<xref target='DNS-TERMS'/>), clients          <bcp14>MUST</bcp14>
 send the Server Name Indication (SNI;
<xref target='RFC6066'/>) TLS extension unless an alternative mechanism to indicate the
target host is used.</t>
        <t>QUIC connections are established as described in <xref target='QUIC-TRANSPORT'/>. During
connection establishment, HTTP/3 support is indicated by selecting the ALPN
token "h3" in the TLS handshake.  Support for other application-layer protocols          <bcp14>MAY</bcp14>
 be offered in the same handshake.</t>
        <t>While connection-level options pertaining to the core QUIC protocol are set in
the initial crypto handshake, settings specific to HTTP/3 are conveyed in the
<xref format='none' target='frame-settings'>SETTINGS</xref><iref item='SETTINGS'/> frame. After the QUIC connection is established, a
<xref format='none' target='frame-settings'>SETTINGS</xref><iref item='SETTINGS'/> frame          <bcp14>MUST</bcp14>
 be sent by each endpoint as the initial frame of their
respective HTTP <xref format='none' target='control-streams'>control stream</xref><iref item='control stream'/>.</t>
      </section>
      <section anchor='connection-reuse'>
        <name>Connection Reuse</name>
        <t>HTTP/3 connections are persistent across multiple requests.  For best
performance, it is expected that clients will not close connections until it is
determined that no further communication with a server is necessary (for
example, when a user navigates away from a particular web page) or until the
server closes the connection.</t>
        <t>Once a connection to a server endpoint exists, this connection          <bcp14>MAY</bcp14>
 be reused for
requests with multiple different URI authority components.  To use an existing
connection for a new origin, clients          <bcp14>MUST</bcp14>
 validate the certificate presented by
the server for the new origin server using the process described in <xref section='4.3.4' sectionFormat='of' target='RFC9110'/>.  This implies that clients will need to retain the
server certificate and any additional information needed to verify that
certificate; clients that do not do so will be unable to reuse the connection
for additional origins.</t>
        <t>If the certificate is not acceptable with regard to the new origin for any
reason, the connection          <bcp14>MUST NOT</bcp14>
 be reused and a new connection          <bcp14>SHOULD</bcp14>
 be
established for the new origin.  If the reason the certificate cannot be
verified might apply to other origins already associated with the connection,
the client          <bcp14>SHOULD</bcp14>
 revalidate the server certificate for those origins. For
instance, if validation of a certificate fails because the certificate has
expired or been revoked, this might be used to invalidate all other origins for
which that certificate was used to establish authority.</t>
        <t>Clients          <bcp14>SHOULD NOT</bcp14>
 open more than one HTTP/3 connection to a given IP address
and UDP port, where the IP address and port might be derived from a URI, a
selected alternative service (<xref target='ALTSVC'/>), a configured proxy, or name
resolution of any of these. A client          <bcp14>MAY</bcp14>
 open multiple HTTP/3 connections to the
same IP address and UDP port using different transport or TLS configurations but          <bcp14>SHOULD</bcp14>
 avoid creating multiple connections with the same configuration.</t>
        <t>Servers are encouraged to maintain open HTTP/3 connections for as long as
possible but are permitted to terminate idle connections if necessary.  When
either endpoint chooses to close the HTTP/3 connection, the terminating endpoint          <bcp14>SHOULD</bcp14>
 first send a <xref format='none' target='frame-goaway'>GOAWAY</xref><iref item='GOAWAY'/> frame (<xref target='connection-shutdown'/>) so that both
endpoints can reliably determine whether previously sent frames have been
processed and gracefully complete or terminate any necessary remaining tasks.</t>
        <t>A server that does not wish clients to reuse HTTP/3 connections for a particular
origin can indicate that it is not authoritative for a request by sending a 421
(Misdirected Request) status code in response to the request; see <xref section='7.4' sectionFormat='of' target='RFC9110'/>.</t>
      </section>
    </section>
    <section anchor='http-request-lifecycle'>
      <name>Expressing HTTP Semantics in HTTP/3</name>
      <section anchor='request-response'>
        <name>HTTP Message Framing</name>
        <t>A client sends an HTTP request on a <xref format='none' target='request-streams'>request stream</xref><iref item='request stream'/>, which is a client-initiated
bidirectional QUIC stream; see <xref target='request-streams'/>.  A client          <bcp14>MUST</bcp14>
 send only a
single request on a given stream.  A server sends zero or more interim HTTP
responses on the same stream as the request, followed by a single final HTTP
response, as detailed below. See <xref section='15' sectionFormat='of' target='RFC9110'/> for a description
of interim and final HTTP responses.</t>
        <t>Pushed responses are sent on a server-initiated unidirectional QUIC stream; see
<xref target='push-streams'/>.  A server sends zero or more interim HTTP responses, followed
by a single final HTTP response, in the same manner as a standard response.
Push is described in more detail in <xref target='server-push'/>.</t>
        <t>On a given stream, receipt of multiple requests or receipt of an additional HTTP
response following a final HTTP response          <bcp14>MUST</bcp14>
 be treated as <xref format='none' target='malformed'>malformed</xref><iref item='malformed'/>.</t>
        <t>An HTTP message (request or response) consists of:</t>
        <ol spacing='normal' type='1'>
          <li>the header section, including message control data, sent as a single <xref format='none' target='frame-headers'>HEADERS</xref><iref item='HEADERS'/>
frame,</li>
          <li>optionally, the content, if present, sent as a series of <xref format='none' target='frame-data'>DATA</xref><iref item='DATA'/> frames, and</li>
          <li>optionally, the trailer section, if present, sent as a single <xref format='none' target='frame-headers'>HEADERS</xref><iref item='HEADERS'/> frame.</li>
        </ol>
        <t>Header and trailer sections are described in Sections <xref section='6.3' sectionFormat='bare' target='RFC9110'/> and <xref section='6.5' sectionFormat='bare' target='RFC9110'/> of <xref target='RFC9110'/>; the content is described in <xref section='6.4' sectionFormat='of' target='RFC9110'/>.</t>
        <t>Receipt of an invalid sequence of frames          <bcp14>MUST</bcp14>
 be treated as a <xref format='none' target='errors'>connection error</xref><iref item='connection error'/>
of type <xref format='none' target='H3_FRAME_UNEXPECTED'>H3_FRAME_UNEXPECTED</xref><iref item='H3_FRAME_UNEXPECTED'/>.  In particular, a <xref format='none' target='frame-data'>DATA</xref><iref item='DATA'/> frame before
any <xref format='none' target='frame-headers'>HEADERS</xref><iref item='HEADERS'/> frame, or a <xref format='none' target='frame-headers'>HEADERS</xref><iref item='HEADERS'/> or <xref format='none' target='frame-data'>DATA</xref><iref item='DATA'/> frame after the trailing <xref format='none' target='frame-headers'>HEADERS</xref><iref item='HEADERS'/> frame,
is considered invalid.  Other frame types, especially unknown frame types,
might be permitted subject to their own rules; see <xref target='extensions'/>.</t>
        <t>A server          <bcp14>MAY</bcp14>
 send one or more <xref format='none' target='frame-push-promise'>PUSH_PROMISE</xref><iref item='PUSH_PROMISE'/> frames
before, after, or interleaved with the frames of a response message. These
<xref format='none' target='frame-push-promise'>PUSH_PROMISE</xref><iref item='PUSH_PROMISE'/> frames are not part of the response; see <xref target='server-push'/> for more
details.  <xref format='none' target='frame-push-promise'>PUSH_PROMISE</xref><iref item='PUSH_PROMISE'/> frames are not permitted on <xref format='none' target='push-streams'>push streams</xref><iref item='push stream'/>; a pushed
response that includes <xref format='none' target='frame-push-promise'>PUSH_PROMISE</xref><iref item='PUSH_PROMISE'/> frames          <bcp14>MUST</bcp14>
 be treated as a <xref format='none' target='errors'>connection error</xref><iref item='connection error'/>
of type <xref format='none' target='H3_FRAME_UNEXPECTED'>H3_FRAME_UNEXPECTED</xref><iref item='H3_FRAME_UNEXPECTED'/>.</t>
        <t>Frames of unknown types (<xref target='extensions'/>), including reserved frames
(<xref target='frame-reserved'/>)          <bcp14>MAY</bcp14>
 be sent on a request or <xref format='none' target='push-streams'>push stream</xref><iref item='push stream'/> before, after, or
interleaved with other frames described in this section.</t>
        <t>The <xref format='none' target='frame-headers'>HEADERS</xref><iref item='HEADERS'/> and <xref format='none' target='frame-push-promise'>PUSH_PROMISE</xref><iref item='PUSH_PROMISE'/> frames might reference updates to the QPACK dynamic
table. While these updates are not directly part of the message exchange, they
must be received and processed before the message can be consumed.  See
<xref target='header-formatting'/> for more details.</t>
        <t>Transfer codings (see <xref section='7' sectionFormat='of' target='RFC9112'/>) are not defined for HTTP/3;
the Transfer-Encoding header field          <bcp14>MUST NOT</bcp14>
 be used.</t>
        <t>A response          <bcp14>MAY</bcp14>
 consist of multiple messages when and only when one or more
interim responses (1xx; see <xref section='15.2' sectionFormat='of' target='RFC9110'/>) precede a final
response to the same request.  Interim responses do not contain content
or trailer sections.</t>
        <t>An HTTP request/response exchange fully consumes a client-initiated
bidirectional QUIC stream. After sending a request, a client          <bcp14>MUST</bcp14>
 close the
stream for sending.  Unless using the CONNECT method (see <xref target='connect'/>), clients          <bcp14>MUST NOT</bcp14>
 make stream closure dependent on receiving a response to their request.
After sending a final response, the server          <bcp14>MUST</bcp14>
 close the stream for sending. At
this point, the QUIC stream is fully closed.</t>
        <t>When a stream is closed, this indicates the end of the final HTTP message.
Because some messages are large or unbounded, endpoints          <bcp14>SHOULD</bcp14>
 begin processing
partial HTTP messages once enough of the message has been received to make
progress.  If a client-initiated stream terminates without enough of the HTTP
message to provide a complete response, the server          <bcp14>SHOULD</bcp14>
 abort its response
stream with the error code <xref format='none' target='H3_REQUEST_INCOMPLETE'>H3_REQUEST_INCOMPLETE</xref><iref item='H3_REQUEST_INCOMPLETE'/>.</t>
        <t>A server can send a complete response prior to the client sending an entire
request if the response does not depend on any portion of the request that has
not been sent and received. When the server does not need to receive the
remainder of the request, it          <bcp14>MAY</bcp14>
 abort reading the <xref format='none' target='request-streams'>request stream</xref><iref item='request stream'/>, send a
complete response, and cleanly close the sending part of the stream.  The error
code <xref format='none' target='H3_NO_ERROR'>H3_NO_ERROR</xref><iref item='H3_NO_ERROR'/>          <bcp14>SHOULD</bcp14>
 be used when requesting that the client stop sending on
the <xref format='none' target='request-streams'>request stream</xref><iref item='request stream'/>.  Clients          <bcp14>MUST NOT</bcp14>
 discard complete responses as a result of
having their request terminated abruptly, though clients can always discard
responses at their discretion for other reasons.  If the server sends a partial
or complete response but does not abort reading the request, clients          <bcp14>SHOULD</bcp14>

continue sending the content of the request and close the stream normally.</t>
        <section anchor='request-cancellation'>
          <name>Request Cancellation and Rejection</name>
          <t>Once a <xref format='none' target='request-streams'>request stream</xref><iref item='request stream'/> has been opened, the request            <bcp14>MAY</bcp14>
 be cancelled by either
endpoint.  Clients cancel requests if the response is no longer of interest;
servers cancel requests if they are unable to or choose not to respond.  When
possible, it is            <bcp14>RECOMMENDED</bcp14>
 that servers send an HTTP response with an
appropriate status code rather than cancelling a request it has already begun
processing.</t>
          <t>Implementations            <bcp14>SHOULD</bcp14>
 cancel requests by abruptly terminating any directions of
a stream that are still open.  To do so, an implementation resets the sending
parts of streams and aborts reading on the receiving parts of streams; see
<xref section='2.4' sectionFormat='of' target='QUIC-TRANSPORT'/>.</t>
          <t>When the server cancels a request without performing any application processing,
the request is considered "rejected".  The server            <bcp14>SHOULD</bcp14>
 abort its response
stream with the error code <xref format='none' target='H3_REQUEST_REJECTED'>H3_REQUEST_REJECTED</xref><iref item='H3_REQUEST_REJECTED'/>. In this context, "processed"
means that some data from the stream was passed to some higher layer of software
that might have taken some action as a result. The client can treat requests
rejected by the server as though they had never been sent at all, thereby
allowing them to be retried later.</t>
          <t>Servers            <bcp14>MUST NOT</bcp14>
 use the <xref format='none' target='H3_REQUEST_REJECTED'>H3_REQUEST_REJECTED</xref><iref item='H3_REQUEST_REJECTED'/> error code for requests that were
partially or fully processed.  When a server abandons a response after partial
processing, it            <bcp14>SHOULD</bcp14>
 abort its response stream with the error code
<xref format='none' target='H3_REQUEST_CANCELLED'>H3_REQUEST_CANCELLED</xref><iref item='H3_REQUEST_CANCELLED'/>.</t>
          <t>Client            <bcp14>SHOULD</bcp14>
 use the error code <xref format='none' target='H3_REQUEST_CANCELLED'>H3_REQUEST_CANCELLED</xref><iref item='H3_REQUEST_CANCELLED'/> to cancel requests.  Upon
receipt of this error code, a server            <bcp14>MAY</bcp14>
 abruptly terminate the response using
the error code <xref format='none' target='H3_REQUEST_REJECTED'>H3_REQUEST_REJECTED</xref><iref item='H3_REQUEST_REJECTED'/> if no processing was performed.  Clients            <bcp14>MUST
NOT</bcp14>
 use the <xref format='none' target='H3_REQUEST_REJECTED'>H3_REQUEST_REJECTED</xref><iref item='H3_REQUEST_REJECTED'/> error code, except when a server has requested
closure of the <xref format='none' target='request-streams'>request stream</xref><iref item='request stream'/> with this error code.</t>
          <t>If a stream is cancelled after receiving a complete response, the client            <bcp14>MAY</bcp14>

ignore the cancellation and use the response.  However, if a stream is cancelled
after receiving a partial response, the response            <bcp14>SHOULD NOT</bcp14>
 be used. Only
idempotent actions such as GET, PUT, or DELETE can be safely retried; a client            <bcp14>SHOULD NOT</bcp14>
 automatically retry a request with a non-idempotent method unless it
has some means to know that the request semantics are idempotent
independent of the method or some means to detect that the original request was
never applied.  See <xref section='9.2.2' sectionFormat='of' target='RFC9110'/> for more details.</t>
        </section>
        <section anchor='malformed'>
          <name>Malformed Requests and Responses</name><iref item='malformed' primary='true'/>
          <t>A malformed request or response is one that is an otherwise valid sequence of
frames but is invalid due to:</t>
          <ul spacing='normal'>
            <li>the presence of prohibited fields or pseudo-header fields,</li>
            <li>the absence of mandatory pseudo-header fields,</li>
            <li>invalid values for pseudo-header fields,</li>
            <li>pseudo-header fields after fields,</li>
            <li>an invalid sequence of HTTP messages,</li>
            <li>the inclusion of uppercase field names, or</li>
            <li>the inclusion of invalid characters in field names or values.</li>
          </ul>
          <t>A request or response that is defined as having content when it contains a
Content-Length header field (<xref section='8.6' sectionFormat='of' target='RFC9110'/>) is malformed if the
value of the Content-Length header field does not equal the sum of the <xref format='none' target='frame-data'>DATA</xref><iref item='DATA'/>
frame lengths received. A response that is defined as never having content, even
when a Content-Length is present, can have a non-zero Content-Length header
field even though no content is included in <xref format='none' target='frame-data'>DATA</xref><iref item='DATA'/> frames.</t>
          <t>Intermediaries that process HTTP requests or responses (i.e., any intermediary
not acting as a tunnel)            <bcp14>MUST NOT</bcp14>
 forward a malformed request or response.
Malformed requests or responses that are detected            <bcp14>MUST</bcp14>
 be treated as a <xref format='none' target='errors'>stream
error</xref><iref item='stream error'/> of type <xref format='none' target='H3_MESSAGE_ERROR'>H3_MESSAGE_ERROR</xref><iref item='H3_MESSAGE_ERROR'/>.</t>
          <t>For malformed requests, a server            <bcp14>MAY</bcp14>
 send an HTTP response indicating the error
prior to closing or resetting the stream.  Clients            <bcp14>MUST NOT</bcp14>
 accept a malformed
response.  Note that these requirements are intended to protect against several
types of common attacks against HTTP; they are deliberately strict because being
permissive can expose implementations to these vulnerabilities.</t>
        </section>
      </section>
      <section anchor='header-formatting'>
        <name>HTTP Fields</name>
        <t>HTTP messages carry metadata as a series of key-value pairs called "HTTP
fields"; see Sections <xref section='6.3' sectionFormat='bare' target='RFC9110'/> and <xref section='6.5' sectionFormat='bare' target='RFC9110'/> of <xref target='RFC9110'/>. For a listing of registered
HTTP fields, see the "Hypertext Transfer Protocol (HTTP) Field Name Registry"
maintained at <eref brackets='angle' target='https://www.iana.org/assignments/http-fields/'/>.  Like HTTP/2, HTTP/3 has additional considerations related to
the use of characters in field names, the Connection header field, and
pseudo-header fields.</t>
        <t>Field names are strings containing a subset of ASCII characters. Properties of
HTTP field names and values are discussed in more detail in <xref section='5.1' sectionFormat='of' target='RFC9110'/>. Characters in field names          <bcp14>MUST</bcp14>
 be converted to lowercase prior to
their encoding. A request or response containing uppercase characters in field
names          <bcp14>MUST</bcp14>
 be treated as <xref format='none' target='malformed'>malformed</xref><iref item='malformed'/>.</t>
        <t>HTTP/3 does not use the Connection header field to indicate connection-specific
fields; in this protocol, connection-specific metadata is conveyed by other
means.  An endpoint          <bcp14>MUST NOT</bcp14>
 generate an HTTP/3 field section containing
connection-specific fields; any message containing connection-specific fields          <bcp14>MUST</bcp14>
 be treated as <xref format='none' target='malformed'>malformed</xref><iref item='malformed'/>.</t>
        <t>The only exception to this is the TE header field, which          <bcp14>MAY</bcp14>
 be present in an
HTTP/3 request header; when it is, it          <bcp14>MUST NOT</bcp14>
 contain any value other than
"trailers".</t>
        <t>An intermediary transforming an HTTP/1.x message to HTTP/3          <bcp14>MUST</bcp14>
 remove
connection-specific header fields as discussed in <xref section='7.6.1' sectionFormat='of' target='RFC9110'/>, or their messages will be treated by other HTTP/3 endpoints as
<xref format='none' target='malformed'>malformed</xref><iref item='malformed'/>.</t>
        <section anchor='field-compression'>
          <name>Field Compression</name>
          <t><xref target='RFC9204'/> describes a variation of HPACK that gives an encoder some control
over how much head-of-line blocking can be caused by compression.  This allows
an encoder to balance compression efficiency with latency.  HTTP/3 uses QPACK to
compress header and trailer sections, including the control data present in the
header section.</t>
          <t>To allow for better compression efficiency, the Cookie header field
(<xref target='COOKIES'/>)            <bcp14>MAY</bcp14>
 be split into separate field lines, each with one or
more cookie-pairs, before compression. If a decompressed field section contains
multiple cookie field lines, these            <bcp14>MUST</bcp14>
 be concatenated into a single byte
string using the two-byte delimiter of "<tt>;&nbsp;</tt>" (ASCII 0x3b, 0x20) before being
passed into a context other than HTTP/2 or HTTP/3, such as an HTTP/1.1
connection, or a generic HTTP server application.</t>
        </section>
        <section anchor='header-size-constraints'>
          <name>Header Size Constraints</name>
          <t>An HTTP/3 implementation            <bcp14>MAY</bcp14>
 impose a limit on the maximum size of the message
header it will accept on an individual HTTP message.  A server that receives a
larger header section than it is willing to handle can send an HTTP 431 (Request
Header Fields Too Large) status code (<xref target='RFC6585'/>).  A client can discard
responses that it cannot process.  The size of a field list is calculated based
on the uncompressed size of fields, including the length of the name and value
in bytes plus an overhead of 32 bytes for each field.</t>
          <t>If an implementation wishes to advise its peer of this limit, it can be conveyed
as a number of bytes in the <xref format='none' target='SETTINGS_MAX_FIELD_SECTION_SIZE'>SETTINGS_MAX_FIELD_SECTION_SIZE</xref><iref item='SETTINGS_MAX_FIELD_SECTION_SIZE'/> parameter. An
implementation that has received this parameter            <bcp14>SHOULD NOT</bcp14>
 send an HTTP message
header that exceeds the indicated size, as the peer will likely refuse to
process it.  However, an HTTP message can traverse one or more intermediaries
before reaching the origin server; see <xref section='3.7' sectionFormat='of' target='RFC9110'/>.  Because
this limit is applied separately by each implementation that processes the
message, messages below this limit are not guaranteed to be accepted.</t>
        </section>
      </section>
      <section anchor='http-control-data'>
        <name>HTTP Control Data</name>
        <t>Like HTTP/2, HTTP/3 employs a series of pseudo-header fields, where the field
name begins with the <tt>:</tt> character (ASCII 0x3a).  These pseudo-header fields
convey message control data; see <xref section='6.2' sectionFormat='of' target='RFC9110'/>.</t>
        <t>Pseudo-header fields are not HTTP fields.  Endpoints          <bcp14>MUST NOT</bcp14>
 generate
pseudo-header fields other than those defined in this document. However, an
extension could negotiate a modification of this restriction; see
<xref target='extensions'/>.</t>
        <t>Pseudo-header fields are only valid in the context in which they are defined.
Pseudo-header fields defined for requests          <bcp14>MUST NOT</bcp14>
 appear in responses;
pseudo-header fields defined for responses          <bcp14>MUST NOT</bcp14>
 appear in requests.
Pseudo-header fields          <bcp14>MUST NOT</bcp14>
 appear in trailer sections. Endpoints          <bcp14>MUST</bcp14>
 treat a
request or response that contains undefined or invalid pseudo-header fields as
<xref format='none' target='malformed'>malformed</xref><iref item='malformed'/>.</t>
        <t>All pseudo-header fields          <bcp14>MUST</bcp14>
 appear in the header section before regular header
fields.  Any request or response that contains a pseudo-header field that
appears in a header section after a regular header field          <bcp14>MUST</bcp14>
 be treated as
<xref format='none' target='malformed'>malformed</xref><iref item='malformed'/>.</t>
        <section anchor='request-pseudo-header-fields'>
          <name>Request Pseudo-Header Fields</name>
          <t>The following pseudo-header fields are defined for requests:</t>
          <dl>
            <dt>":method":</dt>
            <dd>
              <t>Contains the HTTP method (<xref section='9' sectionFormat='of' target='RFC9110'/>)</t>
            </dd>
            <dt>":scheme":</dt>
            <dd>
              <t>Contains the scheme portion of the target URI (<xref section='3.1' sectionFormat='of' target='URI'/>).</t>
            </dd>
            <dt/>
            <dd>
              <t>The :scheme pseudo-header is not restricted to URIs with scheme "http" and
"https". A proxy or gateway can translate requests for non-HTTP schemes,
enabling the use of HTTP to interact with non-HTTP services.</t>
            </dd>
            <dt/>
            <dd>
              <t>See <xref target='other-schemes'/> for guidance on using a scheme other than "https".</t>
            </dd>
            <dt>":authority":</dt>
            <dd>
              <t>Contains the authority portion of the target URI (<xref section='3.2' sectionFormat='of' target='URI'/>).
The authority                <bcp14>MUST NOT</bcp14>
 include the deprecated userinfo
subcomponent for URIs of scheme "http" or "https".</t>
            </dd>
            <dt/>
            <dd>
              <t>To ensure that the HTTP/1.1 request line can be reproduced accurately, this
pseudo-header field                <bcp14>MUST</bcp14>
 be omitted when translating from an HTTP/1.1
request that has a request target in a method-specific form; see <xref section='7.1' sectionFormat='of' target='RFC9110'/>.  Clients that generate HTTP/3 requests directly                <bcp14>SHOULD</bcp14>
 use
the :authority pseudo-header field instead of the Host header field. An
intermediary that converts an HTTP/3 request to HTTP/1.1                <bcp14>MUST</bcp14>
 create a Host
field if one is not present in a request by copying the value of the
:authority pseudo-header field.</t>
            </dd>
            <dt>":path":</dt>
            <dd>
              <t>Contains the path and query parts of the target URI (the "path-absolute"
production and optionally a <tt>?</tt> character (ASCII 0x3f) followed by the
"query" production; see Sections <xref section='3.3' sectionFormat='bare' target='URI'/> and <xref section='3.4' sectionFormat='bare' target='URI'/> of <xref target='URI'/>.</t>
            </dd>
            <dt/>
            <dd>
              <t>This pseudo-header field                <bcp14>MUST NOT</bcp14>
 be empty for "http" or "https" URIs;
"http" or "https" URIs that do not contain a path component                <bcp14>MUST</bcp14>
 include a
value of <tt>/</tt> (ASCII 0x2f).  An OPTIONS request that does not include a path
component includes the value <tt>*</tt> (ASCII 0x2a) for the :path pseudo-header
field; see <xref section='7.1' sectionFormat='of' target='RFC9110'/>.</t>
            </dd>
          </dl>
          <t>All HTTP/3 requests            <bcp14>MUST</bcp14>
 include exactly one value for the :method, :scheme,
and :path pseudo-header fields, unless the request is a CONNECT request; see
<xref target='connect'/>.</t>
          <t>If the :scheme pseudo-header field identifies a scheme that has a mandatory
authority component (including "http" and "https"), the request            <bcp14>MUST</bcp14>
 contain
either an :authority pseudo-header field or a Host header field.  If these
fields are present, they            <bcp14>MUST NOT</bcp14>
 be empty.  If both fields are present, they            <bcp14>MUST</bcp14>
 contain the same value.  If the scheme does not have a mandatory authority
component and none is provided in the request target, the request            <bcp14>MUST NOT</bcp14>

contain the :authority pseudo-header or Host header fields.</t>
          <t>An HTTP request that omits mandatory pseudo-header fields or contains invalid
values for those pseudo-header fields is <xref format='none' target='malformed'>malformed</xref><iref item='malformed'/>.</t>
          <t>HTTP/3 does not define a way to carry the version identifier that is included in
the HTTP/1.1 request line.  HTTP/3 requests implicitly have a protocol version
of "3.0".</t>
        </section>
        <section anchor='response-pseudo-header-fields'>
          <name>Response Pseudo-Header Fields</name>
          <t>For responses, a single ":status" pseudo-header field is defined that carries
the HTTP status code; see <xref section='15' sectionFormat='of' target='RFC9110'/>.  This pseudo-header
field            <bcp14>MUST</bcp14>
 be included in all responses; otherwise, the response is <xref format='none' target='malformed'>malformed</xref><iref item='malformed'/>
(see <xref target='malformed'/>).</t>
          <t>HTTP/3 does not define a way to carry the version or reason phrase that is
included in an HTTP/1.1 status line. HTTP/3 responses implicitly have a protocol
version of "3.0".</t>
        </section>
      </section>
      <section anchor='connect'>
        <name>The CONNECT Method</name>
        <t>The CONNECT method requests that the recipient establish a tunnel to the
destination origin server identified by the request-target; see <xref section='9.3.6' sectionFormat='of' target='RFC9110'/>. It is primarily used with HTTP proxies to establish a TLS
session with an origin server for the purposes of interacting with "https"
resources.</t>
        <t>In HTTP/1.x, CONNECT is used to convert an entire HTTP connection into a tunnel
to a remote host. In HTTP/2 and HTTP/3, the CONNECT method is used to establish
a tunnel over a single stream.</t>
        <t>A CONNECT request          <bcp14>MUST</bcp14>
 be constructed as follows:</t>
        <ul spacing='normal'>
          <li>The :method pseudo-header field is set to "CONNECT"</li>
          <li>The :scheme and :path pseudo-header fields are omitted</li>
          <li>The :authority pseudo-header field contains the host and port to connect to
(equivalent to the authority-form of the request-target of CONNECT requests;
see <xref section='7.1' sectionFormat='of' target='RFC9110'/>).</li>
        </ul>
        <t>The <xref format='none' target='request-streams'>request stream</xref><iref item='request stream'/> remains open at the end of the request to carry the data to
be transferred.  A CONNECT request that does not conform to these restrictions
is <xref format='none' target='malformed'>malformed</xref><iref item='malformed'/>.</t>
        <t>A proxy that supports CONNECT establishes a TCP connection (<xref target='RFC0793'/>) to the
server identified in the :authority pseudo-header field.  Once this connection
is successfully established, the proxy sends a <xref format='none' target='frame-headers'>HEADERS</xref><iref item='HEADERS'/> frame containing a 2xx
series status code to the client, as defined in <xref section='15.3' sectionFormat='of' target='RFC9110'/>.</t>
        <t>All <xref format='none' target='frame-data'>DATA</xref><iref item='DATA'/> frames on the stream correspond to data sent or received on the TCP
connection. The payload of any <xref format='none' target='frame-data'>DATA</xref><iref item='DATA'/> frame sent by the client is transmitted by
the proxy to the TCP server; data received from the TCP server is packaged into
<xref format='none' target='frame-data'>DATA</xref><iref item='DATA'/> frames by the proxy. Note that the size and number of TCP segments is not
guaranteed to map predictably to the size and number of HTTP <xref format='none' target='frame-data'>DATA</xref><iref item='DATA'/> or QUIC STREAM
frames.</t>
        <t>Once the CONNECT method has completed, only <xref format='none' target='frame-data'>DATA</xref><iref item='DATA'/> frames are permitted to be sent
on the stream.  Extension frames          <bcp14>MAY</bcp14>
 be used if specifically permitted by the
definition of the extension.  Receipt of any other known frame type          <bcp14>MUST</bcp14>
 be
treated as a <xref format='none' target='errors'>connection error</xref><iref item='connection error'/> of type <xref format='none' target='H3_FRAME_UNEXPECTED'>H3_FRAME_UNEXPECTED</xref><iref item='H3_FRAME_UNEXPECTED'/>.</t>
        <t>The TCP connection can be closed by either peer. When the client ends the
<xref format='none' target='request-streams'>request stream</xref><iref item='request stream'/> (that is, the receive stream at the proxy enters the "Data Recvd"
state), the proxy will set the FIN bit on its connection to the TCP server. When
the proxy receives a packet with the FIN bit set, it will close the send stream
that it sends to the client. TCP connections that remain half closed in a
single direction are not invalid, but are often handled poorly by servers, so
clients          <bcp14>SHOULD NOT</bcp14>
 close a stream for sending while they still expect to receive
data from the target of the CONNECT.</t>
        <t>A TCP <xref format='none' target='errors'>connection error</xref><iref item='connection error'/> is signaled by abruptly terminating the stream. A proxy
treats any error in the TCP connection, which includes receiving a TCP segment
with the RST bit set, as a <xref format='none' target='errors'>stream error</xref><iref item='stream error'/> of type <xref format='none' target='H3_CONNECT_ERROR'>H3_CONNECT_ERROR</xref><iref item='H3_CONNECT_ERROR'/>.</t>
        <t>Correspondingly, if a proxy detects an error with the stream or the QUIC
connection, it          <bcp14>MUST</bcp14>
 close the TCP connection.  If the proxy detects that the
client has reset the stream or aborted reading from the stream, it          <bcp14>MUST</bcp14>
 close
the TCP connection.  If the stream is reset or reading is aborted by the client,
a proxy          <bcp14>SHOULD</bcp14>
 perform the same operation on the other direction in order to
ensure that both directions of the stream are cancelled. In all these cases, if
the underlying TCP implementation permits it, the proxy          <bcp14>SHOULD</bcp14>
 send a TCP
segment with the RST bit set.</t>
        <t>Since CONNECT creates a tunnel to an arbitrary server, proxies that support
CONNECT          <bcp14>SHOULD</bcp14>
 restrict its use to a set of known ports or a list of safe
request targets; see <xref section='9.3.6' sectionFormat='of' target='RFC9110'/> for more details.</t>
      </section>
      <section anchor='http-upgrade'>
        <name>HTTP Upgrade</name>
        <t>HTTP/3 does not support the HTTP Upgrade mechanism (<xref section='7.8' sectionFormat='of' target='RFC9110'/>) or the 101 (Switching Protocols) informational status code
(<xref section='15.2.2' sectionFormat='of' target='RFC9110'/>).</t>
      </section>
      <section anchor='server-push'>
        <name>Server Push</name><iref item='push ID' primary='true'/>
        <t>Server push is an interaction mode that permits a server to push a
request-response exchange to a client in anticipation of the client making the
indicated request.  This trades off network usage against a potential latency
gain.  HTTP/3 server push is similar to what is described in
<xref section='8.2' sectionFormat='of' target='RFC9113'/>, but it uses different mechanisms.</t>
        <t>Each server push is assigned a unique push ID by the server.  The push ID is
used to refer to the push in various contexts throughout the lifetime of the
HTTP/3 connection.</t>
        <t>The push ID space begins at zero and ends at a maximum value set by the
<xref format='none' target='frame-max-push-id'>MAX_PUSH_ID</xref><iref item='MAX_PUSH_ID'/> frame.  In particular, a server is not
able to push until after the client sends a <xref format='none' target='frame-max-push-id'>MAX_PUSH_ID</xref><iref item='MAX_PUSH_ID'/> frame.  A client sends
<xref format='none' target='frame-max-push-id'>MAX_PUSH_ID</xref><iref item='MAX_PUSH_ID'/> frames to control the number of pushes that a server can promise.  A
server          <bcp14>SHOULD</bcp14>
 use push IDs sequentially, beginning from zero.  A client          <bcp14>MUST</bcp14>

treat receipt of a <xref format='none' target='push-streams'>push stream</xref><iref item='push stream'/> as a <xref format='none' target='errors'>connection error</xref><iref item='connection error'/> of type <xref format='none' target='H3_ID_ERROR'>H3_ID_ERROR</xref><iref item='H3_ID_ERROR'/>
when no <xref format='none' target='frame-max-push-id'>MAX_PUSH_ID</xref><iref item='MAX_PUSH_ID'/> frame has been sent or when the stream
references a push ID that is greater than the maximum push ID.</t>
        <t>The push ID is used in one or more <xref format='none' target='frame-push-promise'>PUSH_PROMISE</xref><iref item='PUSH_PROMISE'/> frames that carry the control
data and header fields of the request message.  These frames are sent on the
<xref format='none' target='request-streams'>request stream</xref><iref item='request stream'/> that generated the push.  This allows the server push to be
associated with a client request.  When the same push ID is promised on multiple
<xref format='none' target='request-streams'>request streams</xref><iref item='request stream'/>, the decompressed request field sections          <bcp14>MUST</bcp14>
 contain the same
fields in the same order, and both the name and the value in each field          <bcp14>MUST</bcp14>
 be
identical.</t>
        <t>The push ID is then included with the <xref format='none' target='push-streams'>push stream</xref><iref item='push stream'/> that ultimately fulfills
those promises.  The <xref format='none' target='push-streams'>push stream</xref><iref item='push stream'/> identifies the push ID of
the promise that it fulfills, then contains a response to the promised request
as described in <xref target='request-response'/>.</t>
        <t>Finally, the push ID can be used in <xref format='none' target='frame-cancel-push'>CANCEL_PUSH</xref><iref item='CANCEL_PUSH'/> frames; see
<xref target='frame-cancel-push'/>.  Clients use this frame to indicate they do not wish to
receive a promised resource.  Servers use this frame to indicate they will not
be fulfilling a previous promise.</t>
        <t>Not all requests can be pushed.  A server          <bcp14>MAY</bcp14>
 push requests that have the
following properties:</t>
        <ul spacing='normal'>
          <li>cacheable; see <xref section='9.2.3' sectionFormat='of' target='RFC9110'/></li>
          <li>safe; see <xref section='9.2.1' sectionFormat='of' target='RFC9110'/></li>
          <li>does not include request content or a trailer section</li>
        </ul>
        <t>The server          <bcp14>MUST</bcp14>
 include a value in the :authority pseudo-header field for
which the server is authoritative.  If the client has not yet validated the
connection for the origin indicated by the pushed request, it          <bcp14>MUST</bcp14>
 perform the
same verification process it would do before sending a request for that origin
on the connection; see <xref target='connection-reuse'/>.  If this verification fails,
the client          <bcp14>MUST NOT</bcp14>
 consider the server authoritative for that origin.</t>
        <t>Clients          <bcp14>SHOULD</bcp14>
 send a <xref format='none' target='frame-cancel-push'>CANCEL_PUSH</xref><iref item='CANCEL_PUSH'/> frame upon receipt of a <xref format='none' target='frame-push-promise'>PUSH_PROMISE</xref><iref item='PUSH_PROMISE'/> frame
carrying a request that is not cacheable, is not known to be safe, that
indicates the presence of request content, or for which it does not consider the
server authoritative.  Any corresponding responses          <bcp14>MUST NOT</bcp14>
 be used or cached.</t>
        <t>Each pushed response is associated with one or more client requests.  The push
is associated with the <xref format='none' target='request-streams'>request stream</xref><iref item='request stream'/> on which the <xref format='none' target='frame-push-promise'>PUSH_PROMISE</xref><iref item='PUSH_PROMISE'/> frame was
received.  The same server push can be associated with additional client
requests using a <xref format='none' target='frame-push-promise'>PUSH_PROMISE</xref><iref item='PUSH_PROMISE'/> frame with the same push ID on multiple <xref format='none' target='request-streams'>request
streams</xref><iref item='request stream'/>.  These associations do not affect the operation of the protocol, but
they          <bcp14>MAY</bcp14>
 be considered by user agents when deciding how to use pushed resources.</t>
        <t>Ordering of a <xref format='none' target='frame-push-promise'>PUSH_PROMISE</xref><iref item='PUSH_PROMISE'/> frame in relation to certain parts of the response is
important. The server          <bcp14>SHOULD</bcp14>
 send <xref format='none' target='frame-push-promise'>PUSH_PROMISE</xref><iref item='PUSH_PROMISE'/> frames prior to sending <xref format='none' target='frame-headers'>HEADERS</xref><iref item='HEADERS'/>
or <xref format='none' target='frame-data'>DATA</xref><iref item='DATA'/> frames that reference the promised responses.  This reduces the chance
that a client requests a resource that will be pushed by the server.</t>
        <t>Due to reordering, <xref format='none' target='push-streams'>push stream</xref><iref item='push stream'/> data can arrive before the corresponding
<xref format='none' target='frame-push-promise'>PUSH_PROMISE</xref><iref item='PUSH_PROMISE'/> frame.  When a client receives a new <xref format='none' target='push-streams'>push stream</xref><iref item='push stream'/> with an
as-yet-unknown push ID, both the associated client request and the pushed
request header fields are unknown.  The client can buffer the stream data in
expectation of the matching <xref format='none' target='frame-push-promise'>PUSH_PROMISE</xref><iref item='PUSH_PROMISE'/>. The client can use stream flow control
(<xref section='4.1' sectionFormat='of' target='QUIC-TRANSPORT'/>) to limit the amount of data a server may
commit to the pushed stream.  Clients          <bcp14>SHOULD</bcp14>
 abort reading and discard data
already read from <xref format='none' target='push-streams'>push streams</xref><iref item='push stream'/> if no corresponding <xref format='none' target='frame-push-promise'>PUSH_PROMISE</xref><iref item='PUSH_PROMISE'/> frame is
processed in a reasonable amount of time.</t>
        <t>Push stream data can also arrive after a client has cancelled a push. In this
case, the client can abort reading the stream with an error code of
<xref format='none' target='H3_REQUEST_CANCELLED'>H3_REQUEST_CANCELLED</xref><iref item='H3_REQUEST_CANCELLED'/>. This asks the server not to transfer additional data and
indicates that it will be discarded upon receipt.</t>
        <t>Pushed responses that are cacheable (see <xref section='3' sectionFormat='of' target='RFC9111'/>) can be
stored by the client, if it implements an HTTP cache. Pushed responses are
considered successfully validated on the origin server (e.g., if the "no-cache"
cache response directive is present; see <xref section='5.2.2.4' sectionFormat='of' target='RFC9111'/>) at the
time the pushed response is received.</t>
        <t>Pushed responses that are not cacheable          <bcp14>MUST NOT</bcp14>
 be stored by any HTTP cache.
They          <bcp14>MAY</bcp14>
 be made available to the application separately.</t>
      </section>
    </section>
    <section anchor='connection-closure'>
      <name>Connection Closure</name>
      <t>Once established, an HTTP/3 connection can be used for many requests and
responses over time until the connection is closed.  Connection closure can
happen in any of several different ways.</t>
      <section anchor='idle-connections'>
        <name>Idle Connections</name>
        <t>Each QUIC endpoint declares an idle timeout during the handshake.  If the QUIC
connection remains idle (no packets received) for longer than this duration, the
peer will assume that the connection has been closed.  HTTP/3 implementations
will need to open a new HTTP/3 connection for new requests if the existing
connection has been idle for longer than the idle timeout negotiated during the
QUIC handshake, and they          <bcp14>SHOULD</bcp14>
 do so if approaching the idle timeout; see
<xref section='10.1' sectionFormat='of' target='QUIC-TRANSPORT'/>.</t>
        <t>HTTP clients are expected to request that the transport keep connections open
while there are responses outstanding for requests or server pushes, as
described in <xref section='10.1.2' sectionFormat='of' target='QUIC-TRANSPORT'/>. If the client is not
expecting a response from the server, allowing an idle connection to time out is
preferred over expending effort maintaining a connection that might not be
needed.  A gateway          <bcp14>MAY</bcp14>
 maintain connections in anticipation of need rather than
incur the latency cost of connection establishment to servers. Servers          <bcp14>SHOULD
NOT</bcp14>
 actively keep connections open.</t>
      </section>
      <section anchor='connection-shutdown'>
        <name>Connection Shutdown</name>
        <t>Even when a connection is not idle, either endpoint can decide to stop using the
connection and initiate a graceful connection close.  Endpoints initiate the
graceful shutdown of an HTTP/3 connection by sending a <xref format='none' target='frame-goaway'>GOAWAY</xref><iref item='GOAWAY'/> frame. The <xref format='none' target='frame-goaway'>GOAWAY</xref><iref item='GOAWAY'/>
frame contains an identifier that indicates to the receiver the range of
requests or pushes that were or might be processed in this connection.  The
server sends a client-initiated bidirectional stream ID; the client sends a <xref format='none' target='server-push'>push
ID</xref><iref item='push ID'/>.  Requests or pushes with the indicated identifier or greater are rejected
(<xref target='request-cancellation'/>) by the sender of the <xref format='none' target='frame-goaway'>GOAWAY</xref><iref item='GOAWAY'/>. This identifier          <bcp14>MAY</bcp14>
 be
zero if no requests or pushes were processed.</t>
        <t>The information in the <xref format='none' target='frame-goaway'>GOAWAY</xref><iref item='GOAWAY'/> frame enables a client and server to agree on
which requests or pushes were accepted prior to the shutdown of the HTTP/3
connection. Upon sending a <xref format='none' target='frame-goaway'>GOAWAY</xref><iref item='GOAWAY'/> frame, the endpoint          <bcp14>SHOULD</bcp14>
 explicitly cancel
(see Sections <xref format='counter' target='request-cancellation'/> and <xref format='counter' target='frame-cancel-push'/>) any requests
or pushes that have identifiers greater than or equal to the one indicated, in
order to clean up transport state for the affected streams. The endpoint          <bcp14>SHOULD</bcp14>

continue to do so as more requests or pushes arrive.</t>
        <t>Endpoints          <bcp14>MUST NOT</bcp14>
 initiate new requests or promise new pushes on the connection
after receipt of a <xref format='none' target='frame-goaway'>GOAWAY</xref><iref item='GOAWAY'/> frame from the peer.  Clients          <bcp14>MAY</bcp14>
 establish a new
connection to send additional requests.</t>
        <t>Some requests or pushes might already be in transit:</t>
        <ul spacing='normal'>
          <li>
            <t>Upon receipt of a <xref format='none' target='frame-goaway'>GOAWAY</xref><iref item='GOAWAY'/> frame, if the client has already sent requests with
a stream ID greater than or equal to the identifier contained in the <xref format='none' target='frame-goaway'>GOAWAY</xref><iref item='GOAWAY'/>
frame, those requests will not be processed.  Clients can safely retry
unprocessed requests on a different HTTP connection.  A client that is
unable to retry requests loses all requests that are in flight when the
server closes the connection.</t>
            <t>Requests on stream IDs less than the stream ID in a <xref format='none' target='frame-goaway'>GOAWAY</xref><iref item='GOAWAY'/> frame from the
server might have been processed; their status cannot be known until a
response is received, the stream is reset individually, another <xref format='none' target='frame-goaway'>GOAWAY</xref><iref item='GOAWAY'/> is
received with a lower stream ID than that of the request in question,
or the connection terminates.</t>
            <t>Servers              <bcp14>MAY</bcp14>
 reject individual requests on streams below the indicated ID if
these requests were not processed.</t>
          </li>
          <li>If a server receives a <xref format='none' target='frame-goaway'>GOAWAY</xref><iref item='GOAWAY'/> frame after having promised pushes with a <xref format='none' target='server-push'>push
ID</xref><iref item='push ID'/> greater than or equal to the identifier contained in the <xref format='none' target='frame-goaway'>GOAWAY</xref><iref item='GOAWAY'/> frame,
those pushes will not be accepted.</li>
        </ul>
        <t>Servers          <bcp14>SHOULD</bcp14>
 send a <xref format='none' target='frame-goaway'>GOAWAY</xref><iref item='GOAWAY'/> frame when the closing of a connection is known
in advance, even if the advance notice is small, so that the remote peer can
know whether or not a request has been partially processed.  For example, if an
HTTP client sends a POST at the same time that a server closes a QUIC
connection, the client cannot know if the server started to process that POST
request if the server does not send a <xref format='none' target='frame-goaway'>GOAWAY</xref><iref item='GOAWAY'/> frame to indicate what streams it
might have acted on.</t>
        <t>An endpoint          <bcp14>MAY</bcp14>
 send multiple <xref format='none' target='frame-goaway'>GOAWAY</xref><iref item='GOAWAY'/> frames indicating different identifiers,
but the identifier in each frame          <bcp14>MUST NOT</bcp14>
 be greater than the identifier in any
previous frame, since clients might already have retried unprocessed requests on
another HTTP connection.  Receiving a <xref format='none' target='frame-goaway'>GOAWAY</xref><iref item='GOAWAY'/> containing a larger identifier than
previously received          <bcp14>MUST</bcp14>
 be treated as a <xref format='none' target='errors'>connection error</xref><iref item='connection error'/> of type <xref format='none' target='H3_ID_ERROR'>H3_ID_ERROR</xref><iref item='H3_ID_ERROR'/>.</t>
        <t>An endpoint that is attempting to gracefully shut down a connection can send a
<xref format='none' target='frame-goaway'>GOAWAY</xref><iref item='GOAWAY'/> frame with a value set to the maximum possible value (2<sup>62</sup>-4
for servers, 2<sup>62</sup>-1 for clients). This ensures that the peer stops
creating new requests or pushes. After allowing time for any in-flight requests
or pushes to arrive, the endpoint can send another <xref format='none' target='frame-goaway'>GOAWAY</xref><iref item='GOAWAY'/> frame indicating which
requests or pushes it might accept before the end of the connection. This
ensures that a connection can be cleanly shut down without losing requests.</t>
        <t>A client has more flexibility in the value it chooses for the Push ID field in a
<xref format='none' target='frame-goaway'>GOAWAY</xref><iref item='GOAWAY'/> that it sends.  A value of 2<sup>62</sup>-1 indicates that the server can
continue fulfilling pushes that have already been promised. A smaller value
indicates the client will reject pushes with push IDs greater than or equal to
this value.  Like the server, the client          <bcp14>MAY</bcp14>
 send subsequent <xref format='none' target='frame-goaway'>GOAWAY</xref><iref item='GOAWAY'/> frames so
long as the specified <xref format='none' target='server-push'>push ID</xref><iref item='push ID'/> is no greater than any previously sent value.</t>
        <t>Even when a <xref format='none' target='frame-goaway'>GOAWAY</xref><iref item='GOAWAY'/> indicates that a given request or push will not be processed
or accepted upon receipt, the underlying transport resources still exist.  The
endpoint that initiated these requests can cancel them to clean up transport
state.</t>
        <t>Once all accepted requests and pushes have been processed, the endpoint can
permit the connection to become idle, or it          <bcp14>MAY</bcp14>
 initiate an immediate closure of
the connection.  An endpoint that completes a graceful shutdown          <bcp14>SHOULD</bcp14>
 use the
<xref format='none' target='H3_NO_ERROR'>H3_NO_ERROR</xref><iref item='H3_NO_ERROR'/> error code when closing the connection.</t>
        <t>If a client has consumed all available bidirectional stream IDs with requests,
the server need not send a <xref format='none' target='frame-goaway'>GOAWAY</xref><iref item='GOAWAY'/> frame, since the client is unable to make
further requests.</t>
      </section>
      <section anchor='immediate-application-closure'>
        <name>Immediate Application Closure</name>
        <t>An HTTP/3 implementation can immediately close the QUIC connection at any time.
This results in sending a QUIC CONNECTION_CLOSE frame to the peer indicating
that the application layer has terminated the connection.  The application error
code in this frame indicates to the peer why the connection is being closed.
See <xref target='errors'/> for error codes that can be used when closing a connection in
HTTP/3.</t>
        <t>Before closing the connection, a <xref format='none' target='frame-goaway'>GOAWAY</xref><iref item='GOAWAY'/> frame          <bcp14>MAY</bcp14>
 be sent to allow the client to
retry some requests.  Including the <xref format='none' target='frame-goaway'>GOAWAY</xref><iref item='GOAWAY'/> frame in the same packet as the QUIC
CONNECTION_CLOSE frame improves the chances of the frame being received by
clients.</t>
        <t>If there are open streams that have not been explicitly closed, they are
implicitly closed when the connection is closed; see
<xref section='10.2' sectionFormat='of' target='QUIC-TRANSPORT'/>.</t>
      </section>
      <section anchor='transport-closure'>
        <name>Transport Closure</name>
        <t>For various reasons, the QUIC transport could indicate to the application layer
that the connection has terminated.  This might be due to an explicit closure
by the peer, a transport-level error, or a change in network topology that
interrupts connectivity.</t>
        <t>If a connection terminates without a <xref format='none' target='frame-goaway'>GOAWAY</xref><iref item='GOAWAY'/> frame, clients          <bcp14>MUST</bcp14>
 assume that any
request that was sent, whether in whole or in part, might have been processed.</t>
      </section>
    </section>
    <section anchor='stream-mapping'>
      <name>Stream Mapping and Usage</name>
      <t>A QUIC stream provides reliable in-order delivery of bytes, but makes no
guarantees about order of delivery with regard to bytes on other streams. In
version 1 of QUIC, the stream data containing HTTP frames is carried by QUIC
STREAM frames, but this framing is invisible to the HTTP framing layer. The
transport layer buffers and orders received stream data, exposing a reliable
byte stream to the application. Although QUIC permits out-of-order delivery
within a stream, HTTP/3 does not make use of this feature.</t>
      <t>QUIC streams can be either unidirectional, carrying data only from initiator to
receiver, or bidirectional, carrying data in both directions.  Streams can be
initiated by either the client or the server.  For more detail on QUIC streams,
see <xref section='2' sectionFormat='of' target='QUIC-TRANSPORT'/>.</t>
      <t>When HTTP fields and data are sent over QUIC, the QUIC layer handles most of
the stream management.  HTTP does not need to do any separate multiplexing when
using QUIC: data sent over a QUIC stream always maps to a particular HTTP
transaction or to the entire HTTP/3 connection context.</t>
      <section anchor='request-streams'>
        <name>Bidirectional Streams</name><iref item='request stream' primary='true'/>
        <t>All client-initiated bidirectional streams are used for HTTP requests and
responses.  A bidirectional stream ensures that the response can be readily
correlated with the request.  These streams are referred to as request streams.</t>
        <t>This means that the client's first request occurs on QUIC stream 0, with
subsequent requests on streams 4, 8, and so on. In order to permit these streams
to open, an HTTP/3 server          <bcp14>SHOULD</bcp14>
 configure non-zero minimum values for the
number of permitted streams and the initial stream flow-control window.  So as
to not unnecessarily limit parallelism, at least 100 request streams          <bcp14>SHOULD</bcp14>
 be
permitted at a time.</t>
        <t>HTTP/3 does not use server-initiated bidirectional streams, though an extension
could define a use for these streams.  Clients          <bcp14>MUST</bcp14>
 treat receipt of a
server-initiated bidirectional stream as a <xref format='none' target='errors'>connection error</xref><iref item='connection error'/> of type
<xref format='none' target='H3_STREAM_CREATION_ERROR'>H3_STREAM_CREATION_ERROR</xref><iref item='H3_STREAM_CREATION_ERROR'/> unless such an extension has been
negotiated.</t>
      </section>
      <section anchor='unidirectional-streams'>
        <name>Unidirectional Streams</name>
        <t>Unidirectional streams, in either direction, are used for a range of purposes.
The purpose is indicated by a stream type, which is sent as a variable-length
integer at the start of the stream. The format and structure of data that
follows this integer is determined by the stream type.</t>
        <figure>
          <name>Unidirectional Stream Header</name>
          <artwork type='ascii-art'><![CDATA[
Unidirectional Stream Header {
  Stream Type (i),
}
]]></artwork>
        </figure>
        <t>Two stream types are defined in this document: <xref format='none' target='control-streams'>control streams</xref><iref item='control stream'/>
(<xref target='control-streams'/>) and <xref format='none' target='push-streams'>push streams</xref><iref item='push stream'/> (<xref target='push-streams'/>). <xref target='RFC9204'/> defines
two additional stream types. Other stream types can be defined by extensions to
HTTP/3; see <xref target='extensions'/> for more details. Some stream types are reserved
(<xref target='stream-grease'/>).</t>
        <t>The performance of HTTP/3 connections in the early phase of their lifetime is
sensitive to the creation and exchange of data on unidirectional streams.
Endpoints that excessively restrict the number of streams or the flow-control
window of these streams will increase the chance that the remote peer reaches
the limit early and becomes blocked. In particular, implementations should
consider that remote peers may wish to exercise reserved stream behavior
(<xref target='stream-grease'/>) with some of the unidirectional streams they are permitted
to use.</t>
        <t>Each endpoint needs to create at least one unidirectional stream for the HTTP
<xref format='none' target='control-streams'>control stream</xref><iref item='control stream'/>. QPACK requires two additional unidirectional streams, and other
extensions might require further streams. Therefore, the transport parameters
sent by both clients and servers          <bcp14>MUST</bcp14>
 allow the peer to create at least three
unidirectional streams. These transport parameters          <bcp14>SHOULD</bcp14>
 also provide at least
1,024 bytes of flow-control credit to each unidirectional stream.</t>
        <t>Note that an endpoint is not required to grant additional credits to create more
unidirectional streams if its peer consumes all the initial credits before
creating the critical unidirectional streams. Endpoints          <bcp14>SHOULD</bcp14>
 create the HTTP
<xref format='none' target='control-streams'>control stream</xref><iref item='control stream'/> as well as the unidirectional streams required by mandatory
extensions (such as the QPACK encoder and decoder streams) first, and then
create additional streams as allowed by their peer.</t>
        <t>If the stream header indicates a stream type that is not supported by the
recipient, the remainder of the stream cannot be consumed as the semantics are
unknown. Recipients of unknown stream types          <bcp14>MUST</bcp14>
 either abort reading of the
stream or discard incoming data without further processing.  If reading is
aborted, the recipient          <bcp14>SHOULD</bcp14>
 use the <xref format='none' target='H3_STREAM_CREATION_ERROR'>H3_STREAM_CREATION_ERROR</xref><iref item='H3_STREAM_CREATION_ERROR'/> error code or a
reserved error code (<xref target='http-error-codes'/>). The recipient          <bcp14>MUST NOT</bcp14>
 consider
unknown stream types to be a <xref format='none' target='errors'>connection error</xref><iref item='connection error'/> of any kind.</t>
        <t>As certain stream types can affect connection state, a recipient          <bcp14>SHOULD NOT</bcp14>

discard data from incoming unidirectional streams prior to reading the stream
type.</t>
        <t>Implementations          <bcp14>MAY</bcp14>
 send stream types before knowing whether the peer supports
them.  However, stream types that could modify the state or semantics of
existing protocol components, including QPACK or other extensions,          <bcp14>MUST NOT</bcp14>
 be
sent until the peer is known to support them.</t>
        <t>A sender can close or reset a unidirectional stream unless otherwise specified.
A receiver          <bcp14>MUST</bcp14>
 tolerate unidirectional streams being closed or reset prior to
the reception of the unidirectional stream header.</t>
        <section anchor='control-streams'>
          <name>Control Streams</name><iref item='control stream' primary='true'/>
          <t>A control stream is indicated by a stream type of 0x00.  Data on this stream
consists of HTTP/3 frames, as defined in <xref target='frames'/>.</t>
          <t>Each side            <bcp14>MUST</bcp14>
 initiate a single control stream at the beginning of the
connection and send its <xref format='none' target='frame-settings'>SETTINGS</xref><iref item='SETTINGS'/> frame as the first frame on this stream.  If
the first frame of the control stream is any other frame type, this            <bcp14>MUST</bcp14>
 be
treated as a <xref format='none' target='errors'>connection error</xref><iref item='connection error'/> of type <xref format='none' target='H3_MISSING_SETTINGS'>H3_MISSING_SETTINGS</xref><iref item='H3_MISSING_SETTINGS'/>. Only one control
stream per peer is permitted; receipt of a second stream claiming to be a
control stream            <bcp14>MUST</bcp14>
 be treated as a <xref format='none' target='errors'>connection error</xref><iref item='connection error'/> of type
<xref format='none' target='H3_STREAM_CREATION_ERROR'>H3_STREAM_CREATION_ERROR</xref><iref item='H3_STREAM_CREATION_ERROR'/>.  The sender            <bcp14>MUST NOT</bcp14>
 close the control stream, and the
receiver            <bcp14>MUST NOT</bcp14>
 request that the sender close the control stream.  If either
control stream is closed at any point, this            <bcp14>MUST</bcp14>
 be treated as a <xref format='none' target='errors'>connection
error</xref><iref item='connection error'/> of type <xref format='none' target='H3_CLOSED_CRITICAL_STREAM'>H3_CLOSED_CRITICAL_STREAM</xref><iref item='H3_CLOSED_CRITICAL_STREAM'/>.  Connection errors are described in
<xref target='errors'/>.</t>
          <t>Because the contents of the control stream are used to manage the behavior of
other streams, endpoints            <bcp14>SHOULD</bcp14>
 provide enough flow-control credit to keep the
peer's control stream from becoming blocked.</t>
          <t>A pair of unidirectional streams is used rather than a single bidirectional
stream.  This allows either peer to send data as soon as it is able.  Depending
on whether 0-RTT is available on the QUIC connection, either client or server
might be able to send stream data first.</t>
        </section>
        <section anchor='push-streams'>
          <name>Push Streams</name><iref item='push stream' primary='true'/>
          <t>Server push is an optional feature introduced in HTTP/2 that allows a server to
initiate a response before a request has been made.  See <xref target='server-push'/> for
more details.</t>
          <t>A push stream is indicated by a stream type of 0x01, followed by the <xref format='none' target='server-push'>push ID</xref><iref item='push ID'/>
of the promise that it fulfills, encoded as a variable-length integer. The
remaining data on this stream consists of HTTP/3 frames, as defined in
<xref target='frames'/>, and fulfills a promised server push by zero or more interim HTTP
responses followed by a single final HTTP response, as defined in
<xref target='request-response'/>.  Server push and push IDs are described in
<xref target='server-push'/>.</t>
          <t>Only servers can push; if a server receives a client-initiated push stream, this            <bcp14>MUST</bcp14>
 be treated as a <xref format='none' target='errors'>connection error</xref><iref item='connection error'/> of type <xref format='none' target='H3_STREAM_CREATION_ERROR'>H3_STREAM_CREATION_ERROR</xref><iref item='H3_STREAM_CREATION_ERROR'/>.</t>
          <figure>
            <name>Push Stream Header</name>
            <artwork type='ascii-art'><![CDATA[
Push Stream Header {
  Stream Type (i) = 0x01,
  Push ID (i),
}
]]></artwork>
          </figure>
          <t>A client            <bcp14>SHOULD NOT</bcp14>
 abort reading on a push stream prior to reading the push
stream header, as this could lead to disagreement between client and server on
which push IDs have already been consumed.</t>
          <t>Each <xref format='none' target='server-push'>push ID</xref><iref item='push ID'/>            <bcp14>MUST</bcp14>
 only be used once in a push stream header. If a client detects
that a push stream header includes a <xref format='none' target='server-push'>push ID</xref><iref item='push ID'/> that was used in another push
stream header, the client            <bcp14>MUST</bcp14>
 treat this as a <xref format='none' target='errors'>connection error</xref><iref item='connection error'/> of type
<xref format='none' target='H3_ID_ERROR'>H3_ID_ERROR</xref><iref item='H3_ID_ERROR'/>.</t>
        </section>
        <section anchor='stream-grease'>
          <name>Reserved Stream Types</name>
          <t>Stream types of the format <tt>0x1f * N + 0x21</tt> for non-negative integer values of
<tt>N</tt> are reserved to exercise the requirement that unknown types be ignored.
These streams have no semantics, and they can be sent when application-layer
padding is desired. They            <bcp14>MAY</bcp14>
 also be sent on connections where no data is
currently being transferred. Endpoints            <bcp14>MUST NOT</bcp14>
 consider these streams to have
any meaning upon receipt.</t>
          <t>The payload and length of the stream are selected in any manner the sending
implementation chooses.  When sending a reserved stream type, the implementation            <bcp14>MAY</bcp14>
 either terminate the stream cleanly or reset it.  When resetting the stream,
either the <xref format='none' target='H3_NO_ERROR'>H3_NO_ERROR</xref><iref item='H3_NO_ERROR'/> error code or a reserved error code
(<xref target='http-error-codes'/>)            <bcp14>SHOULD</bcp14>
 be used.</t>
        </section>
      </section>
    </section>
    <section anchor='http-framing-layer'>
      <name>HTTP Framing Layer</name>
      <t>HTTP frames are carried on QUIC streams, as described in <xref target='stream-mapping'/>.
HTTP/3 defines three stream types: <xref format='none' target='control-streams'>control stream</xref><iref item='control stream'/>, <xref format='none' target='request-streams'>request stream</xref><iref item='request stream'/>, and <xref format='none' target='push-streams'>push
stream</xref><iref item='push stream'/>. This section describes HTTP/3 frame formats and their permitted stream
types; see <xref target='stream-frame-mapping'/> for an overview.  A comparison between
HTTP/2 and HTTP/3 frames is provided in <xref target='h2-frames'/>.</t>
      <table anchor='stream-frame-mapping'>
        <name>HTTP/3 Frames and Stream Type Overview</name>
        <thead>
          <tr>
            <th align='left'>Frame</th>
            <th align='left'>Control Stream</th>
            <th align='left'>Request Stream</th>
            <th align='left'>Push Stream</th>
            <th align='left'>Section</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align='left'><xref format='none' target='frame-data'>DATA</xref><iref item='DATA'/></td>
            <td align='left'>No</td>
            <td align='left'>Yes</td>
            <td align='left'>Yes</td>
            <td align='left'><xref target='frame-data'/></td>
          </tr>
          <tr>
            <td align='left'><xref format='none' target='frame-headers'>HEADERS</xref><iref item='HEADERS'/></td>
            <td align='left'>No</td>
            <td align='left'>Yes</td>
            <td align='left'>Yes</td>
            <td align='left'><xref target='frame-headers'/></td>
          </tr>
          <tr>
            <td align='left'><xref format='none' target='frame-cancel-push'>CANCEL_PUSH</xref><iref item='CANCEL_PUSH'/></td>
            <td align='left'>Yes</td>
            <td align='left'>No</td>
            <td align='left'>No</td>
            <td align='left'><xref target='frame-cancel-push'/></td>
          </tr>
          <tr>
            <td align='left'><xref format='none' target='frame-settings'>SETTINGS</xref><iref item='SETTINGS'/></td>
            <td align='left'>Yes (1)</td>
            <td align='left'>No</td>
            <td align='left'>No</td>
            <td align='left'><xref target='frame-settings'/></td>
          </tr>
          <tr>
            <td align='left'><xref format='none' target='frame-push-promise'>PUSH_PROMISE</xref><iref item='PUSH_PROMISE'/></td>
            <td align='left'>No</td>
            <td align='left'>Yes</td>
            <td align='left'>No</td>
            <td align='left'><xref target='frame-push-promise'/></td>
          </tr>
          <tr>
            <td align='left'><xref format='none' target='frame-goaway'>GOAWAY</xref><iref item='GOAWAY'/></td>
            <td align='left'>Yes</td>
            <td align='left'>No</td>
            <td align='left'>No</td>
            <td align='left'><xref target='frame-goaway'/></td>
          </tr>
          <tr>
            <td align='left'><xref format='none' target='frame-max-push-id'>MAX_PUSH_ID</xref><iref item='MAX_PUSH_ID'/></td>
            <td align='left'>Yes</td>
            <td align='left'>No</td>
            <td align='left'>No</td>
            <td align='left'><xref target='frame-max-push-id'/></td>
          </tr>
          <tr>
            <td align='left'>Reserved</td>
            <td align='left'>Yes</td>
            <td align='left'>Yes</td>
            <td align='left'>Yes</td>
            <td align='left'><xref target='frame-reserved'/></td>
          </tr>
        </tbody>
      </table>
      <t>The <xref format='none' target='frame-settings'>SETTINGS</xref><iref item='SETTINGS'/> frame can only occur as the first frame of a Control stream; this
is indicated in <xref target='stream-frame-mapping'/> with a (1).  Specific guidance
is provided in the relevant section.</t>
      <t>Note that, unlike QUIC frames, HTTP/3 frames can span multiple packets.</t>
      <section anchor='frame-layout'>
        <name>Frame Layout</name>
        <t>All frames have the following format:</t>
        <figure>
          <name>HTTP/3 Frame Format</name>
          <artwork type='ascii-art'><![CDATA[
HTTP/3 Frame Format {
  Type (i),
  Length (i),
  Frame Payload (..),
}
]]></artwork>
        </figure>
        <t>A frame includes the following fields:</t>
        <dl>
          <dt>Type:</dt>
          <dd>
            <t>A variable-length integer that identifies the frame type.</t>
          </dd>
          <dt>Length:</dt>
          <dd>
            <t>A variable-length integer that describes the length in bytes of
the Frame Payload.</t>
          </dd>
          <dt>Frame Payload:</dt>
          <dd>
            <t>A payload, the semantics of which are determined by the Type field.</t>
          </dd>
        </dl>
        <t>Each frame's payload          <bcp14>MUST</bcp14>
 contain exactly the fields identified in its
description.  A frame payload that contains additional bytes after the
identified fields or a frame payload that terminates before the end of the
identified fields          <bcp14>MUST</bcp14>
 be treated as a <xref format='none' target='errors'>connection error</xref><iref item='connection error'/> of type
<xref format='none' target='H3_FRAME_ERROR'>H3_FRAME_ERROR</xref><iref item='H3_FRAME_ERROR'/>.  In particular, redundant length encodings          <bcp14>MUST</bcp14>

be verified to be self-consistent; see <xref target='frame-parsing'/>.</t>
        <t>When a stream terminates cleanly, if the last frame on the stream was truncated,
this          <bcp14>MUST</bcp14>
 be treated as a <xref format='none' target='errors'>connection error</xref><iref item='connection error'/> of type <xref format='none' target='H3_FRAME_ERROR'>H3_FRAME_ERROR</xref><iref item='H3_FRAME_ERROR'/>. Streams that
terminate abruptly may be reset at any point in a frame.</t>
      </section>
      <section anchor='frames'>
        <name>Frame Definitions</name>
        <section anchor='frame-data'>
          <name>DATA</name><iref item='DATA' primary='true'/>
          <t>DATA frames (type=0x00) convey arbitrary, variable-length sequences of bytes
associated with HTTP request or response content.</t>
          <t>DATA frames            <bcp14>MUST</bcp14>
 be associated with an HTTP request or response.  If a DATA
frame is received on a <xref format='none' target='control-streams'>control stream</xref><iref item='control stream'/>, the recipient            <bcp14>MUST</bcp14>
 respond with a
<xref format='none' target='errors'>connection error</xref><iref item='connection error'/> of type <xref format='none' target='H3_FRAME_UNEXPECTED'>H3_FRAME_UNEXPECTED</xref><iref item='H3_FRAME_UNEXPECTED'/>.</t>
          <figure>
            <name>DATA Frame</name>
            <artwork type='ascii-art'><![CDATA[
DATA Frame {
  Type (i) = 0x00,
  Length (i),
  Data (..),
}
]]></artwork>
          </figure>
        </section>
        <section anchor='frame-headers'>
          <name>HEADERS</name><iref item='HEADERS' primary='true'/>
          <t>The HEADERS frame (type=0x01) is used to carry an HTTP field section that is
encoded using QPACK. See <xref target='RFC9204'/> for more details.</t>
          <figure>
            <name>HEADERS Frame</name>
            <artwork type='ascii-art'><![CDATA[
HEADERS Frame {
  Type (i) = 0x01,
  Length (i),
  Encoded Field Section (..),
}
]]></artwork>
          </figure>
          <t>HEADERS frames can only be sent on <xref format='none' target='request-streams'>request streams</xref><iref item='request stream'/> or <xref format='none' target='push-streams'>push streams</xref><iref item='push stream'/>.  If a
HEADERS frame is received on a <xref format='none' target='control-streams'>control stream</xref><iref item='control stream'/>, the recipient            <bcp14>MUST</bcp14>
 respond with a
<xref format='none' target='errors'>connection error</xref><iref item='connection error'/> of type <xref format='none' target='H3_FRAME_UNEXPECTED'>H3_FRAME_UNEXPECTED</xref><iref item='H3_FRAME_UNEXPECTED'/>.</t>
        </section>
        <section anchor='frame-cancel-push'>
          <name>CANCEL_PUSH</name><iref item='CANCEL_PUSH' primary='true'/>
          <t>The CANCEL_PUSH frame (type=0x03) is used to request cancellation of a server
push prior to the <xref format='none' target='push-streams'>push stream</xref><iref item='push stream'/> being received.  The CANCEL_PUSH frame identifies
a server push by <xref format='none' target='server-push'>push ID</xref><iref item='push ID'/> (see <xref target='server-push'/>), encoded as a variable-length
integer.</t>
          <t>When a client sends a CANCEL_PUSH frame, it is indicating that it does not wish
to receive the promised resource.  The server            <bcp14>SHOULD</bcp14>
 abort sending the resource,
but the mechanism to do so depends on the state of the corresponding <xref format='none' target='push-streams'>push
stream</xref><iref item='push stream'/>.  If the server has not yet created a <xref format='none' target='push-streams'>push stream</xref><iref item='push stream'/>, it does not create
one.  If the <xref format='none' target='push-streams'>push stream</xref><iref item='push stream'/> is open, the server            <bcp14>SHOULD</bcp14>
 abruptly terminate that
stream.  If the <xref format='none' target='push-streams'>push stream</xref><iref item='push stream'/> has already ended, the server            <bcp14>MAY</bcp14>
 still abruptly
terminate the stream or            <bcp14>MAY</bcp14>
 take no action.</t>
          <t>A server sends a CANCEL_PUSH frame to indicate that it will not be fulfilling a
promise that was previously sent.  The client cannot expect the corresponding
promise to be fulfilled, unless it has already received and processed the
promised response. Regardless of whether a <xref format='none' target='push-streams'>push stream</xref><iref item='push stream'/> has been opened, a server            <bcp14>SHOULD</bcp14>
 send a CANCEL_PUSH frame when it determines that promise will not be
fulfilled.  If a stream has already been opened, the server can abort sending on
the stream with an error code of <xref format='none' target='H3_REQUEST_CANCELLED'>H3_REQUEST_CANCELLED</xref><iref item='H3_REQUEST_CANCELLED'/>.</t>
          <t>Sending a CANCEL_PUSH frame has no direct effect on the state of existing <xref format='none' target='push-streams'>push
streams</xref><iref item='push stream'/>. A client            <bcp14>SHOULD NOT</bcp14>
 send a CANCEL_PUSH frame when it has already
received a corresponding <xref format='none' target='push-streams'>push stream</xref><iref item='push stream'/>.  A <xref format='none' target='push-streams'>push stream</xref><iref item='push stream'/> could arrive after a client
has sent a CANCEL_PUSH frame, because a server might not have processed the
CANCEL_PUSH. The client            <bcp14>SHOULD</bcp14>
 abort reading the stream with an error code of
<xref format='none' target='H3_REQUEST_CANCELLED'>H3_REQUEST_CANCELLED</xref><iref item='H3_REQUEST_CANCELLED'/>.</t>
          <t>A CANCEL_PUSH frame is sent on the <xref format='none' target='control-streams'>control stream</xref><iref item='control stream'/>.  Receiving a CANCEL_PUSH
frame on a stream other than the <xref format='none' target='control-streams'>control stream</xref><iref item='control stream'/>            <bcp14>MUST</bcp14>
 be treated as a <xref format='none' target='errors'>connection
error</xref><iref item='connection error'/> of type <xref format='none' target='H3_FRAME_UNEXPECTED'>H3_FRAME_UNEXPECTED</xref><iref item='H3_FRAME_UNEXPECTED'/>.</t>
          <figure>
            <name>CANCEL_PUSH Frame</name>
            <artwork type='ascii-art'><![CDATA[
CANCEL_PUSH Frame {
  Type (i) = 0x03,
  Length (i),
  Push ID (i),
}
]]></artwork>
          </figure>
          <t>The CANCEL_PUSH frame carries a <xref format='none' target='server-push'>push ID</xref><iref item='push ID'/> encoded as a variable-length integer.
The Push ID field identifies the server push that is being cancelled; see
<xref target='server-push'/>.  If a CANCEL_PUSH frame is received that references a <xref format='none' target='server-push'>push ID</xref><iref item='push ID'/>
greater than currently allowed on the connection, this            <bcp14>MUST</bcp14>
 be treated as a
<xref format='none' target='errors'>connection error</xref><iref item='connection error'/> of type <xref format='none' target='H3_ID_ERROR'>H3_ID_ERROR</xref><iref item='H3_ID_ERROR'/>.</t>
          <t>If the client receives a CANCEL_PUSH frame, that frame might identify a <xref format='none' target='server-push'>push ID</xref><iref item='push ID'/>
that has not yet been mentioned by a <xref format='none' target='frame-push-promise'>PUSH_PROMISE</xref><iref item='PUSH_PROMISE'/> frame due to reordering.  If a
server receives a CANCEL_PUSH frame for a <xref format='none' target='server-push'>push ID</xref><iref item='push ID'/> that has not yet been
mentioned by a <xref format='none' target='frame-push-promise'>PUSH_PROMISE</xref><iref item='PUSH_PROMISE'/> frame, this            <bcp14>MUST</bcp14>
 be treated as a <xref format='none' target='errors'>connection error</xref><iref item='connection error'/> of
type <xref format='none' target='H3_ID_ERROR'>H3_ID_ERROR</xref><iref item='H3_ID_ERROR'/>.</t>
        </section>
        <section anchor='frame-settings'>
          <name>SETTINGS</name><iref item='SETTINGS' primary='true'/>
          <t>The SETTINGS frame (type=0x04) conveys configuration parameters that affect how
endpoints communicate, such as preferences and constraints on peer behavior.
Individually, a SETTINGS parameter can also be referred to as a "setting"; the
identifier and value of each setting parameter can be referred to as a "setting
identifier" and a "setting value".</t>
          <t>SETTINGS frames always apply to an entire HTTP/3 connection, never a single
stream.  A SETTINGS frame            <bcp14>MUST</bcp14>
 be sent as the first frame of each <xref format='none' target='control-streams'>control stream</xref><iref item='control stream'/>
(see <xref target='control-streams'/>) by each peer, and it            <bcp14>MUST NOT</bcp14>
 be sent subsequently. If
an endpoint receives a second SETTINGS frame on the <xref format='none' target='control-streams'>control stream</xref><iref item='control stream'/>, the endpoint            <bcp14>MUST</bcp14>
 respond with a <xref format='none' target='errors'>connection error</xref><iref item='connection error'/> of type <xref format='none' target='H3_FRAME_UNEXPECTED'>H3_FRAME_UNEXPECTED</xref><iref item='H3_FRAME_UNEXPECTED'/>.</t>
          <t>SETTINGS frames            <bcp14>MUST NOT</bcp14>
 be sent on any stream other than the <xref format='none' target='control-streams'>control stream</xref><iref item='control stream'/>.
If an endpoint receives a SETTINGS frame on a different stream, the endpoint            <bcp14>MUST</bcp14>
 respond with a <xref format='none' target='errors'>connection error</xref><iref item='connection error'/> of type <xref format='none' target='H3_FRAME_UNEXPECTED'>H3_FRAME_UNEXPECTED</xref><iref item='H3_FRAME_UNEXPECTED'/>.</t>
          <t>SETTINGS parameters are not negotiated; they describe characteristics of the
sending peer that can be used by the receiving peer. However, a negotiation
can be implied by the use of SETTINGS: each peer uses SETTINGS to advertise a
set of supported values. The definition of the setting would describe how each
peer combines the two sets to conclude which choice will be used.  SETTINGS does
not provide a mechanism to identify when the choice takes effect.</t>
          <t>Different values for the same parameter can be advertised by each peer. For
example, a client might be willing to consume a very large response field
section, while servers are more cautious about request size.</t>
          <t>The same setting identifier            <bcp14>MUST NOT</bcp14>
 occur more than once in the SETTINGS frame.
A receiver            <bcp14>MAY</bcp14>
 treat the presence of duplicate setting identifiers as a
<xref format='none' target='errors'>connection error</xref><iref item='connection error'/> of type <xref format='none' target='H3_SETTINGS_ERROR'>H3_SETTINGS_ERROR</xref><iref item='H3_SETTINGS_ERROR'/>.</t>
          <t>The payload of a SETTINGS frame consists of zero or more parameters.  Each
parameter consists of a setting identifier and a value, both encoded as QUIC
variable-length integers.</t>
          <figure>
            <name>SETTINGS Frame</name>
            <artwork type='ascii-art'><![CDATA[
Setting {
  Identifier (i),
  Value (i),
}

SETTINGS Frame {
  Type (i) = 0x04,
  Length (i),
  Setting (..) ...,
}
]]></artwork>
          </figure>
          <t>An implementation            <bcp14>MUST</bcp14>
 ignore any parameter with an identifier it does
not understand.</t>
          <section anchor='settings-parameters'>
            <name>Defined SETTINGS Parameters</name>
            <t>The following settings are defined in HTTP/3:</t>
            <dl>
              <dt>SETTINGS_MAX_FIELD_SECTION_SIZE (0x06)<iref item='SETTINGS_MAX_FIELD_SECTION_SIZE'/>:</dt>
              <dd>
                <t anchor='SETTINGS_MAX_FIELD_SECTION_SIZE'>The default value is unlimited.  See <xref target='header-size-constraints'/> for usage.</t>
              </dd>
            </dl>
            <t>Setting identifiers of the format <tt>0x1f * N + 0x21</tt> for non-negative integer
values of <tt>N</tt> are reserved to exercise the requirement that unknown identifiers
be ignored.  Such settings have no defined meaning. Endpoints              <bcp14>SHOULD</bcp14>
 include at
least one such setting in their SETTINGS frame. Endpoints              <bcp14>MUST NOT</bcp14>
 consider such
settings to have any meaning upon receipt.</t>
            <t>Because the setting has no defined meaning, the value of the setting can be any
value the implementation selects.</t>
            <t>Setting identifiers that were defined in <xref target='RFC9113'/> where there is no
corresponding HTTP/3 setting have also been reserved (<xref target='iana-settings'/>). These
reserved settings              <bcp14>MUST NOT</bcp14>
 be sent, and their receipt              <bcp14>MUST</bcp14>
 be treated as a
<xref format='none' target='errors'>connection error</xref><iref item='connection error'/> of type <xref format='none' target='H3_SETTINGS_ERROR'>H3_SETTINGS_ERROR</xref><iref item='H3_SETTINGS_ERROR'/>.</t>
            <t>Additional settings can be defined by extensions to HTTP/3; see <xref target='extensions'/>
for more details.</t>
          </section>
          <section anchor='settings-initialization'>
            <name>Initialization</name>
            <t>An HTTP implementation              <bcp14>MUST NOT</bcp14>
 send frames or requests that would be invalid
based on its current understanding of the peer's settings.</t>
            <t>All settings begin at an initial value.  Each endpoint              <bcp14>SHOULD</bcp14>
 use these initial
values to send messages before the peer's SETTINGS frame has arrived, as packets
carrying the settings can be lost or delayed.  When the SETTINGS frame arrives,
any settings are changed to their new values.</t>
            <t>This removes the need to wait for the SETTINGS frame before sending messages.
Endpoints              <bcp14>MUST NOT</bcp14>
 require any data to be received from the peer prior to
sending the SETTINGS frame; settings              <bcp14>MUST</bcp14>
 be sent as soon as the transport is
ready to send data.</t>
            <t>For servers, the initial value of each client setting is the default value.</t>
            <t>For clients using a 1-RTT QUIC connection, the initial value of each server
setting is the default value.  1-RTT keys will always become available prior to
the packet containing SETTINGS being processed by QUIC, even if the server sends
SETTINGS immediately.  Clients              <bcp14>SHOULD NOT</bcp14>
 wait indefinitely for SETTINGS to
arrive before sending requests, but they              <bcp14>SHOULD</bcp14>
 process received datagrams in
order to increase the likelihood of processing SETTINGS before sending the first
request.</t>
            <t>When a 0-RTT QUIC connection is being used, the initial value of each server
setting is the value used in the previous session. Clients              <bcp14>SHOULD</bcp14>
 store the
settings the server provided in the HTTP/3 connection where resumption
information was provided, but they              <bcp14>MAY</bcp14>
 opt not to store settings in certain
cases (e.g., if the session ticket is received before the SETTINGS frame). A
client              <bcp14>MUST</bcp14>
 comply with stored settings -- or default values if no values are
stored -- when attempting 0-RTT. Once a server has provided new settings,
clients              <bcp14>MUST</bcp14>
 comply with those values.</t>
            <t>A server can remember the settings that it advertised or store an
integrity-protected copy of the values in the ticket and recover the information
when accepting 0-RTT data. A server uses the HTTP/3 settings values in
determining whether to accept 0-RTT data.  If the server cannot determine that
the settings remembered by a client are compatible with its current settings, it              <bcp14>MUST NOT</bcp14>
 accept 0-RTT data.  Remembered settings are compatible if a client
complying with those settings would not violate the server's current settings.</t>
            <t>A server              <bcp14>MAY</bcp14>
 accept 0-RTT and subsequently provide different settings in its
SETTINGS frame. If 0-RTT data is accepted by the server, its SETTINGS frame              <bcp14>MUST
NOT</bcp14>
 reduce any limits or alter any values that might be violated by the client
with its 0-RTT data.  The server              <bcp14>MUST</bcp14>
 include all settings that differ from
their default values.  If a server accepts 0-RTT but then sends settings that
are not compatible with the previously specified settings, this              <bcp14>MUST</bcp14>
 be treated
as a <xref format='none' target='errors'>connection error</xref><iref item='connection error'/> of type <xref format='none' target='H3_SETTINGS_ERROR'>H3_SETTINGS_ERROR</xref><iref item='H3_SETTINGS_ERROR'/>. If a server accepts 0-RTT but
then sends a SETTINGS frame that omits a setting value that the client
understands (apart from reserved setting identifiers) that was previously
specified to have a non-default value, this              <bcp14>MUST</bcp14>
 be treated as a <xref format='none' target='errors'>connection
error</xref><iref item='connection error'/> of type <xref format='none' target='H3_SETTINGS_ERROR'>H3_SETTINGS_ERROR</xref><iref item='H3_SETTINGS_ERROR'/>.</t>
          </section>
        </section>
        <section anchor='frame-push-promise'>
          <name>PUSH_PROMISE</name><iref item='PUSH_PROMISE' primary='true'/>
          <t>The PUSH_PROMISE frame (type=0x05) is used to carry a promised request header
section from server to client on a <xref format='none' target='request-streams'>request stream</xref><iref item='request stream'/>.</t>
          <figure>
            <name>PUSH_PROMISE Frame</name>
            <artwork type='ascii-art'><![CDATA[
PUSH_PROMISE Frame {
  Type (i) = 0x05,
  Length (i),
  Push ID (i),
  Encoded Field Section (..),
}
]]></artwork>
          </figure>
          <t>The payload consists of:</t>
          <dl>
            <dt>Push ID:</dt>
            <dd>
              <t>A variable-length integer that identifies the server push operation.  A <xref format='none' target='server-push'>push
ID</xref><iref item='push ID'/> is used in <xref format='none' target='push-streams'>push stream</xref><iref item='push stream'/> headers (<xref target='server-push'/>) and <xref format='none' target='frame-cancel-push'>CANCEL_PUSH</xref><iref item='CANCEL_PUSH'/> frames.</t>
            </dd>
            <dt>Encoded Field Section:</dt>
            <dd>
              <t>QPACK-encoded request header fields for the promised response.  See
<xref target='RFC9204'/> for more details.</t>
            </dd>
          </dl>
          <t>A server            <bcp14>MUST NOT</bcp14>
 use a <xref format='none' target='server-push'>push ID</xref><iref item='push ID'/> that is larger than the client has provided in a
<xref format='none' target='frame-max-push-id'>MAX_PUSH_ID</xref><iref item='MAX_PUSH_ID'/> frame (<xref target='frame-max-push-id'/>). A client            <bcp14>MUST</bcp14>
 treat receipt of a
PUSH_PROMISE frame that contains a larger <xref format='none' target='server-push'>push ID</xref><iref item='push ID'/> than the client has advertised
as a <xref format='none' target='errors'>connection error</xref><iref item='connection error'/> of <xref format='none' target='H3_ID_ERROR'>H3_ID_ERROR</xref><iref item='H3_ID_ERROR'/>.</t>
          <t>A server            <bcp14>MAY</bcp14>
 use the same <xref format='none' target='server-push'>push ID</xref><iref item='push ID'/> in multiple PUSH_PROMISE frames. If so, the
decompressed request header sets            <bcp14>MUST</bcp14>
 contain the same fields in the same order,
and both the name and the value in each field            <bcp14>MUST</bcp14>
 be exact matches. Clients            <bcp14>SHOULD</bcp14>
 compare the request header sections for resources promised multiple
times. If a client receives a <xref format='none' target='server-push'>push ID</xref><iref item='push ID'/> that has already been promised and detects
a mismatch, it            <bcp14>MUST</bcp14>
 respond with a <xref format='none' target='errors'>connection error</xref><iref item='connection error'/> of type
<xref format='none' target='H3_GENERAL_PROTOCOL_ERROR'>H3_GENERAL_PROTOCOL_ERROR</xref><iref item='H3_GENERAL_PROTOCOL_ERROR'/>. If the decompressed field sections match exactly, the
client            <bcp14>SHOULD</bcp14>
 associate the pushed content with each stream on which a
PUSH_PROMISE frame was received.</t>
          <t>Allowing duplicate references to the same <xref format='none' target='server-push'>push ID</xref><iref item='push ID'/> is primarily to reduce
duplication caused by concurrent requests.  A server            <bcp14>SHOULD</bcp14>
 avoid reusing a <xref format='none' target='server-push'>push
ID</xref><iref item='push ID'/> over a long period.  Clients are likely to consume server push responses and
not retain them for reuse over time.  Clients that see a PUSH_PROMISE frame that
uses a <xref format='none' target='server-push'>push ID</xref><iref item='push ID'/> that they have already consumed and discarded are forced to
ignore the promise.</t>
          <t>If a PUSH_PROMISE frame is received on the <xref format='none' target='control-streams'>control stream</xref><iref item='control stream'/>, the client            <bcp14>MUST</bcp14>

respond with a <xref format='none' target='errors'>connection error</xref><iref item='connection error'/> of type <xref format='none' target='H3_FRAME_UNEXPECTED'>H3_FRAME_UNEXPECTED</xref><iref item='H3_FRAME_UNEXPECTED'/>.</t>
          <t>A client            <bcp14>MUST NOT</bcp14>
 send a PUSH_PROMISE frame.  A server            <bcp14>MUST</bcp14>
 treat the receipt of
a PUSH_PROMISE frame as a <xref format='none' target='errors'>connection error</xref><iref item='connection error'/> of type <xref format='none' target='H3_FRAME_UNEXPECTED'>H3_FRAME_UNEXPECTED</xref><iref item='H3_FRAME_UNEXPECTED'/>.</t>
          <t>See <xref target='server-push'/> for a description of the overall server push mechanism.</t>
        </section>
        <section anchor='frame-goaway'>
          <name>GOAWAY</name><iref item='GOAWAY' primary='true'/>
          <t>The GOAWAY frame (type=0x07) is used to initiate graceful shutdown of an HTTP/3
connection by either endpoint.  GOAWAY allows an endpoint to stop accepting new
requests or pushes while still finishing processing of previously received
requests and pushes.  This enables administrative actions, like server
maintenance.  GOAWAY by itself does not close a connection.</t>
          <figure>
            <name>GOAWAY Frame</name>
            <artwork type='ascii-art'><![CDATA[
GOAWAY Frame {
  Type (i) = 0x07,
  Length (i),
  Stream ID/Push ID (i),
}
]]></artwork>
          </figure>
          <t>The GOAWAY frame is always sent on the <xref format='none' target='control-streams'>control stream</xref><iref item='control stream'/>.  In the server-to-client
direction, it carries a QUIC stream ID for a client-initiated bidirectional
stream encoded as a variable-length integer.  A client            <bcp14>MUST</bcp14>
 treat receipt of a
GOAWAY frame containing a stream ID of any other type as a <xref format='none' target='errors'>connection error</xref><iref item='connection error'/> of
type <xref format='none' target='H3_ID_ERROR'>H3_ID_ERROR</xref><iref item='H3_ID_ERROR'/>.</t>
          <t>In the client-to-server direction, the GOAWAY frame carries a <xref format='none' target='server-push'>push ID</xref><iref item='push ID'/> encoded as
a variable-length integer.</t>
          <t>The GOAWAY frame applies to the entire connection, not a specific stream.  A
client            <bcp14>MUST</bcp14>
 treat a GOAWAY frame on a stream other than the <xref format='none' target='control-streams'>control stream</xref><iref item='control stream'/> as a
<xref format='none' target='errors'>connection error</xref><iref item='connection error'/> of type <xref format='none' target='H3_FRAME_UNEXPECTED'>H3_FRAME_UNEXPECTED</xref><iref item='H3_FRAME_UNEXPECTED'/>.</t>
          <t>See <xref target='connection-shutdown'/> for more information on the use of the GOAWAY frame.</t>
        </section>
        <section anchor='frame-max-push-id'>
          <name>MAX_PUSH_ID</name><iref item='MAX_PUSH_ID' primary='true'/>
          <t>The MAX_PUSH_ID frame (type=0x0d) is used by clients to control the number of
server pushes that the server can initiate.  This sets the maximum value for a
<xref format='none' target='server-push'>push ID</xref><iref item='push ID'/> that the server can use in <xref format='none' target='frame-push-promise'>PUSH_PROMISE</xref><iref item='PUSH_PROMISE'/> and <xref format='none' target='frame-cancel-push'>CANCEL_PUSH</xref><iref item='CANCEL_PUSH'/> frames.
Consequently, this also limits the number of <xref format='none' target='push-streams'>push streams</xref><iref item='push stream'/> that the server can
initiate in addition to the limit maintained by the QUIC transport.</t>
          <t>The MAX_PUSH_ID frame is always sent on the <xref format='none' target='control-streams'>control stream</xref><iref item='control stream'/>.  Receipt of a
MAX_PUSH_ID frame on any other stream            <bcp14>MUST</bcp14>
 be treated as a <xref format='none' target='errors'>connection error</xref><iref item='connection error'/> of
type <xref format='none' target='H3_FRAME_UNEXPECTED'>H3_FRAME_UNEXPECTED</xref><iref item='H3_FRAME_UNEXPECTED'/>.</t>
          <t>A server            <bcp14>MUST NOT</bcp14>
 send a MAX_PUSH_ID frame.  A client            <bcp14>MUST</bcp14>
 treat the receipt of
a MAX_PUSH_ID frame as a <xref format='none' target='errors'>connection error</xref><iref item='connection error'/> of type <xref format='none' target='H3_FRAME_UNEXPECTED'>H3_FRAME_UNEXPECTED</xref><iref item='H3_FRAME_UNEXPECTED'/>.</t>
          <t>The maximum <xref format='none' target='server-push'>push ID</xref><iref item='push ID'/> is unset when an HTTP/3 connection is created, meaning that
a server cannot push until it receives a MAX_PUSH_ID frame.  A client that
wishes to manage the number of promised server pushes can increase the maximum
<xref format='none' target='server-push'>push ID</xref><iref item='push ID'/> by sending MAX_PUSH_ID frames as the server fulfills or cancels server
pushes.</t>
          <figure>
            <name>MAX_PUSH_ID Frame</name>
            <artwork type='ascii-art'><![CDATA[
MAX_PUSH_ID Frame {
  Type (i) = 0x0d,
  Length (i),
  Push ID (i),
}
]]></artwork>
          </figure>
          <t>The MAX_PUSH_ID frame carries a single variable-length integer that identifies
the maximum value for a <xref format='none' target='server-push'>push ID</xref><iref item='push ID'/> that the server can use; see <xref target='server-push'/>.  A
MAX_PUSH_ID frame cannot reduce the maximum <xref format='none' target='server-push'>push ID</xref><iref item='push ID'/>; receipt of a MAX_PUSH_ID
frame that contains a smaller value than previously received            <bcp14>MUST</bcp14>
 be treated as
a <xref format='none' target='errors'>connection error</xref><iref item='connection error'/> of type <xref format='none' target='H3_ID_ERROR'>H3_ID_ERROR</xref><iref item='H3_ID_ERROR'/>.</t>
        </section>
        <section anchor='frame-reserved'>
          <name>Reserved Frame Types</name>
          <t>Frame types of the format <tt>0x1f * N + 0x21</tt> for non-negative integer values of
<tt>N</tt> are reserved to exercise the requirement that unknown types be ignored
(<xref target='extensions'/>).  These frames have no semantics, and they            <bcp14>MAY</bcp14>
 be sent on any
stream where frames are allowed to be sent. This enables their use for
application-layer padding.  Endpoints            <bcp14>MUST NOT</bcp14>
 consider these frames to have any
meaning upon receipt.</t>
          <t>The payload and length of the frames are selected in any manner the
implementation chooses.</t>
          <t>Frame types that were used in HTTP/2 where there is no corresponding HTTP/3
frame have also been reserved (<xref target='iana-frames'/>).  These frame types            <bcp14>MUST NOT</bcp14>
 be
sent, and their receipt            <bcp14>MUST</bcp14>
 be treated as a <xref format='none' target='errors'>connection error</xref><iref item='connection error'/> of type
<xref format='none' target='H3_FRAME_UNEXPECTED'>H3_FRAME_UNEXPECTED</xref><iref item='H3_FRAME_UNEXPECTED'/>.</t>
        </section>
      </section>
    </section>
    <section anchor='errors'>
      <name>Error Handling</name><iref item='connection error' primary='true'/><iref item='stream error' primary='true'/>
      <t>When a stream cannot be completed successfully, QUIC allows the application to
abruptly terminate (reset) that stream and communicate a reason; see <xref section='2.4' sectionFormat='of' target='QUIC-TRANSPORT'/>. This is referred to as a "stream error". An HTTP/3
implementation can decide to close a QUIC stream and communicate the type of
error. Wire encodings of error codes are defined in <xref target='http-error-codes'/>.
Stream errors are distinct from HTTP status codes that indicate error
conditions. Stream errors indicate that the sender did not transfer or consume
the full request or response, while HTTP status codes indicate the result of a
request that was successfully received.</t>
      <t>If an entire connection needs to be terminated, QUIC similarly provides
mechanisms to communicate a reason; see <xref section='5.3' sectionFormat='of' target='QUIC-TRANSPORT'/>.  This
is referred to as a "connection error".  Similar to stream errors, an HTTP/3
implementation can terminate a QUIC connection and communicate the reason using
an error code from <xref target='http-error-codes'/>.</t>
      <t>Although the reasons for closing streams and connections are called "errors",
these actions do not necessarily indicate a problem with the connection or
either implementation. For example, a stream can be reset if the requested
resource is no longer needed.</t>
      <t>An endpoint        <bcp14>MAY</bcp14>
 choose to treat a stream error as a connection error under
certain circumstances, closing the entire connection in response to a condition
on a single stream.  Implementations need to consider the impact on outstanding
requests before making this choice.</t>
      <t>Because new error codes can be defined without negotiation (see <xref target='extensions'/>),
use of an error code in an unexpected context or receipt of an unknown error
code        <bcp14>MUST</bcp14>
 be treated as equivalent to <xref format='none' target='H3_NO_ERROR'>H3_NO_ERROR</xref><iref item='H3_NO_ERROR'/>.  However, closing a stream
can have other effects regardless of the error code; for example, see
<xref target='request-response'/>.</t>
      <section anchor='http-error-codes'>
        <name>HTTP/3 Error Codes</name>
        <t>The following error codes are defined for use when abruptly terminating streams,
aborting reading of streams, or immediately closing HTTP/3 connections.</t>
        <dl>
          <dt>H3_NO_ERROR (0x0100)<iref item='H3_NO_ERROR'/>:</dt>
          <dd>
            <t anchor='H3_NO_ERROR'>No error.  This is used when the connection or stream needs to be closed, but
there is no error to signal.</t>
          </dd>
          <dt>H3_GENERAL_PROTOCOL_ERROR (0x0101)<iref item='H3_GENERAL_PROTOCOL_ERROR'/>:</dt>
          <dd>
            <t anchor='H3_GENERAL_PROTOCOL_ERROR'>Peer violated protocol requirements in a way that does not match a more
specific error code or endpoint declines to use the more specific error code.</t>
          </dd>
          <dt>H3_INTERNAL_ERROR (0x0102)<iref item='H3_INTERNAL_ERROR'/>:</dt>
          <dd>
            <t anchor='H3_INTERNAL_ERROR'>An internal error has occurred in the HTTP stack.</t>
          </dd>
          <dt>H3_STREAM_CREATION_ERROR (0x0103)<iref item='H3_STREAM_CREATION_ERROR'/>:</dt>
          <dd>
            <t anchor='H3_STREAM_CREATION_ERROR'>The endpoint detected that its peer created a stream that it will not accept.</t>
          </dd>
          <dt>H3_CLOSED_CRITICAL_STREAM (0x0104)<iref item='H3_CLOSED_CRITICAL_STREAM'/>:</dt>
          <dd>
            <t anchor='H3_CLOSED_CRITICAL_STREAM'>A stream required by the HTTP/3 connection was closed or reset.</t>
          </dd>
          <dt>H3_FRAME_UNEXPECTED (0x0105)<iref item='H3_FRAME_UNEXPECTED'/>:</dt>
          <dd>
            <t anchor='H3_FRAME_UNEXPECTED'>A frame was received that was not permitted in the current state or on the
current stream.</t>
          </dd>
          <dt>H3_FRAME_ERROR (0x0106)<iref item='H3_FRAME_ERROR'/>:</dt>
          <dd>
            <t anchor='H3_FRAME_ERROR'>A frame that fails to satisfy layout requirements or with an invalid size
was received.</t>
          </dd>
          <dt>H3_EXCESSIVE_LOAD (0x0107)<iref item='H3_EXCESSIVE_LOAD'/>:</dt>
          <dd>
            <t anchor='H3_EXCESSIVE_LOAD'>The endpoint detected that its peer is exhibiting a behavior that might be
generating excessive load.</t>
          </dd>
          <dt>H3_ID_ERROR (0x0108)<iref item='H3_ID_ERROR'/>:</dt>
          <dd>
            <t anchor='H3_ID_ERROR'>A stream ID or <xref format='none' target='server-push'>push ID</xref><iref item='push ID'/> was used incorrectly, such as exceeding a limit,
reducing a limit, or being reused.</t>
          </dd>
          <dt>H3_SETTINGS_ERROR (0x0109)<iref item='H3_SETTINGS_ERROR'/>:</dt>
          <dd>
            <t anchor='H3_SETTINGS_ERROR'>An endpoint detected an error in the payload of a <xref format='none' target='frame-settings'>SETTINGS</xref><iref item='SETTINGS'/> frame.</t>
          </dd>
          <dt>H3_MISSING_SETTINGS (0x010a)<iref item='H3_MISSING_SETTINGS'/>:</dt>
          <dd>
            <t anchor='H3_MISSING_SETTINGS'>No <xref format='none' target='frame-settings'>SETTINGS</xref><iref item='SETTINGS'/> frame was received at the beginning of the <xref format='none' target='control-streams'>control stream</xref><iref item='control stream'/>.</t>
          </dd>
          <dt>H3_REQUEST_REJECTED (0x010b)<iref item='H3_REQUEST_REJECTED'/>:</dt>
          <dd>
            <t anchor='H3_REQUEST_REJECTED'>A server rejected a request without performing any application processing.</t>
          </dd>
          <dt>H3_REQUEST_CANCELLED (0x010c)<iref item='H3_REQUEST_CANCELLED'/>:</dt>
          <dd>
            <t anchor='H3_REQUEST_CANCELLED'>The request or its response (including pushed response) is cancelled.</t>
          </dd>
          <dt>H3_REQUEST_INCOMPLETE (0x010d)<iref item='H3_REQUEST_INCOMPLETE'/>:</dt>
          <dd>
            <t anchor='H3_REQUEST_INCOMPLETE'>The client's stream terminated without containing a fully formed request.</t>
          </dd>
          <dt>H3_MESSAGE_ERROR (0x010e)<iref item='H3_MESSAGE_ERROR'/>:</dt>
          <dd>
            <t anchor='H3_MESSAGE_ERROR'>An HTTP message was <xref format='none' target='malformed'>malformed</xref><iref item='malformed'/> and cannot be processed.</t>
          </dd>
          <dt>H3_CONNECT_ERROR (0x010f)<iref item='H3_CONNECT_ERROR'/>:</dt>
          <dd>
            <t anchor='H3_CONNECT_ERROR'>The TCP connection established in response to a CONNECT request was reset or
abnormally closed.</t>
          </dd>
          <dt>H3_VERSION_FALLBACK (0x0110)<iref item='H3_VERSION_FALLBACK'/>:</dt>
          <dd>
            <t anchor='H3_VERSION_FALLBACK'>The requested operation cannot be served over HTTP/3.  The peer should
retry over HTTP/1.1.</t>
          </dd>
        </dl>
        <t>Error codes of the format <tt>0x1f * N + 0x21</tt> for non-negative integer values of
<tt>N</tt> are reserved to exercise the requirement that unknown error codes be treated
as equivalent to <xref format='none' target='H3_NO_ERROR'>H3_NO_ERROR</xref><iref item='H3_NO_ERROR'/> (<xref target='extensions'/>). Implementations          <bcp14>SHOULD</bcp14>
 select an
error code from this space with some probability when they would have sent
<xref format='none' target='H3_NO_ERROR'>H3_NO_ERROR</xref><iref item='H3_NO_ERROR'/>.</t>
      </section>
    </section>
    <section anchor='extensions'>
      <name>Extensions to HTTP/3</name>
      <t>HTTP/3 permits extension of the protocol.  Within the limitations described in
this section, protocol extensions can be used to provide additional services or
alter any aspect of the protocol.  Extensions are effective only within the
scope of a single HTTP/3 connection.</t>
      <t>This applies to the protocol elements defined in this document.  This does not
affect the existing options for extending HTTP, such as defining new methods,
status codes, or fields.</t>
      <t>Extensions are permitted to use new frame types (<xref target='frames'/>), new settings
(<xref target='settings-parameters'/>), new error codes (<xref target='errors'/>), or new unidirectional
stream types (<xref target='unidirectional-streams'/>).  Registries are established for
managing these extension points: frame types (<xref target='iana-frames'/>), settings
(<xref target='iana-settings'/>), error codes (<xref target='iana-error-codes'/>), and stream types
(<xref target='iana-stream-types'/>).</t>
      <t>Implementations        <bcp14>MUST</bcp14>
 ignore unknown or unsupported values in all extensible
protocol elements.  Implementations        <bcp14>MUST</bcp14>
 discard data or abort reading on
unidirectional streams that have unknown or unsupported types.  This means that
any of these extension points can be safely used by extensions without prior
arrangement or negotiation.  However, where a known frame type is required to be
in a specific location, such as the <xref format='none' target='frame-settings'>SETTINGS</xref><iref item='SETTINGS'/> frame as the first frame of the
<xref format='none' target='control-streams'>control stream</xref><iref item='control stream'/> (see <xref target='control-streams'/>), an unknown frame type does not satisfy
that requirement and        <bcp14>SHOULD</bcp14>
 be treated as an error.</t>
      <t>Extensions that could change the semantics of existing protocol components        <bcp14>MUST</bcp14>

be negotiated before being used.  For example, an extension that changes the
layout of the <xref format='none' target='frame-headers'>HEADERS</xref><iref item='HEADERS'/> frame cannot be used until the peer has given a positive
signal that this is acceptable.  Coordinating when such a revised layout comes
into effect could prove complex.  As such, allocating new identifiers for
new definitions of existing protocol elements is likely to be more effective.</t>
      <t>This document does not mandate a specific method for negotiating the use of an
extension, but it notes that a setting (<xref target='settings-parameters'/>) could be used
for that purpose.  If both peers set a value that indicates willingness to use
the extension, then the extension can be used.  If a setting is used for
extension negotiation, the default value        <bcp14>MUST</bcp14>
 be defined in such a fashion that
the extension is disabled if the setting is omitted.</t>
    </section>
    <section anchor='security-considerations'>
      <name>Security Considerations</name>
      <t>The security considerations of HTTP/3 should be comparable to those of HTTP/2
with TLS.  However, many of the considerations from <xref section='10' sectionFormat='of' target='RFC9113'/>
apply to <xref target='QUIC-TRANSPORT'/> and are discussed in that document.</t>
      <section anchor='server-authority'>
        <name>Server Authority</name>
        <t>HTTP/3 relies on the HTTP definition of authority. The security considerations
of establishing authority are discussed in <xref section='17.1' sectionFormat='of' target='RFC9110'/>.</t>
      </section>
      <section anchor='cross-protocol-attacks'>
        <name>Cross-Protocol Attacks</name>
        <t>The use of ALPN in the TLS and QUIC handshakes establishes the target
application protocol before application-layer bytes are processed.  This ensures
that endpoints have strong assurances that peers are using the same protocol.</t>
        <t>This does not guarantee protection from all cross-protocol attacks. <xref section='21.5' sectionFormat='of' target='QUIC-TRANSPORT'/> describes some ways in which the plaintext of QUIC
packets can be used to perform request forgery against endpoints that don't use
authenticated transports.</t>
      </section>
      <section anchor='intermediary-encapsulation-attacks'>
        <name>Intermediary-Encapsulation Attacks</name>
        <t>The HTTP/3 field encoding allows the expression of names that are not valid
field names in the syntax used by HTTP (<xref section='5.1' sectionFormat='of' target='RFC9110'/>). Requests or
responses containing invalid field names          <bcp14>MUST</bcp14>
 be treated as <xref format='none' target='malformed'>malformed</xref><iref item='malformed'/>.
Therefore, an intermediary cannot translate an HTTP/3 request or response
containing an invalid field name into an HTTP/1.1 message.</t>
        <t>Similarly, HTTP/3 can transport field values that are not valid. While most
values that can be encoded will not alter field parsing, carriage return (ASCII
0x0d), line feed (ASCII 0x0a), and the null character (ASCII 0x00) might be
exploited by an attacker if they are translated verbatim. Any request or
response that contains a character not permitted in a field value          <bcp14>MUST</bcp14>
 be
treated as <xref format='none' target='malformed'>malformed</xref><iref item='malformed'/>.  Valid characters are defined by the
"field-content" ABNF rule in <xref section='5.5' sectionFormat='of' target='RFC9110'/>.</t>
      </section>
      <section anchor='cacheability-of-pushed-responses'>
        <name>Cacheability of Pushed Responses</name>
        <t>Pushed responses do not have an explicit request from the client; the request is
provided by the server in the <xref format='none' target='frame-push-promise'>PUSH_PROMISE</xref><iref item='PUSH_PROMISE'/> frame.</t>
        <t>Caching responses that are pushed is possible based on the guidance provided by
the origin server in the Cache-Control header field. However, this can cause
issues if a single server hosts more than one tenant.  For example, a server
might offer multiple users each a small portion of its URI space.</t>
        <t>Where multiple tenants share space on the same server, that server          <bcp14>MUST</bcp14>
 ensure
that tenants are not able to push representations of resources that they do not
have authority over.  Failure to enforce this would allow a tenant to provide a
representation that would be served out of cache, overriding the actual
representation that the authoritative tenant provides.</t>
        <t>Clients are required to reject pushed responses for which an origin server is
not authoritative; see <xref target='server-push'/>.</t>
      </section>
      <section anchor='denial-of-service-considerations'>
        <name>Denial-of-Service Considerations</name>
        <t>An HTTP/3 connection can demand a greater commitment of resources to operate
than an HTTP/1.1 or HTTP/2 connection.  The use of field compression and flow
control depend on a commitment of resources for storing a greater amount of
state.  Settings for these features ensure that memory commitments for these
features are strictly bounded.</t>
        <t>The number of <xref format='none' target='frame-push-promise'>PUSH_PROMISE</xref><iref item='PUSH_PROMISE'/> frames is constrained in a similar fashion.  A client
that accepts server push          <bcp14>SHOULD</bcp14>
 limit the number of push IDs it issues at a
time.</t>
        <t>Processing capacity cannot be guarded as effectively as state capacity.</t>
        <t>The ability to send undefined protocol elements that the peer is required to
ignore can be abused to cause a peer to expend additional processing time.  This
might be done by setting multiple undefined <xref format='none' target='frame-settings'>SETTINGS</xref><iref item='SETTINGS'/> parameters, unknown frame
types, or unknown stream types.  Note, however, that some uses are entirely
legitimate, such as optional-to-understand extensions and padding to increase
resistance to traffic analysis.</t>
        <t>Compression of field sections also offers some opportunities to waste processing
resources; see <xref section='7' sectionFormat='of' target='RFC9204'/> for more details on potential abuses.</t>
        <t>All these features -- i.e., server push, unknown protocol elements, field
compression -- have legitimate uses.  These features become a burden only when
they are used unnecessarily or to excess.</t>
        <t>An endpoint that does not monitor such behavior exposes itself to a risk of
denial-of-service attack.  Implementations          <bcp14>SHOULD</bcp14>
 track the use of these
features and set limits on their use.  An endpoint          <bcp14>MAY</bcp14>
 treat activity that is
suspicious as a <xref format='none' target='errors'>connection error</xref><iref item='connection error'/> of type <xref format='none' target='H3_EXCESSIVE_LOAD'>H3_EXCESSIVE_LOAD</xref><iref item='H3_EXCESSIVE_LOAD'/>, but
false positives will result in disrupting valid connections and requests.</t>
        <section anchor='limits-on-field-section-size'>
          <name>Limits on Field Section Size</name>
          <t>A large field section (<xref target='request-response'/>) can cause an implementation to
commit a large amount of state.  Header fields that are critical for routing can
appear toward the end of a header section, which prevents streaming of the
header section to its ultimate destination.  This ordering and other reasons,
such as ensuring cache correctness, mean that an endpoint likely needs to buffer
the entire header section.  Since there is no hard limit to the size of a field
section, some endpoints could be forced to commit a large amount of available
memory for header fields.</t>
          <t>An endpoint can use the <xref format='none' target='SETTINGS_MAX_FIELD_SECTION_SIZE'>SETTINGS_MAX_FIELD_SECTION_SIZE</xref><iref item='SETTINGS_MAX_FIELD_SECTION_SIZE'/>
(<xref target='header-size-constraints'/>) setting to advise peers of limits that might apply
on the size of field sections. This setting is only advisory, so endpoints            <bcp14>MAY</bcp14>

choose to send field sections that exceed this limit and risk having the request
or response being treated as <xref format='none' target='malformed'>malformed</xref><iref item='malformed'/>.  This setting is specific to an HTTP/3
connection, so any request or response could encounter a hop with a lower,
unknown limit.  An intermediary can attempt to avoid this problem by passing on
values presented by different peers, but they are not obligated to do so.</t>
          <t>A server that receives a larger field section than it is willing to handle can
send an HTTP 431 (Request Header Fields Too Large) status code (<xref target='RFC6585'/>).
A client can discard responses that it cannot process.</t>
        </section>
        <section anchor='connect-issues'>
          <name>CONNECT Issues</name>
          <t>The CONNECT method can be used to create disproportionate load on a proxy, since
stream creation is relatively inexpensive when compared to the creation and
maintenance of a TCP connection.  Therefore, a proxy that supports CONNECT might
be more conservative in the number of simultaneous requests it accepts.</t>
          <t>A proxy might also maintain some resources for a TCP connection beyond the
closing of the stream that carries the CONNECT request, since the outgoing TCP
connection remains in the TIME_WAIT state.  To account for this, a proxy might
delay increasing the QUIC stream limits for some time after a TCP connection
terminates.</t>
        </section>
      </section>
      <section anchor='use-of-compression'>
        <name>Use of Compression</name>
        <t>Compression can allow an attacker to recover secret data when it is compressed
in the same context as data under attacker control. HTTP/3 enables compression
of fields (<xref target='header-formatting'/>); the following concerns also apply to the use
of HTTP compressed content-codings; see <xref section='8.4.1' sectionFormat='of' target='RFC9110'/>.</t>
        <t>There are demonstrable attacks on compression that exploit the characteristics
of the web (e.g., <xref target='BREACH'/>).  The attacker induces multiple requests
containing varying plaintext, observing the length of the resulting ciphertext
in each, which reveals a shorter length when a guess about the secret is
correct.</t>
        <t>Implementations communicating on a secure channel          <bcp14>MUST NOT</bcp14>
 compress content that
includes both confidential and attacker-controlled data unless separate
compression contexts are used for each source of data.  Compression          <bcp14>MUST NOT</bcp14>
 be
used if the source of data cannot be reliably determined.</t>
        <t>Further considerations regarding the compression of field sections are
described in <xref target='RFC9204'/>.</t>
      </section>
      <section anchor='padding-and-traffic-analysis'>
        <name>Padding and Traffic Analysis</name>
        <t>Padding can be used to obscure the exact size of frame content and is provided
to mitigate specific attacks within HTTP, for example, attacks where compressed
content includes both attacker-controlled plaintext and secret data (e.g.,
<xref target='BREACH'/>).</t>
        <t>Where HTTP/2 employs PADDING frames and Padding fields in other frames to make a
connection more resistant to traffic analysis, HTTP/3 can either rely on
transport-layer padding or employ the reserved frame and stream types discussed
in Sections <xref format='counter' target='frame-reserved'/> and <xref format='counter' target='stream-grease'/>.  These methods of
padding produce different results in terms of the granularity of padding, how
padding is arranged in relation to the information that is being protected,
whether padding is applied in the case of packet loss, and how an implementation
might control padding.</t>
        <t>Reserved stream types can be used to give the appearance of sending traffic even
when the connection is idle.  Because HTTP traffic often occurs in bursts,
apparent traffic can be used to obscure the timing or duration of such bursts,
even to the point of appearing to send a constant stream of data.  However, as
such traffic is still flow controlled by the receiver, a failure to promptly
drain such streams and provide additional flow-control credit can limit the
sender's ability to send real traffic.</t>
        <t>To mitigate attacks that rely on compression, disabling or limiting compression
might be preferable to padding as a countermeasure.</t>
        <t>Use of padding can result in less protection than might seem immediately
obvious.  Redundant padding could even be counterproductive.  At best, padding
only makes it more difficult for an attacker to infer length information by
increasing the number of frames an attacker has to observe.  Incorrectly
implemented padding schemes can be easily defeated.  In particular, randomized
padding with a predictable distribution provides very little protection;
similarly, padding payloads to a fixed size exposes information as payload sizes
cross the fixed-sized boundary, which could be possible if an attacker can
control plaintext.</t>
      </section>
      <section anchor='frame-parsing'>
        <name>Frame Parsing</name>
        <t>Several protocol elements contain nested length elements, typically in the form
of frames with an explicit length containing variable-length integers.  This
could pose a security risk to an incautious implementer.  An implementation          <bcp14>MUST</bcp14>

ensure that the length of a frame exactly matches the length of the fields it
contains.</t>
      </section>
      <section anchor='early-data'>
        <name>Early Data</name>
        <t>The use of 0-RTT with HTTP/3 creates an exposure to replay attack.  The
anti-replay mitigations in <xref target='HTTP-REPLAY'/>          <bcp14>MUST</bcp14>
 be applied when using
HTTP/3 with 0-RTT.  When applying <xref target='HTTP-REPLAY'/> to HTTP/3, references to the
TLS layer refer to the handshake performed within QUIC, while all references to
application data refer to the contents of streams.</t>
      </section>
      <section anchor='migration'>
        <name>Migration</name>
        <t>Certain HTTP implementations use the client address for logging or
access-control purposes.  Since a QUIC client's address might change during a
connection (and future versions might support simultaneous use of multiple
addresses), such implementations will need to either actively retrieve the
client's current address or addresses when they are relevant or explicitly
accept that the original address might change.</t>
      </section>
      <section anchor='privacy-considerations'>
        <name>Privacy Considerations</name>
        <t>Several characteristics of HTTP/3 provide an observer an opportunity to
correlate actions of a single client or server over time.  These include the
value of settings, the timing of reactions to stimulus, and the handling of any
features that are controlled by settings.</t>
        <t>As far as these create observable differences in behavior, they could be used as
a basis for fingerprinting a specific client.</t>
        <t>HTTP/3's preference for using a single QUIC connection allows correlation of a
user's activity on a site.  Reusing connections for different origins allows
for correlation of activity across those origins.</t>
        <t>Several features of QUIC solicit immediate responses and can be used by an
endpoint to measure latency to their peer; this might have privacy implications
in certain scenarios.</t>
      </section>
    </section>
    <section anchor='iana-considerations'>
      <name>IANA Considerations</name>
      <t>This document registers a new ALPN protocol ID (<xref target='iana-alpn'/>) and creates new
registries that manage the assignment of code points in HTTP/3.</t>
      <section anchor='iana-alpn'>
        <name>Registration of HTTP/3 Identification String</name>
        <t>This document creates a new registration for the identification of
HTTP/3 in the "TLS Application-Layer Protocol Negotiation (ALPN)
Protocol IDs" registry established in <xref target='RFC7301'/>.</t>
        <t>The "h3" string identifies HTTP/3:</t>
        <dl>
          <dt>Protocol:</dt>
          <dd>
            <t>HTTP/3</t>
          </dd>
          <dt>Identification Sequence:</dt>
          <dd>
            <t>0x68 0x33 ("h3")</t>
          </dd>
          <dt>Specification:</dt>
          <dd>
            <t>This document</t>
          </dd>
        </dl>
      </section>
      <section anchor='iana-policy'>
        <name>New Registries</name>
        <t>New registries created in this document operate under the QUIC registration
policy documented in <xref section='22.1' sectionFormat='of' target='QUIC-TRANSPORT'/>.  These registries all
include the common set of fields listed in <xref section='22.1.1' sectionFormat='of' target='QUIC-TRANSPORT'/>.
These registries are collected under the "Hypertext Transfer Protocol version 3
(HTTP/3)" heading.</t>
        <t>The initial allocations in these registries are all assigned permanent status
and list a change controller of the IETF and a contact of the HTTP working group
(ietf-http-wg@w3.org).</t>
        <section anchor='iana-frames'>
          <name>Frame Types</name>
          <t>This document establishes a registry for HTTP/3 frame type codes. The "HTTP/3
Frame Types" registry governs a 62-bit space.  This registry follows the QUIC
registry policy; see <xref target='iana-policy'/>.  Permanent registrations in this registry
are assigned using the Specification Required policy (<xref target='RFC8126'/>), except for
values between 0x00 and 0x3f (in hexadecimal; inclusive), which are assigned
using Standards Action or IESG Approval as defined in
Sections <xref section='4.9' sectionFormat='bare' target='RFC8126'/> and <xref section='4.10' sectionFormat='bare' target='RFC8126'/> of <xref target='RFC8126'/>.</t>
          <t>While this registry is separate from the "HTTP/2 Frame Type" registry defined in
<xref target='RFC9113'/>, it is preferable that the assignments parallel each other where the
code spaces overlap.  If an entry is present in only one registry, every effort            <bcp14>SHOULD</bcp14>
 be made to avoid assigning the corresponding value to an unrelated
operation.  Expert reviewers            <bcp14>MAY</bcp14>
 reject unrelated registrations that would
conflict with the same value in the corresponding registry.</t>
          <t>In addition to common fields as described in <xref target='iana-policy'/>, permanent
registrations in this registry            <bcp14>MUST</bcp14>
 include the following field:</t>
          <dl>
            <dt>Frame Type:</dt>
            <dd>
              <t>A name or label for the frame type.</t>
            </dd>
          </dl>
          <t>Specifications of frame types            <bcp14>MUST</bcp14>
 include a description of the frame layout and
its semantics, including any parts of the frame that are conditionally present.</t>
          <t>The entries in <xref target='iana-frame-table'/> are registered by this document.</t>
          <table anchor='iana-frame-table'>
            <name>Initial HTTP/3 Frame Types</name>
            <thead>
              <tr>
                <th align='left'>Frame Type</th>
                <th align='center'>Value</th>
                <th align='left'>Specification</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align='left'><xref format='none' target='frame-data'>DATA</xref><iref item='DATA'/></td>
                <td align='center'>0x00</td>
                <td align='left'><xref target='frame-data'/></td>
              </tr>
              <tr>
                <td align='left'><xref format='none' target='frame-headers'>HEADERS</xref><iref item='HEADERS'/></td>
                <td align='center'>0x01</td>
                <td align='left'><xref target='frame-headers'/></td>
              </tr>
              <tr>
                <td align='left'>Reserved</td>
                <td align='center'>0x02</td>
                <td align='left'>This document</td>
              </tr>
              <tr>
                <td align='left'><xref format='none' target='frame-cancel-push'>CANCEL_PUSH</xref><iref item='CANCEL_PUSH'/></td>
                <td align='center'>0x03</td>
                <td align='left'><xref target='frame-cancel-push'/></td>
              </tr>
              <tr>
                <td align='left'><xref format='none' target='frame-settings'>SETTINGS</xref><iref item='SETTINGS'/></td>
                <td align='center'>0x04</td>
                <td align='left'><xref target='frame-settings'/></td>
              </tr>
              <tr>
                <td align='left'><xref format='none' target='frame-push-promise'>PUSH_PROMISE</xref><iref item='PUSH_PROMISE'/></td>
                <td align='center'>0x05</td>
                <td align='left'><xref target='frame-push-promise'/></td>
              </tr>
              <tr>
                <td align='left'>Reserved</td>
                <td align='center'>0x06</td>
                <td align='left'>This document</td>
              </tr>
              <tr>
                <td align='left'><xref format='none' target='frame-goaway'>GOAWAY</xref><iref item='GOAWAY'/></td>
                <td align='center'>0x07</td>
                <td align='left'><xref target='frame-goaway'/></td>
              </tr>
              <tr>
                <td align='left'>Reserved</td>
                <td align='center'>0x08</td>
                <td align='left'>This document</td>
              </tr>
              <tr>
                <td align='left'>Reserved</td>
                <td align='center'>0x09</td>
                <td align='left'>This document</td>
              </tr>
              <tr>
                <td align='left'><xref format='none' target='frame-max-push-id'>MAX_PUSH_ID</xref><iref item='MAX_PUSH_ID'/></td>
                <td align='center'>0x0d</td>
                <td align='left'><xref target='frame-max-push-id'/></td>
              </tr>
            </tbody>
          </table>
          <t>Each code of the format <tt>0x1f * N + 0x21</tt> for non-negative integer values of <tt>N</tt>
(that is, 0x21, 0x40, ..., through 0x3ffffffffffffffe)            <bcp14>MUST NOT</bcp14>
 be assigned by
IANA and            <bcp14>MUST NOT</bcp14>
 appear in the listing of assigned values.</t>
        </section>
        <section anchor='iana-settings'>
          <name>Settings Parameters</name>
          <t>This document establishes a registry for HTTP/3 settings.  The "HTTP/3 Settings"
registry governs a 62-bit space.  This registry follows the QUIC registry
policy; see <xref target='iana-policy'/>.  Permanent registrations in this registry are
assigned using the Specification Required policy (<xref target='RFC8126'/>), except for
values between 0x00 and 0x3f (in hexadecimal; inclusive), which are assigned
using Standards Action or IESG Approval as defined in
Sections <xref section='4.9' sectionFormat='bare' target='RFC8126'/> and <xref section='4.10' sectionFormat='bare' target='RFC8126'/> of <xref target='RFC8126'/>.</t>
          <t>While this registry is separate from the "HTTP/2 Settings" registry defined in
<xref target='RFC9113'/>, it is preferable that the assignments parallel each other.  If an
entry is present in only one registry, every effort            <bcp14>SHOULD</bcp14>
 be made to avoid
assigning the corresponding value to an unrelated operation. Expert reviewers            <bcp14>MAY</bcp14>
 reject unrelated registrations that would conflict with the same value in
the corresponding registry.</t>
          <t>In addition to common fields as described in <xref target='iana-policy'/>, permanent
registrations in this registry            <bcp14>MUST</bcp14>
 include the following fields:</t>
          <dl>
            <dt>Setting Name:</dt>
            <dd>
              <t>A symbolic name for the setting.  Specifying a setting name is optional.</t>
            </dd>
            <dt>Default:</dt>
            <dd>
              <t>The value of the setting unless otherwise indicated. A default                <bcp14>SHOULD</bcp14>
 be the
most restrictive possible value.</t>
            </dd>
          </dl>
          <t>The entries in <xref target='iana-setting-table'/> are registered by this document.</t>
          <table anchor='iana-setting-table'>
            <name>Initial HTTP/3 Settings</name>
            <thead>
              <tr>
                <th align='left'>Setting Name</th>
                <th align='center'>Value</th>
                <th align='left'>Specification</th>
                <th align='left'>Default</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align='left'>Reserved</td>
                <td align='center'>0x00</td>
                <td align='left'>This document</td>
                <td align='left'>N/A</td>
              </tr>
              <tr>
                <td align='left'>Reserved</td>
                <td align='center'>0x02</td>
                <td align='left'>This document</td>
                <td align='left'>N/A</td>
              </tr>
              <tr>
                <td align='left'>Reserved</td>
                <td align='center'>0x03</td>
                <td align='left'>This document</td>
                <td align='left'>N/A</td>
              </tr>
              <tr>
                <td align='left'>Reserved</td>
                <td align='center'>0x04</td>
                <td align='left'>This document</td>
                <td align='left'>N/A</td>
              </tr>
              <tr>
                <td align='left'>Reserved</td>
                <td align='center'>0x05</td>
                <td align='left'>This document</td>
                <td align='left'>N/A</td>
              </tr>
              <tr>
                <td align='left'>MAX_FIELD_SECTION_SIZE</td>
                <td align='center'>0x06</td>
                <td align='left'><xref target='settings-parameters'/></td>
                <td align='left'>Unlimited</td>
              </tr>
            </tbody>
          </table>
          <t>For formatting reasons, setting names can be abbreviated by removing the
'SETTINGS_' prefix.</t>
          <t>Each code of the format <tt>0x1f * N + 0x21</tt> for non-negative integer values of <tt>N</tt>
(that is, 0x21, 0x40, ..., through 0x3ffffffffffffffe)            <bcp14>MUST NOT</bcp14>
 be assigned by
IANA and            <bcp14>MUST NOT</bcp14>
 appear in the listing of assigned values.</t>
        </section>
        <section anchor='iana-error-codes'>
          <name>Error Codes</name>
          <t>This document establishes a registry for HTTP/3 error codes. The "HTTP/3 Error
Codes" registry manages a 62-bit space.  This registry follows the QUIC registry
policy; see <xref target='iana-policy'/>.  Permanent registrations in this registry are
assigned using the Specification Required policy (<xref target='RFC8126'/>), except for
values between 0x00 and 0x3f (in hexadecimal; inclusive), which are assigned
using Standards Action or IESG Approval as defined in
Sections <xref section='4.9' sectionFormat='bare' target='RFC8126'/> and <xref section='4.10' sectionFormat='bare' target='RFC8126'/> of <xref target='RFC8126'/>.</t>
          <t>Registrations for error codes are required to include a description of the error
code.  An expert reviewer is advised to examine new registrations for possible
duplication with existing error codes.  Use of existing registrations is to be
encouraged, but not mandated.  Use of values that are registered in the "HTTP/2
Error Code" registry is discouraged, and expert reviewers            <bcp14>MAY</bcp14>
 reject such
registrations.</t>
          <t>In addition to common fields as described in <xref target='iana-policy'/>, this registry
includes two additional fields.  Permanent registrations in this registry            <bcp14>MUST</bcp14>

include the following field:</t>
          <dl>
            <dt>Name:</dt>
            <dd>
              <t>A name for the error code.</t>
            </dd>
            <dt>Description:</dt>
            <dd>
              <t>A brief description of the error code semantics.</t>
            </dd>
          </dl>
          <t>The entries in <xref target='iana-error-table'/> are registered by this document. These
error codes were selected from the range that operates on a Specification
Required policy to avoid collisions with HTTP/2 error codes.</t>
          <table anchor='iana-error-table'>
            <name>Initial HTTP/3 Error Codes</name>
            <thead>
              <tr>
                <th align='left'>Name</th>
                <th align='left'>Value</th>
                <th align='left'>Description</th>
                <th align='left'>Specification</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align='left'><xref format='none' target='H3_NO_ERROR'>H3_NO_ERROR</xref><iref item='H3_NO_ERROR'/></td>
                <td align='left'>0x0100</td>
                <td align='left'>No error</td>
                <td align='left'><xref target='http-error-codes'/></td>
              </tr>
              <tr>
                <td align='left'><xref format='none' target='H3_GENERAL_PROTOCOL_ERROR'>H3_GENERAL_PROTOCOL_ERROR</xref><iref item='H3_GENERAL_PROTOCOL_ERROR'/></td>
                <td align='left'>0x0101</td>
                <td align='left'>General protocol error</td>
                <td align='left'><xref target='http-error-codes'/></td>
              </tr>
              <tr>
                <td align='left'><xref format='none' target='H3_INTERNAL_ERROR'>H3_INTERNAL_ERROR</xref><iref item='H3_INTERNAL_ERROR'/></td>
                <td align='left'>0x0102</td>
                <td align='left'>Internal error</td>
                <td align='left'><xref target='http-error-codes'/></td>
              </tr>
              <tr>
                <td align='left'><xref format='none' target='H3_STREAM_CREATION_ERROR'>H3_STREAM_CREATION_ERROR</xref><iref item='H3_STREAM_CREATION_ERROR'/></td>
                <td align='left'>0x0103</td>
                <td align='left'>Stream creation error</td>
                <td align='left'><xref target='http-error-codes'/></td>
              </tr>
              <tr>
                <td align='left'><xref format='none' target='H3_CLOSED_CRITICAL_STREAM'>H3_CLOSED_CRITICAL_STREAM</xref><iref item='H3_CLOSED_CRITICAL_STREAM'/></td>
                <td align='left'>0x0104</td>
                <td align='left'>Critical stream was closed</td>
                <td align='left'><xref target='http-error-codes'/></td>
              </tr>
              <tr>
                <td align='left'><xref format='none' target='H3_FRAME_UNEXPECTED'>H3_FRAME_UNEXPECTED</xref><iref item='H3_FRAME_UNEXPECTED'/></td>
                <td align='left'>0x0105</td>
                <td align='left'>Frame not permitted in the current state</td>
                <td align='left'><xref target='http-error-codes'/></td>
              </tr>
              <tr>
                <td align='left'><xref format='none' target='H3_FRAME_ERROR'>H3_FRAME_ERROR</xref><iref item='H3_FRAME_ERROR'/></td>
                <td align='left'>0x0106</td>
                <td align='left'>Frame violated layout or size rules</td>
                <td align='left'><xref target='http-error-codes'/></td>
              </tr>
              <tr>
                <td align='left'><xref format='none' target='H3_EXCESSIVE_LOAD'>H3_EXCESSIVE_LOAD</xref><iref item='H3_EXCESSIVE_LOAD'/></td>
                <td align='left'>0x0107</td>
                <td align='left'>Peer generating excessive load</td>
                <td align='left'><xref target='http-error-codes'/></td>
              </tr>
              <tr>
                <td align='left'><xref format='none' target='H3_ID_ERROR'>H3_ID_ERROR</xref><iref item='H3_ID_ERROR'/></td>
                <td align='left'>0x0108</td>
                <td align='left'>An identifier was used incorrectly</td>
                <td align='left'><xref target='http-error-codes'/></td>
              </tr>
              <tr>
                <td align='left'><xref format='none' target='H3_SETTINGS_ERROR'>H3_SETTINGS_ERROR</xref><iref item='H3_SETTINGS_ERROR'/></td>
                <td align='left'>0x0109</td>
                <td align='left'><xref format='none' target='frame-settings'>SETTINGS</xref><iref item='SETTINGS'/> frame contained invalid values</td>
                <td align='left'><xref target='http-error-codes'/></td>
              </tr>
              <tr>
                <td align='left'><xref format='none' target='H3_MISSING_SETTINGS'>H3_MISSING_SETTINGS</xref><iref item='H3_MISSING_SETTINGS'/></td>
                <td align='left'>0x010a</td>
                <td align='left'>No <xref format='none' target='frame-settings'>SETTINGS</xref><iref item='SETTINGS'/> frame received</td>
                <td align='left'><xref target='http-error-codes'/></td>
              </tr>
              <tr>
                <td align='left'><xref format='none' target='H3_REQUEST_REJECTED'>H3_REQUEST_REJECTED</xref><iref item='H3_REQUEST_REJECTED'/></td>
                <td align='left'>0x010b</td>
                <td align='left'>Request not processed</td>
                <td align='left'><xref target='http-error-codes'/></td>
              </tr>
              <tr>
                <td align='left'><xref format='none' target='H3_REQUEST_CANCELLED'>H3_REQUEST_CANCELLED</xref><iref item='H3_REQUEST_CANCELLED'/></td>
                <td align='left'>0x010c</td>
                <td align='left'>Data no longer needed</td>
                <td align='left'><xref target='http-error-codes'/></td>
              </tr>
              <tr>
                <td align='left'><xref format='none' target='H3_REQUEST_INCOMPLETE'>H3_REQUEST_INCOMPLETE</xref><iref item='H3_REQUEST_INCOMPLETE'/></td>
                <td align='left'>0x010d</td>
                <td align='left'>Stream terminated early</td>
                <td align='left'><xref target='http-error-codes'/></td>
              </tr>
              <tr>
                <td align='left'><xref format='none' target='H3_MESSAGE_ERROR'>H3_MESSAGE_ERROR</xref><iref item='H3_MESSAGE_ERROR'/></td>
                <td align='left'>0x010e</td>
                <td align='left'>Malformed message</td>
                <td align='left'><xref target='http-error-codes'/></td>
              </tr>
              <tr>
                <td align='left'><xref format='none' target='H3_CONNECT_ERROR'>H3_CONNECT_ERROR</xref><iref item='H3_CONNECT_ERROR'/></td>
                <td align='left'>0x010f</td>
                <td align='left'>TCP reset or error on CONNECT request</td>
                <td align='left'><xref target='http-error-codes'/></td>
              </tr>
              <tr>
                <td align='left'><xref format='none' target='H3_VERSION_FALLBACK'>H3_VERSION_FALLBACK</xref><iref item='H3_VERSION_FALLBACK'/></td>
                <td align='left'>0x0110</td>
                <td align='left'>Retry over HTTP/1.1</td>
                <td align='left'><xref target='http-error-codes'/></td>
              </tr>
            </tbody>
          </table>
          <t>Each code of the format <tt>0x1f * N + 0x21</tt> for non-negative integer values of <tt>N</tt>
(that is, 0x21, 0x40, ..., through 0x3ffffffffffffffe)            <bcp14>MUST NOT</bcp14>
 be assigned by
IANA and            <bcp14>MUST NOT</bcp14>
 appear in the listing of assigned values.</t>
        </section>
        <section anchor='iana-stream-types'>
          <name>Stream Types</name>
          <t>This document establishes a registry for HTTP/3 unidirectional stream types. The
"HTTP/3 Stream Types" registry governs a 62-bit space.  This registry follows
the QUIC registry policy; see <xref target='iana-policy'/>.  Permanent registrations in this
registry are assigned using the Specification Required policy (<xref target='RFC8126'/>),
except for values between 0x00 and 0x3f (in hexadecimal; inclusive), which are
assigned using Standards Action or IESG Approval as defined in Sections <xref section='4.9' sectionFormat='bare' target='RFC8126'/> and <xref section='4.10' sectionFormat='bare' target='RFC8126'/> of <xref target='RFC8126'/>.</t>
          <t>In addition to common fields as described in <xref target='iana-policy'/>, permanent
registrations in this registry            <bcp14>MUST</bcp14>
 include the following fields:</t>
          <dl>
            <dt>Stream Type:</dt>
            <dd>
              <t>A name or label for the stream type.</t>
            </dd>
            <dt>Sender:</dt>
            <dd>
              <t>Which endpoint on an HTTP/3 connection may initiate a stream of this type.
Values are "Client", "Server", or "Both".</t>
            </dd>
          </dl>
          <t>Specifications for permanent registrations            <bcp14>MUST</bcp14>
 include a description of the
stream type, including the layout and semantics of the stream contents.</t>
          <t>The entries in <xref target='iana-stream-type-table'/> are registered by this document.</t>
          <table anchor='iana-stream-type-table'>
            <name>Initial Stream Types</name>
            <thead>
              <tr>
                <th align='left'>Stream Type</th>
                <th align='center'>Value</th>
                <th align='left'>Specification</th>
                <th align='left'>Sender</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align='left'>Control Stream</td>
                <td align='center'>0x00</td>
                <td align='left'><xref target='control-streams'/></td>
                <td align='left'>Both</td>
              </tr>
              <tr>
                <td align='left'>Push Stream</td>
                <td align='center'>0x01</td>
                <td align='left'><xref target='server-push'/></td>
                <td align='left'>Server</td>
              </tr>
            </tbody>
          </table>
          <t>Each code of the format <tt>0x1f * N + 0x21</tt> for non-negative integer values of <tt>N</tt>
(that is, 0x21, 0x40, ..., through 0x3ffffffffffffffe)            <bcp14>MUST NOT</bcp14>
 be assigned by
IANA and            <bcp14>MUST NOT</bcp14>
 appear in the listing of assigned values.</t>
        </section>
      </section>
    </section>
  </middle>
  <back>
    <displayreference target='RFC9204' to='QPACK'/>
    <displayreference target='RFC9110' to='HTTP'/>
    <displayreference target='RFC9111' to='HTTP-CACHING'/>
    <displayreference target='RFC9112' to='HTTP/1.1'/>
    <displayreference target='RFC9113' to='HTTP/2'/>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <reference anchor='RFC9204' target='https://www.rfc-editor.org/info/rfc9204'>
          <front>
            <title>QPACK: Field Compression for HTTP/3</title>
            <author fullname='Charles &apos;Buck&apos; Krasic' initials='C.' surname='Krasic'>
              <organization/>
            </author>
            <author fullname='Mike Bishop' initials='M.' surname='Bishop'>
              <organization>Akamai Technologies</organization>
            </author>
            <author fullname='Alan Frindell' initials='A.' role='editor' surname='Frindell'>
              <organization>Facebook</organization>
            </author>
            <date month='June' year='2022'/>
          </front>
          <seriesInfo name='RFC' value='9204'/>
          <seriesInfo name='DOI' value='10.17487/RFC9204'/>
        </reference>
        <reference anchor='RFC9110' target='https://www.rfc-editor.org/info/rfc9110'>
          <front>
            <title>HTTP Semantics</title>
            <author fullname='Roy T. Fielding' initials='R.' role='editor' surname='Fielding'>
              <organization>Adobe</organization>
            </author>
            <author fullname='Mark Nottingham' initials='M.' role='editor' surname='Nottingham'>
              <organization>Fastly</organization>
            </author>
            <author fullname='Julian Reschke' initials='J.' role='editor' surname='Reschke'>
              <organization>greenbytes</organization>
            </author>
            <date month='June' year='2022'/>
          </front>
          <seriesInfo name='STD' value='97'/>
          <seriesInfo name='RFC' value='9110'/>
          <seriesInfo name='DOI' value='10.17487/RFC9110'/>
        </reference>
        <reference anchor='RFC9111' target='https://www.rfc-editor.org/info/rfc9111'>
          <front>
            <title>HTTP Caching</title>
            <author fullname='Roy T. Fielding' initials='R.' role='editor' surname='Fielding'>
              <organization>Adobe</organization>
            </author>
            <author fullname='Mark Nottingham' initials='M.' role='editor' surname='Nottingham'>
              <organization>Fastly</organization>
            </author>
            <author fullname='Julian Reschke' initials='J.' role='editor' surname='Reschke'>
              <organization>greenbytes</organization>
            </author>
            <date month='June' year='2022'/>
          </front>
          <seriesInfo name='STD' value='98'/>
          <seriesInfo name='RFC' value='9111'/>
          <seriesInfo name='DOI' value='10.17487/RFC9111'/>
        </reference>
        <reference anchor='URI' target='https://www.rfc-editor.org/info/rfc3986'>
          <front>
            <title>Uniform Resource Identifier (URI): Generic Syntax</title>
            <author fullname='T. Berners-Lee' initials='T.' surname='Berners-Lee'>
              <organization/>
            </author>
            <author fullname='R. Fielding' initials='R.' surname='Fielding'>
              <organization/>
            </author>
            <author fullname='L. Masinter' initials='L.' surname='Masinter'>
              <organization/>
            </author>
            <date month='January' year='2005'/>
            <abstract>
              <t>A Uniform Resource Identifier (URI) is a compact sequence of characters that identifies an abstract or physical resource.  This specification defines the generic URI syntax and a process for resolving URI references that might be in relative form, along with guidelines and security considerations for the use of URIs on the Internet.  The URI syntax defines a grammar that is a superset of all valid URIs, allowing an implementation to parse the common components of a URI reference without knowing the scheme-specific requirements of every possible identifier.  This specification does not define a generative grammar for URIs; that task is performed by the individual specifications of each URI scheme.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name='STD' value='66'/>
          <seriesInfo name='RFC' value='3986'/>
          <seriesInfo name='DOI' value='10.17487/RFC3986'/>
        </reference>
        <reference anchor='QUIC-TRANSPORT' target='https://www.rfc-editor.org/info/rfc9000'>
          <front>
            <title>QUIC: A UDP-Based Multiplexed and Secure Transport</title>
            <author fullname='J. Iyengar' initials='J.' role='editor' surname='Iyengar'>
              <organization/>
            </author>
            <author fullname='M. Thomson' initials='M.' role='editor' surname='Thomson'>
              <organization/>
            </author>
            <date month='May' year='2021'/>
            <abstract>
              <t>This document defines the core of the QUIC transport protocol.  QUIC provides applications with flow-controlled streams for structured communication, low-latency connection establishment, and network path migration. QUIC includes security measures that ensure confidentiality, integrity, and availability in a range of deployment circumstances.  Accompanying documents describe the integration of TLS for key negotiation, loss detection, and an exemplary congestion control algorithm.</t>
            </abstract>
          </front>
          <seriesInfo name='RFC' value='9000'/>
          <seriesInfo name='DOI' value='10.17487/RFC9000'/>
        </reference>
        <reference anchor='RFC2119' target='https://www.rfc-editor.org/info/rfc2119'>
          <front>
            <title>Key words for use in RFCs to Indicate Requirement Levels</title>
            <author fullname='S. Bradner' initials='S.' surname='Bradner'>
              <organization/>
            </author>
            <date month='March' year='1997'/>
            <abstract>
              <t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name='BCP' value='14'/>
          <seriesInfo name='RFC' value='2119'/>
          <seriesInfo name='DOI' value='10.17487/RFC2119'/>
        </reference>
        <reference anchor='RFC8174' target='https://www.rfc-editor.org/info/rfc8174'>
          <front>
            <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
            <author fullname='B. Leiba' initials='B.' surname='Leiba'>
              <organization/>
            </author>
            <date month='May' year='2017'/>
            <abstract>
              <t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t>
            </abstract>
          </front>
          <seriesInfo name='BCP' value='14'/>
          <seriesInfo name='RFC' value='8174'/>
          <seriesInfo name='DOI' value='10.17487/RFC8174'/>
        </reference>
        <reference anchor='RFC7301' target='https://www.rfc-editor.org/info/rfc7301'>
          <front>
            <title>Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension</title>
            <author fullname='S. Friedl' initials='S.' surname='Friedl'>
              <organization/>
            </author>
            <author fullname='A. Popov' initials='A.' surname='Popov'>
              <organization/>
            </author>
            <author fullname='A. Langley' initials='A.' surname='Langley'>
              <organization/>
            </author>
            <author fullname='E. Stephan' initials='E.' surname='Stephan'>
              <organization/>
            </author>
            <date month='July' year='2014'/>
            <abstract>
              <t>This document describes a Transport Layer Security (TLS) extension for application-layer protocol negotiation within the TLS handshake. For instances in which multiple application protocols are supported on the same TCP or UDP port, this extension allows the application layer to negotiate which protocol will be used within the TLS connection.</t>
            </abstract>
          </front>
          <seriesInfo name='RFC' value='7301'/>
          <seriesInfo name='DOI' value='10.17487/RFC7301'/>
        </reference>
        <reference anchor='ALTSVC' target='https://www.rfc-editor.org/info/rfc7838'>
          <front>
            <title>HTTP Alternative Services</title>
            <author fullname='M. Nottingham' initials='M.' surname='Nottingham'>
              <organization/>
            </author>
            <author fullname='P. McManus' initials='P.' surname='McManus'>
              <organization/>
            </author>
            <author fullname='J. Reschke' initials='J.' surname='Reschke'>
              <organization/>
            </author>
            <date month='April' year='2016'/>
            <abstract>
              <t>This document specifies "Alternative Services" for HTTP, which allow an origin's resources to be authoritatively available at a separate network location, possibly accessed with a different protocol configuration.</t>
            </abstract>
          </front>
          <seriesInfo name='RFC' value='7838'/>
          <seriesInfo name='DOI' value='10.17487/RFC7838'/>
        </reference>
        <reference anchor='RFC6066' target='https://www.rfc-editor.org/info/rfc6066'>
          <front>
            <title>Transport Layer Security (TLS) Extensions: Extension Definitions</title>
            <author fullname='D. Eastlake 3rd' initials='D.' surname='Eastlake 3rd'>
              <organization/>
            </author>
            <date month='January' year='2011'/>
            <abstract>
              <t>This document provides specifications for existing TLS extensions.  It is a companion document for RFC 5246, "The Transport Layer Security (TLS) Protocol Version 1.2".  The extensions specified are server_name, max_fragment_length, client_certificate_url, trusted_ca_keys, truncated_hmac, and status_request.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name='RFC' value='6066'/>
          <seriesInfo name='DOI' value='10.17487/RFC6066'/>
        </reference>
        <reference anchor='COOKIES' target='https://www.rfc-editor.org/info/rfc6265'>
          <front>
            <title>HTTP State Management Mechanism</title>
            <author fullname='A. Barth' initials='A.' surname='Barth'>
              <organization/>
            </author>
            <date month='April' year='2011'/>
            <abstract>
              <t>This document defines the HTTP Cookie and Set-Cookie header fields. These header fields can be used by HTTP servers to store state (called cookies) at HTTP user agents, letting the servers maintain a stateful session over the mostly stateless HTTP protocol.  Although cookies have many historical infelicities that degrade their security and privacy, the Cookie and Set-Cookie header fields are widely used on the Internet.  This document obsoletes RFC 2965.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name='RFC' value='6265'/>
          <seriesInfo name='DOI' value='10.17487/RFC6265'/>
        </reference>
        <reference anchor='RFC0793' target='https://www.rfc-editor.org/info/rfc793'>
          <front>
            <title>Transmission Control Protocol</title>
            <author fullname='J. Postel' initials='J.' surname='Postel'>
              <organization/>
            </author>
            <date month='September' year='1981'/>
          </front>
          <seriesInfo name='STD' value='7'/>
          <seriesInfo name='RFC' value='793'/>
          <seriesInfo name='DOI' value='10.17487/RFC0793'/>
        </reference>
        <reference anchor='HTTP-REPLAY' target='https://www.rfc-editor.org/info/rfc8470'>
          <front>
            <title>Using Early Data in HTTP</title>
            <author fullname='M. Thomson' initials='M.' surname='Thomson'>
              <organization/>
            </author>
            <author fullname='M. Nottingham' initials='M.' surname='Nottingham'>
              <organization/>
            </author>
            <author fullname='W. Tarreau' initials='W.' surname='Tarreau'>
              <organization/>
            </author>
            <date month='September' year='2018'/>
            <abstract>
              <t>Using TLS early data creates an exposure to the possibility of a replay attack.  This document defines mechanisms that allow clients to communicate with servers about HTTP requests that are sent in early data.  Techniques are described that use these mechanisms to mitigate the risk of replay.</t>
            </abstract>
          </front>
          <seriesInfo name='RFC' value='8470'/>
          <seriesInfo name='DOI' value='10.17487/RFC8470'/>
        </reference>
        <reference anchor='RFC8126' target='https://www.rfc-editor.org/info/rfc8126'>
          <front>
            <title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
            <author fullname='M. Cotton' initials='M.' surname='Cotton'>
              <organization/>
            </author>
            <author fullname='B. Leiba' initials='B.' surname='Leiba'>
              <organization/>
            </author>
            <author fullname='T. Narten' initials='T.' surname='Narten'>
              <organization/>
            </author>
            <date month='June' year='2017'/>
            <abstract>
              <t>Many protocols make use of points of extensibility that use constants to identify various protocol parameters.  To ensure that the values in these fields do not have conflicting uses and to promote interoperability, their allocations are often coordinated by a central record keeper.  For IETF protocols, that role is filled by the Internet Assigned Numbers Authority (IANA).</t>
              <t>To make assignments in a given registry prudently, guidance describing the conditions under which new values should be assigned, as well as when and how modifications to existing values can be made, is needed.  This document defines a framework for the documentation of these guidelines by specification authors, in order to assure that the provided guidance for the IANA Considerations is clear and addresses the various issues that are likely in the operation of a registry.</t>
              <t>This is the third edition of this document; it obsoletes RFC 5226.</t>
            </abstract>
          </front>
          <seriesInfo name='BCP' value='26'/>
          <seriesInfo name='RFC' value='8126'/>
          <seriesInfo name='DOI' value='10.17487/RFC8126'/>
        </reference>
      </references>
      <references>
        <name>Informative References</name>
        <reference anchor='RFC9112' target='https://www.rfc-editor.org/info/rfc9112'>
          <front>
            <title>HTTP/1.1</title>
            <author fullname='Roy T. Fielding' initials='R.' role='editor' surname='Fielding'>
              <organization>Adobe</organization>
            </author>
            <author fullname='Mark Nottingham' initials='M.' role='editor' surname='Nottingham'>
              <organization>Fastly</organization>
            </author>
            <author fullname='Julian Reschke' initials='J.' role='editor' surname='Reschke'>
              <organization>greenbytes</organization>
            </author>
            <date month='June' year='2022'/>
          </front>
          <seriesInfo name='STD' value='99'/>
          <seriesInfo name='RFC' value='9112'/>
          <seriesInfo name='DOI' value='10.17487/RFC9112'/>
        </reference>
        <reference anchor='RFC9113' target='https://www.rfc-editor.org/info/rfc9113'>
          <front>
            <title>HTTP/2</title>
            <author fullname='Martin Thomson' initials='M.' role='editor' surname='Thomson'>
              <organization>Mozilla</organization>
            </author>
            <author fullname='Cory Benfield' initials='C.' role='editor' surname='Benfield'>
              <organization>Apple Inc.</organization>
            </author>
            <date month='June' year='2022'/>
          </front>
          <seriesInfo name='RFC' value='9113'/>
          <seriesInfo name='DOI' value='10.17487/RFC9113'/>
        </reference>
        <reference anchor='BREACH' target='http://breachattack.com/resources/BREACH%20-%20SSL,%20gone%20in%2030%20seconds.pdf'>
          <front>
            <title>BREACH: Reviving the CRIME Attack</title>
            <author initials='Y.' surname='Gluck'>
              <organization/>
            </author>
            <author initials='N.' surname='Harris'>
              <organization/>
            </author>
            <author initials='A.' surname='Prado'>
              <organization/>
            </author>
            <date month='July' year='2013'/>
          </front>
        </reference>
        <reference anchor='TLS' target='https://www.rfc-editor.org/info/rfc8446'>
          <front>
            <title>The Transport Layer Security (TLS) Protocol Version 1.3</title>
            <author fullname='E. Rescorla' initials='E.' surname='Rescorla'>
              <organization/>
            </author>
            <date month='August' year='2018'/>
            <abstract>
              <t>This document specifies version 1.3 of the Transport Layer Security (TLS) protocol.  TLS allows client/server applications to communicate over the Internet in a way that is designed to prevent eavesdropping, tampering, and message forgery.</t>
              <t>This document updates RFCs 5705 and 6066, and obsoletes RFCs 5077, 5246, and 6961.  This document also specifies new requirements for TLS 1.2 implementations.</t>
            </abstract>
          </front>
          <seriesInfo name='RFC' value='8446'/>
          <seriesInfo name='DOI' value='10.17487/RFC8446'/>
        </reference>
        <reference anchor='TFO' target='https://www.rfc-editor.org/info/rfc7413'>
          <front>
            <title>TCP Fast Open</title>
            <author fullname='Y. Cheng' initials='Y.' surname='Cheng'>
              <organization/>
            </author>
            <author fullname='J. Chu' initials='J.' surname='Chu'>
              <organization/>
            </author>
            <author fullname='S. Radhakrishnan' initials='S.' surname='Radhakrishnan'>
              <organization/>
            </author>
            <author fullname='A. Jain' initials='A.' surname='Jain'>
              <organization/>
            </author>
            <date month='December' year='2014'/>
            <abstract>
              <t>This document describes an experimental TCP mechanism called TCP Fast Open (TFO).  TFO allows data to be carried in the SYN and SYN-ACK packets and consumed by the receiving end during the initial connection handshake, and saves up to one full round-trip time (RTT) compared to the standard TCP, which requires a three-way handshake (3WHS) to complete before data can be exchanged.  However, TFO deviates from the standard TCP semantics, since the data in the SYN could be replayed to an application in some rare circumstances.  Applications should not use TFO unless they can tolerate this issue, as detailed in the Applicability section.</t>
            </abstract>
          </front>
          <seriesInfo name='RFC' value='7413'/>
          <seriesInfo name='DOI' value='10.17487/RFC7413'/>
        </reference>
        <reference anchor='HPACK' target='https://www.rfc-editor.org/info/rfc7541'>
          <front>
            <title>HPACK: Header Compression for HTTP/2</title>
            <author fullname='R. Peon' initials='R.' surname='Peon'>
              <organization/>
            </author>
            <author fullname='H. Ruellan' initials='H.' surname='Ruellan'>
              <organization/>
            </author>
            <date month='May' year='2015'/>
            <abstract>
              <t>This specification defines HPACK, a compression format for efficiently representing HTTP header fields, to be used in HTTP/2.</t>
            </abstract>
          </front>
          <seriesInfo name='RFC' value='7541'/>
          <seriesInfo name='DOI' value='10.17487/RFC7541'/>
        </reference>
        <reference anchor='RFC8164' target='https://www.rfc-editor.org/info/rfc8164'>
          <front>
            <title>Opportunistic Security for HTTP/2</title>
            <author fullname='M. Nottingham' initials='M.' surname='Nottingham'>
              <organization/>
            </author>
            <author fullname='M. Thomson' initials='M.' surname='Thomson'>
              <organization/>
            </author>
            <date month='May' year='2017'/>
            <abstract>
              <t>This document describes how "http" URIs can be accessed using Transport Layer Security (TLS) and HTTP/2 to mitigate pervasive monitoring attacks.  This mechanism not a replacement for "https" URIs; it is vulnerable to active attacks.</t>
            </abstract>
          </front>
          <seriesInfo name='RFC' value='8164'/>
          <seriesInfo name='DOI' value='10.17487/RFC8164'/>
        </reference>
        <reference anchor='DNS-TERMS' target='https://www.rfc-editor.org/info/rfc8499'>
          <front>
            <title>DNS Terminology</title>
            <author fullname='P. Hoffman' initials='P.' surname='Hoffman'>
              <organization/>
            </author>
            <author fullname='A. Sullivan' initials='A.' surname='Sullivan'>
              <organization/>
            </author>
            <author fullname='K. Fujiwara' initials='K.' surname='Fujiwara'>
              <organization/>
            </author>
            <date month='January' year='2019'/>
            <abstract>
              <t>The Domain Name System (DNS) is defined in literally dozens of different RFCs.  The terminology used by implementers and developers of DNS protocols, and by operators of DNS systems, has sometimes changed in the decades since the DNS was first defined.  This document gives current definitions for many of the terms used in the DNS in a single document.</t>
              <t>This document obsoletes RFC 7719 and updates RFC 2308.</t>
            </abstract>
          </front>
          <seriesInfo name='BCP' value='219'/>
          <seriesInfo name='RFC' value='8499'/>
          <seriesInfo name='DOI' value='10.17487/RFC8499'/>
        </reference>
        <reference anchor='RFC6585' target='https://www.rfc-editor.org/info/rfc6585'>
          <front>
            <title>Additional HTTP Status Codes</title>
            <author fullname='M. Nottingham' initials='M.' surname='Nottingham'>
              <organization/>
            </author>
            <author fullname='R. Fielding' initials='R.' surname='Fielding'>
              <organization/>
            </author>
            <date month='April' year='2012'/>
            <abstract>
              <t>This document specifies additional HyperText Transfer Protocol (HTTP) status codes for a variety of common situations.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name='RFC' value='6585'/>
          <seriesInfo name='DOI' value='10.17487/RFC6585'/>
        </reference>
      </references>
    </references>
    <section anchor='h2-considerations'>
      <name>Considerations for Transitioning from HTTP/2</name>
      <t>HTTP/3 is strongly informed by HTTP/2, and it bears many similarities.  This
section describes the approach taken to design HTTP/3, points out important
differences from HTTP/2, and describes how to map HTTP/2 extensions into HTTP/3.</t>
      <t>HTTP/3 begins from the premise that similarity to HTTP/2 is preferable, but not
a hard requirement.  HTTP/3 departs from HTTP/2 where QUIC differs from TCP,
either to take advantage of QUIC features (like streams) or to accommodate
important shortcomings (such as a lack of total ordering). While HTTP/3 is
similar to HTTP/2 in key aspects, such as the relationship of requests and
responses to streams, the details of the HTTP/3 design are substantially
different from HTTP/2.</t>
      <t>Some important departures are noted in this section.</t>
      <section anchor='h2-streams'>
        <name>Streams</name>
        <t>HTTP/3 permits use of a larger number of streams (2<sup>62</sup>-1) than HTTP/2.
The same considerations about exhaustion of stream identifier space apply,
though the space is significantly larger such that it is likely that other
limits in QUIC are reached first, such as the limit on the connection
flow-control window.</t>
        <t>In contrast to HTTP/2, stream concurrency in HTTP/3 is managed by QUIC.  QUIC
considers a stream closed when all data has been received and sent data has been
acknowledged by the peer.  HTTP/2 considers a stream closed when the frame
containing the END_STREAM bit has been committed to the transport. As a result,
the stream for an equivalent exchange could remain "active" for a longer period
of time.  HTTP/3 servers might choose to permit a larger number of concurrent
client-initiated bidirectional streams to achieve equivalent concurrency to
HTTP/2, depending on the expected usage patterns.</t>
        <t>In HTTP/2, only request and response bodies (the frame payload of <xref format='none' target='frame-data'>DATA</xref><iref item='DATA'/> frames)
are subject to flow control.  All HTTP/3 frames are sent on QUIC streams, so all
frames on all streams are flow controlled in HTTP/3.</t>
        <t>Due to the presence of other unidirectional stream types, HTTP/3 does not rely
exclusively on the number of concurrent unidirectional streams to control the
number of concurrent in-flight pushes.  Instead, HTTP/3 clients use the
<xref format='none' target='frame-max-push-id'>MAX_PUSH_ID</xref><iref item='MAX_PUSH_ID'/> frame to control the number of pushes received from an HTTP/3
server.</t>
      </section>
      <section anchor='h2-frames'>
        <name>HTTP Frame Types</name>
        <t>Many framing concepts from HTTP/2 can be elided on QUIC, because the transport
deals with them. Because frames are already on a stream, they can omit the
stream number. Because frames do not block multiplexing (QUIC's multiplexing
occurs below this layer), the support for variable-maximum-length packets can be
removed. Because stream termination is handled by QUIC, an END_STREAM flag is
not required.  This permits the removal of the Flags field from the generic
frame layout.</t>
        <t>Frame payloads are largely drawn from <xref target='RFC9113'/>. However, QUIC includes many
features (e.g., flow control) that are also present in HTTP/2. In these cases,
the HTTP mapping does not re-implement them. As a result, several HTTP/2 frame
types are not required in HTTP/3. Where an HTTP/2-defined frame is no longer
used, the frame ID has been reserved in order to maximize portability between
HTTP/2 and HTTP/3 implementations. However, even frame types that appear in
both mappings do not have identical semantics.</t>
        <t>Many of the differences arise from the fact that HTTP/2 provides an absolute
ordering between frames across all streams, while QUIC provides this guarantee
on each stream only.  As a result, if a frame type makes assumptions that frames
from different streams will still be received in the order sent, HTTP/3 will
break them.</t>
        <t>Some examples of feature adaptations are described below, as well as general
guidance to extension frame implementors converting an HTTP/2 extension to
HTTP/3.</t>
        <section anchor='h2-diff-priority'>
          <name>Prioritization Differences</name>
          <t>HTTP/2 specifies priority assignments in PRIORITY frames and (optionally) in
<xref format='none' target='frame-headers'>HEADERS</xref><iref item='HEADERS'/> frames. HTTP/3 does not provide a means of signaling priority.</t>
          <t>Note that, while there is no explicit signaling for priority, this does not mean
that prioritization is not important for achieving good performance.</t>
        </section>
        <section anchor='field-compression-differences'>
          <name>Field Compression Differences</name>
          <t>HPACK was designed with the assumption of in-order delivery. A sequence of
encoded field sections must arrive (and be decoded) at an endpoint in the same
order in which they were encoded. This ensures that the dynamic state at the two
endpoints remains in sync.</t>
          <t>Because this total ordering is not provided by QUIC, HTTP/3 uses a modified
version of HPACK, called QPACK.  QPACK uses a single unidirectional stream to
make all modifications to the dynamic table, ensuring a total order of updates.
All frames that contain encoded fields merely reference the table state at a
given time without modifying it.</t>
          <t><xref target='RFC9204'/> provides additional details.</t>
        </section>
        <section anchor='flow-control-differences'>
          <name>Flow-Control Differences</name>
          <t>HTTP/2 specifies a stream flow-control mechanism. Although all HTTP/2 frames are
delivered on streams, only the <xref format='none' target='frame-data'>DATA</xref><iref item='DATA'/> frame payload is subject to flow control.
QUIC provides flow control for stream data and all HTTP/3 frame types defined in
this document are sent on streams. Therefore, all frame headers and payload are
subject to flow control.</t>
        </section>
        <section anchor='guidance-for-new-frame-type-definitions'>
          <name>Guidance for New Frame Type Definitions</name>
          <t>Frame type definitions in HTTP/3 often use the QUIC variable-length integer
encoding.  In particular, stream IDs use this encoding, which allows for a
larger range of possible values than the encoding used in HTTP/2.  Some frames
in HTTP/3 use an identifier other than a stream ID (e.g., push IDs).
Redefinition of the encoding of extension frame types might be necessary if the
encoding includes a stream ID.</t>
          <t>Because the Flags field is not present in generic HTTP/3 frames, those frames
that depend on the presence of flags need to allocate space for flags as part
of their frame payload.</t>
          <t>Other than these issues, frame type HTTP/2 extensions are typically portable to
QUIC simply by replacing stream 0 in HTTP/2 with a <xref format='none' target='control-streams'>control stream</xref><iref item='control stream'/> in HTTP/3.
HTTP/3 extensions will not assume ordering, but would not be harmed by ordering,
and are expected to be portable to HTTP/2.</t>
        </section>
        <section anchor='comparison-of-http2-and-http3-frame-types'>
          <name>Comparison of HTTP/2 and HTTP/3 Frame Types</name>
          <dl>
            <dt><xref format='none' target='frame-data'>DATA</xref> (0x00)<iref item='DATA'/>:</dt>
            <dd>
              <t>Padding is not defined in HTTP/3 frames.  See <xref target='frame-data'/>.</t>
            </dd>
            <dt><xref format='none' target='frame-headers'>HEADERS</xref> (0x01)<iref item='HEADERS'/>:</dt>
            <dd>
              <t>The PRIORITY region of <xref format='none' target='frame-headers'>HEADERS</xref><iref item='HEADERS'/> is not defined in HTTP/3 frames. Padding is not
defined in HTTP/3 frames.  See <xref target='frame-headers'/>.</t>
            </dd>
            <dt>PRIORITY (0x02):</dt>
            <dd>
              <t>As described in <xref target='h2-diff-priority'/>, HTTP/3 does not provide a means of
signaling priority.</t>
            </dd>
            <dt>RST_STREAM (0x03):</dt>
            <dd>
              <t>RST_STREAM frames do not exist in HTTP/3, since QUIC provides stream lifecycle
management.  The same code point is used for the <xref format='none' target='frame-cancel-push'>CANCEL_PUSH</xref><iref item='CANCEL_PUSH'/> frame
(<xref target='frame-cancel-push'/>).</t>
            </dd>
            <dt><xref format='none' target='frame-settings'>SETTINGS</xref> (0x04)<iref item='SETTINGS'/>:</dt>
            <dd>
              <t><xref format='none' target='frame-settings'>SETTINGS</xref><iref item='SETTINGS'/> frames are sent only at the beginning of the connection.  See
<xref target='frame-settings'/> and <xref target='h2-settings'/>.</t>
            </dd>
            <dt><xref format='none' target='frame-push-promise'>PUSH_PROMISE</xref>  (0x05)<iref item='PUSH_PROMISE'/>:</dt>
            <dd>
              <t>The <xref format='none' target='frame-push-promise'>PUSH_PROMISE</xref><iref item='PUSH_PROMISE'/> frame does not reference a stream; instead, the <xref format='none' target='push-streams'>push stream</xref><iref item='push stream'/>
references the <xref format='none' target='frame-push-promise'>PUSH_PROMISE</xref><iref item='PUSH_PROMISE'/> frame using a <xref format='none' target='server-push'>push ID</xref><iref item='push ID'/>.  See
<xref target='frame-push-promise'/>.</t>
            </dd>
            <dt>PING (0x06):</dt>
            <dd>
              <t>PING frames do not exist in HTTP/3, as QUIC provides equivalent
functionality.</t>
            </dd>
            <dt><xref format='none' target='frame-goaway'>GOAWAY</xref> (0x07)<iref item='GOAWAY'/>:</dt>
            <dd>
              <t><xref format='none' target='frame-goaway'>GOAWAY</xref><iref item='GOAWAY'/> does not contain an error code.  In the client-to-server direction,
it carries a <xref format='none' target='server-push'>push ID</xref><iref item='push ID'/> instead of a server-initiated stream ID.
See <xref target='frame-goaway'/>.</t>
            </dd>
            <dt>WINDOW_UPDATE (0x08):</dt>
            <dd>
              <t>WINDOW_UPDATE frames do not exist in HTTP/3, since QUIC provides flow control.</t>
            </dd>
            <dt>CONTINUATION (0x09):</dt>
            <dd>
              <t>CONTINUATION frames do not exist in HTTP/3; instead, larger
<xref format='none' target='frame-headers'>HEADERS</xref><iref item='HEADERS'/>/<xref format='none' target='frame-push-promise'>PUSH_PROMISE</xref><iref item='PUSH_PROMISE'/> frames than HTTP/2 are permitted.</t>
            </dd>
          </dl>
          <t>Frame types defined by extensions to HTTP/2 need to be separately registered for
HTTP/3 if still applicable.  The IDs of frames defined in <xref target='RFC9113'/> have been
reserved for simplicity.  Note that the frame type space in HTTP/3 is
substantially larger (62 bits versus 8 bits), so many HTTP/3 frame types have no
equivalent HTTP/2 code points.  See <xref target='iana-frames'/>.</t>
        </section>
      </section>
      <section anchor='h2-settings'>
        <name>HTTP/2 SETTINGS Parameters</name>
        <t>An important difference from HTTP/2 is that settings are sent once, as the first
frame of the <xref format='none' target='control-streams'>control stream</xref><iref item='control stream'/>, and thereafter cannot change.  This eliminates many
corner cases around synchronization of changes.</t>
        <t>Some transport-level options that HTTP/2 specifies via the <xref format='none' target='frame-settings'>SETTINGS</xref><iref item='SETTINGS'/> frame are
superseded by QUIC transport parameters in HTTP/3.  The HTTP-level setting that
is retained in HTTP/3 has the same value as in HTTP/2.  The superseded
settings are reserved, and their receipt is an error.  See
<xref target='settings-parameters'/> for discussion of both the retained and reserved values.</t>
        <t>Below is a listing of how each HTTP/2 <xref format='none' target='frame-settings'>SETTINGS</xref><iref item='SETTINGS'/> parameter is mapped:</t>
        <dl>
          <dt>SETTINGS_HEADER_TABLE_SIZE (0x01):</dt>
          <dd>
            <t>See <xref target='RFC9204'/>.</t>
          </dd>
          <dt>SETTINGS_ENABLE_PUSH (0x02):</dt>
          <dd>
            <t>This is removed in favor of the <xref format='none' target='frame-max-push-id'>MAX_PUSH_ID</xref><iref item='MAX_PUSH_ID'/> frame, which provides a more
granular control over server push.  Specifying a setting with the identifier
0x02 (corresponding to the SETTINGS_ENABLE_PUSH parameter) in the HTTP/3
<xref format='none' target='frame-settings'>SETTINGS</xref><iref item='SETTINGS'/> frame is an error.</t>
          </dd>
          <dt>SETTINGS_MAX_CONCURRENT_STREAMS (0x03):</dt>
          <dd>
            <t>QUIC controls the largest open stream ID as part of its flow-control logic.
Specifying a setting with the identifier 0x03 (corresponding to the
SETTINGS_MAX_CONCURRENT_STREAMS parameter) in the HTTP/3 <xref format='none' target='frame-settings'>SETTINGS</xref><iref item='SETTINGS'/> frame is an
error.</t>
          </dd>
          <dt>SETTINGS_INITIAL_WINDOW_SIZE (0x04):</dt>
          <dd>
            <t>QUIC requires both stream and connection flow-control window sizes to be
specified in the initial transport handshake.  Specifying a setting with the
identifier 0x04 (corresponding to the SETTINGS_INITIAL_WINDOW_SIZE parameter)
in the HTTP/3 <xref format='none' target='frame-settings'>SETTINGS</xref><iref item='SETTINGS'/> frame is an error.</t>
          </dd>
          <dt>SETTINGS_MAX_FRAME_SIZE (0x05):</dt>
          <dd>
            <t>This setting has no equivalent in HTTP/3.  Specifying a setting with the
identifier 0x05 (corresponding to the SETTINGS_MAX_FRAME_SIZE parameter) in
the HTTP/3 <xref format='none' target='frame-settings'>SETTINGS</xref><iref item='SETTINGS'/> frame is an error.</t>
          </dd>
          <dt>SETTINGS_MAX_HEADER_LIST_SIZE (0x06):</dt>
          <dd>
            <t>This setting identifier has been renamed <xref format='none' target='SETTINGS_MAX_FIELD_SECTION_SIZE'>SETTINGS_MAX_FIELD_SECTION_SIZE</xref><iref item='SETTINGS_MAX_FIELD_SECTION_SIZE'/>.</t>
          </dd>
        </dl>
        <t>In HTTP/3, setting values are variable-length integers (6, 14, 30, or 62 bits
long) rather than fixed-length 32-bit fields as in HTTP/2.  This will often
produce a shorter encoding, but can produce a longer encoding for settings that
use the full 32-bit space.  Settings ported from HTTP/2 might choose to redefine
their value to limit it to 30 bits for more efficient encoding or to make use
of the 62-bit space if more than 30 bits are required.</t>
        <t>Settings need to be defined separately for HTTP/2 and HTTP/3. The IDs of
settings defined in <xref target='RFC9113'/> have been reserved for simplicity.  Note that
the settings identifier space in HTTP/3 is substantially larger (62 bits versus
16 bits), so many HTTP/3 settings have no equivalent HTTP/2 code point. See
<xref target='iana-settings'/>.</t>
        <t>As QUIC streams might arrive out of order, endpoints are advised not to wait for
the peers' settings to arrive before responding to other streams.  See
<xref target='settings-initialization'/>.</t>
      </section>
      <section anchor='http2-error-codes'>
        <name>HTTP/2 Error Codes</name>
        <t>QUIC has the same concepts of "stream" and "connection" errors that HTTP/2
provides. However, the differences between HTTP/2 and HTTP/3 mean that error
codes are not directly portable between versions.</t>
        <t>The HTTP/2 error codes defined in <xref section='7' sectionFormat='of' target='RFC9113'/> logically map to
the HTTP/3 error codes as follows:</t>
        <dl>
          <dt>NO_ERROR (0x00):</dt>
          <dd>
            <t><xref format='none' target='H3_NO_ERROR'>H3_NO_ERROR</xref><iref item='H3_NO_ERROR'/> in <xref target='http-error-codes'/>.</t>
          </dd>
          <dt>PROTOCOL_ERROR (0x01):</dt>
          <dd>
            <t>This is mapped to <xref format='none' target='H3_GENERAL_PROTOCOL_ERROR'>H3_GENERAL_PROTOCOL_ERROR</xref><iref item='H3_GENERAL_PROTOCOL_ERROR'/> except in cases where more
specific error codes have been defined. Such cases include
<xref format='none' target='H3_FRAME_UNEXPECTED'>H3_FRAME_UNEXPECTED</xref><iref item='H3_FRAME_UNEXPECTED'/>, <xref format='none' target='H3_MESSAGE_ERROR'>H3_MESSAGE_ERROR</xref><iref item='H3_MESSAGE_ERROR'/>, and <xref format='none' target='H3_CLOSED_CRITICAL_STREAM'>H3_CLOSED_CRITICAL_STREAM</xref><iref item='H3_CLOSED_CRITICAL_STREAM'/> defined
in <xref target='http-error-codes'/>.</t>
          </dd>
          <dt>INTERNAL_ERROR (0x02):</dt>
          <dd>
            <t><xref format='none' target='H3_INTERNAL_ERROR'>H3_INTERNAL_ERROR</xref><iref item='H3_INTERNAL_ERROR'/> in <xref target='http-error-codes'/>.</t>
          </dd>
          <dt>FLOW_CONTROL_ERROR (0x03):</dt>
          <dd>
            <t>Not applicable, since QUIC handles flow control.</t>
          </dd>
          <dt>SETTINGS_TIMEOUT (0x04):</dt>
          <dd>
            <t>Not applicable, since no acknowledgment of <xref format='none' target='frame-settings'>SETTINGS</xref><iref item='SETTINGS'/> is defined.</t>
          </dd>
          <dt>STREAM_CLOSED (0x05):</dt>
          <dd>
            <t>Not applicable, since QUIC handles stream management.</t>
          </dd>
          <dt>FRAME_SIZE_ERROR (0x06):</dt>
          <dd>
            <t><xref format='none' target='H3_FRAME_ERROR'>H3_FRAME_ERROR</xref><iref item='H3_FRAME_ERROR'/> error code defined in <xref target='http-error-codes'/>.</t>
          </dd>
          <dt>REFUSED_STREAM (0x07):</dt>
          <dd>
            <t><xref format='none' target='H3_REQUEST_REJECTED'>H3_REQUEST_REJECTED</xref><iref item='H3_REQUEST_REJECTED'/> (in <xref target='http-error-codes'/>) is used to indicate that a
request was not processed. Otherwise, not applicable because QUIC handles
stream management.</t>
          </dd>
          <dt>CANCEL (0x08):</dt>
          <dd>
            <t><xref format='none' target='H3_REQUEST_CANCELLED'>H3_REQUEST_CANCELLED</xref><iref item='H3_REQUEST_CANCELLED'/> in <xref target='http-error-codes'/>.</t>
          </dd>
          <dt>COMPRESSION_ERROR (0x09):</dt>
          <dd>
            <t>Multiple error codes are defined in <xref target='RFC9204'/>.</t>
          </dd>
          <dt>CONNECT_ERROR (0x0a):</dt>
          <dd>
            <t><xref format='none' target='H3_CONNECT_ERROR'>H3_CONNECT_ERROR</xref><iref item='H3_CONNECT_ERROR'/> in <xref target='http-error-codes'/>.</t>
          </dd>
          <dt>ENHANCE_YOUR_CALM (0x0b):</dt>
          <dd>
            <t><xref format='none' target='H3_EXCESSIVE_LOAD'>H3_EXCESSIVE_LOAD</xref><iref item='H3_EXCESSIVE_LOAD'/> in <xref target='http-error-codes'/>.</t>
          </dd>
          <dt>INADEQUATE_SECURITY (0x0c):</dt>
          <dd>
            <t>Not applicable, since QUIC is assumed to provide sufficient security on all
connections.</t>
          </dd>
          <dt>HTTP_1_1_REQUIRED (0x0d):</dt>
          <dd>
            <t><xref format='none' target='H3_VERSION_FALLBACK'>H3_VERSION_FALLBACK</xref><iref item='H3_VERSION_FALLBACK'/> in <xref target='http-error-codes'/>.</t>
          </dd>
        </dl>
        <t>Error codes need to be defined for HTTP/2 and HTTP/3 separately.  See
<xref target='iana-error-codes'/>.</t>
        <section anchor='mapping-between-http2-and-http3-errors'>
          <name>Mapping between HTTP/2 and HTTP/3 Errors</name>
          <t>An intermediary that converts between HTTP/2 and HTTP/3 may encounter error
conditions from either upstream. It is useful to communicate the occurrence of
errors to the downstream, but error codes largely reflect connection-local
problems that generally do not make sense to propagate.</t>
          <t>An intermediary that encounters an error from an upstream origin can indicate
this by sending an HTTP status code such as 502 (Bad Gateway), which is suitable
for a broad class of errors.</t>
          <t>There are some rare cases where it is beneficial to propagate the error by
mapping it to the closest matching error type to the receiver. For example, an
intermediary that receives an HTTP/2 <xref format='none' target='errors'>stream error</xref><iref item='stream error'/> of type REFUSED_STREAM from
the origin has a clear signal that the request was not processed and that the
request is safe to retry. Propagating this error condition to the client as an
HTTP/3 <xref format='none' target='errors'>stream error</xref><iref item='stream error'/> of type <xref format='none' target='H3_REQUEST_REJECTED'>H3_REQUEST_REJECTED</xref><iref item='H3_REQUEST_REJECTED'/> allows the client to take the
action it deems most appropriate. In the reverse direction, the intermediary
might deem it beneficial to pass on client request cancellations that are
indicated by terminating a stream with <xref format='none' target='H3_REQUEST_CANCELLED'>H3_REQUEST_CANCELLED</xref><iref item='H3_REQUEST_CANCELLED'/>; see
<xref target='request-cancellation'/>.</t>
          <t>Conversion between errors is described in the logical mapping. The error codes
are defined in non-overlapping spaces in order to protect against accidental
conversion that could result in the use of inappropriate or unknown error codes
for the target version. An intermediary is permitted to promote <xref format='none' target='errors'>stream errors</xref><iref item='stream error'/> to
<xref format='none' target='errors'>connection errors</xref><iref item='connection error'/> but they should be aware of the cost to the HTTP/3 connection
for what might be a temporary or intermittent error.</t>
        </section>
      </section>
    </section>
    <section anchor='acknowledgments' numbered='false'>
      <name>Acknowledgments</name>
      <t><contact fullname='Robbie Shade'/> and <contact fullname='Mike Warres'/> were the authors of
draft-shade-quic-http2-mapping, a precursor of this document.</t>
      <t>The IETF QUIC Working Group received an enormous amount of support from many
people. Among others, the following people provided substantial contributions to
this document:</t>
      <ul spacing='compact'>
        <li>
          <t><contact fullname="Bence Beky"/></t>
        </li>
        <li>
          <t><contact fullname="Daan De Meyer"/></t>
        </li>
        <li>
          <t><contact fullname="Martin Duke"/></t>
        </li>
        <li>
          <t><contact fullname="Roy Fielding"/></t>
        </li>
        <li>
          <t><contact fullname="Alan Frindell"/></t>
        </li>
        <li>
          <t><contact fullname="Alessandro Ghedini"/></t>
        </li>
        <li>
          <t><contact fullname="Nick Harper"/></t>
        </li>
        <li>
          <t><contact fullname="Ryan Hamilton"/></t>
        </li>
        <li>
          <t><contact fullname="Christian Huitema"/></t>
        </li>
        <li>
          <t><contact fullname="Subodh Iyengar"/></t>
        </li>
        <li>
          <t><contact fullname="Robin Marx"/></t>
        </li>
        <li>
          <t><contact fullname="Patrick McManus"/></t>
        </li>
        <li>
          <t><contact fullname="Luca Niccolini"/></t>
        </li>
        <li>
          <t><contact asciiFullname="Kazuho Oku" fullname=" "/></t>
        </li>
        <li>
          <t><contact fullname="Lucas Pardue"/></t>
        </li>
        <li>
          <t><contact fullname="Roberto Peon"/></t>
        </li>
        <li>
          <t><contact fullname="Julian Reschke"/></t>
        </li>
        <li>
          <t><contact fullname="Eric Rescorla"/></t>
        </li>
        <li>
          <t><contact fullname="Martin Seemann"/></t>
        </li>
        <li>
          <t><contact fullname="Ben Schwartz"/></t>
         </li>
        <li>
          <t><contact fullname="Ian Swett"/></t>
        </li>
        <li>
          <t><contact fullname="Willy Taureau"/></t>
        </li>
        <li>
          <t><contact fullname="Martin Thomson"/></t>
        </li>
        <li>
          <t><contact fullname="Dmitri Tikhonov"/></t>
        </li>
        <li>
          <t><contact fullname="Tatsuhiro Tsujikawa"/></t>
        </li>
      </ul>
      <t>A portion of <contact fullname='Mike Bishop'/>'s contribution was supported by Microsoft during
his employment there.</t>
    </section>
  </back>
</rfc>
