<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<!-- generated by https://github.com/cabo/kramdown-rfc version 1.6.16 (Ruby 2.6.8) -->
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" ipr="trust200902" docName="draft-ietf-masque-connect-udp-latest" category="std" consensus="true" submissionType="IETF" number="9298" tocInclude="true" sortRefs="true" symRefs="true" version="3">
  <!-- xml2rfc v2v3 conversion 3.13.1 -->
  <link href="https://datatracker.ietf.org/doc/draft-ietf-masque-connect-udp-latest" rel="prev"/>
  <front>
    <title>Proxying UDP in HTTP</title>
    <seriesInfo name="RFC" value="9298"/>
    <author initials="D." surname="Schinazi" fullname="David Schinazi">
      <organization>Google LLC</organization>
      <address>
        <postal>
          <street>1600 Amphitheatre Parkway</street>
          <city>Mountain View</city>
          <region>CA</region>
          <code>94043</code>
          <country>United States of America</country>
        </postal>
        <email>dschinazi.ietf@gmail.com</email>
      </address>
    </author>
    <date year="2022" month="August"/>
    <area>Transport</area>
    <workgroup>MASQUE</workgroup>
    <keyword>quic</keyword>
    <keyword>http</keyword>
    <keyword>datagram</keyword>
    <keyword>udp</keyword>
    <keyword>proxy</keyword>
    <keyword>tunnels</keyword>
    <keyword>quic in quic</keyword>
    <keyword>turtles all the way down</keyword>
    <keyword>masque</keyword>
    <keyword>http-ng</keyword>
    <abstract>
      <t>This document describes how to proxy UDP in HTTP, similar to how the HTTP
CONNECT method allows proxying TCP in HTTP. More specifically, this document
defines a protocol that allows an HTTP client to create a tunnel for UDP
communications through an HTTP server that acts as a proxy.</t>
    </abstract>
  </front>
  <middle>
    <section anchor="introduction">
      <name>Introduction</name>
      <t>While HTTP provides the CONNECT method (see <xref section="9.3.6" sectionFormat="of" target="RFC9110"/>)
for creating a TCP <xref target="RFC9293"/> tunnel to a proxy, it lacked a method for
doing so for UDP <xref target="RFC0768"/> traffic prior to this specification.</t>
      <t>This document describes a protocol for tunneling UDP to a server acting as a
UDP-specific proxy over HTTP. UDP tunnels are commonly used to create an
end-to-end virtual connection, which can then be secured using QUIC
<xref target="RFC9000"/> or another protocol running over UDP. Unlike the HTTP CONNECT
method, the UDP proxy itself is identified with an absolute URL containing the
traffic's destination. Clients generate those URLs using a URI Template
<xref target="RFC6570"/>, as described in <xref target="client-config"/>.</t>
      <t>This protocol supports all existing versions of HTTP by using HTTP Datagrams
<xref target="RFC9297"/>. When using HTTP/2 <xref target="RFC9113"/> or HTTP/3
<xref target="RFC9114"/>, it uses HTTP Extended CONNECT as described in <xref target="RFC8441"/>
and <xref target="RFC9220"/>. When using HTTP/1.x <xref target="RFC9112"/>, it uses HTTP Upgrade
as defined in <xref section="7.8" sectionFormat="of" target="RFC9110"/>.</t>
      <section anchor="conventions">
        <name>Conventions and Definitions</name>
        <t>The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL
NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
"<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as
described in BCPÂ 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they
appear in all capitals, as shown here.</t>
        <t>In this document, we use the term "UDP proxy" to refer to the HTTP server that
acts upon the client's UDP tunneling request to open a UDP socket to a target
server and that generates the response to this request. If there are HTTP
intermediaries (as defined in <xref section="3.7" sectionFormat="of" target="RFC9110"/>) between the client and
the UDP proxy, those are referred to as "intermediaries" in this document.</t>
        <t>Note that, when the HTTP version in use does not support multiplexing streams
(such as HTTP/1.1), any reference to "stream" in this document represents the
entire connection.</t>
      </section>
    </section>
    <section anchor="client-config">
      <name>Client Configuration</name>
      <t>HTTP clients are configured to use a UDP proxy with a URI Template
<xref target="RFC6570"/> that has the variables "target_host" and "target_port".
Examples are shown below:</t>
      <figure anchor="fig-template-examples">
        <name>URI Template Examples</name>
        <artwork type="ascii-art"><![CDATA[
https://example.org/.well-known/masque/udp/{target_host}/{target_port}/
https://proxy.example.org:4443/masque?h={target_host}&p={target_port}
https://proxy.example.org:4443/masque{?target_host,target_port}
]]></artwork>
      </figure>
      <t>The following requirements apply to the URI Template:</t>
      <ul spacing="normal">
        <li>The URI Template <bcp14>MUST</bcp14> be a level 3 template or lower.</li>
        <li>The URI Template <bcp14>MUST</bcp14> be in absolute form and <bcp14>MUST</bcp14> include non-empty scheme,
authority, and path components.</li>
        <li>The path component of the URI Template <bcp14>MUST</bcp14> start with a slash ("/").</li>
        <li>All template variables <bcp14>MUST</bcp14> be within the path or query components of the URI.</li>
        <li>The URI Template <bcp14>MUST</bcp14> contain the two variables "target_host" and
"target_port" and <bcp14>MAY</bcp14> contain other variables.</li>
        <li>The URI Template <bcp14>MUST NOT</bcp14> contain any non-ASCII Unicode characters and <bcp14>MUST</bcp14>
only contain ASCII characters in the range 0x21-0x7E inclusive (note that
percent-encoding is allowed; see <xref section="2.1" sectionFormat="of" target="RFC3986"/>).</li>
        <li>The URI Template <bcp14>MUST NOT</bcp14> use Reserved Expansion ("+" operator), Fragment
Expansion ("#" operator), Label Expansion with Dot-Prefix, Path Segment
Expansion with Slash-Prefix, nor Path-Style Parameter Expansion with
Semicolon-Prefix.</li>
      </ul>
      <t>Clients <bcp14>SHOULD</bcp14> validate the requirements above; however, clients <bcp14>MAY</bcp14> use a
general-purpose URI Template implementation that lacks this specific validation.
If a client detects that any of the requirements above are not met by a URI
Template, the client <bcp14>MUST</bcp14> reject its configuration and abort the request without
sending it to the UDP proxy.</t>
      <t>The original HTTP CONNECT method allowed for the conveyance of the target host
and port, but not the scheme, proxy authority, path, or query. Thus, clients
with proxy configuration interfaces that only allow the user to configure the
proxy host and the proxy port exist. Client implementations of this
specification that are constrained by such limitations <bcp14>MAY</bcp14> attempt to access UDP
proxying capabilities using the default template, which is defined as
"https://$PROXY_HOST:$PROXY_PORT/.well-known/masque/udp/{target_host}/{target_port}/",
where $PROXY_HOST and $PROXY_PORT are the configured host and port of the UDP
proxy, respectively. UDP proxy deployments <bcp14>SHOULD</bcp14> offer service at this location
if they need to interoperate with such clients.</t>
    </section>
    <section anchor="tunneling-udp-over-http">
      <name>Tunneling UDP over HTTP</name>
      <t>To allow negotiation of a tunnel for UDP over HTTP, this document defines the
"connect-udp" HTTP upgrade token. The resulting UDP tunnels use the Capsule
Protocol (see <xref section="3.2" sectionFormat="of" target="RFC9297"/>) with HTTP Datagrams in the format
defined in <xref target="format"/>.</t>
      <t>To initiate a UDP tunnel associated with a single HTTP stream, a client issues a
request containing the "connect-udp" upgrade token. The target of the tunnel is
indicated by the client to the UDP proxy via the "target_host" and "target_port"
variables of the URI Template; see <xref target="client-config"/>.</t>
      <t>"target_host" supports using DNS names, IPv6 literals and IPv4 literals. Note
that IPv6 scoped addressing zone identifiers are not supported. Using the terms
IPv6address, IPv4address, reg-name, and port from <xref target="RFC3986"/>, the "target_host" and
"target_port" variables <bcp14>MUST</bcp14> adhere to the format in <xref target="target-format"/>, using
notation from <xref target="RFC2234"/>. Additionally:</t>
      <ul spacing="normal">
        <li>both the "target_host" and "target_port" variables <bcp14>MUST NOT</bcp14> be empty.</li>
        <li>if "target_host" contains an IPv6 literal, the colons (":") <bcp14>MUST</bcp14> be
percent-encoded. For example, if the target host is "2001:db8::42", it will be
encoded in the URI as "2001%3Adb8%3A%3A42".</li>
        <li>"target_port" <bcp14>MUST</bcp14> represent an integer between 1 and 65535 inclusive.</li>
      </ul>
      <figure anchor="target-format">
        <name>URI Template Variable Format</name>
        <artwork type="ascii-art"><![CDATA[
target_host = IPv6address / IPv4address / reg-name
target_port = port
]]></artwork>
      </figure>
      <t>When sending its UDP proxying request, the client <bcp14>SHALL</bcp14> perform URI Template
expansion to determine the path and query of its request.</t>
      <t>If the request is successful, the UDP proxy commits to converting received HTTP
Datagrams into UDP packets, and vice versa, until the tunnel is closed.</t>
      <t>By virtue of the definition of the Capsule Protocol (see <xref section="3.2" sectionFormat="of" target="RFC9297"/>), UDP proxying requests do not carry any message content.
Similarly, successful UDP proxying responses also do not carry any message
content.</t>
      <section anchor="handling">
        <name>UDP Proxy Handling</name>
        <t>Upon receiving a UDP proxying request:</t>
        <ul spacing="normal">
          <li>if the recipient is configured to use another HTTP proxy, it will act as an
intermediary by forwarding the request to another HTTP server. Note that such
intermediaries may need to re-encode the request if they forward it using a
version of HTTP that is different from the one used to receive it, as the
request encoding differs by version (see below).</li>
          <li>otherwise, the recipient will act as a UDP proxy. It extracts the
"target_host" and "target_port" variables from the URI it has reconstructed
from the request headers, decodes their percent-encoding, and establishes a
tunnel by directly opening a UDP socket to the requested target.</li>
        </ul>
        <t>Unlike TCP, UDP is connectionless. The UDP proxy that opens the UDP socket has
no way of knowing whether the destination is reachable. Therefore, it needs to
respond to the request without waiting for a packet from the target. However, if
the "target_host" is a DNS name, the UDP proxy <bcp14>MUST</bcp14> perform DNS resolution
before replying to the HTTP request. If errors occur during this process, the
UDP proxy <bcp14>MUST</bcp14> reject the request and <bcp14>SHOULD</bcp14> send details using an appropriate
Proxy-Status header field <xref target="RFC9209"/>. For example, if DNS
resolution returns an error, the proxy can use the dns_error Proxy Error Type
from <xref section="2.3.2" sectionFormat="of" target="RFC9209"/>.</t>
        <t>UDP proxies can use connected UDP sockets if their operating system supports
them, as that allows the UDP proxy to rely on the kernel to only send it UDP
packets that match the correct 5-tuple. If the UDP proxy uses a non-connected
socket, it <bcp14>MUST</bcp14> validate the IP source address and UDP source port on received
packets to ensure they match the client's request. Packets that do not match
<bcp14>MUST</bcp14> be discarded by the UDP proxy.</t>
        <t>The lifetime of the socket is tied to the request stream. The UDP proxy <bcp14>MUST</bcp14>
keep the socket open while the request stream is open. If a UDP proxy is
notified by its operating system that its socket is no longer usable, it <bcp14>MUST</bcp14>
close the request stream. For example, this can happen when an ICMP Destination
Unreachable message is received; see <xref section="3.1" sectionFormat="of" target="RFC4443"/>. UDP
proxies <bcp14>MAY</bcp14> choose to close sockets due to a period of inactivity, but they <bcp14>MUST</bcp14>
close the request stream when closing the socket. UDP proxies that close sockets
after a period of inactivity <bcp14>SHOULD NOT</bcp14> use a period lower than two minutes; see
<xref section="4.3" sectionFormat="of" target="RFC4787"/>.</t>
        <t>A successful response (as defined in Sections <xref format="counter" target="resp1"/> and <xref format="counter" target="resp23"/>)
indicates that the UDP proxy has opened a socket to the requested target and is
willing to proxy UDP payloads. Any response other than a successful response
indicates that the request has failed; thus, the client <bcp14>MUST</bcp14> abort the request.</t>
        <t>UDP proxies <bcp14>MUST NOT</bcp14> introduce fragmentation at the IP layer when forwarding
HTTP Datagrams onto a UDP socket; overly large datagrams are silently dropped.
In IPv4, the Don't Fragment (DF) bit <bcp14>MUST</bcp14> be set, if possible, to prevent
fragmentation on the path. Future extensions <bcp14>MAY</bcp14> remove these requirements.</t>
        <t>Implementers of UDP proxies will benefit from reading the guidance in
<xref target="RFC8085"/>.</t>
      </section>
      <section anchor="req1">
        <name>HTTP/1.1 Request</name>
        <t>When using HTTP/1.1 <xref target="RFC9112"/>, a UDP proxying request will meet the following
requirements:</t>
        <ul spacing="normal">
          <li>the method <bcp14>SHALL</bcp14> be "GET".</li>
          <li>the request <bcp14>SHALL</bcp14> include a single Host header field containing the origin
of the UDP proxy.</li>
          <li>the request <bcp14>SHALL</bcp14> include a Connection header field with value "Upgrade"
(note that this requirement is case-insensitive as per <xref section="7.6.1" sectionFormat="of" target="RFC9110"/>).</li>
          <li>the request <bcp14>SHALL</bcp14> include an Upgrade header field with value "connect-udp".</li>
        </ul>
        <t>A UDP proxying request that does not conform to these restrictions is malformed.
The recipient of such a malformed request <bcp14>MUST</bcp14> respond with an error and <bcp14>SHOULD</bcp14>
use the 400 (Bad Request) status code.</t>
        <t>For example, if the client is configured with URI Template
"https://example.org/.well-known/masque/udp/{target_host}/{target_port}/" and
wishes to open a UDP proxying tunnel to target 192.0.2.6:443, it could send the
following request:</t>
        <figure anchor="fig-req-h1">
          <name>Example HTTP/1.1 Request</name>
          <artwork><![CDATA[
GET https://example.org/.well-known/masque/udp/192.0.2.6/443/ HTTP/1.1
Host: example.org
Connection: Upgrade
Upgrade: connect-udp
Capsule-Protocol: ?1
]]></artwork>
        </figure>
        <t>In HTTP/1.1, this protocol uses the GET method to mimic the design of the
WebSocket Protocol <xref target="RFC6455"/>.</t>
      </section>
      <section anchor="resp1">
        <name>HTTP/1.1 Response</name>
        <t>The UDP proxy <bcp14>SHALL</bcp14> indicate a successful response by replying with the
following requirements:</t>
        <ul spacing="normal">
          <li>the HTTP status code on the response <bcp14>SHALL</bcp14> be 101 (Switching Protocols).</li>
          <li>the response <bcp14>SHALL</bcp14> include a Connection header field with value "Upgrade"
(note that this requirement is case-insensitive as per <xref section="7.6.1" sectionFormat="of" target="RFC9110"/>).</li>
          <li>the response <bcp14>SHALL</bcp14> include a single Upgrade header field with value
"connect-udp".</li>
          <li>the response <bcp14>SHALL</bcp14> meet the requirements of HTTP responses that start the
Capsule Protocol; see <xref section="3.2" sectionFormat="of" target="RFC9297"/>.</li>
        </ul>
        <t>If any of these requirements are not met, the client <bcp14>MUST</bcp14> treat this proxying
attempt as failed and abort the connection.</t>
        <t>For example, the UDP proxy could respond with:</t>
        <figure anchor="fig-resp-h1">
          <name>Example HTTP/1.1 Response</name>
          <sourcecode type="http-message"><![CDATA[
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: connect-udp
Capsule-Protocol: ?1
]]></sourcecode>
        </figure>
      </section>
      <section anchor="req23">
        <name>HTTP/2 and HTTP/3 Requests</name>
        <t>When using HTTP/2 <xref target="RFC9113"/> or HTTP/3 <xref target="RFC9114"/>, UDP proxying requests use HTTP
Extended CONNECT. This requires that servers send an HTTP Setting as specified
in <xref target="RFC8441"/> and <xref target="RFC9220"/> and that requests use HTTP
pseudo-header fields with the following requirements:</t>
        <ul spacing="normal">
          <li>The :method pseudo-header field <bcp14>SHALL</bcp14> be "CONNECT".</li>
          <li>The :protocol pseudo-header field <bcp14>SHALL</bcp14> be "connect-udp".</li>
          <li>The :authority pseudo-header field <bcp14>SHALL</bcp14> contain the authority of the UDP
proxy.</li>
          <li>The :path and :scheme pseudo-header fields <bcp14>SHALL NOT</bcp14> be empty. Their
values <bcp14>SHALL</bcp14> contain the scheme and path from the URI Template after the URI
Template expansion process has been completed.</li>
        </ul>
        <t>A UDP proxying request that does not conform to these restrictions is
malformed (see <xref section="8.1.1" sectionFormat="of" target="RFC9113"/> and <xref section="4.1.2" sectionFormat="of" target="RFC9114"/>).</t>
        <t>For example, if the client is configured with URI Template
"https://example.org/.well-known/masque/udp/{target_host}/{target_port}/" and
wishes to open a UDP proxying tunnel to target 192.0.2.6:443, it could send the
following request:</t>
        <figure anchor="fig-req-h2">
          <name>Example HTTP/2 Request</name>
          <sourcecode type="http-message"><![CDATA[
HEADERS
:method = CONNECT
:protocol = connect-udp
:scheme = https
:path = /.well-known/masque/udp/192.0.2.6/443/
:authority = example.org
capsule-protocol = ?1
]]></sourcecode>
        </figure>
      </section>
      <section anchor="resp23">
        <name>HTTP/2 and HTTP/3 Responses</name>
        <t>The UDP proxy <bcp14>SHALL</bcp14> indicate a successful response by replying with the
following requirements:</t>
        <ul spacing="normal">
          <li>the HTTP status code on the response <bcp14>SHALL</bcp14> be in the 2xx (Successful) range.</li>
          <li>the response <bcp14>SHALL</bcp14> meet the requirements of HTTP responses that start the
Capsule Protocol; see <xref section="3.2" sectionFormat="of" target="RFC9297"/>.</li>
        </ul>
        <t>If any of these requirements are not met, the client <bcp14>MUST</bcp14> treat this proxying
attempt as failed and abort the request.</t>
        <t>For example, the UDP proxy could respond with:</t>
        <figure anchor="fig-resp-h2">
          <name>Example HTTP/2 Response</name>
          <sourcecode type="http-message"><![CDATA[
HEADERS
:status = 200
capsule-protocol = ?1
]]></sourcecode>
        </figure>
      </section>
    </section>
    <section anchor="context-id">
      <name>Context Identifiers</name>
      <t>The mechanism for proxying UDP in HTTP defined in this document allows future
extensions to exchange HTTP Datagrams that carry different semantics from UDP
payloads. Some of these extensions can augment UDP payloads with additional
data, while others can exchange data that is completely separate from UDP
payloads. In order to accomplish this, all HTTP Datagrams associated with UDP
Proxying request streams start with a Context ID field; see <xref target="format"/>.</t>
      <t>Context IDs are 62-bit integers (0 to 2<sup>62</sup>-1). Context IDs are encoded
as variable-length integers; see <xref section="16" sectionFormat="of" target="RFC9000"/>. The Context ID value of
0 is reserved for UDP payloads, while non-zero values are dynamically allocated.
Non-zero even-numbered Context IDs are client-allocated, and odd-numbered
Context IDs are proxy-allocated. The Context ID namespace is tied to a given
HTTP request; it is possible for a Context ID with the same numeric value to be
simultaneously allocated in distinct requests, potentially with different
semantics. Context IDs <bcp14>MUST NOT</bcp14> be re-allocated within a given HTTP namespace
but <bcp14>MAY</bcp14> be allocated in any order. The Context ID allocation restrictions to the
use of even-numbered and odd-numbered Context IDs exist in order to avoid the
need for synchronization between endpoints. However, once a Context ID has been
allocated, those restrictions do not apply to the use of the Context ID; it can
be used by any client or UDP proxy, independent of which endpoint initially
allocated it.</t>
      <t>Registration is the action by which an endpoint informs its peer of the
semantics and format of a given Context ID. This document does not define how
registration occurs. Future extensions <bcp14>MAY</bcp14> use HTTP header fields or capsules to
register Context IDs. Depending on the method being used, it is possible for
datagrams to be received with Context IDs that have not yet been registered. For
instance, this can be due to reordering of the packet containing the datagram
and the packet containing the registration message during transmission.</t>
    </section>
    <section anchor="format">
      <name>HTTP Datagram Payload Format</name>
      <t>When HTTP Datagrams (see <xref section="2" sectionFormat="of" target="RFC9297"/>) are associated with UDP
Proxying request streams, the HTTP Datagram Payload field has the format defined
in <xref target="dgram-format"/>, using notation from <xref section="1.3" sectionFormat="of" target="RFC9000"/>. Note that when
HTTP Datagrams are encoded using QUIC DATAGRAM frames <xref target="RFC9221"/>,
the Context ID field defined below directly follows the Quarter Stream ID field,
which is at the start of the QUIC DATAGRAM frame payload; see <xref section="2.1" sectionFormat="of" target="RFC9297"/>.</t>
      <figure anchor="dgram-format">
        <name>UDP Proxying HTTP Datagram Format</name>
        <artwork type="ascii-art"><![CDATA[
UDP Proxying HTTP Datagram Payload {
  Context ID (i),
  UDP Proxying Payload (..),
}
]]></artwork>
      </figure>
      <dl spacing="compact">
        <dt>Context ID:</dt>
        <dd>
          <t>A variable-length integer (see <xref section="16" sectionFormat="of" target="RFC9000"/>) that contains the value
of the Context ID. If an HTTP/3 Datagram that carries an unknown Context ID is
received, the receiver <bcp14>SHALL</bcp14> either drop that datagram silently or buffer it
temporarily (on the order of a round trip) while awaiting the registration of
the corresponding Context ID.</t>
        </dd>
        <dt>UDP Proxying Payload:</dt>
        <dd>
          <t>The payload of the datagram, whose semantics depend on the value of the
previous field. Note that this field can be empty.</t>
        </dd>
      </dl>
      <t>UDP packets are encoded using HTTP Datagrams with the Context ID field set to
zero. When the Context ID field is set to zero, the UDP Proxying Payload field
contains the unmodified payload of a UDP packet (referred to as data octets in
<xref target="RFC0768"/>).</t>
      <t>By virtue of the definition of the UDP header <xref target="RFC0768"/>, it is not possible to
encode UDP payloads longer than 65527 bytes. Therefore, endpoints <bcp14>MUST NOT</bcp14> send
HTTP Datagrams with a UDP Proxying Payload field longer than 65527 using Context
ID zero. An endpoint that receives an HTTP Datagram using Context ID zero whose
UDP Proxying Payload field is longer than 65527 <bcp14>MUST</bcp14> abort the corresponding
stream. If a UDP proxy knows it can only send out UDP packets of a certain
length due to its underlying link MTU, it has no choice but to discard incoming
HTTP Datagrams using Context ID zero whose UDP Proxying Payload field is longer
than that limit. If the discarded HTTP Datagram was transported by a DATAGRAM
capsule, the receiver <bcp14>SHOULD</bcp14> discard that capsule without buffering the capsule
contents.</t>
      <t>If a UDP proxy receives an HTTP Datagram before it has received the
corresponding request, it <bcp14>SHALL</bcp14> either drop that HTTP Datagram silently or
buffer it temporarily (on the order of a round trip) while awaiting the
corresponding request.</t>
      <t>Note that buffering datagrams (either because the request was not yet received
or because the Context ID is not yet known) consumes resources. Receivers that
buffer datagrams <bcp14>SHOULD</bcp14> apply buffering limits in order to reduce the risk of
resource exhaustion occurring. For example, receivers can limit the total number
of buffered datagrams or the cumulative size of buffered datagrams on a
per-stream, per-context, or per-connection basis.</t>
      <t>A client <bcp14>MAY</bcp14> optimistically start sending UDP packets in HTTP Datagrams before
receiving the response to its UDP proxying request. However, implementers should
note that such proxied packets may not be processed by the UDP proxy if it
responds to the request with a failure or if the proxied packets are received by
the UDP proxy before the request and the UDP proxy chooses to not buffer them.</t>
    </section>
    <section anchor="performance">
      <name>Performance Considerations</name>
      <t>Bursty traffic can often lead to temporally correlated packet losses; in turn,
this can lead to suboptimal responses from congestion controllers in protocols
running over UDP. To avoid this, UDP proxies <bcp14>SHOULD</bcp14> strive to avoid increasing
burstiness of UDP traffic; they <bcp14>SHOULD NOT</bcp14> queue packets in order to increase
batching.</t>
      <t>When the protocol running over UDP that is being proxied uses congestion control
(e.g., <xref target="RFC9000"/>), the proxied traffic will incur at least two nested congestion
controllers. The underlying HTTP connection <bcp14>MUST NOT</bcp14> disable congestion control
unless it has an out-of-band way of knowing with absolute certainty that the
inner traffic is congestion-controlled.</t>
      <t>If a client or UDP proxy with a connection containing a UDP Proxying request
stream disables congestion control, it <bcp14>MUST NOT</bcp14> signal Explicit Congestion
Notification (ECN) <xref target="RFC3168"/> support on that connection. That is, it <bcp14>MUST</bcp14>
mark all IP headers with the Not-ECT codepoint. It <bcp14>MAY</bcp14> continue to report ECN
feedback via QUIC ACK_ECN frames or the TCP ECE bit, as the peer may not have
disabled congestion control.</t>
      <t>When the protocol running over UDP that is being proxied uses loss recovery
(e.g., <xref target="RFC9000"/>), and the underlying HTTP connection runs over TCP, the proxied
traffic will incur at least two nested loss recovery mechanisms. This can reduce
performance as both can sometimes independently retransmit the same data. To
avoid this, UDP proxying <bcp14>SHOULD</bcp14> be performed over HTTP/3 to allow leveraging the
QUIC DATAGRAM frame.</t>
      <section anchor="mtu-considerations">
        <name>MTU Considerations</name>
        <t>When using HTTP/3 with the QUIC Datagram extension <xref target="RFC9221"/>, UDP payloads
are transmitted in QUIC DATAGRAM frames. Since those cannot be fragmented, they
can only carry payloads up to a given length determined by the QUIC connection
configuration and the Path MTU (PMTU). If a UDP proxy is using QUIC DATAGRAM
frames and it receives a UDP payload from the target that will not fit inside a
QUIC DATAGRAM frame, the UDP proxy <bcp14>SHOULD NOT</bcp14> send the UDP payload in a DATAGRAM
capsule, as that defeats the end-to-end unreliability characteristic that
methods such as Datagram Packetization Layer PMTU Discovery (DPLPMTUD) depend on
<xref target="RFC8899"/>. In this scenario, the UDP proxy <bcp14>SHOULD</bcp14> drop the UDP
payload and send an ICMP Packet Too Big message to the target; see <xref section="3.2" sectionFormat="of" target="RFC4443"/>.</t>
      </section>
      <section anchor="tunneling-of-ecn-marks">
        <name>Tunneling of ECN Marks</name>
        <t>UDP proxying does not create an IP-in-IP tunnel, so the guidance in
<xref target="RFC6040"/> about transferring ECN marks between inner and outer IP
headers does not apply. There is no inner IP header in UDP proxying tunnels.</t>
        <t>In this specification, note that UDP proxying clients do not have the ability to
control the ECN codepoints on UDP packets the UDP proxy sends to the target, nor
can UDP proxies communicate the markings of each UDP packet from target to UDP
proxy.</t>
        <t>A UDP proxy <bcp14>MUST</bcp14> ignore ECN bits in the IP header of UDP packets received from
the target, and it <bcp14>MUST</bcp14> set the ECN bits to Not-ECT on UDP packets it sends to
the target. These do not relate to the ECN markings of packets sent between
client and UDP proxy in any way.</t>
      </section>
    </section>
    <section anchor="security">
      <name>Security Considerations</name>
      <t>There are significant risks in allowing arbitrary clients to establish a tunnel
to arbitrary targets, as that could allow bad actors to send traffic and have it
attributed to the UDP proxy. HTTP servers that support UDP proxying ought to
restrict its use to authenticated users.</t>
      <t>There exist software and network deployments that perform access control checks
based on the source IP address of incoming requests. For example, some software
allows unauthenticated configuration changes if they originated from 127.0.0.1.
Such software could be running on the same host as the UDP proxy or in the same
broadcast domain. Proxied UDP traffic would then be received with a source IP
address belonging to the UDP proxy. If this source address is used for access
control, UDP proxying clients could use the UDP proxy to escalate their access
privileges beyond those they might otherwise have. This could lead to
unauthorized access by UDP proxying clients unless the UDP proxy disallows UDP
proxying requests to vulnerable targets, such as the UDP proxy's own addresses
and localhost, link-local, multicast, and broadcast addresses. UDP proxies can
use the destination_ip_prohibited Proxy Error Type from <xref section="2.3.5" sectionFormat="of" target="RFC9209"/> when rejecting such requests.</t>
      <t>UDP proxies share many similarities with TCP CONNECT proxies when considering
them as infrastructure for abuse to enable denial-of-service (DoS) attacks. Both
can obfuscate the attacker's source address from the attack target. In the case
of a stateless volumetric attack (e.g., a TCP SYN flood or a UDP flood), both
types of proxies pass the traffic to the target host. With stateful volumetric
attacks (e.g., HTTP flooding) being sent over a TCP CONNECT proxy, the proxy
will only send data if the target has indicated its willingness to accept data
by responding with a TCP SYN-ACK. Once the path to the target is flooded, the
TCP CONNECT proxy will no longer receive replies from the target and will stop
sending data. Since UDP does not establish shared state between the UDP proxy
and the target, the UDP proxy could continue sending data to the target in such
a situation. While a UDP proxy could potentially limit the number of UDP packets
it is willing to forward until it has observed a response from the target, that
provides limited protection against DoS attacks when attacks target open UDP
ports where the protocol running over UDP would respond and that would be
interpreted as willingness to accept UDP by the UDP proxy. Such a packet limit
could also cause issues for valid traffic.</t>
      <t>The security considerations described in <xref section="4" sectionFormat="of" target="RFC9297"/> also apply
here. Since it is possible to tunnel IP packets over UDP, the guidance in
<xref target="RFC6169"/> can apply.</t>
    </section>
    <section anchor="iana">
      <name>IANA Considerations</name>
      <section anchor="iana-upgrade">
        <name>HTTP Upgrade Token</name>
        <t>IANA has registered "connect-udp" in the "HTTP Upgrade Tokens" registry
maintained at &lt;<eref target="https://www.iana.org/assignments/http-upgrade-tokens"/>&gt;.</t>
        <dl spacing="compact">
          <dt>Value:</dt>
          <dd>
            <t>connect-udp</t>
          </dd>
          <dt>Description:</dt>
          <dd>
            <t>Proxying of UDP Payloads</t>
          </dd>
          <dt>Expected Version Tokens:</dt>
          <dd>
            <t>None</t>
          </dd>
          <dt>Reference:</dt>
          <dd>
            <t>RFC 9298</t>
          </dd>
        </dl>
      </section>
      <section anchor="iana-uri">
        <name>Well-Known URI</name>
        <t>IANA has registered "masque" in the "Well-Known URIs" registry maintained at
&lt;<eref target="https://www.iana.org/assignments/well-known-uris"/>&gt;.</t>
        <dl spacing="compact">
          <dt>URI Suffix:</dt>
          <dd>
            <t>masque</t>
          </dd>
          <dt>Change Controller:</dt>
          <dd>
            <t>IETF</t>
          </dd>
          <dt>Reference:</dt>
          <dd>
            <t>RFC 9298</t>
          </dd>
          <dt>Status:</dt>
          <dd>
            <t>permanent</t>
          </dd>
          <dt>Related Information:</dt>
          <dd>
            <t>Includes all resources identified with the path prefix
"/.well-known/masque/udp/"</t>
          </dd>
        </dl>
      </section>
    </section>
  </middle>
  <back>
      <displayreference target="RFC9112" to="HTTP/1.1"/>
      <displayreference target="RFC9113" to="HTTP/2"/>
      <displayreference target="RFC9114" to="HTTP/3"/>
      <displayreference target="RFC9110" to="HTTP"/>
      <displayreference target="RFC9293" to="TCP"/>
      <displayreference target="RFC0768" to="UDP"/>
      <displayreference target="RFC9000" to="QUIC"/>
      <displayreference target="RFC6570" to="TEMPLATE"/>
      <displayreference target="RFC9297" to="HTTP-DGRAM"/>
      <displayreference target="RFC8441" to="EXT-CONNECT2"/>
      <displayreference target="RFC9220" to="EXT-CONNECT3"/>
      <displayreference target="RFC9209" to="PROXY-STATUS"/>
      <displayreference target="RFC9221" to="QUIC-DGRAM"/>
      <displayreference target="RFC3168" to="ECN"/>
      <displayreference target="RFC3986" to="URI"/>
      <displayreference target="RFC4443" to="ICMP6"/>
      <displayreference target="RFC4787" to="BEHAVE"/>
      <displayreference target="RFC8085" to="UDP-USAGE"/>
      <displayreference target="RFC6455" to="WEBSOCKET"/>
      <displayreference target="RFC8899" to="DPLPMTUD"/>
      <displayreference target="RFC6040" to="ECN-TUNNEL"/>
      <displayreference target="RFC6169" to="TUNNEL-SECURITY"/>
      <displayreference target="RFC2234" to="ABNF"/>
      <displayreference target="I-D.schwartz-httpbis-helium" to="HELIUM"/>
      <displayreference target="I-D.pardue-httpbis-http-network-tunnelling" to="HiNT"/>
      <displayreference target="I-D.schinazi-masque" to="MASQUE-ORIGINAL"/>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>

<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.9112.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.9113.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.9114.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.9110.xml"/>
<xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.9293.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.0768.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.9000.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6570.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2234.xml"/>

<xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.9297.xml"/>

<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8441.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.9220.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.9209.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.9221.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3168.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3986.xml"/>

      </references>
      <references>
        <name>Informative References</name>

<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4443.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4787.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8085.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6455.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8899.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6040.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6169.xml"/>
<xi:include href="https://datatracker.ietf.org/doc/bibxml3/reference.I-D.draft-schwartz-httpbis-helium-00.xml"/>
<xi:include href="https://datatracker.ietf.org/doc/bibxml3/reference.I-D.draft-pardue-httpbis-http-network-tunnelling-00.xml"/>
<xi:include href="https://datatracker.ietf.org/doc/bibxml3/reference.I-D.draft-schinazi-masque-00.xml"/>

      </references>
    </references>
    <section numbered="false" anchor="acknowledgments">
      <name>Acknowledgments</name>
 <t>This document is a product of the MASQUE Working Group, and
      the author thanks all MASQUE enthusiasts for their
      contributions. This proposal was inspired directly or indirectly
      by prior work from many people, in particular <xref target="I-D.schwartz-httpbis-helium"/>
      by <contact fullname="Ben Schwartz"/>, <xref target="I-D.pardue-httpbis-http-network-tunnelling"/>
      by <contact fullname="Lucas Pardue"/>, and the original MASQUE Protocol <xref target="I-D.schinazi-masque"/>  by the author of this document.</t>
      
      <t>The author would like to thank <contact fullname="Eric
      Rescorla"/> for suggesting the use of an HTTP method to proxy
      UDP. The author is indebted to <contact fullname="Mark
      Nottingham"/> and <contact fullname="Lucas Pardue"/> for the
      many improvements they contributed to this document. The
      extensibility design in this document came out of the HTTP
      Datagrams Design Team, whose members were <contact
      fullname="Alan Frindell"/>, <contact fullname="Alex
      Chernyakhovsky"/>, <contact fullname="Ben Schwartz"/>, <contact
      fullname="Eric Rescorla"/>, <contact fullname="Lucas Pardue"/>,
      <contact fullname="Marcus Ihlar"/>, <contact fullname="Martin
      Thomson"/>, <contact fullname="Mike Bishop"/>, <contact
      fullname="Tommy Pauly"/>, <contact fullname="Victor Vasiliev"/>,
      and the author of this document.</t>
    </section>
  </back>


</rfc>
