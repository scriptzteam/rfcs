<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>

<rfc xmlns:xi="http://www.w3.org/2001/XInclude" ipr="trust200902" docName="draft-ietf-uuidrev-rfc4122bis-14" number="9562" submissionType="IETF" category="std" consensus="true" obsoletes="4122" updates="" tocDepth="3" tocInclude="true" sortRefs="true" symRefs="true" xml:lang="en" version="3">

  <front>
    <title abbrev="UUIDs">Universally Unique IDentifiers (UUIDs)</title>
    <seriesInfo name="RFC" value="9562"/>
    <author initials="K." surname="Davis" fullname="Kyzer R. Davis">
      <organization>Cisco Systems</organization>
      <address>
        <email>kydavis@cisco.com</email>
      </address>
    </author>
    <author initials="B." surname="Peabody" fullname="Brad G. Peabody">
      <organization>Uncloud</organization>
      <address>
        <email>brad@peabody.io</email>
      </address>
    </author>
    <author initials="P." surname="Leach" fullname="Paul J. Leach">
      <organization>University of Washington</organization>
      <address>
        <email>pjl7@uw.edu</email>
      </address>
    </author>
    <date year="2024" month="May"/>
    <area>art</area>
    <workgroup>uuidrev</workgroup>
    <keyword>uuid</keyword>

    <abstract>
      <t>This specification defines UUIDs (Universally Unique IDentifiers) --
      also known as GUIDs (Globally Unique IDentifiers) -- and a Uniform
      Resource Name namespace for UUIDs. A UUID is 128 bits long and is intended to
      guarantee uniqueness across space and time.  UUIDs were originally used
      in the Apollo Network Computing System (NCS), later in the Open Software
      Foundation's (OSF's) Distributed Computing Environment (DCE), and then
      in Microsoft Windows platforms.</t>
      <t>This specification is derived from the OSF DCE specification with the
      kind permission of the OSF (now known as "The Open Group").  Information
      from earlier versions of the OSF DCE specification have been incorporated
      into this document. This document obsoletes RFC 4122.</t>
    </abstract>
  </front>
  <middle>


<section anchor="Background">
      <name>Introduction</name>
      <t>This specification defines a Uniform Resource Name namespace for
   Universally Unique IDentifiers (UUIDs), also known as Globally
   Unique IDentifiers (GUIDs).  A UUID is 128 bits long and
      requires no central registration process.</t>
      <t>The use of UUIDs is extremely pervasive in computing.  They comprise
      the core identifier infrastructure for many operating systems such as
      Microsoft Windows and applications such as the Mozilla Web browser;
      in many cases, they can become exposed in many non-standard ways.</t>
      <t>This specification attempts to standardize that practice as openly as
      possible and in a way that attempts to benefit the entire Internet.  The information
      here is meant to be a concise guide for those wishing to implement
      services using UUIDs either in combination with URNs <xref
      target="RFC8141"/> or otherwise.</t>
      <t>There is an ITU-T Recommendation and an ISO/IEC Standard <xref
      target="X667"/> that are derived from <xref target="RFC4122"/>.  Both
      sets of specifications have been aligned and are fully technically
      compatible.  Nothing in this document should be construed to override
      the DCE standards that defined UUIDs.</t>
    </section>
    <section anchor="motivation">
      <name>Motivation</name>
      <t>One of the main reasons for using UUIDs is that no centralized
      authority is required to administer them (although two formats may
      leverage optional IEEE 802 Node IDs, others do not).  As a
      result, generation on demand can be completely automated and used for a
      variety of purposes.  The UUID generation algorithm described here
      supports very high allocation rates of 10 million per second per machine
      or more, if necessary, so that they could even be used as transaction
      IDs.</t>
      <t>UUIDs are of a fixed size (128 bits), which is reasonably small
      compared to other alternatives.  This lends itself well to sorting,
      ordering, and hashing of all sorts; storing in databases; simple
      allocation; and ease of programming in general.</t>
      <t>Since UUIDs are unique and persistent, they make excellent URNs. 
      The unique ability to generate a new UUID without a
      registration process allows for UUIDs to be one of the URNs with the
      lowest minting cost.</t>
      <section anchor="update-motivation">
        <name>Update Motivation</name>
        <t>Many things have changed in the time since UUIDs were originally
        created.  Modern applications have a need to create and utilize UUIDs
        as the primary identifier for a variety of different items in complex
        computational systems, including but not limited to database keys,
        file names, machine or system names, and identifiers for event-driven
        transactions.</t>
        <t>One area in which UUIDs have gained popularity is database keys.
        This stems from the increasingly distributed nature of modern
        applications.  In such cases, "auto-increment" schemes that are often
        used by databases do not work well: the effort required to
        coordinate sequential numeric identifiers across a network can easily
        become a burden.  The fact that UUIDs can be used to create unique,
        reasonably short values in distributed systems without requiring
        coordination makes them a good alternative, but UUID versions 1-5,
        which were originally defined by <xref target="RFC4122"/>, lack
        certain other desirable characteristics, such as:</t>
        <ol spacing="normal" type="1">
	  <li>UUID versions that are not time ordered, such as UUIDv4 (described in
	  <xref target="uuidv4"/>), have poor database-index locality.  This
	  means that new values created in succession are not close to each
	  other in the index; thus, they require inserts to be performed at
	  random locations.  The resulting negative performance effects on the
	  common structures used for this (B-tree and its variants) can be
	  dramatic.</li>
          <li>The 100-nanosecond Gregorian Epoch used in UUIDv1 timestamps (described in
          <xref target="uuidv1"/>) is uncommon and difficult to
          represent accurately using a standard number format such as that
          described in <xref target="IEEE754"/>.</li>
          <li>Introspection/parsing is required to order by time sequence, as
          opposed to being able to perform a simple byte-by-byte comparison.
          </li>
          <li>Privacy and network security issues arise from using a Media Access Control (MAC)
          address in the node field of UUIDv1.  Exposed MAC addresses
          can be used as an attack surface to locate network interfaces and
          reveal various other information about such machines (minimally, the 
          manufacturer and, potentially, other details). Additionally, with the
          advent of virtual machines and containers, uniqueness of the MAC address is
          no longer guaranteed.</li>
          <li>Many of the implementation details specified in <xref
          target="RFC4122"/> involved trade-offs that are neither possible to
          specify for all applications nor necessary to produce interoperable
          implementations.</li>
          <li><xref target="RFC4122"/> did not distinguish between the
          requirements for generating a UUID and those for simply storing one,
          although they are often different. </li>
        </ol>

        <t>Due to the aforementioned issues, many widely distributed database
        applications and large application vendors have sought to solve the
        problem of creating a better time-based, sortable unique identifier
        for use as a database key. This has led to numerous implementations
        over the past 10+ years solving the same problem in slightly different
        ways.</t>
        <t>While preparing this specification, the following 16 different
        implementations were analyzed for trends in total ID length, bit
        layout, lexical formatting and encoding, timestamp type, timestamp
        format, timestamp accuracy, node format and components, collision
        handling, and multi-timestamp tick generation sequencing:</t>

<ol spacing="compact" type="1">
	  <li><xref target="ULID"/></li>
          <li><xref target="LexicalUUID"/></li>
          <li><xref target="Snowflake"/></li>
          <li><xref target="Flake"/></li>
          <li><xref target="ShardingID"/></li>
          <li><xref target="KSUID"/></li>
          <li><xref target="Elasticflake"/></li>
          <li><xref target="FlakeID"/></li>
          <li><xref target="Sonyflake"/></li>
          <li><xref target="orderedUuid"/></li>
          <li><xref target="COMBGUID"/></li>
          <li><xref target="SID"/></li>
          <li><xref target="pushID"/></li>
          <li><xref target="XID"/></li>
          <li><xref target="ObjectID"/></li>
          <li><xref target="CUID"/></li>
        </ol>

        <t>An inspection of these implementations and the issues described
        above has led to this document, in which new UUIDs are adapted to
        address these issues.</t>
        <t>Further, <xref target="RFC4122"/> itself was in need of an overhaul to
        address a number of topics such as, but not limited to, the
        following:</t>
	
        <ol spacing="normal" type="1">
	  <li>Implementation of miscellaneous errata reports. Mostly around
	  bit-layout clarifications, which lead to inconsistent
	  implementations <xref target="Err1957"/>, <xref target="Err3546"/>,
	  <xref target="Err4975"/>, <xref target="Err4976"/>, <xref
	  target="Err5560"/>, etc.</li>
          <li>Decoupling other UUID versions from the UUIDv1 bit layout so that
          fields like "time_hi_and_version" do not need to be referenced
          within a UUID that is not time based while also providing
          definition sections similar to that for UUIDv1 for UUIDv3, UUIDv4, and UUIDv5.</li>
          <li>Providing implementation best practices around many real-world
          scenarios and corner cases observed by existing and prototype
          implementations.</li>
          <li>Addressing security best practices and
          considerations for the modern age as it pertains to MAC addresses,
          hashing algorithms, secure randomness, and other topics.</li>
          <li>Providing implementations a standard-based option for
          implementation-specific and/or experimental UUID designs.</li>
          <li>Providing more test vectors that illustrate real UUIDs created as
          per the specification.</li>
        </ol>

      </section>
    </section>
    <section anchor="terminology">
      <name>Terminology</name>
      <section anchor="requirements_language">
        <name>Requirements Language</name>
        <t>The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>",
        "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL
        NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>",
        "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
        "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document
        are to be interpreted as described in BCP&nbsp;14 <xref
        target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they
        appear in all capitals, as shown here.</t>
      </section>
      <section anchor="acronyms">
        <name>Abbreviations</name>
        <t>The following abbreviations are used in this document:</t>
        <dl newline="false" spacing="normal" indent="14">
	  <dt>ABNF</dt> <dd>Augmented Backus-Naur Form</dd>
	  <dt>CSPRNG</dt> <dd>Cryptographically Secure Pseudorandom Number Generator</dd>
	  <dt>DBMS</dt> <dd>Database Management System</dd>
	  <dt>IEEE</dt> <dd>Institute of Electrical and Electronics Engineers</dd>
	  <dt>ITU</dt> <dd>International Telecommunication Union</dd>
	  <dt>MAC</dt> <dd>Media Access Control</dd>
	  <dt>MD5</dt> <dd>Message Digest 5</dd>
	  <dt>MSB</dt> <dd>Most Significant Bit</dd>
	  <dt>OID</dt> <dd>Object Identifier</dd>
	  <dt>SHA</dt> <dd>Secure Hash Algorithm</dd>
	  <dt>SHA-1</dt> <dd>Secure Hash Algorithm 1 (with message digest of 160 bits)</dd>
	  <dt>SHA-3</dt> <dd>Secure Hash Algorithm 3 (arbitrary size)</dd>
	  <dt>SHA-224</dt> <dd>Secure Hash Algorithm 2 with message digest size of 224 bits</dd>
	  <dt>SHA-256</dt> <dd>Secure Hash Algorithm 2 with message digest size of 256 bits</dd>
	  <dt>SHA-512</dt> <dd>Secure Hash Algorithm 2 with message digest size of 512 bits</dd>
	  <dt>SHAKE</dt> <dd>Secure Hash Algorithm 3 based on the KECCAK algorithm</dd>
	  <dt>URN</dt> <dd>Uniform Resource Names</dd>
	  <dt>UTC</dt> <dd>Coordinated Universal Time</dd>
	  <dt>UUID</dt> <dd>Universally Unique Identifier</dd>
	  <dt>UUIDv1</dt> <dd>Universally Unique Identifier version 1</dd>
	  <dt>UUIDv2</dt> <dd>Universally Unique Identifier version 2</dd>
	  <dt>UUIDv3</dt> <dd>Universally Unique Identifier version 3</dd>
	  <dt>UUIDv4</dt> <dd>Universally Unique Identifier version 4</dd>
	  <dt>UUIDv5</dt> <dd>Universally Unique Identifier version 5</dd>
	  <dt>UUIDv6</dt> <dd>Universally Unique Identifier version 6</dd>
	  <dt>UUIDv7</dt> <dd>Universally Unique Identifier version 7</dd>
	  <dt>UUIDv8</dt> <dd>Universally Unique Identifier version 8</dd>
        </dl>
      </section>
      </section>
    <section anchor="format">
      <name>UUID Format</name>
      <t>The UUID format is 16 octets (128 bits) in size; the variant bits in
      conjunction with the version bits described in the next sections
      determine finer structure. In terms of these UUID formats and layout, bit
      definitions start at 0 and end at 127, while octet definitions start at 0
      and end at 15.</t>
      <t>In the absence of explicit application or presentation protocol
      specification to the contrary, each field is encoded with the most
      significant byte first (known as "network byte order").</t>
      <t>Saving UUIDs to binary format is done by sequencing all fields in
      big-endian format.  However, there is a known caveat that Microsoft's
      Component Object Model (COM) GUIDs leverage little-endian when saving
      GUIDs.  The discussion of this (see <xref target="MS_COM_GUID"/>) is outside
      the scope of this specification.</t>
      <t>UUIDs <bcp14>MAY</bcp14> be represented as binary data or integers.
      When in use with URNs or as text in applications, any given UUID should
      be represented by the "hex-and-dash" string format consisting of
      multiple groups of uppercase or lowercase alphanumeric hexadecimal
      characters separated by single dashes/hyphens.  When used with databases,
      please refer to <xref target="database_considerations"/>.</t>
      <t>The formal definition of the UUID string representation is provided by the following ABNF <xref target="RFC5234"/>:</t>
      <sourcecode type="abnf"><![CDATA[
UUID     = 4hexOctet "-"
           2hexOctet "-"
           2hexOctet "-"
           2hexOctet "-"
           6hexOctet
hexOctet = HEXDIG HEXDIG
DIGIT    = %x30-39
HEXDIG   = DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
]]></sourcecode>
      <t>Note that the alphabetic characters may be all uppercase, all lowercase, or mixed case, as per <xref section="2.3" sectionFormat="of" target="RFC5234"/>.
An example UUID using this textual representation from the above ABNF is shown in <xref target="sampleStringUUID"/>.</t>

      <figure anchor="sampleStringUUID">
        <name>Example String UUID Format</name>
        <artwork><![CDATA[
f81d4fae-7dec-11d0-a765-00a0c91e6bf6
]]></artwork>
      </figure>



      <t>The same UUID from <xref target="sampleStringUUID"/> is represented in binary (<xref target="sampleBinaryUUID"/>), as an unsigned integer (<xref target="sampleIntegerUUID"/>), and as a URN (<xref target="sampleURNUUID"/>) defined by <xref target="RFC8141"/>.</t>

      <figure anchor="sampleBinaryUUID">
        <name>Example Binary UUID</name>
        <artwork><![CDATA[
111110000001110101001111101011100111110111101100000100011101000\
01010011101100101000000001010000011001001000111100110101111110110
]]></artwork>
      </figure>

      <figure anchor="sampleIntegerUUID">
        <name>Example Unsigned Integer UUID (Shown as a Decimal Number)</name>
        <artwork><![CDATA[
329800735698586629295641978511506172918
]]></artwork>
      </figure>

      <figure anchor="sampleURNUUID">
        <name>Example URN Namespace for UUID</name>
        <artwork><![CDATA[
urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf6
]]></artwork>
      </figure>

      <t>There are many other ways to define a UUID format; some examples are detailed below.
Please note that this is not an exhaustive list and is only provided for informational purposes.</t>

      <ul spacing="normal">
        <li>Some UUID implementations, such as those found in <xref
        target="Python"/> and <xref target="Microsoft"/>, will output UUID
        with the string format, including dashes, enclosed in curly braces.
        </li>
        <li><xref target="X667"/> provides UUID format definitions for use of
        UUID with an OID.</li>
        <li><xref target="IBM_NCS"/> is a legacy implementation that produces a
        unique UUID format compatible with Variant 0xx of <xref
        target="table1"/>.</li>
      </ul>

      <section anchor="variant_field">
        <name>Variant Field</name>
        <t>The variant field determines the layout of the UUID.  That is, the
        interpretation of all other bits in the UUID depends on the setting of
        the bits in the variant field.  As such, it could more accurately be
        called a "type" field; we retain the original term for compatibility.
        The variant field consists of a variable number of the most
        significant bits of octet 8 of the UUID.</t>
        <t><xref target="table1"/> lists the contents of the variant field,
        where the letter "x" indicates a "don't-care" value.</t>

        <table anchor="table1">
          <name>UUID Variants</name>
          <thead>
            <tr>
              <th align="left">MSB0</th>
              <th align="left">MSB1</th>
              <th align="left">MSB2</th>
              <th align="left">MSB3</th>
              <th align="left">Variant</th>
              <th align="left">Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">0</td>
              <td align="left">x</td>
              <td align="left">x</td>
              <td align="left">x</td>
              <td align="left">1-7</td>
              <td align="left">Reserved. Network Computing System (NCS) backward compatibility, and
              includes Nil UUID as per <xref target="niluuid"/>.</td>
            </tr>
            <tr>
              <td align="left">1</td>
              <td align="left">0</td>
              <td align="left">x</td>
              <td align="left">x</td>
              <td align="left">8-9,A-B</td>
              <td align="left">The variant specified in this document.</td>
            </tr>
            <tr>
              <td align="left">1</td>
              <td align="left">1</td>
              <td align="left">0</td>
              <td align="left">x</td>
              <td align="left">C-D</td>
              <td align="left">Reserved. Microsoft Corporation backward compatibility.</td>
            </tr>
            <tr>
              <td align="left">1</td>
              <td align="left">1</td>
              <td align="left">1</td>
              <td align="left">x</td>
              <td align="left">E-F</td>
              <td align="left">Reserved for future definition and includes Max UUID as per <xref target="maxuuid"/>.</td>
            </tr>
          </tbody>
        </table>

        <t>Interoperability, in any form, with variants other than the one
defined here is not guaranteed but is not likely to be an issue in
practice.</t>
        <t>Specifically for UUIDs in this document, bits 64 and 65 of the UUID (bits 0 and 1 of octet 8) <bcp14>MUST</bcp14> be set to 1 and 0 as specified in row 2 of <xref target="table1"/>.
Accordingly, all bit and field layouts avoid the use of these bits.</t>
      </section>
      <section anchor="version_field">
        <name>Version Field</name>
        <t>The version number is in the most significant 4 bits of octet 6
(bits 48 through 51 of the UUID).</t>
        <t><xref target="table2"/> lists all of the versions for this UUID variant 10xx specified in this document.</t>

        <table anchor="table2">
          <name>UUID Variant 10xx Versions Defined by This Specification</name>
          <thead>
            <tr>
              <th align="left">MSB0</th>
              <th align="left">MSB1</th>
              <th align="left">MSB2</th>
              <th align="left">MSB3</th>
              <th align="left">Version</th>
              <th align="left">Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">0</td>
              <td align="left">0</td>
              <td align="left">0</td>
              <td align="left">0</td>
              <td align="left">0</td>
              <td align="left">Unused.</td>
            </tr>
            <tr>
              <td align="left">0</td>
              <td align="left">0</td>
              <td align="left">0</td>
              <td align="left">1</td>
              <td align="left">1</td>
              <td align="left">The Gregorian time-based UUID specified in this document.</td>
            </tr>
            <tr>
              <td align="left">0</td>
              <td align="left">0</td>
              <td align="left">1</td>
              <td align="left">0</td>
              <td align="left">2</td>
              <td align="left">Reserved for DCE Security version, with embedded POSIX UUIDs.</td>
            </tr>
            <tr>
              <td align="left">0</td>
              <td align="left">0</td>
              <td align="left">1</td>
              <td align="left">1</td>
              <td align="left">3</td>
              <td align="left">The name-based version specified in this document that uses MD5 hashing.</td>
            </tr>
            <tr>
              <td align="left">0</td>
              <td align="left">1</td>
              <td align="left">0</td>
              <td align="left">0</td>
              <td align="left">4</td>
              <td align="left">The randomly or pseudorandomly generated version specified in this document.</td>
            </tr>
            <tr>
              <td align="left">0</td>
              <td align="left">1</td>
              <td align="left">0</td>
              <td align="left">1</td>
              <td align="left">5</td>
              <td align="left">The name-based version specified in this document that uses SHA-1 hashing.</td>
            </tr>
            <tr>
              <td align="left">0</td>
              <td align="left">1</td>
              <td align="left">1</td>
              <td align="left">0</td>
              <td align="left">6</td>
              <td align="left">Reordered Gregorian time-based UUID specified in this document.</td>
            </tr>
            <tr>
              <td align="left">0</td>
              <td align="left">1</td>
              <td align="left">1</td>
              <td align="left">1</td>
              <td align="left">7</td>
              <td align="left">Unix Epoch time-based UUID specified in this document.</td>
            </tr>
            <tr>
              <td align="left">1</td>
              <td align="left">0</td>
              <td align="left">0</td>
              <td align="left">0</td>
              <td align="left">8</td>
              <td align="left">Reserved for custom UUID formats specified in this document.</td>
            </tr>
            <tr>
              <td align="left">1</td>
              <td align="left">0</td>
              <td align="left">0</td>
              <td align="left">1</td>
              <td align="left">9</td>
              <td align="left">Reserved for future definition.</td>
            </tr>
            <tr>
              <td align="left">1</td>
              <td align="left">0</td>
              <td align="left">1</td>
              <td align="left">0</td>
              <td align="left">10</td>
              <td align="left">Reserved for future definition.</td>
            </tr>
            <tr>
              <td align="left">1</td>
              <td align="left">0</td>
              <td align="left">1</td>
              <td align="left">1</td>
              <td align="left">11</td>
              <td align="left">Reserved for future definition.</td>
            </tr>
            <tr>
              <td align="left">1</td>
              <td align="left">1</td>
              <td align="left">0</td>
              <td align="left">0</td>
              <td align="left">12</td>
              <td align="left">Reserved for future definition.</td>
            </tr>
            <tr>
              <td align="left">1</td>
              <td align="left">1</td>
              <td align="left">0</td>
              <td align="left">1</td>
              <td align="left">13</td>
              <td align="left">Reserved for future definition.</td>
            </tr>
            <tr>
              <td align="left">1</td>
              <td align="left">1</td>
              <td align="left">1</td>
              <td align="left">0</td>
              <td align="left">14</td>
              <td align="left">Reserved for future definition.</td>
            </tr>
            <tr>
              <td align="left">1</td>
              <td align="left">1</td>
              <td align="left">1</td>
              <td align="left">1</td>
              <td align="left">15</td>
              <td align="left">Reserved for future definition.</td>
            </tr>
          </tbody>
        </table>

        <t>An example version/variant layout for UUIDv4 follows the table
        where "M" represents the version placement for the hexadecimal
        representation of 0x4 (0b0100) and the "N" represents the variant
        placement for one of the four possible hexadecimal representation of
        variant 10xx: 0x8 (0b1000), 0x9 (0b1001), 0xA (0b1010), 0xB
        (0b1011).</t>
        <figure>
          <name>UUIDv4 Variant Examples</name>
          <artwork><![CDATA[
00000000-0000-4000-8000-000000000000
00000000-0000-4000-9000-000000000000
00000000-0000-4000-A000-000000000000
00000000-0000-4000-B000-000000000000
xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx
]]></artwork>
        </figure>
        <t>It should be noted that the other remaining UUID variants found in <xref target="table1"/> leverage different sub-typing or versioning mechanisms.
The recording and definition of the remaining UUID variant and sub-typing combinations are outside of the scope of this document.</t>
      </section>
    </section>
    <section anchor="layout">
      <name>UUID Layouts</name>
      <t>To minimize confusion about bit assignments within octets and among
      differing versions, the UUID record definition is provided as a grouping
      of fields within a bit layout consisting of four octets per row.  The
      fields are presented with the most significant one first.</t>
      <section anchor="uuidv1">
        <name>UUID Version 1</name>
        <t>UUIDv1 is a time-based UUID featuring a 60-bit timestamp
        represented by Coordinated Universal Time (UTC) as a count of
        100-nanosecond intervals since 00:00:00.00, 15 October 1582 (the date
        of Gregorian reform to the Christian calendar).</t>
        <t>UUIDv1 also features a clock sequence field that is used to help
        avoid duplicates that could arise when the clock is set backwards in
        time or if the Node ID changes.</t>
        <t>The node field consists of an IEEE 802 MAC address, usually the
        host address or a randomly derived value per Sections <xref
        target="unguessability" format="counter" /> and <xref
        target="unidentifiable" format="counter"/>.</t>

        <figure>
          <name>UUIDv1 Field and Bit Layout</name>
          <artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           time_low                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           time_mid            |  ver  |       time_high       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|var|         clock_seq         |             node              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                              node                             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
        </figure>

        <dl spacing="normal" newline="true">
          <dt>time_low:</dt>
          <dd>The least significant 32 bits of the 60-bit starting
          timestamp.  Occupies bits 0 through 31 (octets 0-3).</dd>
          <dt>time_mid:</dt>
          <dd>The middle 16 bits of the 60-bit starting timestamp.  Occupies
          bits 32 through 47 (octets 4-5).</dd>
          <dt>ver:</dt>	  
          <dd>The 4-bit version field as defined by <xref
          target="version_field"/>, set to 0b0001 (1).  Occupies bits 48
          through 51 of octet 6. </dd>
          <dt>time_high:</dt>
          <dd>The least significant 12 bits from the 60-bit starting
          timestamp.  Occupies bits 52 through 63 (octets 6-7).</dd>
          <dt>var:</dt>
          <dd>The 2-bit variant field as defined by <xref
          target="variant_field"/>, set to 0b10.  Occupies bits 64 and 65 of
          octet 8.</dd>
          <dt>clock_seq:</dt>
          <dd>The 14 bits containing the clock sequence.  Occupies bits 66
          through 79 (octets 8-9).  </dd>
          <dt>node:</dt>
          <dd>48-bit spatially unique identifier.  Occupies bits 80 through
          127 (octets 10-15).</dd>
        </dl>

        <t>For systems that do not have UTC available but do have the local
        time, they may use that instead of UTC as long as they do so
        consistently throughout the system.  However, this is not recommended
        since generating the UTC from local time only needs a time-zone
        offset.</t>
        <t>If the clock is set backwards, or if it might have been set
        backwards (e.g., while the system was powered off), and the UUID
        generator cannot be sure that no UUIDs were generated with timestamps
        larger than the value to which the clock was set, then the clock
        sequence <bcp14>MUST</bcp14> be changed.  If the previous value of the
        clock sequence is known, it <bcp14>MAY</bcp14> be incremented;
        otherwise it <bcp14>SHOULD</bcp14> be set to a random or high-quality
        pseudorandom value.</t>
        <t>Similarly, if the Node ID changes (e.g., because a network card has
been moved between machines), setting the clock sequence to a random
number minimizes the probability of a duplicate due to slight
differences in the clock settings of the machines.  If the value of
the clock sequence associated with the changed Node ID were known, then
the clock sequence <bcp14>MAY</bcp14> be incremented, but that is unlikely.</t>
        <t>The clock sequence <bcp14>MUST</bcp14> be originally (i.e., once in the lifetime of
a system) initialized to a random number to minimize the correlation
across systems.  This provides maximum protection against Node
IDs that may move or switch from system to system rapidly.
The initial value <bcp14>MUST NOT</bcp14> be correlated to the Node ID.</t>

        <t>Notes about nodes derived from IEEE 802:</t>
        <ul spacing="normal">
          <li>On systems with multiple IEEE 802 addresses, any available one
          <bcp14>MAY</bcp14> be used.</li>
          <li>On systems with no IEEE address, a randomly or pseudorandomly
          generated value <bcp14>MUST</bcp14> be used; see Sections <xref
          target="unguessability" format="counter"/> and <xref
          target="unidentifiable" format="counter"/>.
          </li>
          <li>On systems utilizing a 64-bit MAC address, the least significant,
          rightmost 48 bits <bcp14>MAY</bcp14> be used.</li>

          <li>Systems utilizing an IEEE 802.15.4 16-bit address
          <bcp14>SHOULD</bcp14> instead utilize their 64-bit MAC address where
          the least significant, rightmost 48 bits <bcp14>MAY</bcp14> be used. An
          alternative is to generate 32 bits of random data and postfix at the
          end of the 16-bit MAC address to create a 48-bit value.</li>
        </ul>

      </section>
      <section anchor="uuidv2">
        <name>UUID Version 2</name>
        <t>UUIDv2 is for DCE Security UUIDs (see <xref target="C309"/> and
        <xref target="C311"/>).  As such, the definition of these UUIDs is
        outside the scope of this specification.</t>
      </section>
      <section anchor="uuidv3">
        <name>UUID Version 3</name>
        <t>UUIDv3 is meant for generating UUIDs from names that are
        drawn from, and unique within, some namespace as per <xref
        target="name_based_uuid_generation"/>.</t>
        <t>UUIDv3 values are created by computing an MD5 hash <xref
        target="RFC1321"/> over a given Namespace ID value (<xref
        target="namespaces"/>) concatenated with the desired name value after
        both have been converted to a canonical sequence of octets, as defined
        by the standards or conventions of its namespace, in network byte
        order.  This MD5 value is then used to populate all 128 bits of the
        UUID layout.  The UUID version and variant then replace the respective
        bits as defined by Sections <xref target="version_field"
        format="counter"/> and  <xref target="variant_field"
        format="counter"/>. An example of this bit substitution can be found
        in <xref target="uuidv3_example"/>.</t>
        <t>Information around selecting a desired name's canonical format
        within a given namespace can be found in <xref
        target="name_based_uuid_generation"/> under the heading "A note on names".</t>
        <t>Where possible, UUIDv5 <bcp14>SHOULD</bcp14> be used in lieu of
        UUIDv3.  For more information on MD5 security considerations, see <xref
        target="RFC6151"/>.</t>
        <figure>
          <name>UUIDv3 Field and Bit Layout</name>
          <artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            md5_high                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          md5_high             |  ver  |       md5_mid         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|var|                        md5_low                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            md5_low                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
        </figure>

        <dl spacing="normal" newline="true">
          <dt>md5_high:</dt>
          <dd>The first 48 bits of the layout are filled with the most
          significant, leftmost 48 bits from the computed MD5 value. Occupies
          bits 0 through 47 (octets 0-5).</dd>
          <dt>ver:</dt>
          <dd>The 4-bit version field as defined by <xref
          target="version_field"/>, set to 0b0011 (3).  Occupies bits 48
          through 51 of octet 6.</dd>
          <dt>md5_mid:</dt>
          <dd>12 more bits of the layout consisting of the least significant,
          rightmost 12 bits of 16 bits immediately following md5_high from
          the computed MD5 value.  Occupies bits 52 through 63 (octets 6-7).
          </dd>
          <dt>var:</dt>
          <dd>The 2-bit variant field as defined by <xref
          target="variant_field"/>, set to 0b10.  Occupies bits 64 and 65 of
          octet 8.</dd>
          <dt>md5_low:</dt>
          <dd>The final 62 bits of the layout immediately following the var
          field to be filled with the least significant, rightmost bits of
          the final 64 bits from the computed MD5 value. Occupies bits 66
          through 127 (octets 8-15)</dd>
        </dl>

      </section>
      <section anchor="uuidv4">
        <name>UUID Version 4</name>
        <t>UUIDv4 is meant for generating UUIDs from truly random or
        pseudorandom numbers.</t>
        <t>An implementation may generate 128 bits of random data that is used
        to fill out the UUID fields in <xref target="uuidv4fields"/>. The UUID
        version and variant then replace the respective bits as defined by
        Sections  <xref
        target="variant_field" format="counter"/> and <xref target="version_field" format="counter"/>.</t>
        <t>Alternatively, an implementation <bcp14>MAY</bcp14> choose to
        randomly generate the exact required number of bits for random_a,
        random_b, and random_c (122 bits total) and then concatenate the
        version and variant in the required position.</t>
        <t>For guidelines on random data generation, see <xref
        target="unguessability"/>.</t>
        <figure anchor="uuidv4fields">
          <name>UUIDv4 Field and Bit Layout</name>
          <artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           random_a                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          random_a             |  ver  |       random_b        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|var|                       random_c                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           random_c                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
        </figure>

        <dl spacing="normal" newline="true">
          <dt>random_a:</dt>
          <dd>The first 48 bits of the layout that can be filled with random
          data as specified in <xref target="unguessability"/>. Occupies bits
          0 through 47 (octets 0-5).</dd>
          <dt>ver:</dt>
          <dd>The 4-bit version field as defined by <xref
          target="version_field"/>, set to 0b0100 (4).  Occupies bits 48
          through 51 of octet 6.</dd>
          <dt>random_b:</dt>
          <dd>12 more bits of the layout that can be filled random data as per
          <xref target="unguessability"/>. Occupies bits 52 through 63 (octets
          6-7).</dd>
          <dt>var:</dt>
          <dd>The 2-bit variant field as defined by <xref
          target="variant_field"/>, set to 0b10.  Occupies bits 64 and 65 of
          octet 8.</dd>
          <dt>random_c:</dt>
          <dd>The final 62 bits of the layout immediately following the var
          field to be filled with random data as per <xref
          target="unguessability"/>. Occupies bits 66 through 127 (octets
          8-15).</dd>
        </dl>

      </section>
      <section anchor="uuidv5">
        <name>UUID Version 5</name>
        <t>UUIDv5 is meant for generating UUIDs from "names" that are
        drawn from, and unique within, some "namespace" as per <xref
        target="name_based_uuid_generation"/>.</t>
        <t>UUIDv5 values are created by computing an SHA-1 hash <xref
        target="FIPS180-4"/> over a given Namespace ID value (<xref
        target="namespaces"/>) concatenated with the desired name value after
        both have been converted to a canonical sequence of octets, as defined
        by the standards or conventions of its namespace, in network byte
        order.  The most significant, leftmost 128 bits of the SHA-1 value
        are then used to populate all 128 bits of the UUID layout, and the
        remaining 32 least significant, rightmost bits of SHA-1 output are
        discarded.  The UUID version and variant then replace the respective
        bits as defined by Sections <xref target="version_field"
        format="counter"/> and <xref target="variant_field"
        format="counter"/>. An example of this bit substitution and discarding
        excess bits can be found in <xref target="uuidv5_example"/>.</t>
        <t>Information around selecting a desired name's canonical format
        within a given namespace can be found in <xref
        target="name_based_uuid_generation"/> under the heading "A note on names".</t>
        <t>There may be scenarios, usually depending on organizational
        security policies, where SHA-1 libraries may not be available or may
        be deemed unsafe for use.  As such, it may be desirable to generate
        name-based UUIDs derived from SHA-256 or newer SHA methods. These
        name-based UUIDs <bcp14>MUST NOT</bcp14> utilize UUIDv5 and
        <bcp14>MUST</bcp14> be within the UUIDv8 space defined by <xref
        target="uuidv8"/>.  An illustrative example of UUIDv8 for SHA-256
        name-based UUIDs is provided in <xref
        target="uuidv8_example_name"/>.</t>
        <t>For more information on SHA-1 security considerations, see <xref
        target="RFC6194"/>.</t>
        <figure>
          <name>UUIDv5 Field and Bit Layout</name>
          <artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           sha1_high                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         sha1_high             |  ver  |      sha1_mid         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|var|                       sha1_low                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           sha1_low                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
        </figure>

        <dl spacing="normal" newline="true">
          <dt>sha1_high:</dt>
          <dd>The first 48 bits of the layout are filled with the most
          significant, leftmost 48 bits from the computed SHA-1 value.
          Occupies bits 0 through 47 (octets 0-5).  </dd>
          <dt>ver:</dt>
          <dd>The 4-bit version field as defined by <xref
          target="version_field"/>, set to 0b0101 (5).  Occupies bits 48
          through 51 of octet 6.</dd>
          <dt>sha1_mid:</dt>
          <dd>12 more bits of the layout consisting of the least significant,
          rightmost 12 bits of 16 bits immediately following sha1_high from
          the computed SHA-1 value.  Occupies bits 52 through 63 (octets 6-7).
          </dd>
          <dt>var:</dt>
          <dd>The 2-bit variant field as defined by <xref
          target="variant_field"/>, set to 0b10.  Occupies bits 64 and 65 of
          octet 8.</dd>
          <dt>sha1_low:</dt>
          <dd>The final 62 bits of the layout immediately following the var
          field to be filled by skipping the two most significant, leftmost
          bits of the remaining SHA-1 hash and then using the next 62 most
          significant, leftmost bits.  Any leftover SHA-1 bits are discarded
          and unused. Occupies bits 66 through 127 (octets 8-15).</dd>
        </dl>

      </section>
      <section anchor="uuidv6">
        <name>UUID Version 6</name>
        <t>UUIDv6 is a field-compatible version of UUIDv1 (<xref
        target="uuidv1"/>), reordered for improved DB locality.  It is expected
        that UUIDv6 will primarily be implemented in contexts where UUIDv1 is used.
        Systems that do not involve legacy UUIDv1 <bcp14>SHOULD</bcp14> use
        UUIDv7 (<xref target="uuidv7"/>) instead.</t>
        <t>Instead of splitting the timestamp into the low, mid, and high
        sections from UUIDv1, UUIDv6 changes this sequence so timestamp bytes
        are stored from most to least significant.  That is, given a 60-bit
        timestamp value as specified for UUIDv1 in <xref target="uuidv1"/>,
        for UUIDv6 the first 48 most significant bits are stored first,
        followed by the 4-bit version (same position), followed by the
        remaining 12 bits of the original 60-bit timestamp.</t>
        <t>The clock sequence and node bits remain unchanged from their
        position in <xref target="uuidv1"/>.</t>
        <t>The clock sequence and node bits <bcp14>SHOULD</bcp14> be reset to
        a pseudorandom value for each new UUIDv6 generated; however,
        implementations <bcp14>MAY</bcp14> choose to retain the old clock
        sequence and MAC address behavior from <xref target="uuidv1"/>. For
        more information on MAC address usage within UUIDs, see the <xref
        target="Security"/>.</t>
        <t>The format for the 16-byte, 128-bit UUIDv6 is shown in <xref
        target="v6layout"/>.</t>
        <figure anchor="v6layout">
          <name>UUIDv6 Field and Bit Layout</name>
          <artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           time_high                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           time_mid            |  ver  |       time_low        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|var|         clock_seq         |             node              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                              node                             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
        </figure>
        <dl spacing="normal" newline="true">
          <dt>time_high:</dt>
          <dd>The most significant 32 bits of the 60-bit starting timestamp.
          Occupies bits 0 through 31 (octets 0-3).</dd>
          <dt>time_mid:</dt>
          <dd>The middle 16 bits of the 60-bit starting timestamp.  Occupies
          bits 32 through 47 (octets 4-5).</dd>
          <dt>ver:</dt>
          <dd>The 4-bit version field as defined by <xref
          target="version_field"/>, set to 0b0110 (6).  Occupies bits 48
          through 51 of octet 6.</dd>
          <dt>time_low:</dt>
          <dd>12 bits that will contain the least significant 12 bits from the
          60-bit starting timestamp.  Occupies bits 52 through 63 (octets
          6-7).</dd>
          <dt>var:</dt>
          <dd>The 2-bit variant field as defined by <xref
          target="variant_field"/>, set to 0b10.  Occupies bits 64 and 65 of
          octet 8.</dd>
          <dt>clock_seq:</dt>
          <dd>The 14 bits containing the clock sequence.  Occupies bits 66
          through 79 (octets 8-9).</dd>
          <dt>node:</dt>
          <dd>48-bit spatially unique identifier.  Occupies bits 80 through
          127 (octets 10-15).</dd>
        </dl>

        <t>With UUIDv6, the steps for splitting the timestamp into time_high and time_mid
are <bcp14>OPTIONAL</bcp14>
since the 48 bits of time_high and time_mid will remain in the same order.
An extra step of splitting the first 48 bits of the timestamp into the most
significant
32 bits and least significant 16 bits proves useful when reusing an existing
UUIDv1 implementation.</t>
      </section>
      <section anchor="uuidv7">
        <name>UUID Version 7</name>
        <t>UUIDv7 features a time-ordered value field derived from the widely
implemented and well-known Unix Epoch timestamp source, the number of milliseconds
since midnight 1 Jan 1970 UTC, leap seconds excluded.
Generally, UUIDv7 has improved entropy characteristics over UUIDv1 (<xref target="uuidv1"/>) or UUIDv6 (<xref target="uuidv6"/>).</t>
        <t>UUIDv7 values are created by allocating a Unix timestamp in milliseconds in the most significant 48 bits and filling the remaining 74 bits, excluding the required version and variant bits, with random bits for each new UUIDv7 generated to provide uniqueness as per <xref target="unguessability"/>. Alternatively, implementations <bcp14>MAY</bcp14> fill the 74 bits, jointly, with a combination of the following subfields, in this order from the most significant bits to the least, to guarantee additional monotonicity within a millisecond:</t>

        <ol spacing="normal" type="1">
	  <li>An <bcp14>OPTIONAL</bcp14> sub-millisecond timestamp fraction
	  (12 bits at maximum) as per <xref target="monotonicity_counters"/>
	  (Method 3).</li>
          <li>An <bcp14>OPTIONAL</bcp14> carefully seeded counter as per <xref
          target="monotonicity_counters"/> (Method 1 or 2).</li>
          <li>Random data for each new UUIDv7 generated for any remaining
          space.</li>
        </ol>

        <t>Implementations <bcp14>SHOULD</bcp14> utilize UUIDv7 instead of UUIDv1 and UUIDv6 if
possible.</t>
        <figure>
          <name>UUIDv7 Field and Bit Layout</name>
          <artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           unix_ts_ms                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          unix_ts_ms           |  ver  |       rand_a          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|var|                        rand_b                             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            rand_b                             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
        </figure>

        <dl spacing="normal" newline="true">
          <dt>unix_ts_ms:</dt>
          <dd>48-bit big-endian unsigned number of the Unix Epoch timestamp in
          milliseconds as per <xref target="timestamp_considerations"/>.
          Occupies bits 0 through 47 (octets 0-5).</dd>
          <dt>ver:</dt>
          <dd>The 4-bit version field as defined by <xref
          target="version_field"/>, set to 0b0111 (7).  Occupies bits 48
          through 51 of octet 6.</dd>
          <dt>rand_a:</dt>
          <dd>12 bits of pseudorandom data to provide uniqueness as per <xref
          target="unguessability"/> and/or optional constructs to guarantee
          additional monotonicity as per <xref
          target="monotonicity_counters"/>.  Occupies bits 52 through 63
          (octets 6-7).</dd>
          <dt>var:</dt>
          <dd>The 2-bit variant field as defined by <xref
          target="variant_field"/>, set to 0b10.  Occupies bits 64 and 65 of
          octet 8.</dd>
          <dt>rand_b:</dt>
          <dd>The final 62 bits of pseudorandom data to provide uniqueness as
          per <xref target="unguessability"/> and/or an optional counter to
          guarantee additional monotonicity as per <xref
          target="monotonicity_counters"/>.  Occupies bits 66 through 127
          (octets 8-15).</dd>
        </dl>

      </section>
      <section anchor="uuidv8">
        <name>UUID Version 8</name>
        <t>UUIDv8 provides a format for experimental
        or vendor-specific use cases.  The only requirement is that the
        variant and version bits <bcp14>MUST</bcp14> be set as defined in
        Sections <xref target="variant_field" format="counter"/> and <xref
        target="version_field" format="counter"/>.  UUIDv8's uniqueness will be
        implementation specific and <bcp14>MUST NOT</bcp14> be assumed.</t>
        <t>The only explicitly defined bits are those of the version and
        variant fields, leaving 122 bits for implementation-specific UUIDs. To
        be clear, UUIDv8 is not a replacement for UUIDv4 (<xref
        target="uuidv4"/>) where all 122 extra bits are filled with random
        data.</t>
        <t>Some example situations in which UUIDv8 usage could occur:</t>

        <ul spacing="normal">
          <li>An implementation would like to embed extra information
          within the UUID other than what is defined in this document.</li>
          <li>An implementation has other application and/or language
          restrictions that inhibit the use of one of the current UUIDs.</li>
        </ul>

        <t><xref target="ill_examples"/> provides two illustrative examples of
        custom UUIDv8 algorithms to address two example scenarios.</t>
        <figure>
          <name>UUIDv8 Field and Bit Layout</name>
          <artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           custom_a                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          custom_a             |  ver  |       custom_b        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|var|                       custom_c                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           custom_c                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
        </figure>

        <dl spacing="normal" newline="true">
          <dt>custom_a:</dt>
          <dd>The first 48 bits of the layout that can be filled as an
          implementation sees fit. Occupies bits 0 through 47 (octets 0-5).
          </dd>
          <dt>ver:</dt>
          <dd>The 4-bit version field as defined by <xref
          target="version_field"/>, set to 0b1000 (8).  Occupies bits 48
          through 51 of octet 6.</dd>
          <dt>custom_b:</dt>
          <dd>12 more bits of the layout that can be filled as an
          implementation sees fit.  Occupies bits 52 through 63 (octets 6-7).
          </dd>
          <dt>var:</dt>
          <dd>The 2-bit variant field as defined by <xref
          target="variant_field"/>, set to 0b10.  Occupies bits 64 and 65 of
          octet 8.</dd>
          <dt>custom_c:</dt>
          <dd>The final 62 bits of the layout immediately following the var
          field to be filled as an implementation sees fit.  Occupies bits 66
          through 127 (octets 8-15).</dd>
        </dl>

      </section>
      <section anchor="niluuid">
        <name>Nil UUID</name>
        <t>The Nil UUID is special form of UUID that is specified to have all
128 bits set to zero.</t>

        <figure>
          <name>Nil UUID Format</name>
          <artwork><![CDATA[
00000000-0000-0000-0000-000000000000
]]></artwork>
        </figure>

        <t>A Nil UUID value can be useful to communicate the absence of any
        other UUID value in situations that otherwise require or use a 128-bit
        UUID.  A Nil UUID can express the concept "no such value here". Thus,
        it is reserved for such use as needed for implementation-specific
        situations.</t>
        <t>Note that the Nil UUID value falls within the range of the Apollo
        NCS variant as per the first row of <xref target="table1"/> rather
        than the variant defined by this document.</t>
      </section>
      <section anchor="maxuuid">
        <name>Max UUID</name>
        <t>The Max UUID is a special form of UUID that is specified to have
        all 128 bits set to 1. This UUID can be thought of as the inverse of
        the Nil UUID defined in <xref target="niluuid"/>.</t>

        <figure>
          <name>Max UUID Format</name>
          <artwork><![CDATA[
FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF
]]></artwork>
        </figure>

        <t>A Max UUID value can be used as a sentinel value in situations
        where a 128-bit UUID is required, but a concept such as "end of UUID
        list" needs to be expressed and is reserved for such use as needed
        for implementation-specific situations.</t>
        <t>Note that the Max UUID value falls within the range of the "yet-to-be defined" future UUID variant as per the last row of <xref
        target="table1"/> rather than the variant defined by this
        document.</t>
      </section>
    </section>
    <section anchor="uuid_best_practices">
      <name>UUID Best Practices</name>
      <t>The minimum requirements for generating UUIDs of each version are described in this
      document.  Everything else is an implementation detail,
      and it is up to the implementer to decide what is appropriate for a
      given implementation. Various relevant factors are covered below to help
      guide an implementer through the different trade-offs among differing
      UUID implementations.</t>
      <section anchor="timestamp_considerations">
        <name>Timestamp Considerations</name>
        <t>UUID timestamp source, precision, and length were topics of great
        debate while creating UUIDv7 for this specification. Choosing the
        right timestamp for your application is very important. This
        section will detail some of the most common points on this issue.</t>

        <dl spacing="normal" newline="true">
          <dt>Reliability:</dt>
          <dd>Implementations acquire the current timestamp from a reliable
          source to provide values that are time ordered and continually
          increasing.  Care must be taken to ensure that timestamp changes
          from the environment or operating system are handled in a way that
          is consistent with implementation requirements.  For example, if it
          is possible for the system clock to move backward due to either
          manual adjustment or corrections from a time synchronization
          protocol, implementations need to determine how to handle such
          cases. (See "Altering, Fuzzing, or Smearing" below.)</dd>
          <dt>Source:</dt>
          <dd>UUIDv1 and UUIDv6 both utilize a Gregorian Epoch timestamp,
          while UUIDv7 utilizes a Unix Epoch timestamp. If other timestamp
          sources or a custom timestamp Epoch are required, UUIDv8
          <bcp14>MUST</bcp14> be used.</dd>
          <dt>Sub-second Precision and Accuracy:</dt>
          <dd>Many levels of precision exist for timestamps: milliseconds,
          microseconds, nanoseconds, and beyond.  Additionally, fractional
          representations of sub-second precision may be desired to mix
          various levels of precision in a time-ordered manner.  Furthermore,
          system clocks themselves have an underlying granularity, which is
          frequently less than the precision offered by the operating system.
          With UUIDv1 and UUIDv6, 100 nanoseconds of precision are present,
          while UUIDv7 features a millisecond level of precision by default
          within the Unix Epoch that does not exceed the granularity capable
          in most modern systems.  For other levels of precision, UUIDv8 is
          available.  Similar to <xref target="monotonicity_counters"/>, with
          UUIDv1 or UUIDv6, a high-resolution timestamp can be simulated by
          keeping a count of the number of UUIDs that have been generated with
          the same value of the system time and using that count to construct the low
          order bits of the timestamp.  The count of the high-resolution
          timestamp will range between zero and the number of 100-nanosecond
          intervals per system-time interval.</dd>
          <dt>Length:</dt>
          <dd>The length of a given timestamp directly impacts how many
          timestamp ticks can be contained in a UUID before the maximum value
          for the timestamp field is reached.  Take care to ensure that the
          proper length is selected for a given timestamp.  UUIDv1 and
          UUIDv6 utilize a 60-bit timestamp valid until 5623 AD; UUIDv7 features
          a 48-bit timestamp valid until the year 10889 AD.</dd>
          <dt>Altering, Fuzzing, or Smearing:</dt>
          <dd>Implementations <bcp14>MAY</bcp14> alter the actual
          timestamp. Some examples include security considerations around
          providing a real-clock value within a UUID to 1) correct inaccurate
          clocks, 2) handle leap seconds, or 3) obtain a millisecond value by
          dividing by 1024 (or some other value) for performance reasons
          (instead of dividing a number of microseconds by 1000). This
          specification makes no requirement or guarantee about how close the
          clock value needs to be to the actual time.  If UUIDs do not need to
          be frequently generated, the UUIDv1 or UUIDv6 timestamp can simply
          be the system time multiplied by the number of 100-nanosecond
          intervals per system-time interval.</dd>
          <dt>Padding:</dt>
          <dd>When timestamp padding is required, implementations
          <bcp14>MUST</bcp14> pad the most significant bits (leftmost)
          with data. An example for this padding data is to fill the most
          significant, leftmost bits of a Unix timestamp with zeroes to
          complete the 48-bit timestamp in UUIDv7. An alternative approach for
          padding data is to fill the most significant, leftmost bits with
          the number of 32-bit Unix timestamp rollovers after 2038-01-19.
          </dd>
          <dt>Truncating:</dt>
          <dd>When timestamps need to be truncated, the lower, least
          significant bits <bcp14>MUST</bcp14> be used. An example would be
          truncating a 64-bit Unix timestamp to the least significant,
          rightmost 48 bits for UUIDv7.</dd>
          <dt>Error Handling:</dt>
          <dd>If a system overruns the generator by requesting too many UUIDs
          within a single system-time interval, the UUID service can return an
          error or stall the UUID generator until the system clock catches
          up and <bcp14>MUST NOT</bcp14> knowingly return duplicate values
          due to a counter rollover.  Note that if the processors overrun the
          UUID generation frequently, additional Node IDs can be
          allocated to the system, which will permit higher speed allocation
          by making multiple UUIDs potentially available for each timestamp
          value.  Similar techniques are discussed in <xref
          target="distributed_shared_knowledge"/>.</dd>
        </dl>

      </section>
      <section anchor="monotonicity_counters">
        <name>Monotonicity and Counters</name>
        <t>Monotonicity (each subsequent value being greater than the last) is
        the backbone of time-based sortable UUIDs. Normally, time-based UUIDs
        from this document will be monotonic due to an embedded timestamp;
        however, implementations can guarantee additional monotonicity via the
        concepts covered in this section.</t>
        <t>Take care to ensure UUIDs generated in batches are also
        monotonic. That is, if one thousand UUIDs are generated for the same
        timestamp, there should be sufficient logic for organizing the
        creation order of those one thousand UUIDs.  Batch UUID creation
        implementations <bcp14>MAY</bcp14> utilize a monotonic counter that
        increments for each UUID created during a given timestamp.</t>
        <t>For single-node UUID implementations that do not need to create
        batches of UUIDs, the embedded timestamp within UUIDv6 and UUIDv7
        can provide sufficient monotonicity guarantees by simply ensuring that
        timestamp increments before creating a new UUID. Distributed nodes are
        discussed in <xref target="distributed_shared_knowledge"/>.</t>
        <t>Implementations <bcp14>SHOULD</bcp14> employ the following methods
        for single-node UUID implementations that require batch UUID creation
        or are otherwise concerned about monotonicity with high-frequency UUID
        generation.</t>

        <dl spacing="normal" newline="true">
          <dt>Fixed Bit-Length Dedicated Counter (Method 1):</dt>
          <dd>Some implementations allocate a specific number of bits in the
          UUID layout to the sole purpose of tallying the total number of
          UUIDs created during a given UUID timestamp tick.  If present, a fixed
          bit-length counter <bcp14>MUST</bcp14> be positioned
          immediately after the embedded timestamp. This promotes sortability
          and allows random data generation for each counter increment.
	  With
          this method, the rand_a section (or a subset of its leftmost bits)
          of UUIDv7 is used as a fixed bit-length dedicated counter that is
          incremented for every UUID generation.  The trailing random bits
          generated for each new UUID in rand_b can help produce unguessable
          UUIDs. In the event that more counter bits are required, the most
          significant (leftmost) bits of rand_b <bcp14>MAY</bcp14> be used as
          additional counter bits.</dd>
          <dt>Monotonic Random (Method 2):</dt>
          <dd>With this method, the random data is extended to also function
          as a counter.  This monotonic value can be thought of as a "randomly
          seeded counter" that <bcp14>MUST</bcp14> be incremented in the
          least significant position for each UUID created on a given
          timestamp tick.  UUIDv7's rand_b section <bcp14>SHOULD</bcp14> be
          utilized with this method to handle batch UUID generation during a
          single timestamp tick.  The increment value for every UUID
          generation is a random integer of any desired length larger than
          zero. It ensures that the UUIDs retain the required level of
          unguessability provided by the underlying entropy.  The increment
          value <bcp14>MAY</bcp14> be 1 when the number of UUIDs generated in
          a particular period of time is important and guessability is not an
          issue. However, incrementing the counter by 1 <bcp14>SHOULD
          NOT</bcp14> be used by implementations that favor unguessability, as
          the resulting values are easily guessable.</dd>
          <dt>Replace Leftmost Random Bits with Increased Clock Precision (Method 3):</dt>
          <dd><t>For UUIDv7, which has millisecond timestamp precision, it is
          possible to use additional clock precision available on the system
          to substitute for up to 12 random bits immediately following the
          timestamp.  This can provide values that are time ordered with
          sub-millisecond precision, using however many bits are appropriate
          in the implementation environment.  With this method, the additional
          time precision bits <bcp14>MUST</bcp14> follow the timestamp as the
          next available bit in the rand_a field for UUIDv7.</t>
          <t>To calculate this value, start with the portion of the timestamp
          expressed as a fraction of the clock's tick value (fraction of a
          millisecond for UUIDv7).  Compute the count of possible values that
          can be represented in the available bit space, 4096 for the UUIDv7
          rand_a field.  Using floating point or scaled integer arithmetic,
          multiply this fraction of a millisecond value by 4096 and round down
          (toward zero) to an integer result to arrive at a number between 0
          and the maximum allowed for the indicated bits, which sorts
          monotonically based on time. Each increasing fractional value will
          result in an increasing bit field value to the precision available
          with these bits.</t>
          <t>For example, let's assume a system timestamp of 1 Jan 2023
          12:34:56.1234567.  Taking the precision greater than 1 ms gives us a
          value of 0.4567, as a fraction of a millisecond.  If we wish to
          encode this as 12 bits, we can take the count of possible values
          that fit in those bits (4096 or 2<sup>12</sup>), multiply it by our
          millisecond fraction value of 0.4567, and truncate the result to an
          integer, which gives an integer value of 1870. Expressed as
          hexadecimal, it is 0x74E or the binary bits 0b011101001110.  One can
          then use those 12 bits as the most significant (leftmost) portion of
          the random section of the UUID (e.g., the rand_a field in UUIDv7).
          This works for any desired bit length that fits into a UUID, and
          applications can decide the appropriate length based on available
          clock precision; for UUIDv7, it is limited to 12 bits at maximum to
          reserve sufficient space for random bits.</t>
          <t>The main benefit to encoding additional timestamp precision is
          that it utilizes additional time precision already available in the
          system clock to provide values that are more likely to be unique; thus, it may simplify certain implementations. This technique can
          also be used in conjunction with one of the other methods, where
          this additional time precision would immediately follow the
          timestamp. Then, if any bits are to be used as a clock sequence,
          they would follow next.</t></dd>
        </dl>

        <t>The following sub-topics cover issues related solely to creating reliable
fixed bit-length dedicated counters:</t>

        <dl spacing="normal" newline="true">
          <dt>Fixed Bit-Length Dedicated Counter Seeding:</dt>
          <dd>Implementations utilizing the fixed bit-length counter method
          randomly initialize the counter with each new timestamp tick.
          However, when the timestamp has not increased, the counter is
          instead incremented by the desired increment logic.  When utilizing
          a randomly seeded counter alongside Method 1, the random value
          <bcp14>MAY</bcp14> be regenerated with each counter increment
          without impacting sortability.  The downside is that Method 1 is
          prone to overflows if a counter of adequate length is not selected
          or the random data generated leaves little room for the required
          number of increments.  Implementations utilizing fixed bit-length
          counter method <bcp14>MAY</bcp14> also choose to randomly initialize
          a portion of the counter rather than the entire counter. For
          example, a 24-bit counter could have the 23 bits in
          least significant, rightmost position randomly initialized. The
          remaining most significant, leftmost counter bit is initialized as
          zero for the sole purpose of guarding against counter rollovers.
          </dd>
          <dt>Fixed Bit-Length Dedicated Counter Length:</dt>
          <dd>Select a counter bit-length that can properly handle the level
          of timestamp precision in use.  For example, millisecond precision
          generally requires a larger counter than a timestamp with nanosecond
          precision.  General guidance is that the counter
          <bcp14>SHOULD</bcp14> be at least 12 bits but no longer than 42
          bits.  Care must be taken to ensure that the counter length selected
          leaves room for sufficient entropy in the random portion of the UUID
          after the counter.  This entropy helps improve the unguessability
          characteristics of UUIDs created within the batch.</dd>
        </dl>

        <t>The following sub-topics cover rollover handling with either type of counter
method:</t>

        <dl spacing="normal" newline="true">
          <dt>Counter Rollover Guards:</dt>
          <dd>The technique from "Fixed Bit-Length Dedicated Counter Seeding" above that
          describes allocating a segment of the fixed bit-length counter as a
          rollover guard is also helpful to mitigate counter rollover issues.
          This same technique can be used with monotonic random counter
          methods by ensuring that the total length of a possible increment in
          the least significant, rightmost position is less than the total
          length of the random value being incremented.  As such, the most
          significant, leftmost bits can be incremented as rollover
          guarding.</dd>
          <dt>Counter Rollover Handling:</dt>
          <dd>Counter rollovers <bcp14>MUST</bcp14> be handled by the
          application to avoid sorting issues.  The general guidance is that
          applications that care about absolute monotonicity and sortability
          should freeze the counter and wait for the timestamp to advance,
          which ensures monotonicity is not broken.  Alternatively,
          implementations <bcp14>MAY</bcp14> increment the timestamp ahead of
          the actual time and reinitialize the counter.</dd>
        </dl>

        <t>Implementations <bcp14>MAY</bcp14> use the following logic to
        ensure UUIDs featuring embedded counters are monotonic in nature:</t>

        <ol spacing="normal" type="1">
	  <li>Compare the current timestamp against the previously stored
	  timestamp.</li>
          <li>If the current timestamp is equal to the previous timestamp,
          increment the counter according to the desired method.</li>
          <li>If the current timestamp is greater than the previous timestamp,
          re-initialize the desired counter method to the new timestamp and
          generate new random bytes (if the bytes were frozen or being used as
          the seed for a monotonic counter). </li>
        </ol>

        <dl spacing="normal" newline="true">
          <dt>Monotonic Error Checking:</dt>
          <dd>Implementations <bcp14>SHOULD</bcp14> check if the currently
          generated UUID is greater than the previously generated UUID. If
          this is not the case, then any number of things could have occurred,
          such as clock rollbacks, leap second handling, and counter
          rollovers. Applications <bcp14>SHOULD</bcp14> embed sufficient logic
          to catch these scenarios and correct the problem to ensure that the
          next UUID generated is greater than the previous, or they should at least report
          an appropriate error.  To handle this scenario, the general guidance
          is that the application <bcp14>MAY</bcp14> reuse the previous timestamp
          and increment the previous counter method. </dd>
        </dl>

      </section>
      <section anchor="generator_states">
        <name>UUID Generator States</name>
        <t>The (optional) UUID generator state only needs to be read from
        stable storage once at boot time, if it is read into a system-wide
        shared volatile store (and updated whenever the stable store is
        updated).</t>
        <t>This stable storage <bcp14>MAY</bcp14> be used to record various
        portions of the UUID generation, which prove useful for batch UUID
        generation purposes and monotonic error checking with UUIDv6 and
        UUIDv7.  These stored values include but are not limited to last known
        timestamp, clock sequence, counters, and random data.</t>
        <t>If an implementation does not have any stable store available, then
        it <bcp14>MAY</bcp14> proceed with UUID generation as if this were the
        first UUID created within a batch.  This is the least desirable
        implementation because it will increase the frequency of creation of
        values such as clock sequence, counters, or random data, which
        increases the probability of duplicates. Further, frequent generation
        of random numbers also puts more stress on any entropy source and/or
        entropy pool being used as the basis for such random numbers.</t>
        <t>An implementation <bcp14>MAY</bcp14> also return an application
        error in the event that collision resistance is of the utmost concern.
        The semantics of this error are up to the application and
        implementation.  See <xref target="collision_resistance"/> for more
        information on weighting collision tolerance in applications.</t>
        <t>For UUIDv1 and UUIDv6, if the Node ID can never change (e.g., the
        network interface card from which the Node ID is derived is
        inseparable from the system), or if any change also re-initializes the
        clock sequence to a random value, then instead of keeping it in stable
        store, the current Node ID may be returned.</t>
        <t>For UUIDv1 and UUIDv6, the state does not always need to be written
        to stable store every time a UUID is generated.  The timestamp in the
        stable store can periodically be set to a value larger than any yet
        used in a UUID.  As long as the generated UUIDs have timestamps less
        than that value, and the clock sequence and Node ID remain unchanged,
        only the shared volatile copy of the state needs to be updated.
        Furthermore, if the timestamp value in stable store is in the future
        by less than the typical time it takes the system to reboot, a crash
        will not cause a re-initialization of the clock sequence.</t>
        <t>If it is too expensive to access shared state each time a UUID is
        generated, then the system-wide generator can be implemented to
        allocate a block of timestamps each time it is called; a per-process
        generator can allocate from that block until it is exhausted.</t>
      </section>
      <section anchor="distributed_shared_knowledge">
        <name>Distributed UUID Generation</name>
        <t>Some implementations <bcp14>MAY</bcp14> desire the utilization of
        multi-node, clustered, applications that involve two or more nodes
        independently generating UUIDs that will be stored in a common
        location.  While UUIDs already feature sufficient entropy to ensure
        that the chances of collision are low, as the total number of UUID
        generating nodes increases, so does the likelihood of a collision.</t>
        <t>This section will detail the two additional collision resistance
        approaches that have been observed by multi-node UUID implementations
        in distributed environments.</t>
        <t>It should be noted that, although this section details two methods
        for the sake of completeness, implementations should utilize the
        pseudorandom Node ID option if additional collision resistance for
        distributed UUID generation is a requirement.  Likewise, utilization
        of either method is not required for implementing UUID generation in
        distributed environments.</t>

        <dl spacing="normal" newline="true">
          <dt>Node IDs:</dt>
          <dd>With this method, a pseudorandom Node ID value is placed within
          the UUID layout.  This identifier helps ensure the bit space for a
          given node is unique, resulting in UUIDs that do not conflict with
          any other UUID created by another node with a different node id.
          Implementations that choose to leverage an embedded node id
          <bcp14>SHOULD</bcp14> utilize UUIDv8.  The node id <bcp14>SHOULD
          NOT</bcp14> be an IEEE 802 MAC address per <xref
          target="Security"/>.  The location and bit length are left to
          implementations and are outside the scope of this specification.
          Furthermore, the creation and negotiation of unique node ids among
          nodes is also out of scope for this specification.</dd>
          <dt>Centralized Registry:</dt>
          <dd>With this method, all nodes tasked with creating UUIDs consult a
          central registry and confirm the generated value is unique. As
          applications scale, the communication with the central registry
          could become a bottleneck and impact UUID generation in a negative
          way. Shared knowledge schemes with central/global registries are
          outside the scope of this specification and are <bcp14>NOT
          RECOMMENDED</bcp14>.</dd>
        </dl>

        <t>Distributed applications generating UUIDs at a variety of hosts <bcp14>MUST</bcp14>
be willing to rely on the random number source at all hosts.</t>
      </section>
      <section anchor="name_based_uuid_generation">
        <name>Name-Based UUID Generation</name>
	<t>Although some prefer to use the word "hash-based" to describe UUIDs
	featuring hashing algorithms (MD5 or SHA-1), this document retains the
	usage of the term "name-based" in order to maintain consistency with
	previously published documents and existing implementations.</t>
        <t>The requirements for name-based UUIDs are as follows:</t>

        <ul spacing="normal">
          <li>UUIDs generated at different times from the same name (using
          the same canonical format) in the same namespace <bcp14>MUST</bcp14>
          be equal.</li>
          <li>UUIDs generated from two different names (same or differing
          canonical format) in the same namespace should be different (with
          very high probability).</li>
          <li>UUIDs generated from the same name (same or differing
          canonical format) in two different namespaces should be different
          (with very high probability).</li>
          <li>If two UUIDs that were generated from names (using the same
          canonical format) are equal, then they were generated from the same
          name in the same namespace (with very high probability).</li>
        </ul>

          <t>A note on names:</t>
          <t indent="3">The concept of name (and namespace) should be broadly
          construed and not limited to textual names. A canonical sequence of
          octets is one that conforms to the specification for that name
          form's canonical representation. A name can have many usual forms,
          only one of which can be canonical. An implementer of new namespaces
          for UUIDs needs to reference the specification for the canonical
          form of names in that space or define such a canonical form for the
          namespace if it does not exist.  For example, at the time of
          writing, Domain Name System (DNS) <xref target="RFC9499"/> has three
          conveyance formats: common (www.example.com), presentation
          (www.example.com.), and wire format (3www7example3com0).  Looking at
          <xref target="X500"/> Distinguished Names (DNs), <xref
          target="RFC4122" format="default"/> allowed either text-based or
          binary DER-based names as inputs.  For Uniform Resource Locators
          (URLs) <xref target="RFC1738"/>, one could provide a Fully Qualified
          Domain Name (FQDN) with or without the protocol identifier
          www.example.com or https://www.example.com.  When it comes to Object
          Identifiers (OIDs) <xref target="X660"/>, one could choose dot
          notation without the leading dot (2.999), choose to include the
          leading dot (.2.999), or select one of the many formats from <xref
          target="X680"/> such as OID Internationalized Resource Identifier
          (OID-IRI) (/Joint-ISO-ITU-T/Example).  While most users may default
          to the common format for DNS, FQDN format for a URL, text format for
          X.500, and dot notation without a leading dot for OID, name-based
          UUID implementations generally <bcp14>SHOULD</bcp14> allow arbitrary
          input that will compute name-based UUIDs for any of the
          aforementioned example names and others not defined here.  Each name
          format within a namespace will output different UUIDs.  As such, the
          mechanisms or conventions used for allocating names and ensuring
          their uniqueness within their namespaces are beyond the scope of
          this specification.</t>
          
      </section>
      <section anchor="namespaces">
        <name>Namespace ID Usage and Allocation</name>
	
        <t>This section details the namespace
        IDs for some potentially interesting namespaces such as those for DNS
        <xref target="RFC9499"/>, URLs <xref target="RFC1738"/>, OIDs <xref
        target="X660"/>, and DNs <xref target="X500"/>.</t>


        <t>Further, this section also details allocation, IANA registration,
        and other details pertinent to Namespace IDs.</t>

        <table anchor="namespaceIDs">
          <name>Namespace IDs</name>
          <thead>
            <tr>
              <th align="left">Namespace</th>
              <th align="left">Namespace ID Value</th>
              <th align="left">Name Reference</th>
              <th align="left">Namespace ID Reference</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">DNS</td>
              <td align="left">6ba7b810-9dad-11d1-80b4-00c04fd430c8</td>
              <td align="left">
                <xref target="RFC9499"/></td>
              <td align="left">
                <xref target="RFC4122"/>, RFC 9562</td>
            </tr>
            <tr>
              <td align="left">URL</td>
              <td align="left">6ba7b811-9dad-11d1-80b4-00c04fd430c8</td>
              <td align="left">
                <xref target="RFC1738"/></td>
              <td align="left">
                <xref target="RFC4122"/>, RFC 9562</td>
            </tr>
            <tr>
              <td align="left">OID</td>
              <td align="left">6ba7b812-9dad-11d1-80b4-00c04fd430c8</td>
              <td align="left">
                <xref target="X660"/></td>
              <td align="left">
                <xref target="RFC4122"/>, RFC 9562</td>
            </tr>
            <tr>
              <td align="left">X500</td>
              <td align="left">6ba7b814-9dad-11d1-80b4-00c04fd430c8</td>
              <td align="left">
                <xref target="X500"/></td>
              <td align="left">
                <xref target="RFC4122"/>, RFC 9562</td>
            </tr>
          </tbody>
        </table>

        <t>Items may be added to this registry using the Specification Required
        policy as per <xref target="RFC8126"/>.</t>
        <t>For designated experts, generally speaking, Namespace IDs are
        allocated as follows:</t>

        <ul spacing="normal">
          <li>The first Namespace ID value, for DNS, was calculated from a
          time-based UUIDv1 and "6ba7b810-9dad-11d1-80b4-00c04fd430c8", used as
          a starting point.</li>
          <li>Subsequent Namespace ID values increment the
          least significant, rightmost bit of time_low "6ba7b810" while
          freezing the rest of the UUID to "9dad-11d1-80b4-00c04fd430c8".</li>
          <li>New Namespace ID values <bcp14>MUST</bcp14> use this same
          logic and <bcp14>MUST NOT</bcp14> use a previously used Namespace ID
          value.</li>
          <li>Thus, "6ba7b815" is the next available time_low for a new
          Namespace ID value with the full ID being
          "6ba7b815-9dad-11d1-80b4-00c04fd430c8".</li>


<li>The upper bound for time_low in this special use, Namespace ID
          values, is "ffffffff" or "ffffffff-9dad-11d1-80b4-00c04fd430c8",
          which should be sufficient space for future Namespace ID values.</li>
        </ul>

        <t>Note that the Namespace ID value
        "6ba7b813-9dad-11d1-80b4-00c04fd430c8" and its usage are not defined by
        this document or by <xref target="RFC4122"/>; thus, it <bcp14>SHOULD
        NOT</bcp14> be used as a Namespace ID value.</t>
        <t>New Namespace ID values <bcp14>MUST</bcp14> be documented as per
        <xref target="IANA"/> if they are to be globally available and fully
        interoperable.  Implementations <bcp14>MAY</bcp14> continue to use
        vendor-specific, application-specific, and deployment-specific
        Namespace ID values; but know that interoperability is not guaranteed.
        These custom Namespace ID values <bcp14>MUST NOT</bcp14> use the logic
        above; instead, generating a
        UUIDv4 or UUIDv7 Namespace ID value is <bcp14>RECOMMENDED</bcp14>.  If collision probability (<xref
        target="collision_resistance"/>) and uniqueness (<xref
        target="global_local_uniqueness"/>) of the final name-based UUID are
        not a problem, an implementation <bcp14>MAY</bcp14> also leverage
        UUIDv8 instead to create a custom, application-specific Namespace ID
        value.</t>
        <t>Implementations <bcp14>SHOULD</bcp14> provide the ability to input
        a custom namespace to account for newly registered IANA Namespace ID
        values outside of those listed in this section or custom,
        application-specific Namespace ID values.</t>
      </section>
      <section anchor="collision_resistance">
        <name>Collision Resistance</name>
        <t>Implementations should weigh the consequences of UUID collisions
        within their application and when deciding between UUID versions that
        use entropy (randomness) versus the other components such as those in
        Sections <xref target="timestamp_considerations" format="counter"/>
        and <xref target="monotonicity_counters" format="counter"/>.  This is
        especially true for distributed node collision resistance as defined
        by <xref target="distributed_shared_knowledge"/>.</t>
        <t>There are two example scenarios below that help illustrate the
        varying seriousness of a collision within an application.</t>

        <dl spacing="normal" newline="true">
          <dt>Low Impact:</dt>
          <dd>A UUID collision generated a duplicate log entry, which results
          in incorrect statistics derived from the data. Implementations that
          are not negatively affected by collisions may continue with the
          entropy and uniqueness provided by UUIDs defined in this document.
          </dd>
          <dt>High Impact:</dt>
          <dd>A duplicate key causes an airplane to receive the wrong course,
          which puts people's lives at risk. In this scenario, there is no
          margin for error. Collisions must be avoided: failure is
          unacceptable. Applications dealing with this type of scenario must
          employ as much collision resistance as possible within the given
          application context.</dd>
        </dl>

      </section>
      <section anchor="global_local_uniqueness">
        <name>Global and Local Uniqueness</name>
        <t>UUIDs created by this specification <bcp14>MAY</bcp14> be used to
        provide local uniqueness guarantees.  For example, ensuring UUIDs
        created within a local application context are unique within a
        database <bcp14>MAY</bcp14> be sufficient for some implementations
        where global uniqueness outside of the application context, in other
        applications, or around the world is not required.</t>
        <t>Although true global uniqueness is impossible to guarantee without
        a shared knowledge scheme, a shared knowledge scheme is not required
        by a UUID to provide uniqueness for practical implementation purposes.
        Implementations <bcp14>MAY</bcp14> use a shared knowledge
        scheme, introduced in <xref target="distributed_shared_knowledge"/>,
        as they see fit to extend the uniqueness guaranteed by this
        specification.</t>
      </section>
      <section anchor="unguessability">
        <name>Unguessability</name>
        <t>Implementations <bcp14>SHOULD</bcp14> utilize a cryptographically
        secure pseudorandom number generator (CSPRNG) to provide values that
        are both difficult to predict ("unguessable") and have a low
        likelihood of collision ("unique").  The exception is when a suitable
        CSPRNG is unavailable in the execution environment.  Take care to
        ensure the CSPRNG state is properly reseeded upon state changes, such
        as process forks, to ensure proper CSPRNG operation.  CSPRNG ensures
        the best of Sections <xref target="collision_resistance"
        format="counter"/> and <xref target="Security" format="counter"/> are
        present in modern UUIDs.</t>
        <t>Further advice on generating cryptographic-quality random numbers
        can be found in <xref target="RFC4086"/>, <xref target="RFC8937"/>,
        and <xref target="RANDOM"/>.</t>
      </section>
      <section anchor="unidentifiable">
        <name>UUIDs That Do Not Identify the Host</name>
        <t>This section describes how to generate a UUIDv1 or UUIDv6 value if
        an IEEE 802 address is not available or its use is not desired.</t>
        <t>Implementations <bcp14>MAY</bcp14> leverage MAC address
        randomization techniques <xref target="IEEE802.11bh"
        format="default"/> as an alternative to the pseudorandom logic
        provided in this section.</t>
        <t>Alternatively, implementations <bcp14>MAY</bcp14> elect to obtain a
        48-bit cryptographic-quality random number as per <xref
        target="unguessability"/> to use as the Node ID.  After generating the
        48-bit fully randomized node value, implementations
        <bcp14>MUST</bcp14> set the least significant bit of the first octet
        of the Node ID to 1.  This bit is the unicast or multicast bit, which
        will never be set in IEEE 802 addresses obtained from network cards.
        Hence, there can never be a conflict between UUIDs generated by
        machines with and without network cards.  An example of generating a
        randomized 48-bit node value and the subsequent bit modification is
        detailed in <xref target="test_vectors"/>.  For more information about
        IEEE 802 address and the unicast or multicast or local/global bits,
        please review <xref target="RFC9542"/>.</t>
        <t>For compatibility with earlier specifications, note that this
        document uses the unicast or multicast bit instead of the arguably more
        correct local/global bit because MAC addresses with the local/global
        bit set or not set are both possible in a network.  This is not the case
        with the unicast or multicast bit.  One node cannot have a MAC address
        that multicasts to multiple nodes.</t>
        <t>In addition, items such as the computer's name and the name of the
        operating system, while not strictly speaking random, will help
        differentiate the results from those obtained by other systems.</t>
        <t>The exact algorithm to generate a Node ID using these data is
        system specific because both the data available and the functions to
        obtain them are often very system specific.  However, a generic approach
        is to accumulate as many sources as possible into a buffer, use a
        message digest (such as SHA-256 or SHA-512 defined by <xref
        target="FIPS180-4"/>), take an arbitrary 6 bytes from the hash value,
        and set the multicast bit as described above.</t>
      </section>
      <section anchor="sorting">
        <name>Sorting</name>
        <t>UUIDv6 and UUIDv7 are designed so that implementations that require
        sorting (e.g., database indexes) sort as opaque raw bytes without the
        need for parsing or introspection.</t>
        <t>Time-ordered monotonic UUIDs benefit from greater database-index
        locality because the new values are near each other in the index.  As
        a result, objects are more easily clustered together for better
        performance.  The real-world differences in this approach of index
        locality versus random data inserts can be one order of magnitude or
        more.</t>
        <t>UUID formats created by this specification are intended to be
        lexicographically sortable while in the textual representation.</t>
        <t>UUIDs created by this specification are crafted with big-endian
        byte order (network byte order) in mind. If little-endian style is
        required, UUIDv8 is available for custom UUID formats.</t>
      </section>
      <section anchor="opacity">
        <name>Opacity</name>
        <t>As general guidance, avoiding parsing UUID values
        unnecessarily is recommended; instead, treat UUIDs as opaquely as possible.
        Although application-specific concerns could, of course, require some
        degree of introspection (e.g., to examine Sections <xref
        target="variant_field" format="counter"/> or <xref
        target="version_field" format="counter"/> or perhaps the timestamp of
        a UUID), the advice here is to avoid this or other parsing unless
        absolutely necessary.  Applications typically tend to be simpler, be more
        interoperable, and perform better when this advice is followed.</t>
      </section>
      <section anchor="database_considerations">
        <name>DBMS and Database Considerations</name>
        <t>For many applications, such as databases, storing UUIDs as text is
        unnecessarily verbose, requiring 288 bits to represent 128-bit UUID
        values.  Thus, where feasible, UUIDs <bcp14>SHOULD</bcp14> be stored
        within database applications as the underlying 128-bit binary
        value.</t>
        <t>For other systems, UUIDs <bcp14>MAY</bcp14> be stored in binary
        form or as text, as appropriate.  The trade-offs to both approaches
        are as follows:</t>

        <ul spacing="normal">
          <li>Storing in binary form requires less space and may result in faster
          data access.</li>
          <li>Storing as text requires more space but may require less
          translation if the resulting text form is to be used after
          retrieval, which may make it simpler to implement. </li>
        </ul>

        <t>DBMS vendors are encouraged to provide functionality to generate
        and store UUID formats defined by this specification for use as
        identifiers or left parts of identifiers such as, but not limited to,
        primary keys, surrogate keys for temporal databases, foreign keys
        included in polymorphic relationships, and keys for key-value pairs in
        JSON columns and key-value databases.  Applications using a monolithic
        database may find using database-generated UUIDs (as opposed to
        client-generated UUIDs) provides the best UUID monotonicity.  In
        addition to UUIDs, additional identifiers <bcp14>MAY</bcp14> be used
        to ensure integrity and feedback.</t>
        <t>Designers of database schema are cautioned against using name-based
        UUIDs (see Sections <xref target="uuidv3" format="counter"/> and <xref
        target="uuidv5" format="counter"/>) as primary keys in tables.  A
        common issue observed in database schema design is the assumption that
        a particular value will never change, which later turns out to be
        an incorrect assumption.  Postal codes, license or other
        identification numbers, and numerous other such identifiers seem
        unique and unchanging at a given point time -- only later to have edge
        cases where they need to change.  The subsequent change of the
        identifier, used as a "name" input for name-based UUIDs, can
        invalidate a given database structure.  In such scenarios, it is
        observed that using any non-name-based UUID version would have
        resulted in the field in question being placed somewhere that would
        have been easier to adapt to such changes (primary key excluded from
        this statement).  The general advice is to avoid name-based UUID
        natural keys and, instead, to utilize time-based UUID surrogate keys
        based on the aforementioned problems detailed in this section.</t>
      </section>
    </section>
    <section anchor="IANA">
      <name>IANA Considerations</name>
      <t>All references to <xref target="RFC4122"/> in IANA registries
      (outside of those created by this document) have been replaced with
      references to this document, including the IANA URN namespace
      registration <xref target="URNNamespaces"/> for UUID.  References to
      <xref target="RFC4122" sectionFormat="of" section="4.1.2"/> have been
      updated to refer to <xref target="format"/> of this document.</t>
      <t>Finally, IANA should track UUID Subtypes and Special Case "Namespace
      IDs Values" as specified in Sections <xref target="iana2"
      format="counter"/> and <xref target="iana3" format="counter"/> at the
      following location: <eref brackets="angle"
      target="https://www.iana.org/assignments/uuid"/>.</t>
      <t>When evaluating requests, the designated expert should consider
      community feedback, how well-defined the reference specification is, and
      this specification's requirements.  Vendor-specific,
      application-specific, and deployment-specific values are unable to be
      registered.  Specification documents should be published in a stable,
      freely available manner (ideally, located with a URL) but need not be
      standards.  The designated expert will either approve or deny the
      registration request and communicate this decision to IANA. Denials
      should include an explanation and, if applicable, suggestions as to how
      to make the request successful.</t>
      <section anchor="iana2">
        <name>IANA UUID Subtype Registry and Registration</name>
        <t>This specification defines the "UUID Subtypes" registry for common
        widely used UUID standards.</t>
        

        <table anchor="ianaSubtypes">
          <name>IANA UUID Subtypes</name>
          <thead>
            <tr>
              <th align="left">Name</th>
              <th align="left">ID</th>
              <th align="left">Subtype</th>
              <th align="left">Variant</th>
              <th align="left">Reference</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">Gregorian Time-based</td>
              <td align="left">1</td>
              <td align="left">version</td>
              <td align="left">OSF DCE / IETF</td>
              <td align="left">
                <xref target="RFC4122"/>, RFC 9562</td>
            </tr>
            <tr>
              <td align="left">DCE Security</td>
              <td align="left">2</td>
              <td align="left">version</td>
              <td align="left">OSF DCE / IETF</td>
              <td align="left">
                <xref target="C309"/>, <xref target="C311"/></td>
            </tr>
            <tr>
              <td align="left">MD5 Name-based</td>
              <td align="left">3</td>
              <td align="left">version</td>
              <td align="left">OSF DCE / IETF</td>
              <td align="left">
                <xref target="RFC4122"/>, RFC 9562</td>
            </tr>
            <tr>
              <td align="left">Random</td>
              <td align="left">4</td>
              <td align="left">version</td>
              <td align="left">OSF DCE / IETF</td>
              <td align="left">
                <xref target="RFC4122"/>, RFC 9562</td>
            </tr>
            <tr>
              <td align="left">SHA-1 Name-based</td>
              <td align="left">5</td>
              <td align="left">version</td>
              <td align="left">OSF DCE / IETF</td>
              <td align="left">
                <xref target="RFC4122"/>, RFC 9562</td>
            </tr>
            <tr>
              <td align="left">Reordered Gregorian Time-based</td>
              <td align="left">6</td>
              <td align="left">version</td>
              <td align="left">OSF DCE / IETF</td>
              <td align="left">RFC 9562</td>
            </tr>
            <tr>
              <td align="left">Unix Time-based</td>
              <td align="left">7</td>
              <td align="left">version</td>
              <td align="left">OSF DCE / IETF</td>
              <td align="left">RFC 9562</td>
            </tr>
            <tr>
              <td align="left">Custom</td>
              <td align="left">8</td>
              <td align="left">version</td>
              <td align="left">OSF DCE / IETF</td>
              <td align="left">RFC 9562</td>
            </tr>
          </tbody>
        </table>

        <t>This table may be extended by Standards Action as per
        <xref target="RFC8126"/>.</t>
        <t>For designated experts:</t>

        <ul spacing="normal">
          <li>The minimum and maximum "ID" value for the subtype "version"
          within the "OSF DCE / IETF" variant is 0 through 15. The versions
          within <xref target="table1"/> described as "Reserved for future
          definition" or "unused" are omitted from this IANA registry until
          properly defined. </li>
          <li>The "Subtype" column is free-form text.  However, at the time of
          publication, "version" and "family" are the only known UUID
          subtypes. The "family" subtype is part of the "Apollo NCS" variant
          space (both are outside the scope of this specification). The
          Microsoft variant may have subtyping mechanisms defined; however,
          they are unknown and outside of the scope of this
          specification. Similarly, the final "Reserved for future definition"
          variant may introduce new subtyping logic at a future date. Subtype
          IDs are permitted to overlap. That is, an ID of "1" may exist in
          multiple variant spaces.</li>
          <li>The "Variant" column is free-form text. However, it is likely that one
          of four values will be included: the first three are "OSF DCE /
          IETF", "Apollo NCS", and "Microsoft", and the final variant value belongs to
          the "Reserved for future definition" variant and may introduce a new
          name at a future date.</li>
        </ul>

      </section>
      <section anchor="iana3">
        <name>IANA UUID Namespace ID Registry and Registration</name>
        <t>This specification defines the "UUID Namespace IDs" registry for common, widely used Namespace ID values.</t>
        <t>The full details of this registration, including information for designated experts, can be found in <xref target="namespaces"/>.</t>
      </section>
    </section>
    <section anchor="Security">
      <name>Security Considerations</name>
      <t>Implementations <bcp14>SHOULD NOT</bcp14> assume that UUIDs are hard
      to guess.  For example, they <bcp14>MUST NOT</bcp14> be used as security
      capabilities (identifiers whose mere possession grants access).
      Discovery of predictability in a random number source will result in a
      vulnerability.</t>
      <t>Implementations <bcp14>MUST NOT</bcp14> assume that it is easy to
      determine if a UUID has been slightly modified in order to redirect a
      reference to another object.  Humans do not have the ability to easily
      check the integrity of a UUID by simply glancing at it.</t>
      <t>MAC addresses pose inherent security risks around privacy and
      <bcp14>SHOULD NOT</bcp14> be used within a UUID.  Instead CSPRNG data
      <bcp14>SHOULD</bcp14> be selected from a source with sufficient entropy
      to ensure guaranteed uniqueness among UUID generation. See Sections
      <xref target="unguessability" format="counter"/> and <xref
      target="unidentifiable" format="counter"/> for more information.</t>
      <t>Timestamps embedded in the UUID do pose a very small attack
      surface. The timestamp in conjunction with an embedded counter does
      signal the order of creation for a given UUID and its corresponding data
      but does not define anything about the data itself or the application as
      a whole.  If UUIDs are required for use with any security operation
      within an application context in any shape or form, then UUIDv4 (<xref
      target="uuidv4"/>) <bcp14>SHOULD</bcp14> be utilized.</t>
      <t>See <xref target="RFC6151"/> for MD5 security considerations and
      <xref target="RFC6194"/> for SHA-1 security considerations.</t>
    </section>

  </middle>
  <back>
    <references>
      <name>References</name>
      <references anchor="sec-normative-references">
        <name>Normative References</name>

        <reference anchor="C309" target="https://pubs.opengroup.org/onlinepubs/9696999099/toc.pdf">
          <front>
            <title>X/Open DCE: Remote Procedure Call</title>
            <author>
              <organization>X/Open Company Limited</organization>
            </author>
            <date year="1994" month="August"/>
          </front>
          <seriesInfo name="ISBN" value="1-85912-041-5"/>
          <seriesInfo name="Open CAE Specification" value="C309"/>
        </reference>

        <reference anchor="X667">
          <front>
            <title>Information technology - Open Systems Interconnection -
            Procedures for the operation of OSI Registration Authorities:
            Generation and registration of Universally Unique Identifiers
            (UUIDs) and their use as ASN.1 object identifier
            components</title>
            <author>
              <organization>ITU-T</organization>
            </author>
            <date month="September" year="2004"/>
          </front>
          <seriesInfo name="ISO/IEC" value="9834-8:2004"/>
          <seriesInfo name="ITU-T Recommendation" value="X.667"/>
        </reference>

<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8141.xml"/>

        <reference anchor="FIPS180-4" target="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf">
          <front>
            <title>Secure Hash Standard (SHS)</title>
            <author>
              <organization>National Institute of Standards and Technology
              (NIST)</organization>
            </author>
            <date year="2015" month="August"/>
          </front>
          <seriesInfo name="FIPS PUB" value="180-4"/>
	  <seriesInfo name="DOI" value="10.6028/NIST.FIPS.180-4"/>
        </reference>

        <reference anchor="FIPS202" target="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf">
          <front>
            <title>SHA-3 Standard: Permutation-Based Hash and Extendable-Output Functions</title>
            <author>
              <organization>National Institute of Standards and Technology
              (NIST)</organization>
            </author>
            <date year="2015" month="August"/>
          </front>
          <seriesInfo name="FIPS PUB" value="202"/>
	  <seriesInfo name="DOI" value="10.6028/NIST.FIPS.202"/>
        </reference>

        <reference anchor="C311" target="https://pubs.opengroup.org/onlinepubs/9696989899/toc.pdf">
          <front>
            <title>DCE 1.1: Authentication and Security Services</title>
            <author>
              <organization>The Open Group</organization>
            </author>
            <date year="1997" month="August"/>
          </front>
          <seriesInfo name="Open Group CAE Specification" value="C311"/>
        </reference>

<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>

      </references>
      <references anchor="sec-informative-references">
        <name>Informative References</name>

<reference anchor="IEEE802.11bh" target="https://standards.ieee.org/ieee/802.11bh/10525/">
  <front>
    <title>IEEE Draft Standard for Information technology--Telecommunications and information exchange between systems Local and metropolitan area networks--Specific requirements - Part 11: Wireless LAN Medium Access Control (MAC) and Physical Layer (PHY) Specifications Amendment: Enhancements for Extremely High Throughput (EHT)</title>
    <author>
      <organization>IEEE</organization>
    </author>
    <date year="2023" month="March"/>
  </front>
  <seriesInfo name="Electronic ISBN" value="978-1-5044-9520-2"/>
</reference>

<reference anchor="Err1957" quote-title="false" target="https://www.rfc-editor.org/errata/eid1957"> 
   <front> 
      <title>Erratum ID 1957</title>
      <author>
         <organization>RFC Errata</organization>
      </author> 
   </front> 
   <refcontent>RFC 4122</refcontent>
</reference>

<reference anchor="Err3546" quote-title="false" target="https://www.rfc-editor.org/errata/eid3546"> 
   <front> 
      <title>Erratum ID 3546</title>
      <author>
         <organization>RFC Errata</organization>
      </author> 
   </front> 
   <refcontent>RFC 4122</refcontent>
</reference>

<reference anchor="Err4976" quote-title="false" target="https://www.rfc-editor.org/errata/eid4976"> 
   <front> 
      <title>Erratum ID 4976</title>
      <author>
         <organization>RFC Errata</organization>
      </author> 
   </front> 
   <refcontent>RFC 4122</refcontent>
</reference>

<reference anchor="Err4975" quote-title="false"                                 
target="https://www.rfc-editor.org/errata/eid4975">
   <front>
      <title>Erratum ID 4975</title>
      <author>
         <organization>RFC Errata</organization>
      </author>
   </front>
   <refcontent>RFC 4122</refcontent>
</reference>

<reference anchor="Err5560" quote-title="false"                                 
target="https://www.rfc-editor.org/errata/eid5560">
   <front>
      <title>Erratum ID 5560</title>
      <author>
         <organization>RFC Errata</organization>
      </author>
   </front>
   <refcontent>RFC 4122</refcontent>
</reference>

<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.1321.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.1738.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4086.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4122.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.5234.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6151.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6194.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9542.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8126.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9499.xml"/>
<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8937.xml"/>

        <reference anchor="X500">
          <front>
            <title>Information technology - Open Systems Interconnection - The
            Directory: Overview of concepts, models and services</title>
            <author>
              <organization>ITU-T</organization>
            </author>
            <date year="2019" month="October"/>
          </front>
          <seriesInfo name="ISO/IEC" value="9594-1"/>
          <seriesInfo name="ITU-T Recommendation" value="X.500"/>
        </reference>

        <reference anchor="X660">
          <front>
            <title>Information technology - Procedures for the operation of
            object identifier registration authorities: General procedures and
            top arcs of the international object identifier tree</title>
            <author>
              <organization>ITU-T</organization>
            </author>
            <date month="July" year="2011"/>
          </front>
          <seriesInfo name="ISO/IEC" value="9834-1"/>
          <seriesInfo name="ITU-T Recommendation" value="X.660"/>
        </reference>

        <reference anchor="X680">
          <front>
            <title>Information Technology - Abstract Syntax Notation One
            (ASN.1) &amp; ASN.1 encoding rules</title>
            <author>
              <organization>ITU-T</organization>
            </author>
            <date month="February" year="2021"/>
          </front>
          <seriesInfo name="ISO/IEC" value="8824-1:2021"/>
          <seriesInfo name="ITU-T Recommendation" value="X.680"/>
        </reference>

        <reference anchor="LexicalUUID" target="https://github.com/twitter-archive/cassie">
          <front>
            <title>Cassie</title>
            <author>
              <organization>Twitter</organization>
            </author>
            <date year="2012" month="November"/>
          </front>
          <refcontent>commit f6da4e0</refcontent>
        </reference>

        <reference anchor="Snowflake" target="https://github.com/twitter-archive/snowflake">
          <front>
            <title>Snowflake is a network service for generating unique ID
            numbers at high scale with some simple guarantees.</title>
            <author>
              <organization>Twitter</organization>
            </author>
            <date year="2014" month="May"/>
          </front>
          <refcontent>commit ec40836</refcontent>
        </reference>

        <reference anchor="Flake" target="https://github.com/boundary/flake">
          <front>
            <title>Flake: A decentralized, k-ordered id generation service in Erlang</title>
            <author>
              <organization>Boundary</organization>
            </author>
            <date year="2017" month="February"/>
          </front>
          <refcontent>commit 15c933a</refcontent>
        </reference>

        <reference anchor="ShardingID" target="https://instagram-engineering.com/sharding-ids-at-instagram-1cf5a71e5a5c">
          <front>
            <title>Sharding &amp; IDs at Instagram</title>
            <author>
              <organization>Instagram Engineering</organization>
            </author>
            <date year="2012" month="December"/>
          </front>
        </reference>

        <reference anchor="KSUID" target="https://github.com/segmentio/ksuid">
          <front>
            <title>K-Sortable Globally Unique IDs</title>
            <author>
              <organization>Segment</organization>
            </author>
            <date year="2020" month="July"/>
          </front>
          <refcontent>commit bf376a7</refcontent>
        </reference>

        <reference anchor="Elasticflake" target="https://github.com/ppearcy/elasticflake">
          <front>
            <title>Sequential UUID / Flake ID generator pulled out of elasticsearch common</title>
            <author initials="P." surname="Pearcy" fullname="Paul Pearcy">
              <organization/>
            </author>
            <date year="2015" month="January"/>
          </front>
          <refcontent>commit dd71c21</refcontent>
        </reference>

        <reference anchor="FlakeID" target="https://github.com/T-PWK/flake-idgen">
          <front>
            <title>Flake ID Generator</title>
            <author>
              <organization/>
            </author>
            <date year="2020" month="April"/>
          </front>
          <refcontent>commit fcd6a2f</refcontent>
        </reference>

        <reference anchor="Sonyflake" target="https://github.com/sony/sonyflake">
          <front>
            <title>A distributed unique ID generator inspired by Twitter's Snowflake</title>
            <author>
              <organization>Sony</organization>
            </author>
            <date year="2020" month="August"/>
          </front>
          <refcontent>commit 848d664</refcontent>
        </reference>

        <reference anchor="orderedUuid" target="https://itnext.io/laravel-the-mysterious-ordered-uuid-29e7500b4f8">
          <front>
            <title>Laravel: The mysterious "Ordered UUID"</title>
            <author initials="I. B." surname="Cabrera" fullname="Italo Baeza Cabrera">
              <organization/>
            </author>
            <date year="2020" month="January"/>
          </front>
        </reference>

        <reference anchor="COMBGUID" target="https://github.com/richardtallent/RT.Comb">
          <front>
            <title>Creating sequential GUIDs in C# for MSSQL or PostgreSql</title>
            <author>
              <organization/>
            </author>
            <date year="2020" month="December"/>
          </front>
          <refcontent>commit 2759820</refcontent>
        </reference>

        <reference anchor="ULID" target="https://github.com/ulid/spec">
          <front>
            <title>Universally Unique Lexicographically Sortable Identifier</title>
            <author>
              <organization/>
            </author>
            <date year="2019" month="May"/>
          </front>
          <seriesInfo name="Commit" value="d0c7170"/>
        </reference>

        <reference anchor="SID" target="https://github.com/chilts/sid">
          <front>
            <title>sid : generate sortable identifiers</title>
            <author>
              <organization/>
            </author>
            <date year="2019" month="June"/>
          </front>
          <seriesInfo name="Commit" value="660e947"/>
        </reference>

        <reference anchor="pushID" target="https://firebase.googleblog.com/2015/02/the-2120-ways-to-ensure-unique_68.html">
          <front>
            <title>The 2^120 Ways to Ensure Unique Identifiers</title>
            <author fullname="Michael Lehenbauer" surname="Lehenbauer" initials="M.">
              <organization>Google</organization>
            </author>
            <date year="2015" month="February"/>
          </front>
        </reference>

        <reference anchor="XID" target="https://github.com/rs/xid">
          <front>
            <title>Globally Unique ID Generator</title>
            <author>
              <organization/>
            </author>
            <date year="2020" month="October"/>
          </front>
          <refcontent>commit efa678f</refcontent>
        </reference>

        <reference anchor="ObjectID" target="https://docs.mongodb.com/manual/reference/method/ObjectId/">
          <front>
            <title>ObjectId</title>
            <author>
              <organization>MongoDB</organization>
            </author>
            <date/>
          </front>
        </reference>

        <reference anchor="CUID" target="https://github.com/ericelliott/cuid">
          <front>
            <title>Collision-resistant ids optimized for horizontal scaling and performance.</title>
            <author>
              <organization/>
            </author>
            <date year="2020" month="October"/>
          </front>
          <refcontent>commit 215b27b</refcontent>
        </reference>

        <reference anchor="IEEE754" target="https://standards.ieee.org/ieee/754/6210/">
          <front>
            <title>IEEE Standard for Floating-Point Arithmetic.</title>
            <author>
              <organization>IEEE</organization>
            </author>
            <date year="2019" month="July"/>
          </front>
          <seriesInfo name="IEEE Std" value="754-2019"/>
	  <seriesInfo name="DOI" value="10.1109/IEEESTD.2019.8766229"/>
        </reference>

        <reference anchor="URNNamespaces" target="https://www.iana.org/assignments/urn-namespaces/">
          <front>
            <title>Uniform Resource Names (URN) Namespaces</title>
            <author>
              <organization>IANA</organization>
            </author>
          </front>
        </reference>

        <reference anchor="Python" target="https://docs.python.org/3/library/uuid.html">
          <front>
            <title>uuid - UUID objects according to RFC 4122</title>
            <author>
              <organization>Python</organization>
            </author>
          </front>
        </reference>

        <reference anchor="Microsoft" target="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dtyp/222af2d3-5c00-4899-bc87-ed4c6515e80d">
          <front>
            <title>2.3.4.3 GUID - Curly Braced String Representation</title>
            <author>
              <organization>Microsoft</organization>
            </author>
            <date year="2023" month="April"/>
          </front>
        </reference>

        <reference anchor="MS_COM_GUID" target="https://devblogs.microsoft.com/oldnewthing/20220928-00/?p=107221">
          <front>
            <title>Why does COM express GUIDs in a mix of big-endian and little-endian? Why can't it just pick a side and stick with it?</title>
            <author initials="R." surname="Chen" fullname="Raymond Chen">
              <organization>Microsoft</organization>
            </author>
            <date year="2022" month="September"/>
          </front>
        </reference>

        <reference anchor="IBM_NCS" target="https://www.ibm.com/docs/en/aix/7.1?topic=u-uuid-gen-command-ncs">
          <front>
            <title>uuid_gen Command (NCS)</title>
            <author>
              <organization>IBM</organization>
            </author>
            <date year="2023" month="March"/>
          </front>
        </reference>

        <reference anchor="RANDOM" target="https://peteroupc.github.io/random.html">
          <front>
            <title>Random Number Generator Recommendations for Applications</title>
            <author initials="P." surname="Occil" fullname="Peter Occil">
              <organization/>
            </author>
            <date month="June" year="2023"/>
          </front>
        </reference>

      </references>
    </references>


<section anchor="test_vectors">
      <name>Test Vectors</name>
      <t>Both UUIDv1 and UUIDv6 test vectors utilize the same 60-bit
      timestamp: 0x1EC9414C232AB00 (138648505420000000) Tuesday, February 22,
      2022 2:22:22.000000 PM GMT-05:00.</t>
      <t>Both UUIDv1 and UUIDv6 utilize the same values in clock_seq and
      node; all of which have been generated with random data.  For the
      randomized node, the least significant bit of the first octet is set to
      a value of 1 as per <xref target="unidentifiable"/>.  Thus, the starting
      value 0x9E6BDECED846 was changed to 0x9F6BDECED846.</t>
      <t>The pseudocode used for converting from a 64-bit Unix timestamp to a
      100 ns Gregorian timestamp value has been left in the document for
      reference purposes.</t>

      <figure>
        <name>Test Vector Timestamp Pseudocode</name>
        <sourcecode type="pseudocode"><![CDATA[
# Gregorian-to-Unix Offset:
# The number of 100 ns intervals between the
# UUID Epoch 1582-10-15 00:00:00
# and the Unix Epoch 1970-01-01 00:00:00
# Greg_Unix_offset = 0x01b21dd213814000 or 122192928000000000

# Unix 64-bit Nanosecond Timestamp:
# Unix NS: Tuesday, February 22, 2022 2:22:22 PM GMT-05:00
# Unix_64_bit_ns = 0x16D6320C3D4DCC00 or 1645557742000000000

# Unix Nanosecond precision to Gregorian 100-nanosecond intervals
# Greg_100_ns = (Unix_64_bit_ns/100)+Greg_Unix_offset

# Work:
# Greg_100_ns = (1645557742000000000/100)+122192928000000000
# Unix_64_bit_ns = (138648505420000000-122192928000000000)*100

# Final:
# Greg_100_ns = 0x1EC9414C232AB00 or 138648505420000000
]]></sourcecode>
      </figure>
      <section anchor="uuidv1_example">
        <name>Example of a UUIDv1 Value</name>

        <figure>
          <name>UUIDv1 Example Test Vector</name>
          <artwork><![CDATA[
-------------------------------------------
field      bits value
-------------------------------------------
time_low   32   0xC232AB00
time_mid   16   0x9414
ver         4   0x1
time_high  12   0x1EC
var         2   0b10
clock_seq  14   0b11, 0x3C8
node       48   0x9F6BDECED846
-------------------------------------------
total      128
-------------------------------------------
final: C232AB00-9414-11EC-B3C8-9F6BDECED846
]]></artwork>
        </figure>
	
      </section>
      <section anchor="uuidv3_example">
        <name>Example of a UUIDv3 Value</name>
        <t>The MD5 computation from is detailed in <xref target="v3md5"/>
        using the DNS Namespace ID value and the Name "www.example.com".
        The field mapping and all values are illustrated in <xref
        target="v3fields"/>.  Finally, to further illustrate the bit swapping
        for version and variant, see <xref target="v3vervar"/>.</t>

        <figure anchor="v3md5">
          <name>UUIDv3 Example MD5</name>
          <artwork><![CDATA[
Namespace (DNS):  6ba7b810-9dad-11d1-80b4-00c04fd430c8
Name:             www.example.com
------------------------------------------------------
MD5:              5df418813aed051548a72f4a814cf09e
]]></artwork>
        </figure>

        <figure anchor="v3fields">
          <name>UUIDv3 Example Test Vector</name>
          <artwork><![CDATA[
-------------------------------------------
field     bits value
-------------------------------------------
md5_high  48   0x5df418813aed
ver        4   0x3
md5_mid   12   0x515
var        2   0b10
md5_low   62   0b00, 0x8a72f4a814cf09e
-------------------------------------------
total     128
-------------------------------------------
final: 5df41881-3aed-3515-88a7-2f4a814cf09e
]]></artwork>
        </figure>

        <figure anchor="v3vervar">
          <name>UUIDv3 Example Ver/Var Bit Swaps</name>
          <artwork><![CDATA[
MD5 hex and dash:      5df41881-3aed-0515-48a7-2f4a814cf09e
Ver and Var Overwrite: xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx
Final:                 5df41881-3aed-3515-88a7-2f4a814cf09e
]]></artwork>
        </figure>

      </section>
      <section anchor="uuidv4_example">
        <name>Example of a UUIDv4 Value</name>
        <t>This UUIDv4 example was created by generating 16 bytes of random
        data resulting in the hexadecimal value of
        919108F752D133205BACF847DB4148A8. This is then used to fill out the
        fields as shown in <xref target="v4fields"/>.</t>
        <t>Finally, to further illustrate the bit swapping for version and
        variant, see <xref target="v4vervar"/>.</t>

        <figure anchor="v4fields">
          <name>UUIDv4 Example Test Vector</name>
          <artwork><![CDATA[
-------------------------------------------
field     bits value
-------------------------------------------
random_a  48   0x919108f752d1
ver        4   0x4
random_b  12   0x320
var        2   0b10
random_c  62   0b01, 0xbacf847db4148a8
-------------------------------------------
total     128
-------------------------------------------
final: 919108f7-52d1-4320-9bac-f847db4148a8
]]></artwork>
        </figure>

        <figure anchor="v4vervar">
          <name>UUIDv4 Example Ver/Var Bit Swaps</name>
          <artwork><![CDATA[
Random hex:            919108f752d133205bacf847db4148a8
Random hex and dash:   919108f7-52d1-3320-5bac-f847db4148a8
Ver and Var Overwrite: xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx
Final:                 919108f7-52d1-4320-9bac-f847db4148a8
]]></artwork>
        </figure>

      </section>
      <section anchor="uuidv5_example">
        <name>Example of a UUIDv5 Value</name>
        <t>The SHA-1 computation form is detailed in <xref target="v5sha1"/>,
        using the DNS Namespace ID value and the Name "www.example.com".  The
        field mapping and all values are illustrated in <xref
        target="v5fields"/>.  Finally, to further illustrate the bit swapping
        for version and variant and the unused/discarded part of the SHA-1
        value, see <xref target="v5vervar"/>.</t>

        <figure anchor="v5sha1">
          <name>UUIDv5 Example SHA-1</name>
          <artwork><![CDATA[
Namespace (DNS):  6ba7b810-9dad-11d1-80b4-00c04fd430c8
Name:             www.example.com
----------------------------------------------------------
SHA-1:            2ed6657de927468b55e12665a8aea6a22dee3e35
]]></artwork>
        </figure>

        <figure anchor="v5fields">
          <name>UUIDv5 Example Test Vector</name>
          <artwork><![CDATA[
-------------------------------------------
field      bits value
-------------------------------------------
sha1_high  48   0x2ed6657de927
ver         4   0x5
sha1_mid   12   0x68b
var         2   0b10
sha1_low   62   0b01, 0x5e12665a8aea6a2
-------------------------------------------
total      128
-------------------------------------------
final: 2ed6657d-e927-568b-95e1-2665a8aea6a2
]]></artwork>
        </figure>
	
        <figure anchor="v5vervar">
          <name>UUIDv5 Example Ver/Var Bit Swaps and Discarded SHA-1 Segment</name>
          <artwork><![CDATA[
SHA-1 hex and dash:    2ed6657d-e927-468b-55e1-2665a8aea6a2-2dee3e35
Ver and Var Overwrite: xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx
Final:                 2ed6657d-e927-568b-95e1-2665a8aea6a2
Discarded:                                                 -2dee3e35
]]></artwork>
        </figure>

      </section>
      <section anchor="uuidv6_example">
        <name>Example of a UUIDv6 Value</name>
        <figure>
          <name>UUIDv6 Example Test Vector</name>
          <artwork><![CDATA[
-------------------------------------------
field       bits value
-------------------------------------------
time_high   32   0x1EC9414C
time_mid    16   0x232A
ver          4   0x6
time_high   12   0xB00
var          2   0b10
clock_seq   14   0b11, 0x3C8
node        48   0x9F6BDECED846
-------------------------------------------
total       128
-------------------------------------------
final: 1EC9414C-232A-6B00-B3C8-9F6BDECED846
]]></artwork>
        </figure>
      </section>
      <section anchor="uuidv7_example">
        <name>Example of a UUIDv7 Value</name>
        <t>This example UUIDv7 test vector utilizes a well-known Unix Epoch
        timestamp with millisecond precision to fill the first 48 bits.</t>
        <t>rand_a and rand_b are filled with random data.</t>
        <t>The timestamp is Tuesday, February 22, 2022 2:22:22.00 PM
        GMT-05:00, represented as 0x017F22E279B0 or 1645557742000.</t>
        <figure>
          <name>UUIDv7 Example Test Vector</name>
          <artwork><![CDATA[
-------------------------------------------
field       bits value
-------------------------------------------
unix_ts_ms  48   0x017F22E279B0
ver          4   0x7
rand_a      12   0xCC3
var          2   0b10
rand_b      62   0b01, 0x8C4DC0C0C07398F
-------------------------------------------
total       128
-------------------------------------------
final: 017F22E2-79B0-7CC3-98C4-DC0C0C07398F
]]></artwork>
        </figure>
      </section>
    </section>
    <section anchor="ill_examples">
      <name>Illustrative Examples</name>
      <t>The following sections contain illustrative examples that serve to
      show how one may use UUIDv8 (<xref target="uuidv8"/>) for custom and/or
      experimental application-based logic.  The examples below have not been
      through the same rigorous testing, prototyping, and feedback loop that
      other algorithms in this document have undergone.  The authors
      encourage implementers to create their own UUIDv8 algorithm rather than
      use the items defined in this section.</t>
      <section anchor="uuidv8_example">
        <name>Example of a UUIDv8 Value (Time-Based)</name>
        <t>This example UUIDv8 test vector utilizes a well-known 64-bit Unix
        Epoch timestamp with 10 ns precision, truncated to the
        least significant, rightmost bits to fill the first 60 bits of
        custom_a and custom_b, while setting the version bits between these two
        segments to the version value of 8.</t>
        <t>The variant bits are set; and the final segment, custom_c, is filled
        with random data.</t>
        <t>Timestamp is Tuesday, February 22, 2022 2:22:22.000000 PM
        GMT-05:00, represented as 0x2489E9AD2EE2E00 or 164555774200000000
        (10 ns-steps).</t>
        <figure>
          <name>UUIDv8 Example Time-Based Illustrative Example</name>
          <artwork><![CDATA[
-------------------------------------------
field     bits value
-------------------------------------------
custom_a  48   0x2489E9AD2EE2
ver        4   0x8
custom_b  12   0xE00
var        2   0b10
custom_c  62   0b00, 0xEC932D5F69181C0
-------------------------------------------
total     128
-------------------------------------------
final: 2489E9AD-2EE2-8E00-8EC9-32D5F69181C0
]]></artwork>
        </figure>
      </section>
      <section anchor="uuidv8_example_name">
        <name>Example of a UUIDv8 Value (Name-Based)</name>
        <t>As per <xref target="uuidv5"/>, name-based UUIDs that want to use
        modern hashing algorithms <bcp14>MUST</bcp14> be created within the
        UUIDv8 space. These <bcp14>MAY</bcp14> leverage newer hashing
        algorithms such as SHA-256 or SHA-512 (as defined by <xref
        target="FIPS180-4"/>), SHA-3 or SHAKE (as defined by <xref
        target="FIPS202"/>), or even algorithms that have not been defined
        yet.</t>

        <t>A SHA-256 version of the SHA-1 computation in <xref
        target="uuidv5_example"/> is detailed in <xref target="v8sha256"/> as
        an illustrative example detailing how this can be achieved.  The
        creation of the name-based UUIDv8 value in this section follows the
        same logic defined in <xref target="uuidv5"/> with the difference
        being SHA-256 in place of SHA-1.</t>
        <t>The field mapping and all values are illustrated in <xref
        target="v8fieldssha256"/>.  Finally, to further illustrate the bit
        swapping for version and variant and the unused/discarded part of the
        SHA-256 value, see <xref target="v8vervar"/>.  An important note for
        secure hashing algorithms that produce outputs of an arbitrary size,
        such as those found in SHAKE, is that the output hash
        <bcp14>MUST</bcp14> be 128 bits or larger.</t>
        <figure anchor="v8sha256">
          <name>UUIDv8 Example SHA256</name>
          <artwork><![CDATA[
Namespace (DNS):       6ba7b810-9dad-11d1-80b4-00c04fd430c8
Name:                  www.example.com
----------------------------------------------------------------
SHA-256:
5c146b143c524afd938a375d0df1fbf6fe12a66b645f72f6158759387e51f3c8
]]></artwork>
        </figure>
        <figure anchor="v8fieldssha256">
          <name>UUIDv8 Example Name-Based SHA-256 Illustrative Example</name>
          <artwork><![CDATA[
-------------------------------------------
field     bits value
-------------------------------------------
custom_a  48   0x5c146b143c52
ver        4   0x8
custom_b  12   0xafd
var        2   0b10
custom_c  62   0b00, 0x38a375d0df1fbf6
-------------------------------------------
total     128
-------------------------------------------
final: 5c146b14-3c52-8afd-938a-375d0df1fbf6
]]></artwork>
        </figure>
	
        <figure anchor="v8vervar">
          <name>UUIDv8 Example Ver/Var Bit Swaps and Discarded SHA-256 Segment</name>
          <artwork><![CDATA[	  
A: 5c146b14-3c52-4afd-938a-375d0df1fbf6-fe12a66b645f72f6158759387e51f3c8
B: xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx
C: 5c146b14-3c52-8afd-938a-375d0df1fbf6
D:                                     -fe12a66b645f72f6158759387e51f3c8
]]></artwork>
        </figure>
        <t>Examining <xref target="v8vervar"/>:</t>

        <ul spacing="normal">
          <li>Line A details the full SHA-256 as a hexadecimal value with the
          dashes inserted.</li>
          <li>Line B details the version and variant hexadecimal positions,
          which must be overwritten.</li>
          <li>Line C details the final value after the ver and var have been
          overwritten.</li>
          <li>Line D details the discarded leftover values from the original
          SHA-256 computation.</li>
        </ul>
      </section>
    </section>
    <section anchor="Acknowledgements" toc="default" numbered="false">
      <name>Acknowledgements</name>
      <t>The authors gratefully acknowledge the contributions of <contact
      fullname="Rich Salz"/>, <contact fullname="Michael Mealling"/>, <contact
      fullname="Ben Campbell"/>, <contact fullname="Ben Ramsey"/>, <contact
      fullname="Fabio Lima"/>, <contact fullname="Gonzalo Salgueiro"/>,
      <contact fullname="Martin Thomson"/>, <contact fullname="Murray
      S. Kucherawy"/>, <contact fullname="Rick van Rein"/>, <contact
      fullname="Rob Wilton"/>, <contact fullname="Sean Leonard"/>, <contact
      fullname="Theodore Y. Ts'o"/>, <contact fullname="Robert Kieffer"/>,
      <contact fullname="Sergey Prokhorenko"/>, and <contact
      fullname="LiosK"/>.</t>
      <t>As well as all of those in the IETF community and on GitHub to who
      contributed to the discussions that resulted in this document.</t>
      <t>This document draws heavily on the OSF DCE specification (Appendix A
      of <xref target="C309" format="default"/>) for UUIDs.  <contact
      fullname="Ted Ts'o"/> provided helpful comments.</t>
      <t>We are also grateful to the careful reading and bit-twiddling of
      <contact fullname="Ralf S. Engelschall"/>, <contact fullname="John
      Larmouth"/>, and <contact fullname="Paul Thorpe"/>.  <contact
      fullname="Professor Larmouth"/> was also invaluable in achieving
      coordination with ISO/IEC.</t>
    </section>

  </back>

</rfc>
